<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dive into Deep Learning</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="static/d2l.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Deep Learning</a></li><li class="chapter-item expanded "><a href="chapter_preface/index.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="chapter_installation/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="chapter_notation/index.html"><strong aria-hidden="true">3.</strong> Notation</a></li><li class="chapter-item expanded "><a href="chapter_introduction/index.html"><strong aria-hidden="true">4.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_preliminaries/index.html"><strong aria-hidden="true">5.</strong> Preliminaries</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_preliminaries/ndarray.html"><strong aria-hidden="true">5.1.</strong> Data Manipulation</a></li><li class="chapter-item "><a href="chapter_preliminaries/pandas.html"><strong aria-hidden="true">5.2.</strong> Data Preprocessing</a></li><li class="chapter-item "><a href="chapter_preliminaries/linear-algebra.html"><strong aria-hidden="true">5.3.</strong> Linear Algebra</a></li><li class="chapter-item "><a href="chapter_preliminaries/calculus.html"><strong aria-hidden="true">5.4.</strong> Calculus</a></li><li class="chapter-item "><a href="chapter_preliminaries/autograd.html"><strong aria-hidden="true">5.5.</strong> Automatic Differentiation</a></li><li class="chapter-item "><a href="chapter_preliminaries/probability.html"><strong aria-hidden="true">5.6.</strong> Probability and Statistics</a></li><li class="chapter-item "><a href="chapter_preliminaries/lookup-api.html"><strong aria-hidden="true">5.7.</strong> Documentation</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_linear-regression/index.html"><strong aria-hidden="true">6.</strong> Linear Neural Networks for Regression</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_linear-regression/linear-regression.html"><strong aria-hidden="true">6.1.</strong> Linear Regression</a></li><li class="chapter-item "><a href="chapter_linear-regression/oo-design.html"><strong aria-hidden="true">6.2.</strong> Object-Oriented Design for Implementation</a></li><li class="chapter-item "><a href="chapter_linear-regression/synthetic-regression-data.html"><strong aria-hidden="true">6.3.</strong> Synthetic Regression Data</a></li><li class="chapter-item "><a href="chapter_linear-regression/linear-regression-scratch.html"><strong aria-hidden="true">6.4.</strong> Linear Regression Implementation from Scratch</a></li><li class="chapter-item "><a href="chapter_linear-regression/linear-regression-concise.html"><strong aria-hidden="true">6.5.</strong> Concise Implementation of Linear Regression</a></li><li class="chapter-item "><a href="chapter_linear-regression/generalization.html"><strong aria-hidden="true">6.6.</strong> Generalization</a></li><li class="chapter-item "><a href="chapter_linear-regression/weight-decay.html"><strong aria-hidden="true">6.7.</strong> Weight Decay</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_linear-classification/index.html"><strong aria-hidden="true">7.</strong> Linear Neural Networks for Classification</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_linear-classification/softmax-regression.html"><strong aria-hidden="true">7.1.</strong> Softmax Regression</a></li><li class="chapter-item "><a href="chapter_linear-classification/image-classification-dataset.html"><strong aria-hidden="true">7.2.</strong> The Image Classification Dataset</a></li><li class="chapter-item "><a href="chapter_linear-classification/classification.html"><strong aria-hidden="true">7.3.</strong> The Base Classification Model</a></li><li class="chapter-item "><a href="chapter_linear-classification/softmax-regression-scratch.html"><strong aria-hidden="true">7.4.</strong> Softmax Regression Implementation from Scratch</a></li><li class="chapter-item "><a href="chapter_linear-classification/softmax-regression-concise.html"><strong aria-hidden="true">7.5.</strong> Concise Implementation of Softmax Regression</a></li><li class="chapter-item "><a href="chapter_linear-classification/generalization-classification.html"><strong aria-hidden="true">7.6.</strong> Generalization in Classification</a></li><li class="chapter-item "><a href="chapter_linear-classification/environment-and-distribution-shift.html"><strong aria-hidden="true">7.7.</strong> Environment and Distribution Shift</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_multilayer-perceptrons/index.html"><strong aria-hidden="true">8.</strong> Multilayer Perceptrons</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_multilayer-perceptrons/mlp.html"><strong aria-hidden="true">8.1.</strong> Multilayer Perceptrons</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/mlp-implementation.html"><strong aria-hidden="true">8.2.</strong> Implementation of Multilayer Perceptrons</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/backprop.html"><strong aria-hidden="true">8.3.</strong> Forward Propagation, Backward Propagation, and Computational Graphs</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/numerical-stability-and-init.html"><strong aria-hidden="true">8.4.</strong> Numerical Stability and Initialization</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/generalization-deep.html"><strong aria-hidden="true">8.5.</strong> Generalization in Deep Learning</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/dropout.html"><strong aria-hidden="true">8.6.</strong> Dropout</a></li><li class="chapter-item "><a href="chapter_multilayer-perceptrons/kaggle-house-price.html"><strong aria-hidden="true">8.7.</strong> Predicting House Prices on Kaggle</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_builders-guide/index.html"><strong aria-hidden="true">9.</strong> Builders' Guide</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_builders-guide/model-construction.html"><strong aria-hidden="true">9.1.</strong> Layers and Modules</a></li><li class="chapter-item "><a href="chapter_builders-guide/parameters.html"><strong aria-hidden="true">9.2.</strong> Parameter Management</a></li><li class="chapter-item "><a href="chapter_builders-guide/init-param.html"><strong aria-hidden="true">9.3.</strong> Parameter Initialization</a></li><li class="chapter-item "><a href="chapter_builders-guide/lazy-init.html"><strong aria-hidden="true">9.4.</strong> Lazy Initialization</a></li><li class="chapter-item "><a href="chapter_builders-guide/custom-layer.html"><strong aria-hidden="true">9.5.</strong> Custom Layers</a></li><li class="chapter-item "><a href="chapter_builders-guide/read-write.html"><strong aria-hidden="true">9.6.</strong> File I/O</a></li><li class="chapter-item "><a href="chapter_builders-guide/use-gpu.html"><strong aria-hidden="true">9.7.</strong> GPUs</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_convolutional-neural-networks/index.html"><strong aria-hidden="true">10.</strong> Convolutional Neural Networks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_convolutional-neural-networks/why-conv.html"><strong aria-hidden="true">10.1.</strong> From Fully Connected Layers to Convolutions</a></li><li class="chapter-item "><a href="chapter_convolutional-neural-networks/conv-layer.html"><strong aria-hidden="true">10.2.</strong> Convolutions for Images</a></li><li class="chapter-item "><a href="chapter_convolutional-neural-networks/padding-and-strides.html"><strong aria-hidden="true">10.3.</strong> Padding and Stride</a></li><li class="chapter-item "><a href="chapter_convolutional-neural-networks/channels.html"><strong aria-hidden="true">10.4.</strong> Multiple Input and Multiple Output Channels</a></li><li class="chapter-item "><a href="chapter_convolutional-neural-networks/pooling.html"><strong aria-hidden="true">10.5.</strong> Pooling</a></li><li class="chapter-item "><a href="chapter_convolutional-neural-networks/lenet.html"><strong aria-hidden="true">10.6.</strong> Convolutional Neural Networks (LeNet)</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_convolutional-modern/index.html"><strong aria-hidden="true">11.</strong> Modern Convolutional Neural Networks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_convolutional-modern/alexnet.html"><strong aria-hidden="true">11.1.</strong> Deep Convolutional Neural Networks (AlexNet)</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/vgg.html"><strong aria-hidden="true">11.2.</strong> Networks Using Blocks (VGG)</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/nin.html"><strong aria-hidden="true">11.3.</strong> Network in Network (NiN)</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/googlenet.html"><strong aria-hidden="true">11.4.</strong> Multi-Branch Networks  (GoogLeNet)</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/batch-norm.html"><strong aria-hidden="true">11.5.</strong> Batch Normalization</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/resnet.html"><strong aria-hidden="true">11.6.</strong> Residual Networks (ResNet) and ResNeXt</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/densenet.html"><strong aria-hidden="true">11.7.</strong> Densely Connected Networks (DenseNet)</a></li><li class="chapter-item "><a href="chapter_convolutional-modern/cnn-design.html"><strong aria-hidden="true">11.8.</strong> Designing Convolution Network Architectures</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_recurrent-neural-networks/index.html"><strong aria-hidden="true">12.</strong> Recurrent Neural Networks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_recurrent-neural-networks/sequence.html"><strong aria-hidden="true">12.1.</strong> Working with Sequences</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/text-sequence.html"><strong aria-hidden="true">12.2.</strong> Converting Raw Text into Sequence Data</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/language-model.html"><strong aria-hidden="true">12.3.</strong> Language Models</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/rnn.html"><strong aria-hidden="true">12.4.</strong> Recurrent Neural Networks</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/rnn-scratch.html"><strong aria-hidden="true">12.5.</strong> Recurrent Neural Network Implementation from Scratch</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/rnn-concise.html"><strong aria-hidden="true">12.6.</strong> Concise Implementation of Recurrent Neural Networks</a></li><li class="chapter-item "><a href="chapter_recurrent-neural-networks/bptt.html"><strong aria-hidden="true">12.7.</strong> Backpropagation Through Time</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_recurrent-modern/index.html"><strong aria-hidden="true">13.</strong> Modern Recurrent Neural Networks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_recurrent-modern/lstm.html"><strong aria-hidden="true">13.1.</strong> Long Short-Term Memory (LSTM)</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/gru.html"><strong aria-hidden="true">13.2.</strong> Gated Recurrent Units (GRU)</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/deep-rnn.html"><strong aria-hidden="true">13.3.</strong> Deep Recurrent Neural Networks</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/bi-rnn.html"><strong aria-hidden="true">13.4.</strong> Bidirectional Recurrent Neural Networks</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/machine-translation-and-dataset.html"><strong aria-hidden="true">13.5.</strong> Machine Translation and the Dataset</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/encoder-decoder.html"><strong aria-hidden="true">13.6.</strong> The Encoder--Decoder Architecture</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/seq2seq.html"><strong aria-hidden="true">13.7.</strong> Sequence-to-Sequence Learning for Machine Translation</a></li><li class="chapter-item "><a href="chapter_recurrent-modern/beam-search.html"><strong aria-hidden="true">13.8.</strong> Beam Search</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_attention-mechanisms-and-transformers/index.html"><strong aria-hidden="true">14.</strong> Attention Mechanisms and Transformers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/queries-keys-values.html"><strong aria-hidden="true">14.1.</strong> Queries, Keys, and Values</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/attention-pooling.html"><strong aria-hidden="true">14.2.</strong> Attention Pooling by Similarity</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/attention-scoring-functions.html"><strong aria-hidden="true">14.3.</strong> Attention Scoring Functions</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/bahdanau-attention.html"><strong aria-hidden="true">14.4.</strong> The Bahdanau Attention Mechanism</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/multihead-attention.html"><strong aria-hidden="true">14.5.</strong> Multi-Head Attention</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/self-attention-and-positional-encoding.html"><strong aria-hidden="true">14.6.</strong> Self-Attention and Positional Encoding</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/transformer.html"><strong aria-hidden="true">14.7.</strong> The Transformer Architecture</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/vision-transformer.html"><strong aria-hidden="true">14.8.</strong> Transformers for Vision</a></li><li class="chapter-item "><a href="chapter_attention-mechanisms-and-transformers/large-pretraining-transformers.html"><strong aria-hidden="true">14.9.</strong> Large-Scale Pretraining with Transformers</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_optimization/index.html"><strong aria-hidden="true">15.</strong> Optimization Algorithms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_optimization/optimization-intro.html"><strong aria-hidden="true">15.1.</strong> Optimization and Deep Learning</a></li><li class="chapter-item "><a href="chapter_optimization/convexity.html"><strong aria-hidden="true">15.2.</strong> Convexity</a></li><li class="chapter-item "><a href="chapter_optimization/gd.html"><strong aria-hidden="true">15.3.</strong> Gradient Descent</a></li><li class="chapter-item "><a href="chapter_optimization/sgd.html"><strong aria-hidden="true">15.4.</strong> Stochastic Gradient Descent</a></li><li class="chapter-item "><a href="chapter_optimization/minibatch-sgd.html"><strong aria-hidden="true">15.5.</strong> Minibatch Stochastic Gradient Descent</a></li><li class="chapter-item "><a href="chapter_optimization/momentum.html"><strong aria-hidden="true">15.6.</strong> Momentum</a></li><li class="chapter-item "><a href="chapter_optimization/adagrad.html"><strong aria-hidden="true">15.7.</strong> Adagrad</a></li><li class="chapter-item "><a href="chapter_optimization/rmsprop.html"><strong aria-hidden="true">15.8.</strong> RMSProp</a></li><li class="chapter-item "><a href="chapter_optimization/adadelta.html"><strong aria-hidden="true">15.9.</strong> Adadelta</a></li><li class="chapter-item "><a href="chapter_optimization/adam.html"><strong aria-hidden="true">15.10.</strong> Adam</a></li><li class="chapter-item "><a href="chapter_optimization/lr-scheduler.html"><strong aria-hidden="true">15.11.</strong> Learning Rate Scheduling</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_computational-performance/index.html"><strong aria-hidden="true">16.</strong> Computational Performance</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_computational-performance/hybridize.html"><strong aria-hidden="true">16.1.</strong> Compilers and Interpreters</a></li><li class="chapter-item "><a href="chapter_computational-performance/async-computation.html"><strong aria-hidden="true">16.2.</strong> Asynchronous Computation</a></li><li class="chapter-item "><a href="chapter_computational-performance/auto-parallelism.html"><strong aria-hidden="true">16.3.</strong> Automatic Parallelism</a></li><li class="chapter-item "><a href="chapter_computational-performance/hardware.html"><strong aria-hidden="true">16.4.</strong> Hardware</a></li><li class="chapter-item "><a href="chapter_computational-performance/multiple-gpus.html"><strong aria-hidden="true">16.5.</strong> Training on Multiple GPUs</a></li><li class="chapter-item "><a href="chapter_computational-performance/multiple-gpus-concise.html"><strong aria-hidden="true">16.6.</strong> Concise Implementation for Multiple GPUs</a></li><li class="chapter-item "><a href="chapter_computational-performance/parameterserver.html"><strong aria-hidden="true">16.7.</strong> Parameter Servers</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_computer-vision/index.html"><strong aria-hidden="true">17.</strong> Computer Vision</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_computer-vision/image-augmentation.html"><strong aria-hidden="true">17.1.</strong> Image Augmentation</a></li><li class="chapter-item "><a href="chapter_computer-vision/fine-tuning.html"><strong aria-hidden="true">17.2.</strong> Fine-Tuning</a></li><li class="chapter-item "><a href="chapter_computer-vision/bounding-box.html"><strong aria-hidden="true">17.3.</strong> Object Detection and Bounding Boxes</a></li><li class="chapter-item "><a href="chapter_computer-vision/anchor.html"><strong aria-hidden="true">17.4.</strong> Anchor Boxes</a></li><li class="chapter-item "><a href="chapter_computer-vision/multiscale-object-detection.html"><strong aria-hidden="true">17.5.</strong> Multiscale Object Detection</a></li><li class="chapter-item "><a href="chapter_computer-vision/object-detection-dataset.html"><strong aria-hidden="true">17.6.</strong> The Object Detection Dataset</a></li><li class="chapter-item "><a href="chapter_computer-vision/ssd.html"><strong aria-hidden="true">17.7.</strong> Single Shot Multibox Detection</a></li><li class="chapter-item "><a href="chapter_computer-vision/rcnn.html"><strong aria-hidden="true">17.8.</strong> Region-based CNNs (R-CNNs)</a></li><li class="chapter-item "><a href="chapter_computer-vision/semantic-segmentation-and-dataset.html"><strong aria-hidden="true">17.9.</strong> Semantic Segmentation and the Dataset</a></li><li class="chapter-item "><a href="chapter_computer-vision/transposed-conv.html"><strong aria-hidden="true">17.10.</strong> Transposed Convolution</a></li><li class="chapter-item "><a href="chapter_computer-vision/fcn.html"><strong aria-hidden="true">17.11.</strong> Fully Convolutional Networks</a></li><li class="chapter-item "><a href="chapter_computer-vision/neural-style.html"><strong aria-hidden="true">17.12.</strong> Neural Style Transfer</a></li><li class="chapter-item "><a href="chapter_computer-vision/kaggle-cifar10.html"><strong aria-hidden="true">17.13.</strong> Image Classification (CIFAR-10) on Kaggle</a></li><li class="chapter-item "><a href="chapter_computer-vision/kaggle-dog.html"><strong aria-hidden="true">17.14.</strong> Dog Breed Identification (ImageNet Dogs) on Kaggle</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_natural-language-processing-pretraining/index.html"><strong aria-hidden="true">18.</strong> Natural Language Processing: Pretraining</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/word2vec.html"><strong aria-hidden="true">18.1.</strong> Word Embedding (word2vec)</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/approx-training.html"><strong aria-hidden="true">18.2.</strong> Approximate Training</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/word-embedding-dataset.html"><strong aria-hidden="true">18.3.</strong> The Dataset for Pretraining Word Embeddings</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/word2vec-pretraining.html"><strong aria-hidden="true">18.4.</strong> Pretraining word2vec</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/glove.html"><strong aria-hidden="true">18.5.</strong> Word Embedding with Global Vectors (GloVe)</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/subword-embedding.html"><strong aria-hidden="true">18.6.</strong> Subword Embedding</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/similarity-analogy.html"><strong aria-hidden="true">18.7.</strong> Word Similarity and Analogy</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/bert.html"><strong aria-hidden="true">18.8.</strong> Bidirectional Encoder Representations from Transformers (BERT)</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/bert-dataset.html"><strong aria-hidden="true">18.9.</strong> The Dataset for Pretraining BERT</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-pretraining/bert-pretraining.html"><strong aria-hidden="true">18.10.</strong> Pretraining BERT</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_natural-language-processing-applications/index.html"><strong aria-hidden="true">19.</strong> Natural Language Processing: Applications</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_natural-language-processing-applications/sentiment-analysis-and-dataset.html"><strong aria-hidden="true">19.1.</strong> Sentiment Analysis and the Dataset</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/sentiment-analysis-rnn.html"><strong aria-hidden="true">19.2.</strong> Sentiment Analysis: Using Recurrent Neural Networks</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/sentiment-analysis-cnn.html"><strong aria-hidden="true">19.3.</strong> Sentiment Analysis: Using Convolutional Neural Networks</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/natural-language-inference-and-dataset.html"><strong aria-hidden="true">19.4.</strong> Natural Language Inference and the Dataset</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/natural-language-inference-attention.html"><strong aria-hidden="true">19.5.</strong> Natural Language Inference: Using Attention</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/finetuning-bert.html"><strong aria-hidden="true">19.6.</strong> Fine-Tuning BERT for Sequence-Level and Token-Level Applications</a></li><li class="chapter-item "><a href="chapter_natural-language-processing-applications/natural-language-inference-bert.html"><strong aria-hidden="true">19.7.</strong> Natural Language Inference: Fine-Tuning BERT</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_reinforcement-learning/index.html"><strong aria-hidden="true">20.</strong> Reinforcement Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_reinforcement-learning/mdp.html"><strong aria-hidden="true">20.1.</strong> Markov Decision Process (MDP)</a></li><li class="chapter-item "><a href="chapter_reinforcement-learning/value-iter.html"><strong aria-hidden="true">20.2.</strong> Value Iteration</a></li><li class="chapter-item "><a href="chapter_reinforcement-learning/qlearning.html"><strong aria-hidden="true">20.3.</strong> Q-Learning</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_gaussian-processes/index.html"><strong aria-hidden="true">21.</strong> Gaussian Processes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_gaussian-processes/gp-intro.html"><strong aria-hidden="true">21.1.</strong> Introduction to Gaussian Processes</a></li><li class="chapter-item "><a href="chapter_gaussian-processes/gp-priors.html"><strong aria-hidden="true">21.2.</strong> Gaussian Process Priors</a></li><li class="chapter-item "><a href="chapter_gaussian-processes/gp-inference.html"><strong aria-hidden="true">21.3.</strong> Gaussian Process Inference</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_hyperparameter-optimization/index.html"><strong aria-hidden="true">22.</strong> Hyperparameter Optimization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_hyperparameter-optimization/hyperopt-intro.html"><strong aria-hidden="true">22.1.</strong> What Is Hyperparameter Optimization?</a></li><li class="chapter-item "><a href="chapter_hyperparameter-optimization/hyperopt-api.html"><strong aria-hidden="true">22.2.</strong> Hyperparameter Optimization API</a></li><li class="chapter-item "><a href="chapter_hyperparameter-optimization/rs-async.html"><strong aria-hidden="true">22.3.</strong> Asynchronous Random Search</a></li><li class="chapter-item "><a href="chapter_hyperparameter-optimization/sh-intro.html"><strong aria-hidden="true">22.4.</strong> Multi-Fidelity Hyperparameter Optimization</a></li><li class="chapter-item "><a href="chapter_hyperparameter-optimization/sh-async.html"><strong aria-hidden="true">22.5.</strong> Asynchronous Successive Halving</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_generative-adversarial-networks/index.html"><strong aria-hidden="true">23.</strong> Generative Adversarial Networks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_generative-adversarial-networks/gan.html"><strong aria-hidden="true">23.1.</strong> Generative Adversarial Networks</a></li><li class="chapter-item "><a href="chapter_generative-adversarial-networks/dcgan.html"><strong aria-hidden="true">23.2.</strong> Deep Convolutional Generative Adversarial Networks</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_recommender-systems/index.html"><strong aria-hidden="true">24.</strong> Recommender Systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_recommender-systems/recsys-intro.html"><strong aria-hidden="true">24.1.</strong> Overview of Recommender Systems</a></li><li class="chapter-item "><a href="chapter_recommender-systems/movielens.html"><strong aria-hidden="true">24.2.</strong> The MovieLens Dataset</a></li><li class="chapter-item "><a href="chapter_recommender-systems/mf.html"><strong aria-hidden="true">24.3.</strong> Matrix Factorization</a></li><li class="chapter-item "><a href="chapter_recommender-systems/autorec.html"><strong aria-hidden="true">24.4.</strong> AutoRec: Rating Prediction with Autoencoders</a></li><li class="chapter-item "><a href="chapter_recommender-systems/ranking.html"><strong aria-hidden="true">24.5.</strong> Personalized Ranking for Recommender Systems</a></li><li class="chapter-item "><a href="chapter_recommender-systems/neumf.html"><strong aria-hidden="true">24.6.</strong> Neural Collaborative Filtering for Personalized Ranking</a></li><li class="chapter-item "><a href="chapter_recommender-systems/seqrec.html"><strong aria-hidden="true">24.7.</strong> Sequence-Aware Recommender Systems</a></li><li class="chapter-item "><a href="chapter_recommender-systems/ctr.html"><strong aria-hidden="true">24.8.</strong> Feature-Rich Recommender Systems</a></li><li class="chapter-item "><a href="chapter_recommender-systems/fm.html"><strong aria-hidden="true">24.9.</strong> Factorization Machines</a></li><li class="chapter-item "><a href="chapter_recommender-systems/deepfm.html"><strong aria-hidden="true">24.10.</strong> Deep Factorization Machines</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_appendix-mathematics-for-deep-learning/index.html"><strong aria-hidden="true">25.</strong> Appendix: Mathematics for Deep Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/geometry-linear-algebraic-ops.html"><strong aria-hidden="true">25.1.</strong> Geometry and Linear Algebraic Operations</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/eigendecomposition.html"><strong aria-hidden="true">25.2.</strong> Eigendecompositions</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/single-variable-calculus.html"><strong aria-hidden="true">25.3.</strong> Single Variable Calculus</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/multivariable-calculus.html"><strong aria-hidden="true">25.4.</strong> Multivariable Calculus</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/integral-calculus.html"><strong aria-hidden="true">25.5.</strong> Integral Calculus</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/random-variables.html"><strong aria-hidden="true">25.6.</strong> Random Variables</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/maximum-likelihood.html"><strong aria-hidden="true">25.7.</strong> Maximum Likelihood</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/distributions.html"><strong aria-hidden="true">25.8.</strong> Distributions</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/naive-bayes.html"><strong aria-hidden="true">25.9.</strong> Naive Bayes</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/statistics.html"><strong aria-hidden="true">25.10.</strong> Statistics</a></li><li class="chapter-item "><a href="chapter_appendix-mathematics-for-deep-learning/information-theory.html"><strong aria-hidden="true">25.11.</strong> Information Theory</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_appendix-tools-for-deep-learning/index.html"><strong aria-hidden="true">26.</strong> Appendix: Tools for Deep Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/jupyter.html"><strong aria-hidden="true">26.1.</strong> Using Jupyter Notebooks</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/sagemaker.html"><strong aria-hidden="true">26.2.</strong> Using Amazon SageMaker</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/aws.html"><strong aria-hidden="true">26.3.</strong> Using AWS EC2 Instances</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/colab.html"><strong aria-hidden="true">26.4.</strong> Using Google Colab</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/selecting-servers-gpus.html"><strong aria-hidden="true">26.5.</strong> Selecting Servers and GPUs</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/contributing.html"><strong aria-hidden="true">26.6.</strong> Contributing to This Book</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/utils.html"><strong aria-hidden="true">26.7.</strong> Utility Functions and Classes</a></li><li class="chapter-item "><a href="chapter_appendix-tools-for-deep-learning/d2l.html"><strong aria-hidden="true">26.8.</strong> The d2l API Document</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_references/zreferences.html"><strong aria-hidden="true">27.</strong> chapter_references/zreferences.md</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dive into Deep Learning</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/d2l-ai/d2l-en" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dive-into-deep-learning"><a class="header" href="#dive-into-deep-learning">Dive into Deep Learning</a></h1>
<pre><code class="language-eval_rst">.. raw:: html
   :file: frontpage.html
</code></pre>
<pre><code class="language-toc">:maxdepth: 1

chapter_preface/index
chapter_installation/index
chapter_notation/index
</code></pre>
<pre><code class="language-toc">:maxdepth: 2
:numbered:

chapter_introduction/index
chapter_preliminaries/index
chapter_linear-regression/index
chapter_linear-classification/index
chapter_multilayer-perceptrons/index
chapter_builders-guide/index
chapter_convolutional-neural-networks/index
chapter_convolutional-modern/index
chapter_recurrent-neural-networks/index
chapter_recurrent-modern/index
chapter_attention-mechanisms-and-transformers/index
chapter_optimization/index
chapter_computational-performance/index
chapter_computer-vision/index
chapter_natural-language-processing-pretraining/index
chapter_natural-language-processing-applications/index
chapter_reinforcement-learning/index
chapter_gaussian-processes/index
chapter_hyperparameter-optimization/index
chapter_generative-adversarial-networks/index
chapter_recommender-systems/index
chapter_appendix-mathematics-for-deep-learning/index
chapter_appendix-tools-for-deep-learning/index

</code></pre>
<pre><code class="language-toc">:maxdepth: 1

chapter_references/zreferences
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Just a few years ago, there were no legions of deep learning scientists
developing intelligent products and services at major companies and startups.
When we entered the field, machine learning
did not command headlines in daily newspapers.
Our parents had no idea what machine learning was,
let alone why we might prefer it to a career in medicine or law.
Machine learning was a blue skies academic discipline
whose industrial significance was limited
to a narrow set of real-world applications,
including speech recognition and computer vision.
Moreover, many of these applications
required so much domain knowledge
that they were often regarded as entirely separate areas
for which machine learning was one small component.
At that time, neural networks---the
predecessors of the deep learning methods
that we focus on in this book---were
generally regarded as outmoded.</p>
<p>Yet in just a few years, deep learning has taken the world by surprise,
driving rapid progress in such diverse fields
as computer vision, natural language processing,
automatic speech recognition, reinforcement learning,
and biomedical informatics.
Moreover, the success of deep learning
in so many tasks of practical interest
has even catalyzed developments
in theoretical machine learning and statistics.
With these advances in hand,
we can now build cars that drive themselves
with more autonomy than ever before
(though less autonomy than some companies might have you believe),
dialogue systems that debug code by asking clarifying questions,
and software agents beating the best human players in the world at board games such as Go, a feat once thought to be decades away.
Already, these tools exert ever-wider influence on industry and society,
changing the way movies are made, diseases are diagnosed,
and playing a growing role in basic sciences---from astrophysics, to climate modeling, to weather prediction, to biomedicine.</p>
<h2 id="about-this-book"><a class="header" href="#about-this-book">About This Book</a></h2>
<p>This book represents our attempt to make deep learning approachable,
teaching you the <em>concepts</em>, the <em>context</em>, and the <em>code</em>.</p>
<h3 id="one-medium-combining-code-math-and-html"><a class="header" href="#one-medium-combining-code-math-and-html">One Medium Combining Code, Math, and HTML</a></h3>
<p>For any computing technology to reach its full impact,
it must be well understood, well documented, and supported by
mature, well-maintained tools.
The key ideas should be clearly distilled,
minimizing the onboarding time needed
to bring new practitioners up to date.
Mature libraries should automate common tasks,
and exemplar code should make it easy for practitioners
to modify, apply, and extend common applications to suit their needs.</p>
<p>As an example, take dynamic web applications.
Despite a large number of companies, such as Amazon,
developing successful database-driven web applications in the 1990s,
the potential of this technology to aid creative entrepreneurs
was realized to a far greater degree only in the past ten years,
owing in part to the development of powerful, well-documented frameworks.</p>
<p>Testing the potential of deep learning presents unique challenges
because any single application brings together various disciplines.
Applying deep learning requires simultaneously understanding
(i) the motivations for casting a problem in a particular way;
(ii) the mathematical form of a given model;
(iii) the optimization algorithms for fitting the models to data;
(iv) the statistical principles that tell us
when we should expect our models
to generalize to unseen data
and practical methods for certifying
that they have, in fact, generalized;
and (v) the engineering techniques
required to train models efficiently,
navigating the pitfalls of numerical computing
and getting the most out of available hardware.
Teaching the critical thinking skills
required to formulate problems,
the mathematics to solve them,
and the software tools to implement those solutions
all in one place presents formidable challenges.
Our goal in this book is to present a unified resource
to bring would-be practitioners up to speed.</p>
<p>When we started this book project,
there were no resources that simultaneously
(i) remained up to date;
(ii) covered the breadth of modern machine learning practices
with sufficient technical depth;
and (iii) interleaved exposition of
the quality one expects of a textbook
with the clean runnable code
that one expects of a hands-on tutorial.
We found plenty of code examples illustrating
how to use a given deep learning framework
(e.g., how to do basic numerical computing with matrices in TensorFlow)
or for implementing particular techniques
(e.g., code snippets for LeNet, AlexNet, ResNet, etc.)
scattered across various blog posts and GitHub repositories.
However, these examples typically focused on
<em>how</em> to implement a given approach,
but left out the discussion of
<em>why</em> certain algorithmic decisions are made.
While some interactive resources
have popped up sporadically
to address a particular topic,
e.g., the engaging blog posts
published on the website <a href="http://distill.pub">Distill</a>, or personal blogs,
they only covered selected topics in deep learning,
and often lacked associated code.
On the other hand, while several deep learning textbooks
have emerged---e.g., :citet:<code>Goodfellow.Bengio.Courville.2016</code>,
which offers a comprehensive survey
on the basics of deep learning---these
resources do not marry the descriptions
to realizations of the concepts in code,
sometimes leaving readers clueless
as to how to implement them.
Moreover, too many resources
are hidden behind the paywalls
of commercial course providers.</p>
<p>We set out to create a resource that could
(i) be freely available for everyone;
(ii) offer sufficient technical depth
to provide a starting point on the path
to actually becoming an applied machine learning scientist;
(iii) include runnable code, showing readers
<em>how</em> to solve problems in practice;
(iv) allow for rapid updates, both by us
and also by the community at large;
and (v) be complemented by a <a href="https://discuss.d2l.ai/c/5">forum</a>
for interactive discussion of technical details and to answer questions.</p>
<p>These goals were often in conflict.
Equations, theorems, and citations
are best managed and laid out in LaTeX.
Code is best described in Python.
And webpages are native in HTML and JavaScript.
Furthermore, we want the content to be
accessible both as executable code, as a physical book,
as a downloadable PDF, and on the Internet as a website.
No workflows seemed suited to these demands,
so we decided to assemble our own (:numref:<code>sec_how_to_contribute</code>).
We settled on GitHub to share the source
and to facilitate community contributions;
Jupyter notebooks for mixing code, equations and text;
Sphinx as a rendering engine;
and Discourse as a discussion platform.
While our system is not perfect,
these choices strike a compromise
among the competing concerns.
We believe that <em>Dive into Deep Learning</em>
might be the first book published
using such an integrated workflow.</p>
<h3 id="learning-by-doing"><a class="header" href="#learning-by-doing">Learning by Doing</a></h3>
<p>Many textbooks present concepts in succession,
covering each in exhaustive detail.
For example,
the excellent textbook of
:citet:<code>Bishop.2006</code>
teaches each topic so thoroughly
that getting to the chapter
on linear regression requires
a nontrivial amount of work.
While experts love this book
precisely for its thoroughness,
for true beginners, this property limits
its usefulness as an introductory text.</p>
<p>In this book, we teach most concepts <em>just in time</em>.
In other words, you will learn concepts at the very moment
that they are needed to accomplish some practical end.
While we take some time at the outset to teach
fundamental preliminaries, like linear algebra and probability,
we want you to taste the satisfaction of training your first model
before worrying about more esoteric concepts.</p>
<p>Aside from a few preliminary notebooks that provide a crash course
in the basic mathematical background,
each subsequent chapter both introduces a reasonable number of new concepts
and provides several self-contained working examples, using real datasets.
This presented an organizational challenge.
Some models might logically be grouped together in a single notebook.
And some ideas might be best taught
by executing several models in succession.
By contrast, there is a big advantage to adhering
to a policy of <em>one working example, one notebook</em>:
This makes it as easy as possible for you to
start your own research projects by leveraging our code.
Just copy a notebook and start modifying it.</p>
<p>Throughout, we interleave the runnable code
with background material as needed.
In general, we err on the side of making tools
available before explaining them fully
(often filling in the background later).
For instance, we might use <em>stochastic gradient descent</em>
before explaining why it is useful
or offering some intuition for why it works.
This helps to give practitioners the necessary
ammunition to solve problems quickly,
at the expense of requiring the reader
to trust us with some curatorial decisions.</p>
<p>This book teaches deep learning concepts from scratch.
Sometimes, we delve into fine details about models
that would typically be hidden from users
by modern deep learning frameworks.
This comes up especially in the basic tutorials,
where we want you to understand everything
that happens in a given layer or optimizer.
In these cases, we often present
two versions of the example:
one where we implement everything from scratch,
relying only on NumPy-like functionality
and automatic differentiation,
and a more practical example,
where we write succinct code
using the high-level APIs of deep learning frameworks.
After explaining how some component works,
we rely on the high-level API in subsequent tutorials.</p>
<h3 id="content-and-structure"><a class="header" href="#content-and-structure">Content and Structure</a></h3>
<p>The book can be divided into roughly three parts,
dealing with preliminaries,
deep learning techniques,
and advanced topics
focused on real systems
and applications (:numref:<code>fig_book_org</code>).</p>
<p><img src="chapter_preface/../img/book-org.svg" alt="Book structure." />
:label:<code>fig_book_org</code></p>
<ul>
<li>
<p><strong>Part 1: Basics and Preliminaries</strong>.
:numref:<code>chap_introduction</code> is
an introduction to deep learning.
Then, in :numref:<code>chap_preliminaries</code>,
we quickly bring you up to speed
on the prerequisites required
for hands-on deep learning,
such as how to store and manipulate data,
and how to apply various numerical operations
based on elementary concepts from linear algebra,
calculus, and probability.
:numref:<code>chap_regression</code> and :numref:<code>chap_perceptrons</code>
cover the most fundamental concepts and techniques in deep learning,
including regression and classification;
linear models; multilayer perceptrons;
and overfitting and regularization.</p>
</li>
<li>
<p><strong>Part 2: Modern Deep Learning Techniques</strong>.
:numref:<code>chap_computation</code> describes
the key computational components
of deep learning systems
and lays the groundwork
for our subsequent implementations
of more complex models.
Next, :numref:<code>chap_cnn</code> and :numref:<code>chap_modern_cnn</code>
present convolutional neural networks (CNNs),
powerful tools that form the backbone
of most modern computer vision systems.
Similarly, :numref:<code>chap_rnn</code> and :numref:<code>chap_modern_rnn</code>
introduce recurrent neural networks (RNNs),
models that exploit sequential (e.g., temporal)
structure in data and are commonly used
for natural language processing
and time series prediction.
In :numref:<code>chap_attention-and-transformers</code>,
we describe a relatively new class of models,
based on so-called <em>attention mechanisms</em>,
that has displaced RNNs as the dominant architecture
for most natural language processing tasks.
These sections will bring you up to speed
on the most powerful and general tools
that are widely used by deep learning practitioners.</p>
</li>
<li>
<p><strong>Part 3: Scalability, Efficiency, and Applications</strong> (available <a href="https://d2l.ai">online</a>).
In Chapter 12,
we discuss several common optimization algorithms
used to train deep learning models.
Next, in Chapter 13,
we examine several key factors
that influence the computational performance
of deep learning code.
Then, in Chapter 14,
we illustrate major applications
of deep learning in computer vision.
Finally, in Chapter 15 and Chapter 16,
we demonstrate how to pretrain language representation models
and apply them to natural language processing tasks.</p>
</li>
</ul>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>:label:<code>sec_code</code></p>
<p>Most sections of this book feature executable code.
We believe that some intuitions are best developed
via trial and error,
tweaking the code in small ways and observing the results.
Ideally, an elegant mathematical theory might tell us
precisely how to tweak our code to achieve a desired result.
However, deep learning practitioners today
must often tread where no solid theory provides guidance.
Despite our best attempts, formal explanations
for the efficacy of various techniques are
still lacking, for a variety of reasons: the mathematics to characterize these models
can be so difficult;
the explanation likely depends on properties
of the data that currently lack clear definitions;
and serious inquiry on these topics
has only recently kicked into high gear.
We are hopeful that as the theory of deep learning progresses,
each future edition of this book will provide insights
that eclipse those presently available.</p>
<p>To avoid unnecessary repetition, we capture
some of our most frequently imported and used
functions and classes in the <code>d2l</code> package.
Throughout, we mark blocks of code
(such as functions, classes,
or collection of import statements) with <code>#@save</code>
to indicate that they will be accessed later
via the <code>d2l</code> package.
We offer a detailed overview
of these classes and functions in :numref:<code>sec_d2l</code>.
The <code>d2l</code> package is lightweight and only requires
the following dependencies:</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
import inspect
import collections
from collections import defaultdict
from IPython import display
import math
from matplotlib import pyplot as plt
from matplotlib_inline import backend_inline
import os
import pandas as pd
import random
import re
import shutil
import sys
import tarfile
import time
import requests
import zipfile
import hashlib
d2l = sys.modules[__name__]
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Most of the code in this book is based on Apache MXNet,
an open-source framework for deep learning
that is the preferred choice
of AWS (Amazon Web Services),
as well as many colleges and companies.
All of the code in this book has passed tests
under the newest MXNet version.
However, due to the rapid development of deep learning,
some code <em>in the print edition</em>
may not work properly in future versions of MXNet.
We plan to keep the online version up to date.
In case you encounter any problems,
please consult :ref:<code>chap_installation</code>
to update your code and runtime environment.
Below lists dependencies in our MXNet implementation.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Most of the code in this book is based on PyTorch,
a popular open-source framework
that has been enthusiastically embraced
by the deep learning research community.
All of the code in this book has passed tests
under the latest stable version of PyTorch.
However, due to the rapid development of deep learning,
some code <em>in the print edition</em>
may not work properly in future versions of PyTorch.
We plan to keep the online version up to date.
In case you encounter any problems,
please consult :ref:<code>chap_installation</code>
to update your code and runtime environment.
Below lists dependencies in our PyTorch implementation.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Most of the code in this book is based on TensorFlow,
an open-source framework for deep learning
that is widely adopted in industry
and popular among researchers.
All of the code in this book has passed tests
under the latest stable version TensorFlow.
However, due to the rapid development of deep learning,
some code <em>in the print edition</em>
may not work properly in future versions of TensorFlow.
We plan to keep the online version up to date.
In case you encounter any problems,
please consult :ref:<code>chap_installation</code>
to update your code and runtime environment.
Below lists dependencies in our TensorFlow implementation.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Most of the code in this book is based on Jax,
an open-source framework enabling composable function
transformations such as differentiation of arbitrary
Python and NumPy functions, as well as JIT compliation,
vectorization and much more! It is becoming popular in
the machine learning research space and has an
easy-to-learn NumPy-like API. Actually, JAX tries
to achieve 1:1 parity with NumPy, so switching your
code could be as simple as changing a single import statement!
However, due to the rapid development of deep learning,
some code <em>in the print edition</em>
may not work properly in future versions of Jax.
We plan to keep the online version up to date.
In case you encounter any problems,
please consult :ref:<code>chap_installation</code>
to update your code and runtime environment.
Below lists dependencies in our JAX implementation.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
from mxnet import autograd, context, gluon, image, init, np, npx
from mxnet.gluon import nn, rnn
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
import numpy as np
import torch
import torchvision
from torch import nn
from torch.nn import functional as F
from torchvision import transforms
from PIL import Image
from scipy.spatial import distance_matrix
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
import numpy as np
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">#@tab jax
#@save
from dataclasses import field
from functools import partial
import flax
from flax import linen as nn
from flax.training import train_state
import jax
from jax import numpy as jnp
from jax import grad, vmap
import numpy as np
import optax
import tensorflow as tf
import tensorflow_datasets as tfds
from types import FunctionType
from typing import Any
</code></pre>
<h3 id="target-audience"><a class="header" href="#target-audience">Target Audience</a></h3>
<p>This book is for students (undergraduate or graduate),
engineers, and researchers, who seek a solid grasp
of the practical techniques of deep learning.
Because we explain every concept from scratch,
no previous background in deep learning or machine learning is required.
Fully explaining the methods of deep learning
requires some mathematics and programming,
but we will only assume that you enter with some basics,
including modest amounts of linear algebra,
calculus, probability, and Python programming.
Just in case you have forgotten anything,
the <a href="https://d2l.ai/chapter_appendix-mathematics-for-deep-learning/index.html">online Appendix</a> provides a refresher
on most of the mathematics
you will find in this book.
Usually, we will prioritize
intuition and ideas
over mathematical rigor.
If you would like to extend these foundations
beyond the prerequisites to understand our book,
we happily recommend some other terrific resources:
<em>Linear Analysis</em> by :citet:<code>Bollobas.1999</code>
covers linear algebra and functional analysis in great depth.
<em>All of Statistics</em> :cite:<code>Wasserman.2013</code>
provides a marvelous introduction to statistics.
Joe Blitzstein's <a href="https://www.amazon.com/Introduction-Probability-Chapman-Statistical-Science/dp/1138369918">books</a>
and <a href="https://projects.iq.harvard.edu/stat110/home">courses</a>
on probability and inference are pedagogical gems.
And if you have not used Python before,
you may want to peruse this <a href="http://learnpython.org/">Python tutorial</a>.</p>
<h3 id="notebooks-website-github-and-forum"><a class="header" href="#notebooks-website-github-and-forum">Notebooks, Website, GitHub, and Forum</a></h3>
<p>All our notebooks can be downloaded
from the <a href="https://d2l.ai">D2L.ai website</a>
and from <a href="https://github.com/d2l-ai/d2l-en">GitHub</a>.
Associated with this book we have launched a discussion forum
at <a href="https://discuss.d2l.ai/c/5">discuss.d2l.ai</a>.
Whenever you have questions on any section of the book,
you can find a link to the associated discussion page
at the end of each notebook.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>We are indebted to the hundreds of contributors for both
the English and the Chinese drafts.
They helped improve the content and offered valuable feedback.
This book was originally implemented with MXNet as the primary framework.
We thank Anirudh Dagar and Yuan Tang for adapting a majority part of earlier MXNet code into PyTorch and TensorFlow implementations, respectively.
Since July 2021, we have redesigned and reimplemented this book in PyTorch, MXNet, and TensorFlow, choosing PyTorch as the primary framework.
We thank Anirudh Dagar for adapting a majority part of more recent PyTorch code into JAX implementations.
We thank Gaosheng Wu, Liujun Hu, Ge Zhang, and Jiehang Xie from Baidu for adapting a majority part of more recent PyTorch code into PaddlePaddle implementations in the Chinese draft.
We thank Shuai Zhang for integrating the LaTeX style from the press into the PDF building.</p>
<p>On GitHub, we thank every contributor of this English draft
for making it better for everyone.
Their GitHub IDs or names are (in no particular order):
alxnorden, avinashingit, bowen0701, brettkoonce, Chaitanya Prakash Bapat,
cryptonaut, Davide Fiocco, edgarroman, gkutiel, John Mitro, Liang Pu,
Rahul Agarwal, Mohamed Ali Jamaoui, Michael (Stu) Stewart, Mike Müller,
NRauschmayr, Prakhar Srivastav, sad-, sfermigier, Sheng Zha, sundeepteki,
topecongiro, tpdi, vermicelli, Vishaal Kapoor, Vishwesh Ravi Shrimali, YaYaB, Yuhong Chen,
Evgeniy Smirnov, lgov, Simon Corston-Oliver, Igor Dzreyev, Ha Nguyen, pmuens,
Andrei Lukovenko, senorcinco, vfdev-5, dsweet, Mohammad Mahdi Rahimi, Abhishek Gupta,
uwsd, DomKM, Lisa Oakley, Bowen Li, Aarush Ahuja, Prasanth Buddareddygari, brianhendee,
mani2106, mtn, lkevinzc, caojilin, Lakshya, Fiete Lüer, Surbhi Vijayvargeeya,
Muhyun Kim, dennismalmgren, adursun, Anirudh Dagar, liqingnz, Pedro Larroy,
lgov, ati-ozgur, Jun Wu, Matthias Blume, Lin Yuan, geogunow, Josh Gardner,
Maximilian Böther, Rakib Islam, Leonard Lausen, Abhinav Upadhyay, rongruosong,
Steve Sedlmeyer, Ruslan Baratov, Rafael Schlatter, liusy182, Giannis Pappas,
ati-ozgur, qbaza, dchoi77, Adam Gerson, Phuc Le, Mark Atwood, christabella, vn09,
Haibin Lin, jjangga0214, RichyChen, noelo, hansent, Giel Dops, dvincent1337, WhiteD3vil,
Peter Kulits, codypenta, joseppinilla, ahmaurya, karolszk, heytitle, Peter Goetz, rigtorp,
Tiep Vu, sfilip, mlxd, Kale-ab Tessera, Sanjar Adilov, MatteoFerrara, hsneto,
Katarzyna Biesialska, Gregory Bruss, Duy–Thanh Doan, paulaurel, graytowne, Duc Pham,
sl7423, Jaedong Hwang, Yida Wang, cys4, clhm, Jean Kaddour, austinmw, trebeljahr, tbaums,
Cuong V. Nguyen, pavelkomarov, vzlamal, NotAnotherSystem, J-Arun-Mani, jancio, eldarkurtic,
the-great-shazbot, doctorcolossus, gducharme, cclauss, Daniel-Mietchen, hoonose, biagiom,
abhinavsp0730, jonathanhrandall, ysraell, Nodar Okroshiashvili, UgurKap, Jiyang Kang,
StevenJokes, Tomer Kaftan, liweiwp, netyster, ypandya, NishantTharani, heiligerl, SportsTHU,
Hoa Nguyen, manuel-arno-korfmann-webentwicklung, aterzis-personal, nxby, Xiaoting He, Josiah Yoder,
mathresearch, mzz2017, jroberayalas, iluu, ghejc, BSharmi, vkramdev, simonwardjones, LakshKD,
TalNeoran, djliden, Nikhil95, Oren Barkan, guoweis, haozhu233, pratikhack, Yue Ying, tayfununal,
steinsag, charleybeller, Andrew Lumsdaine, Jiekui Zhang, Deepak Pathak, Florian Donhauser, Tim Gates,
Adriaan Tijsseling, Ron Medina, Gaurav Saha, Murat Semerci, Lei Mao, Levi McClenny, Joshua Broyde,
jake221, jonbally, zyhazwraith, Brian Pulfer, Nick Tomasino, Lefan Zhang, Hongshen Yang, Vinney Cavallo,
yuntai, Yuanxiang Zhu, amarazov, pasricha, Ben Greenawald, Shivam Upadhyay, Quanshangze Du, Biswajit Sahoo,
Parthe Pandit, Ishan Kumar, HomunculusK, Lane Schwartz, varadgunjal, Jason Wiener, Armin Gholampoor,
Shreshtha13, eigen-arnav, Hyeonggyu Kim, EmilyOng, Bálint Mucsányi, Chase DuBois, Juntian Tao,
Wenxiang Xu, Lifu Huang, filevich, quake2005, nils-werner, Yiming Li, Marsel Khisamutdinov,
Francesco "Fuma" Fumagalli, Peilin Sun, Vincent Gurgul, qingfengtommy, Janmey Shukla, Mo Shan,
Kaan Sancak, regob, AlexSauer, Gopalakrishna Ramachandra, Tobias Uelwer, Chao Wang, Tian Cao,
Nicolas Corthorn, akash5474, kxxt, zxydi1992, Jacob Britton, Shuangchi He, zhmou, krahets, Jie-Han Chen,
Atishay Garg, Marcel Flygare, adtygan, Nik Vaessen, bolded, Louis Schlessinger, Balaji Varatharajan,
atgctg, Kaixin Li, Victor Barbaros, Riccardo Musto, Elizabeth Ho, azimjonn, Guilherme Miotto, Alessandro Finamore,
Joji Joseph, Anthony Biel, Zeming Zhao, shjustinbaek, gab-chen, nantekoto, Yutaro Nishiyama, Oren Amsalem,
Tian-MaoMao, Amin Allahyar, Gijs van Tulder, Mikhail Berkov, iamorphen, Matthew Caseres, Andrew Walsh,
pggPL, RohanKarthikeyan, Ryan Choi, and Likun Lei.</p>
<p>We thank Amazon Web Services, especially Wen-Ming Ye, George Karypis, Swami Sivasubramanian, Peter DeSantis, Adam Selipsky,
and Andrew Jassy for their generous support in writing this book.
Without the available time, resources, discussions with colleagues,
and continuous encouragement, this book would not have happened.
During the preparation of the book for publication,
Cambridge University Press has offered excellent support.
We thank our commissioning editor David Tranah
for his help and professionalism.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Deep learning has revolutionized pattern recognition,
introducing technology that now powers a wide range of  technologies,
in such diverse fields as computer vision,
natural language processing,
and automatic speech recognition.
To successfully apply deep learning,
you must understand how to cast a problem,
the basic mathematics of modeling,
the algorithms for fitting your models to data,
and the engineering techniques to implement it all.
This book presents a comprehensive resource,
including prose, figures, mathematics, and code, all in one place.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>Register an account on the discussion forum of this book <a href="https://discuss.d2l.ai/">discuss.d2l.ai</a>.</li>
<li>Install Python on your computer.</li>
<li>Follow the links at the bottom of the section to the forum, where you will be able to seek out help and discuss the book and find answers to your questions by engaging the authors and broader community.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/18">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/20">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/186">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17963">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>:label:<code>chap_installation</code></p>
<p>In order to get up and running,
we will need an environment for running Python,
the Jupyter Notebook, the relevant libraries,
and the code needed to run the book itself.</p>
<h2 id="installing-miniconda"><a class="header" href="#installing-miniconda">Installing Miniconda</a></h2>
<p>Your simplest option is to install
<a href="https://conda.io/en/latest/miniconda.html">Miniconda</a>.
Note that the Python 3.x version is required.
You can skip the following steps
if your machine already has conda installed.</p>
<p>Visit the Miniconda website and determine
the appropriate version for your system
based on your Python 3.x version and machine architecture.
Suppose that your Python version is 3.9
(our tested version).
If you are using macOS,
you would download the bash script
whose name contains the strings "MacOSX",
navigate to the download location,
and execute the installation as follows
(taking Intel Macs as an example):</p>
<pre><code class="language-bash"># The file name is subject to changes
sh Miniconda3-py39_4.12.0-MacOSX-x86_64.sh -b
</code></pre>
<p>A Linux user
would download the file
whose name contains the strings "Linux"
and execute the following at the download location:</p>
<pre><code class="language-bash"># The file name is subject to changes
sh Miniconda3-py39_4.12.0-Linux-x86_64.sh -b
</code></pre>
<p>A Windows user would download and install Miniconda by following its <a href="https://conda.io/en/latest/miniconda.html">online instructions</a>.
On Windows, you may search for <code>cmd</code> to open the Command Prompt (command-line interpreter) for running commands.</p>
<p>Next, initialize the shell so we can run <code>conda</code> directly.</p>
<pre><code class="language-bash">~/miniconda3/bin/conda init
</code></pre>
<p>Then close and reopen your current shell.
You should be able to create
a new environment as follows:</p>
<pre><code class="language-bash">conda create --name d2l python=3.9 -y
</code></pre>
<p>Now we can activate the <code>d2l</code> environment:</p>
<pre><code class="language-bash">conda activate d2l
</code></pre>
<h2 id="installing-the-deep-learning-framework-and-the-d2l-package"><a class="header" href="#installing-the-deep-learning-framework-and-the-d2l-package">Installing the Deep Learning Framework and the <code>d2l</code> Package</a></h2>
<p>Before installing any deep learning framework,
please first check whether or not
you have proper GPUs on your machine
(the GPUs that power the display
on a standard laptop are not relevant for our purposes).
For example,
if your computer has NVIDIA GPUs and has installed <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>,
then you are all set.
If your machine does not house any GPU,
there is no need to worry just yet.
Your CPU provides more than enough horsepower
to get you through the first few chapters.
Just remember that you will want to access GPUs
before running larger models.</p>
<p>:begin_tab:<code>mxnet</code></p>
<p>To install a GPU-enabled version of MXNet,
we need to find out what version of CUDA you have installed.
You can check this by running <code>nvcc --version</code>
or <code>cat /usr/local/cuda/version.txt</code>.
Assume that you have installed CUDA 11.2,
then execute the following command:</p>
<pre><code class="language-bash"># For macOS and Linux users
pip install mxnet-cu112==1.9.1

# For Windows users
pip install mxnet-cu112==1.9.1 -f https://dist.mxnet.io/python
</code></pre>
<p>You may change the last digits according to your CUDA version, e.g., <code>cu101</code> for
CUDA 10.1 and <code>cu90</code> for CUDA 9.0.</p>
<p>If your machine has no NVIDIA GPUs
or CUDA,
you can install the CPU version
as follows:</p>
<pre><code class="language-bash">pip install mxnet==1.9.1
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>pytorch</code></p>
<p>You can install PyTorch (the specified versions are tested at the time of writing) with either CPU or GPU support as follows:</p>
<pre><code class="language-bash">pip install torch==2.0.0 torchvision==0.15.1
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
You can install TensorFlow with either CPU or GPU support as follows:</p>
<pre><code class="language-bash">pip install tensorflow==2.12.0 tensorflow-probability==0.20.0
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>jax</code>
You can install JAX and Flax with either CPU or GPU support as follows:</p>
<pre><code class="language-bash"># GPU
pip install "jax[cuda11_pip]==0.4.13" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html flax==0.7.0
</code></pre>
<p>If your machine has no NVIDIA GPUs
or CUDA,
you can install the CPU version
as follows:</p>
<pre><code class="language-bash"># CPU
pip install "jax[cpu]==0.4.13" flax==0.7.0
</code></pre>
<p>:end_tab:</p>
<p>Our next step is to install
the <code>d2l</code> package that we developed
in order to encapsulate
frequently used functions and classes
found throughout this book:</p>
<pre><code class="language-bash">pip install d2l==1.0.3
</code></pre>
<h2 id="downloading-and-running-the-code"><a class="header" href="#downloading-and-running-the-code">Downloading and Running the Code</a></h2>
<p>Next, you will want to download the notebooks
so that you can run each of the book's code blocks.
Simply click on the "Notebooks" tab at the top
of any HTML page on <a href="https://d2l.ai/">the D2L.ai website</a>
to download the code and then unzip it.
Alternatively, you can fetch the notebooks
from the command line as follows:</p>
<p>:begin_tab:<code>mxnet</code></p>
<pre><code class="language-bash">mkdir d2l-en &amp;&amp; cd d2l-en
curl https://d2l.ai/d2l-en-1.0.3.zip -o d2l-en.zip
unzip d2l-en.zip &amp;&amp; rm d2l-en.zip
cd mxnet
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>pytorch</code></p>
<pre><code class="language-bash">mkdir d2l-en &amp;&amp; cd d2l-en
curl https://d2l.ai/d2l-en-1.0.3.zip -o d2l-en.zip
unzip d2l-en.zip &amp;&amp; rm d2l-en.zip
cd pytorch
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code></p>
<pre><code class="language-bash">mkdir d2l-en &amp;&amp; cd d2l-en
curl https://d2l.ai/d2l-en-1.0.3.zip -o d2l-en.zip
unzip d2l-en.zip &amp;&amp; rm d2l-en.zip
cd tensorflow
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>jax</code></p>
<pre><code class="language-bash">mkdir d2l-en &amp;&amp; cd d2l-en
curl https://d2l.ai/d2l-en-1.0.3.zip -o d2l-en.zip
unzip d2l-en.zip &amp;&amp; rm d2l-en.zip
cd jax
</code></pre>
<p>:end_tab:</p>
<p>If you do not already have <code>unzip</code> installed, first run <code>sudo apt-get install unzip</code>.
Now we can start the Jupyter Notebook server by running:</p>
<pre><code class="language-bash">jupyter notebook
</code></pre>
<p>At this point, you can open http://localhost:8888
(it may have already opened automatically) in your web browser.
Then we can run the code for each section of the book.
Whenever you open a new command line window,
you will need to execute <code>conda activate d2l</code>
to activate the runtime environment
before running the D2L notebooks,
or updating your packages
(either the deep learning framework
or the <code>d2l</code> package).
To exit the environment,
run <code>conda deactivate</code>.</p>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/23">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/24">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/436">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17964">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<p>:label:<code>chap_notation</code></p>
<p>Throughout this book, we adhere
to the following notational conventions.
Note that some of these symbols are placeholders,
while others refer to specific objects.
As a general rule of thumb,
the indefinite article "a" often indicates
that the symbol is a placeholder
and that similarly formatted symbols
can denote other objects of the same type.
For example, "$x$: a scalar" means
that lowercased letters generally
represent scalar values,
but "$\mathbb{Z}$: the set of integers"
refers specifically to the symbol $\mathbb{Z}$.</p>
<h2 id="numerical-objects"><a class="header" href="#numerical-objects">Numerical Objects</a></h2>
<ul>
<li>$x$: a scalar</li>
<li>$\mathbf{x}$: a vector</li>
<li>$\mathbf{X}$: a matrix</li>
<li>$\mathsf{X}$: a general tensor</li>
<li>$\mathbf{I}$: the identity matrix (of some given dimension), i.e., a square matrix with $1$ on all diagonal entries and $0$ on all off-diagonals</li>
<li>$x_i$, $[\mathbf{x}]_i$: the $i^\textrm{th}$ element of vector $\mathbf{x}$</li>
<li>$x_{ij}$, $x_{i,j}$,$[\mathbf{X}]<em>{ij}$, $[\mathbf{X}]</em>{i,j}$: the element of matrix $\mathbf{X}$ at row $i$ and column $j$.</li>
</ul>
<h2 id="set-theory"><a class="header" href="#set-theory">Set Theory</a></h2>
<ul>
<li>$\mathcal{X}$: a set</li>
<li>$\mathbb{Z}$: the set of integers</li>
<li>$\mathbb{Z}^+$: the set of positive integers</li>
<li>$\mathbb{R}$: the set of real numbers</li>
<li>$\mathbb{R}^n$: the set of $n$-dimensional vectors of real numbers</li>
<li>$\mathbb{R}^{a\times b}$: The set of matrices of real numbers with $a$ rows and $b$ columns</li>
<li>$|\mathcal{X}|$: cardinality (number of elements) of set $\mathcal{X}$</li>
<li>$\mathcal{A}\cup\mathcal{B}$: union of sets $\mathcal{A}$ and $\mathcal{B}$</li>
<li>$\mathcal{A}\cap\mathcal{B}$: intersection of sets $\mathcal{A}$ and $\mathcal{B}$</li>
<li>$\mathcal{A}\setminus\mathcal{B}$: set subtraction of $\mathcal{B}$ from $\mathcal{A}$ (contains only those elements of $\mathcal{A}$ that do not belong to $\mathcal{B}$)</li>
</ul>
<h2 id="functions-and-operators"><a class="header" href="#functions-and-operators">Functions and Operators</a></h2>
<ul>
<li>$f(\cdot)$: a function</li>
<li>$\log(\cdot)$: the natural logarithm (base $e$)</li>
<li>$\log_2(\cdot)$: logarithm to base $2$</li>
<li>$\exp(\cdot)$: the exponential function</li>
<li>$\mathbf{1}(\cdot)$: the indicator function; evaluates to $1$ if the boolean argument is true, and $0$ otherwise</li>
<li>$\mathbf{1}_{\mathcal{X}}(z)$: the set-membership indicator function; evaluates to $1$ if the element $z$ belongs to the set $\mathcal{X}$ and $0$ otherwise</li>
<li>$\mathbf{(\cdot)}^\top$: transpose of a vector or a matrix</li>
<li>$\mathbf{X}^{-1}$: inverse of matrix $\mathbf{X}$</li>
<li>$\odot$: Hadamard (elementwise) product</li>
<li>$[\cdot, \cdot]$: concatenation</li>
<li>$|\cdot|_p$: $\ell_p$ norm</li>
<li>$|\cdot|$: $\ell_2$ norm</li>
<li>$\langle \mathbf{x}, \mathbf{y} \rangle$: inner (dot) product of vectors $\mathbf{x}$ and $\mathbf{y}$</li>
<li>$\sum$: summation over a collection of elements</li>
<li>$\prod$: product over a collection of elements</li>
<li>$\stackrel{\textrm{def}}{=}$: an equality asserted as a definition of the symbol on the left-hand side</li>
</ul>
<h2 id="calculus"><a class="header" href="#calculus">Calculus</a></h2>
<ul>
<li>$\frac{dy}{dx}$: derivative of $y$ with respect to $x$</li>
<li>$\frac{\partial y}{\partial x}$: partial derivative of $y$ with respect to $x$</li>
<li>$\nabla_{\mathbf{x}} y$: gradient of $y$ with respect to $\mathbf{x}$</li>
<li>$\int_a^b f(x) ;dx$: definite integral of $f$ from $a$ to $b$ with respect to $x$</li>
<li>$\int f(x) ;dx$: indefinite integral of $f$ with respect to $x$</li>
</ul>
<h2 id="probability-and-information-theory"><a class="header" href="#probability-and-information-theory">Probability and Information Theory</a></h2>
<ul>
<li>$X$: a random variable</li>
<li>$P$: a probability distribution</li>
<li>$X \sim P$: the random variable $X$ follows distribution $P$</li>
<li>$P(X=x)$: the probability assigned to the event where random variable $X$ takes value $x$</li>
<li>$P(X \mid Y)$: the conditional probability distribution of $X$ given $Y$</li>
<li>$p(\cdot)$: a probability density function (PDF) associated with distribution $P$</li>
<li>${E}[X]$: expectation of a random variable $X$</li>
<li>$X \perp Y$: random variables $X$ and $Y$ are independent</li>
<li>$X \perp Y \mid Z$: random variables  $X$  and  $Y$ are conditionally independent given $Z$</li>
<li>$\sigma_X$: standard deviation of random variable $X$</li>
<li>$\textrm{Var}(X)$: variance of random variable $X$, equal to $\sigma^2_X$</li>
<li>$\textrm{Cov}(X, Y)$: covariance of random variables $X$ and $Y$</li>
<li>$\rho(X, Y)$: the Pearson correlation coefficient between $X$ and $Y$, equals $\frac{\textrm{Cov}(X, Y)}{\sigma_X \sigma_Y}$</li>
<li>$H(X)$: entropy of random variable $X$</li>
<li>$D_{\textrm{KL}}(P|Q)$: the KL-divergence (or relative entropy) from distribution $Q$ to distribution $P$</li>
</ul>
<p><a href="https://discuss.d2l.ai/t/25">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>:label:<code>chap_introduction</code></p>
<p>Until recently, nearly every computer program
that you might have interacted with during
an ordinary day
was coded up as a rigid set of rules
specifying precisely how it should behave.
Say that we wanted to write an application
to manage an e-commerce platform.
After huddling around a whiteboard
for a few hours to ponder the problem,
we might settle on the broad strokes
of a working solution, for example:
(i) users interact with the application through an interface
running in a web browser or mobile application;
(ii) our application interacts with a commercial-grade database engine
to keep track of each user's state and maintain records
of historical transactions;
and (iii) at the heart of our application,
the <em>business logic</em> (you might say, the <em>brains</em>) of our application
spells out a set of rules that map every conceivable circumstance
to the corresponding action that our program should take.</p>
<p>To build the brains of our application,
we might enumerate all the common events
that our program should handle.
For example, whenever a customer clicks
to add an item to their shopping cart,
our program should add an entry
to the shopping cart database table,
associating that user's ID
with the requested product's ID.
We might then attempt to step through
every possible corner case,
testing the appropriateness of our rules
and making any necessary modifications.
What happens if a user
initiates a purchase with an empty cart?
While few developers ever get it
completely right the first time
(it might take some test runs to work out the kinks),
for the most part we can write such programs
and confidently launch them
<em>before</em> ever seeing a real customer.
Our ability to manually design automated systems
that drive functioning products and systems,
often in novel situations,
is a remarkable cognitive feat.
And when you are able to devise solutions
that work $100%$ of the time,
you typically should not be
worrying about machine learning.</p>
<p>Fortunately for the growing community
of machine learning scientists,
many tasks that we would like to automate
do not bend so easily to human ingenuity.
Imagine huddling around the whiteboard
with the smartest minds you know,
but this time you are tackling
one of the following problems:</p>
<ul>
<li>Write a program that predicts tomorrow's weather given geographic information, satellite images, and a trailing window of past weather.</li>
<li>Write a program that takes in a factoid question, expressed in free-form text, and  answers it correctly.</li>
<li>Write a program that, given an image, identifies every person depicted in it and draws outlines around each.</li>
<li>Write a program that presents users with products that they are likely to enjoy but unlikely, in the natural course of browsing, to encounter.</li>
</ul>
<p>For these problems,
even elite programmers would struggle
to code up solutions from scratch.
The reasons can vary.
Sometimes the program that we are looking for
follows a pattern that changes over time,
so there is no fixed right answer!
In such cases, any successful solution
must adapt gracefully to a changing world.
At other times, the relationship (say between pixels,
and abstract categories) may be too complicated,
requiring thousands or millions of computations
and following unknown principles.
In the case of image recognition,
the precise steps required to perform the task
lie beyond our conscious understanding,
even though our subconscious cognitive processes
execute the task effortlessly.</p>
<p><em>Machine learning</em> is the study of algorithms
that can learn from experience.
As a machine learning algorithm accumulates more experience,
typically in the form of observational data
or interactions with an environment,
its performance improves.
Contrast this with our deterministic e-commerce platform,
which follows the same business logic,
no matter how much experience accrues,
until the developers themselves learn and decide
that it is time to update the software.
In this book, we will teach you
the fundamentals of machine learning,
focusing in particular on <em>deep learning</em>,
a powerful set of techniques
driving innovations in areas as diverse as computer vision,
natural language processing, healthcare, and genomics.</p>
<h2 id="a-motivating-example"><a class="header" href="#a-motivating-example">A Motivating Example</a></h2>
<p>Before beginning writing, the authors of this book,
like much of the work force, had to become caffeinated.
We hopped in the car and started driving.
Using an iPhone, Alex called out "Hey Siri",
awakening the phone's voice recognition system.
Then Mu commanded "directions to Blue Bottle coffee shop".
The phone quickly displayed the transcription of his command.
It also recognized that we were asking for directions
and launched the Maps application (app)
to fulfill our request.
Once launched, the Maps app identified a number of routes.
Next to each route, the phone displayed a predicted transit time.
While this story was fabricated for pedagogical convenience,
it demonstrates that in the span of just a few seconds,
our everyday interactions with a smart phone
can engage several machine learning models.</p>
<p>Imagine just writing a program to respond to a <em>wake word</em>
such as "Alexa", "OK Google", and "Hey Siri".
Try coding it up in a room by yourself
with nothing but a computer and a code editor,
as illustrated in :numref:<code>fig_wake_word</code>.
How would you write such a program from first principles?
Think about it... the problem is hard.
Every second, the microphone will collect roughly
44,000 samples.
Each sample is a measurement of the amplitude of the sound wave.
What rule could map reliably from a snippet of raw audio to confident predictions
${\textrm{yes}, \textrm{no}}$
about whether the snippet contains the wake word?
If you are stuck, do not worry.
We do not know how to write such a program from scratch either.
That is why we use machine learning.</p>
<p><img src="chapter_introduction/../img/wake-word.svg" alt="Identify a wake word." />
:label:<code>fig_wake_word</code></p>
<p>Here is the trick.
Often, even when we do not know how to tell a computer
explicitly how to map from inputs to outputs,
we are nonetheless capable of performing the cognitive feat ourselves.
In other words, even if you do not know
how to program a computer to recognize the word "Alexa",
you yourself are able to recognize it.
Armed with this ability, we can collect a huge <em>dataset</em>
containing examples of audio snippets and associated labels,
indicating which snippets contain the wake word.
In the currently dominant approach to machine learning,
we do not attempt to design a system
<em>explicitly</em> to recognize wake words.
Instead, we define a flexible program
whose behavior is determined by a number of <em>parameters</em>.
Then we use the dataset to determine the best possible parameter values,
i.e., those that improve the performance of our program
with respect to a chosen performance measure.</p>
<p>You can think of the parameters as knobs that we can turn,
manipulating the behavior of the program.
Once the parameters are fixed, we call the program a <em>model</em>.
The set of all distinct programs (input--output mappings)
that we can produce just by manipulating the parameters
is called a <em>family</em> of models.
And the "meta-program" that uses our dataset
to choose the parameters is called a <em>learning algorithm</em>.</p>
<p>Before we can go ahead and engage the learning algorithm,
we have to define the problem precisely,
pinning down the exact nature of the inputs and outputs,
and choosing an appropriate model family.
In this case,
our model receives a snippet of audio as <em>input</em>,
and the model
generates a selection among
${\textrm{yes}, \textrm{no}}$ as <em>output</em>.
If all goes according to plan
the model's guesses will
typically be correct as to
whether the snippet contains the wake word.</p>
<p>If we choose the right family of models,
there should exist one setting of the knobs
such that the model fires "yes" every time it hears the word "Alexa".
Because the exact choice of the wake word is arbitrary,
we will probably need a model family sufficiently rich that,
via another setting of the knobs, it could fire "yes"
only upon hearing the word "Apricot".
We expect that the same model family should be suitable
for "Alexa" recognition and "Apricot" recognition
because they seem, intuitively, to be similar tasks.
However, we might need a different family of models entirely
if we want to deal with fundamentally different inputs or outputs,
say if we wanted to map from images to captions,
or from English sentences to Chinese sentences.</p>
<p>As you might guess, if we just set all of the knobs randomly,
it is unlikely that our model will recognize "Alexa",
"Apricot", or any other English word.
In machine learning,
the <em>learning</em> is the process
by which we discover the right setting of the knobs
for coercing the desired behavior from our model.
In other words,
we <em>train</em> our model with data.
As shown in :numref:<code>fig_ml_loop</code>, the training process usually looks like the following:</p>
<ol>
<li>Start off with a randomly initialized model that cannot do anything useful.</li>
<li>Grab some of your data (e.g., audio snippets and corresponding ${\textrm{yes}, \textrm{no}}$ labels).</li>
<li>Tweak the knobs to make the model perform better as assessed on those examples.</li>
<li>Repeat Steps 2 and 3 until the model is awesome.</li>
</ol>
<p><img src="chapter_introduction/../img/ml-loop.svg" alt="A typical training process." />
:label:<code>fig_ml_loop</code></p>
<p>To summarize, rather than code up a wake word recognizer,
we code up a program that can <em>learn</em> to recognize wake words,
if presented with a large labeled dataset.
You can think of this act of determining a program's behavior
by presenting it with a dataset as <em>programming with data</em>.
That is to say, we can "program" a cat detector
by providing our machine learning system
with many examples of cats and dogs.
This way the detector will eventually learn to emit
a very large positive number if it is a cat,
a very large negative number if it is a dog,
and something closer to zero if it is not sure.
This barely scratches the surface of what machine learning can do.
Deep learning, which we will explain in greater detail later,
is just one among many popular methods
for solving machine learning problems.</p>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<p>In our wake word example, we described a dataset
consisting of audio snippets and binary labels,
and we gave a hand-wavy sense of how we might train
a model to approximate a mapping from snippets to classifications.
This sort of problem,
where we try to predict a designated unknown label
based on known inputs
given a dataset consisting of examples
for which the labels are known,
is called <em>supervised learning</em>.
This is just one among many kinds of machine learning problems.
Before we explore other varieties,
we would like to shed more light
on some core components that will follow us around,
no matter what kind of machine learning problem we tackle:</p>
<ol>
<li>The <em>data</em> that we can learn from.</li>
<li>A <em>model</em> of how to transform the data.</li>
<li>An <em>objective function</em> that quantifies how well (or badly) the model is doing.</li>
<li>An <em>algorithm</em> to adjust the model's parameters to optimize the objective function.</li>
</ol>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>It might go without saying that you cannot do data science without data.
We could lose hundreds of pages pondering what precisely data <em>is</em>,
but for now, we will focus on the key properties
of the datasets that we will be concerned with.
Generally, we are concerned with a collection of examples.
In order to work with data usefully, we typically
need to come up with a suitable numerical representation.
Each <em>example</em> (or <em>data point</em>, <em>data instance</em>, <em>sample</em>)
typically consists of a set of attributes
called <em>features</em> (sometimes called <em>covariates</em> or <em>inputs</em>),
based on which the model must make its predictions.
In supervised learning problems,
our goal is to predict the value of a special attribute,
called the <em>label</em> (or <em>target</em>),
that is not part of the model's input.</p>
<p>If we were working with image data,
each example might consist of an
individual photograph (the features)
and a number indicating the category
to which the photograph belongs (the label).
The photograph would be represented numerically
as three grids of numerical values representing
the brightness of red, green, and blue light
at each pixel location.
For example, a $200\times 200$ pixel color photograph
would consist of $200\times200\times3=120000$ numerical values.</p>
<p>Alternatively, we might work with electronic health record data
and tackle the task of predicting the likelihood
that a given patient  will survive the next 30 days.
Here, our features might consist of a collection
of readily available attributes
and frequently recorded measurements,
including age, vital signs, comorbidities,
current medications, and recent procedures.
The label available for training would be a binary value
indicating whether each patient in the historical data
survived within the 30-day window.</p>
<p>In such cases, when every example is characterized
by the same number of numerical features,
we say that the inputs are fixed-length vectors
and we call the (constant) length of the vectors
the <em>dimensionality</em> of the data.
As you might imagine, fixed-length inputs can be convenient,
giving us one less complication to worry about.
However, not all data can easily
be represented as <em>fixed-length</em> vectors.
While we might expect microscope images
to come from standard equipment,
we cannot expect images mined from the Internet
all to have the same resolution or shape.
For images, we might consider
cropping them to a standard size,
but that strategy only gets us so far.
We risk losing information in the cropped-out portions.
Moreover, text data resists fixed-length
representations even more stubbornly.
Consider the customer reviews left
on e-commerce sites such as Amazon, IMDb, and TripAdvisor.
Some are short: "it stinks!".
Others ramble for pages.
One major advantage of deep learning over traditional methods
is the comparative grace with which modern models
can handle <em>varying-length</em> data.</p>
<p>Generally, the more data we have, the easier our job becomes.
When we have more data, we can train more powerful models
and rely less heavily on preconceived assumptions.
The regime change from (comparatively) small to big data
is a major contributor to the success of modern deep learning.
To drive the point home, many of
the most exciting models in deep learning
do not work without large datasets.
Some others might work in the small data regime,
but are no better than traditional approaches.</p>
<p>Finally, it is not enough to have lots of data
and to process it cleverly.
We need the <em>right</em> data.
If the data is full of mistakes,
or if the chosen features are not predictive
of the target quantity of interest,
learning is going to fail.
The situation is captured well by the cliché:
<em>garbage in, garbage out</em>.
Moreover, poor predictive performance
is not the only potential consequence.
In sensitive applications of machine learning,
like predictive policing, resume screening,
and risk models used for lending,
we must be especially alert
to the consequences of garbage data.
One commonly occurring failure mode concerns datasets
where some groups of people are unrepresented
in the training data.
Imagine applying a skin cancer recognition system
that had never seen black skin before.
Failure can also occur when the data
does not only under-represent some groups
but reflects societal prejudices.
For example, if past hiring decisions
are used to train a predictive model
that will be used to screen resumes
then machine learning models could inadvertently
capture and automate historical injustices.
Note that this can all happen without the data scientist
actively conspiring, or even being aware.</p>
<h3 id="models"><a class="header" href="#models">Models</a></h3>
<p>Most machine learning involves transforming the data in some sense.
We might want to build a system that ingests photos and predicts smiley-ness.
Alternatively,
we might want to ingest a set of sensor readings
and predict how normal vs. anomalous the readings are.
By <em>model</em>, we denote the computational machinery for ingesting data
of one type,
and spitting out predictions of a possibly different type.
In particular, we are interested in <em>statistical models</em>
that can be estimated from data.
While simple models are perfectly capable of addressing
appropriately simple problems,
the problems
that we focus on in this book stretch the limits of classical methods.
Deep learning is differentiated from classical approaches
principally by the set of powerful models that it focuses on.
These models consist of many successive transformations of the data
that are chained together top to bottom, thus the name <em>deep learning</em>.
On our way to discussing deep models,
we will also discuss some more traditional methods.</p>
<h3 id="objective-functions"><a class="header" href="#objective-functions">Objective Functions</a></h3>
<p>Earlier, we introduced machine learning as learning from experience.
By <em>learning</em> here,
we mean improving at some task over time.
But who is to say what constitutes an improvement?
You might imagine that we could propose updating our model,
and some people might disagree on whether our proposal
constituted an improvement or not.</p>
<p>In order to develop a formal mathematical system of learning machines,
we need to have formal measures of how good (or bad) our models are.
In machine learning, and optimization more generally,
we call these <em>objective functions</em>.
By convention, we usually define objective functions
so that lower is better.
This is merely a convention.
You can take any function
for which higher is better, and turn it into a new function
that is qualitatively identical but for which lower is better
by flipping the sign.
Because we choose lower to be better, these functions are sometimes called
<em>loss functions</em>.</p>
<p>When trying to predict numerical values,
the most common loss function is <em>squared error</em>,
i.e., the square of the difference between
the prediction and the ground truth target.
For classification, the most common objective
is to minimize error rate,
i.e., the fraction of examples on which
our predictions disagree with the ground truth.
Some objectives (e.g., squared error) are easy to optimize,
while others (e.g., error rate) are difficult to optimize directly,
owing to non-differentiability or other complications.
In these cases, it is common instead to optimize a <em>surrogate objective</em>.</p>
<p>During optimization, we think of the loss
as a function of the model's parameters,
and treat the training dataset as a constant.
We learn
the best values of our model's parameters
by minimizing the loss incurred on a set
consisting of some number of examples collected for training.
However, doing well on the training data
does not guarantee that we will do well on unseen data.
So we will typically want to split the available data into two partitions:
the <em>training dataset</em> (or <em>training set</em>), for learning model parameters;
and the <em>test dataset</em> (or <em>test set</em>), which is held out for evaluation.
At the end of the day, we typically report
how our models perform on both partitions.
You could think of training performance
as analogous to the scores that a student achieves
on the practice exams used to prepare for some real final exam.
Even if the results are encouraging,
that does not guarantee success on the final exam.
Over the course of studying, the student
might begin to memorize the practice questions,
appearing to master the topic but faltering
when faced with previously unseen questions
on the actual final exam.
When a model performs well on the training set
but fails to generalize to unseen data,
we say that it is <em>overfitting</em> to the training data.</p>
<h3 id="optimization-algorithms"><a class="header" href="#optimization-algorithms">Optimization Algorithms</a></h3>
<p>Once we have got some data source and representation,
a model, and a well-defined objective function,
we need an algorithm capable of searching
for the best possible parameters for minimizing the loss function.
Popular optimization algorithms for deep learning
are based on an approach called <em>gradient descent</em>.
In brief, at each step, this method
checks to see, for each parameter,
how that training set loss would change
if you perturbed that parameter by just a small amount.
It would then update the parameter
in the direction that lowers the loss.</p>
<h2 id="kinds-of-machine-learning-problems"><a class="header" href="#kinds-of-machine-learning-problems">Kinds of Machine Learning Problems</a></h2>
<p>The wake word problem in our motivating example
is just one among many
that machine learning can tackle.
To motivate the reader further
and provide us with some common language
that will follow us throughout the book,
we now provide a broad overview of the landscape
of machine learning problems.</p>
<h3 id="supervised-learning"><a class="header" href="#supervised-learning">Supervised Learning</a></h3>
<p>Supervised learning describes tasks
where we are given a dataset
containing both features and labels
and
asked to produce a model that predicts the labels when
given input features.
Each feature--label pair is called an example.
Sometimes, when the context is clear,
we may use the term <em>examples</em>
to refer to a collection of inputs,
even when the corresponding labels are unknown.
The supervision comes into play
because, for choosing the parameters,
we (the supervisors) provide the model
with a dataset consisting of labeled examples.
In probabilistic terms, we typically are interested in estimating
the conditional probability of a label given input features.
While it is just one among several paradigms,
supervised learning accounts for the majority of successful
applications of machine learning in industry.
Partly that is because many important tasks
can be described crisply as estimating the probability
of something unknown given a particular set of available data:</p>
<ul>
<li>Predict cancer vs. not cancer, given a computer tomography image.</li>
<li>Predict the correct translation in French, given a sentence in English.</li>
<li>Predict the price of a stock next month based on this month's financial reporting data.</li>
</ul>
<p>While all supervised learning problems
are captured by the simple description
"predicting the labels given input features",
supervised learning itself can take diverse forms
and require tons of modeling decisions,
depending on (among other considerations)
the type, size, and quantity of the inputs and outputs.
For example, we use different models
for processing sequences of arbitrary lengths
and fixed-length vector representations.
We will visit many of these problems
in depth throughout this book.</p>
<p>Informally, the learning process looks something like the following.
First, grab a big collection of examples for which the features are known
and select from them a random subset,
acquiring the ground truth labels for each.
Sometimes these labels might be available data that have already been collected
(e.g., did a patient die within the following year?)
and other times we might need to employ human annotators to label the data,
(e.g., assigning images to categories).
Together, these inputs and corresponding labels comprise the training set.
We feed the training dataset into a supervised learning algorithm,
a function that takes as input a dataset
and outputs another function: the learned model.
Finally, we can feed previously unseen inputs to the learned model,
using its outputs as predictions of the corresponding label.
The full process is drawn in :numref:<code>fig_supervised_learning</code>.</p>
<p><img src="chapter_introduction/../img/supervised-learning.svg" alt="Supervised learning." />
:label:<code>fig_supervised_learning</code></p>
<h4 id="regression"><a class="header" href="#regression">Regression</a></h4>
<p>Perhaps the simplest supervised learning task
to wrap your head around is <em>regression</em>.
Consider, for example, a set of data harvested
from a database of home sales.
We might construct a table,
in which each row corresponds to a different house,
and each column corresponds to some relevant attribute,
such as the square footage of a house,
the number of bedrooms, the number of bathrooms,
and the number of minutes (walking) to the center of town.
In this dataset, each example would be a specific house,
and the corresponding feature vector would be one row in the table.
If you live in New York or San Francisco,
and you are not the CEO of Amazon, Google, Microsoft, or Facebook,
the (sq. footage, no. of bedrooms, no. of bathrooms, walking distance)
feature vector for your home might look something like: $[600, 1, 1, 60]$.
However, if you live in Pittsburgh, it might look more like $[3000, 4, 3, 10]$.
Fixed-length feature vectors like this are essential
for most classic machine learning algorithms.</p>
<p>What makes a problem a regression is actually
the form of the target.
Say that you are in the market for a new home.
You might want to estimate the fair market value of a house,
given some features such as above.
The data here might consist of historical home listings
and the labels might be the observed sales prices.
When labels take on arbitrary numerical values
(even within some interval),
we call this a <em>regression</em> problem.
The goal is to produce a model whose predictions
closely approximate the actual label values.</p>
<p>Lots of practical problems are easily described as regression problems.
Predicting the rating that a user will assign to a movie
can be thought of as a regression problem
and if you designed a great algorithm
to accomplish this feat in 2009,
you might have won the <a href="https://en.wikipedia.org/wiki/Netflix_Prize">1-million-dollar Netflix prize</a>.
Predicting the length of stay for patients in the hospital
is also a regression problem.
A good rule of thumb is that any <em>how much?</em> or <em>how many?</em> problem
is likely to be regression. For example:</p>
<ul>
<li>How many hours will this surgery take?</li>
<li>How much rainfall will this town have in the next six hours?</li>
</ul>
<p>Even if you have never worked with machine learning before,
you have probably worked through a regression problem informally.
Imagine, for example, that you had your drains repaired
and that your contractor spent 3 hours
removing gunk from your sewage pipes.
Then they sent you a bill of 350 dollars.
Now imagine that your friend hired the same contractor for 2 hours
and received a bill of 250 dollars.
If someone then asked you how much to expect
on their upcoming gunk-removal invoice
you might make some reasonable assumptions,
such as more hours worked costs more dollars.
You might also assume that there is some base charge
and that the contractor then charges per hour.
If these assumptions held true, then given these two data examples,
you could already identify the contractor's pricing structure:
100 dollars per hour plus 50 dollars to show up at your house.
If you followed that much, then you already understand
the high-level idea behind <em>linear</em> regression.</p>
<p>In this case, we could produce the parameters
that exactly matched the contractor's prices.
Sometimes this is not possible,
e.g., if some of the variation
arises from factors beyond your two features.
In these cases, we will try to learn models
that minimize the distance between our predictions and the observed values.
In most of our chapters, we will focus on
minimizing the squared error loss function.
As we will see later, this loss corresponds to the assumption
that our data were corrupted by Gaussian noise.</p>
<h4 id="classification"><a class="header" href="#classification">Classification</a></h4>
<p>While regression models are great
for addressing <em>how many?</em> questions,
lots of problems do not fit comfortably in this template.
Consider, for example, a bank that wants
to develop a check scanning feature for its mobile app.
Ideally, the customer would simply snap a photo of a check
and the app would automatically recognize the text from the image.
Assuming that we had some ability
to segment out image patches
corresponding to each handwritten character,
then the primary remaining task would be
to determine which character among some known set
is depicted in each image patch.
These kinds of <em>which one?</em> problems are called <em>classification</em>
and require a different set of tools
from those used for regression,
although many techniques will carry over.</p>
<p>In <em>classification</em>, we want our model to look at features,
e.g., the pixel values in an image,
and then predict to which <em>category</em>
(sometimes called a <em>class</em>)
among some discrete set of options,
an example belongs.
For handwritten digits, we might have ten classes,
corresponding to the digits 0 through 9.
The simplest form of classification is when there are only two classes,
a problem which we call <em>binary classification</em>.
For example, our dataset could consist of images of animals
and our labels  might be the classes $\textrm{{cat, dog}}$.
Whereas in regression we sought a regressor to output a numerical value,
in classification we seek a classifier,
whose output is the predicted class assignment.</p>
<p>For reasons that we will get into as the book gets more technical,
it can be difficult to optimize a model that can only output
a <em>firm</em> categorical assignment,
e.g., either "cat" or "dog".
In these cases, it is usually much easier to express
our model in the language of probabilities.
Given features of an example,
our model assigns a probability
to each possible class.
Returning to our animal classification example
where the classes are $\textrm{{cat, dog}}$,
a classifier might see an image and output the probability
that the image is a cat as 0.9.
We can interpret this number by saying that the classifier
is 90% sure that the image depicts a cat.
The magnitude of the probability for the predicted class
conveys a notion of uncertainty.
It is not the only one available
and we will discuss others in chapters dealing with more advanced topics.</p>
<p>When we have more than two possible classes,
we call the problem <em>multiclass classification</em>.
Common examples include handwritten character recognition
$\textrm{{0, 1, 2, ... 9, a, b, c, ...}}$.
While we attacked regression problems by trying
to minimize the squared error loss function,
the common loss function for classification problems is called <em>cross-entropy</em>,
whose name will be demystified
when we introduce information theory in later chapters.</p>
<p>Note that the most likely class is not necessarily
the one that you are going to use for your decision.
Assume that you find a beautiful mushroom in your backyard
as shown in :numref:<code>fig_death_cap</code>.</p>
<p><img src="chapter_introduction/../img/death-cap.jpg" alt="Death cap---do not eat!" />
:width:<code>200px</code>
:label:<code>fig_death_cap</code></p>
<p>Now, assume that you built a classifier and trained it
to predict whether a mushroom is poisonous based on a photograph.
Say our poison-detection classifier outputs
that the probability that
:numref:<code>fig_death_cap</code> shows a death cap is 0.2.
In other words, the classifier is 80% sure
that our mushroom is not a death cap.
Still, you would have to be a fool to eat it.
That is because the certain benefit of a delicious dinner
is not worth a 20% risk of dying from it.
In other words, the effect of the uncertain risk
outweighs the benefit by far.
Thus, in order to make a decision about whether to eat the mushroom,
we need to compute the expected detriment
associated with each action
which depends both on the likely outcomes
and the benefits or harms associated with each.
In this case, the detriment incurred
by eating the mushroom
might be $0.2 \times \infty + 0.8 \times 0 = \infty$,
whereas the loss of discarding it
is $0.2 \times 0 + 0.8 \times 1 = 0.8$.
Our caution was justified:
as any mycologist would tell us,
the mushroom in :numref:<code>fig_death_cap</code>
is actually a death cap.</p>
<p>Classification can get much more complicated than just
binary or multiclass classification.
For instance, there are some variants of classification
addressing hierarchically structured classes.
In such cases not all errors are equal---if
we must err, we might prefer to misclassify
to a related class rather than a distant class.
Usually, this is referred to as <em>hierarchical classification</em>.
For inspiration, you might think of <a href="https://en.wikipedia.org/wiki/Carl_Linnaeus">Linnaeus</a>,
who organized fauna in a hierarchy.</p>
<p>In the case of animal classification,
it might not be so bad to mistake
a poodle for a schnauzer,
but our model would pay a huge penalty
if it confused a poodle with a dinosaur.
Which hierarchy is relevant might depend
on how you plan to use the model.
For example, rattlesnakes and garter snakes
might be close on the phylogenetic tree,
but mistaking a rattler for a garter could have fatal consequences.</p>
<h4 id="tagging"><a class="header" href="#tagging">Tagging</a></h4>
<p>Some classification problems fit neatly
into the binary or multiclass classification setups.
For example, we could train a normal binary classifier
to distinguish cats from dogs.
Given the current state of computer vision,
we can do this easily, with off-the-shelf tools.
Nonetheless, no matter how accurate our model gets,
we might find ourselves in trouble when the classifier
encounters an image of the <em>Town Musicians of Bremen</em>,
a popular German fairy tale featuring four animals
(:numref:<code>fig_stackedanimals</code>).</p>
<p><img src="chapter_introduction/../img/stackedanimals.png" alt="A donkey, a dog, a cat, and a rooster." />
:width:<code>300px</code>
:label:<code>fig_stackedanimals</code></p>
<p>As you can see, the photo features a cat,
a rooster, a dog, and a donkey,
with some trees in the background.
If we anticipate encountering such images,
multiclass classification might not be
the right problem formulation.
Instead, we might want to give the model the option of
saying the image depicts a cat, a dog, a donkey,
<em>and</em> a rooster.</p>
<p>The problem of learning to predict classes that are
not mutually exclusive is called <em>multi-label classification</em>.
Auto-tagging problems are typically best described
in terms of multi-label classification.
Think of the tags people might apply
to posts on a technical blog,
e.g., "machine learning", "technology", "gadgets",
"programming languages", "Linux", "cloud computing", "AWS".
A typical article might have 5--10 tags applied.
Typically, tags will exhibit some correlation structure.
Posts about "cloud computing" are likely to mention "AWS"
and posts about "machine learning" are likely to mention "GPUs".</p>
<p>Sometimes such tagging problems
draw on enormous label sets.
The National Library of Medicine
employs many professional annotators
who associate each article to be indexed in PubMed
with a set of tags drawn from the
Medical Subject Headings (MeSH) ontology,
a collection of roughly 28,000 tags.
Correctly tagging articles is important
because it allows researchers to conduct
exhaustive reviews of the literature.
This is a time-consuming process and typically there is a one-year lag between archiving and tagging.
Machine learning can provide provisional tags
until each article has a proper manual review.
Indeed, for several years, the BioASQ organization
has <a href="http://bioasq.org/">hosted competitions</a>
for this task.</p>
<h4 id="search"><a class="header" href="#search">Search</a></h4>
<p>In the field of information retrieval,
we often impose ranks on sets of items.
Take web search for example.
The goal is less to determine <em>whether</em>
a particular page is relevant for a query,
but rather which, among a set of relevant results,
should be shown most prominently
to a particular user.
One way of doing this might be
to first assign a score
to every element in the set
and then to retrieve the top-rated elements.
<a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a>,
the original secret sauce behind the Google search engine,
was an early example of such a scoring system.
Weirdly, the scoring provided by PageRank
did not depend on the actual query.
Instead, they relied on a simple relevance filter
to identify the set of relevant candidates
and then used PageRank to prioritize
the more authoritative pages.
Nowadays, search engines use machine learning and behavioral models
to obtain query-dependent relevance scores.
There are entire academic conferences devoted to this subject.</p>
<h4 id="recommender-systems"><a class="header" href="#recommender-systems">Recommender Systems</a></h4>
<p>:label:<code>subsec_recommender_systems</code></p>
<p>Recommender systems are another problem setting
that is related to search and ranking.
The problems are similar insofar as the goal
is to display a set of items relevant to the user.
The main difference is the emphasis on <em>personalization</em>
to specific users in the context of recommender systems.
For instance, for movie recommendations,
the results page for a science fiction fan
and the results page
for a connoisseur of Peter Sellers comedies
might differ significantly.
Similar problems pop up in other recommendation settings,
e.g., for retail products, music, and news recommendation.</p>
<p>In some cases, customers provide explicit feedback,
communicating how much they liked a particular product
(e.g., the product ratings and reviews
on Amazon, IMDb, or Goodreads).
In other cases, they provide implicit feedback,
e.g., by skipping titles on a playlist,
which might indicate
dissatisfaction or maybe just
indicate
that the song was inappropriate in context.
In the simplest formulations,
these systems are trained
to estimate some score,
such as an expected star rating
or the probability that a given user
will purchase a particular item.</p>
<p>Given such a model, for any given user,
we could retrieve the set of objects with the largest scores,
which could then be recommended to the user.
Production systems are considerably more advanced
and take detailed user activity and item characteristics
into account when computing such scores.
:numref:<code>fig_deeplearning_amazon</code> displays the deep learning books
recommended by Amazon based on personalization algorithms
tuned to capture Aston's preferences.</p>
<p><img src="chapter_introduction/../img/deeplearning-amazon.jpg" alt="Deep learning books recommended by Amazon." />
:label:<code>fig_deeplearning_amazon</code></p>
<p>Despite their tremendous economic value,
recommender systems
naively built on top of predictive models
suffer some serious conceptual flaws.
To start, we only observe <em>censored feedback</em>:
users preferentially rate movies
that they feel strongly about.
For example, on a five-point scale,
you might notice that items receive
many one- and five-star ratings
but that there are conspicuously few three-star ratings.
Moreover, current purchase habits are often a result
of the recommendation algorithm currently in place,
but learning algorithms do not always take this detail into account.
Thus it is possible for feedback loops to form
where a recommender system preferentially pushes an item
that is then taken to be better (due to greater purchases)
and in turn is recommended even more frequently.
Many of these problems---about
how to deal with censoring,
incentives, and feedback loops---are important open research questions.</p>
<h4 id="sequence-learning"><a class="header" href="#sequence-learning">Sequence Learning</a></h4>
<p>So far, we have looked at problems where we have
some fixed number of inputs and produce a fixed number of outputs.
For example, we considered predicting house prices
given a fixed set of features:
square footage, number of bedrooms,
number of bathrooms, and the transit time to downtown.
We also discussed mapping from an image (of fixed dimension)
to the predicted probabilities that it belongs
to each among a fixed number of classes
and predicting star ratings associated with purchases
based on the user ID and product ID alone.
In these cases, once our model is trained,
after each test example is fed into our model,
it is immediately forgotten.
We assumed that successive observations were independent
and thus there was no need to hold on to this context.</p>
<p>But how should we deal with video snippets?
In this case, each snippet might consist of a different number of frames.
And our guess of what is going on in each frame might be much stronger
if we take into account the previous or succeeding frames.
The same goes for language.
For example, one popular deep learning problem is machine translation:
the task of ingesting sentences in some source language
and predicting their translations in another language.</p>
<p>Such problems also occur in medicine.
We might want a model to monitor patients in the intensive care unit
and to fire off alerts whenever their risk of dying in the next 24 hours
exceeds some threshold.
Here, we would not throw away everything
that we know about the patient history every hour,
because we might not want to make predictions based only
on the most recent measurements.</p>
<p>Questions like these are among the most
exciting applications of machine learning
and they are instances of <em>sequence learning</em>.
They require a model either to ingest sequences of inputs
or to emit sequences of outputs (or both).
Specifically, <em>sequence-to-sequence learning</em> considers problems
where both inputs and outputs consist of variable-length sequences.
Examples include machine translation
and speech-to-text transcription.
While it is impossible to consider
all types of sequence transformations,
the following special cases are worth mentioning.</p>
<p><strong>Tagging and Parsing</strong>.
This involves annotating a text sequence with attributes.
Here, the inputs and outputs are <em>aligned</em>,
i.e., they are of the same number
and occur in a corresponding order.
For instance, in <em>part-of-speech (PoS) tagging</em>,
we annotate every word in a sentence
with the corresponding part of speech,
i.e., "noun" or "direct object".
Alternatively, we might want to know
which groups of contiguous words refer to named entities,
like <em>people</em>, <em>places</em>, or <em>organizations</em>.
In the cartoonishly simple example below,
we might just want to indicate whether or not any word in the sentence is part of a named entity (tagged as "Ent").</p>
<pre><code class="language-text">Tom has dinner in Washington with Sally
Ent  -    -    -     Ent      -    Ent
</code></pre>
<p><strong>Automatic Speech Recognition</strong>.
With speech recognition, the input sequence
is an audio recording of a speaker (:numref:<code>fig_speech</code>),
and the output is a transcript of what the speaker said.
The challenge is that there are many more audio frames
(sound is typically sampled at 8kHz or 16kHz)
than text, i.e., there is no 1:1 correspondence between audio and text,
since thousands of samples may
correspond to a single spoken word.
These are sequence-to-sequence learning problems,
where the output is much shorter than the input.
While humans are remarkably good at recognizing speech,
even from low-quality audio,
getting computers to perform the same feat
is a formidable challenge.</p>
<p><img src="chapter_introduction/../img/speech.png" alt="-D-e-e-p- L-ea-r-ni-ng- in an audio recording." />
:width:<code>700px</code>
:label:<code>fig_speech</code></p>
<p><strong>Text to Speech</strong>.
This is the inverse of automatic speech recognition.
Here, the input is text and the output is an audio file.
In this case, the output is much longer than the input.</p>
<p><strong>Machine Translation</strong>.
Unlike the case of speech recognition,
where corresponding inputs and outputs
occur in the same order,
in machine translation,
unaligned data poses a new challenge.
Here the input and output sequences
can have different lengths,
and the corresponding regions
of the respective sequences
may appear in a different order.
Consider the following illustrative example
of the peculiar tendency of Germans
to place the verbs at the end of sentences:</p>
<pre><code class="language-text">German:           Haben Sie sich schon dieses grossartige Lehrwerk angeschaut?
English:          Have you already looked at this excellent textbook?
Wrong alignment:  Have you yourself already this excellent textbook looked at?
</code></pre>
<p>Many related problems pop up in other learning tasks.
For instance, determining the order in which a user
reads a webpage is a two-dimensional layout analysis problem.
Dialogue problems exhibit all kinds of additional complications,
where determining what to say next requires taking into account
real-world knowledge and the prior state of the conversation
across long temporal distances.
Such topics are active areas of research.</p>
<h3 id="unsupervised-and-self-supervised-learning"><a class="header" href="#unsupervised-and-self-supervised-learning">Unsupervised and Self-Supervised Learning</a></h3>
<p>The previous examples focused on supervised learning,
where we feed the model a giant dataset
containing both the features and corresponding label values.
You could think of the supervised learner as having
an extremely specialized job and an extremely dictatorial boss.
The boss stands over the learner's shoulder and tells them exactly what to do
in every situation until they learn to map from situations to actions.
Working for such a boss sounds pretty lame.
On the other hand, pleasing such a boss is pretty easy.
You just recognize the pattern as quickly as possible
and imitate the boss's actions.</p>
<p>Considering the opposite situation,
it could be frustrating to work for a boss
who has no idea what they want you to do.
However, if you plan to be a data scientist,
you had better get used to it.
The boss might just hand you a giant dump of data
and tell you to <em>do some data science with it!</em>
This sounds vague because it is vague.
We call this class of problems <em>unsupervised learning</em>,
and the type and number of questions we can ask
is limited only by our creativity.
We will address unsupervised learning techniques
in later chapters.
To whet your appetite for now,
we describe a few of the following questions you might ask.</p>
<ul>
<li>Can we find a small number of prototypes
that accurately summarize the data?
Given a set of photos, can we group them into landscape photos,
pictures of dogs, babies, cats, and mountain peaks?
Likewise, given a collection of users' browsing activities,
can we group them into users with similar behavior?
This problem is typically known as <em>clustering</em>.</li>
<li>Can we find a small number of parameters
that accurately capture the relevant properties of the data?
The trajectories of a ball are well described
by velocity, diameter, and mass of the ball.
Tailors have developed a small number of parameters
that describe human body shape fairly accurately
for the purpose of fitting clothes.
These problems are referred to as <em>subspace estimation</em>.
If the dependence is linear, it is called <em>principal component analysis</em>.</li>
<li>Is there a representation of (arbitrarily structured) objects
in Euclidean space
such that symbolic properties can be well matched?
This can be used to describe entities and their relations,
such as "Rome" $-$ "Italy" $+$ "France" $=$ "Paris".</li>
<li>Is there a description of the root causes
of much of the data that we observe?
For instance, if we have demographic data
about house prices, pollution, crime, location,
education, and salaries, can we discover
how they are related simply based on empirical data?
The fields concerned with <em>causality</em> and
<em>probabilistic graphical models</em> tackle such questions.</li>
<li>Another important and exciting recent development in unsupervised learning
is the advent of <em>deep generative models</em>.
These models estimate the density of the data,
either explicitly or <em>implicitly</em>.
Once trained, we can use a generative model
either to score examples according to how likely they are,
or to sample synthetic examples from the learned distribution.
Early deep learning breakthroughs in generative modeling
came with the invention of <em>variational autoencoders</em> :cite:<code>Kingma.Welling.2014,rezende2014stochastic</code>
and continued with the development of <em>generative adversarial networks</em> :cite:<code>Goodfellow.Pouget-Abadie.Mirza.ea.2014</code>.
More recent advances include normalizing flows :cite:<code>dinh2014nice,dinh2017density</code> and
diffusion models :cite:<code>sohl2015deep,song2019generative,ho2020denoising,song2021score</code>.</li>
</ul>
<p>A further development in unsupervised learning
has been the rise of <em>self-supervised learning</em>,
techniques that leverage some aspect of the unlabeled data
to provide supervision.
For text, we can train models
to "fill in the blanks"
by predicting randomly masked words
using their surrounding words (contexts)
in big corpora without any labeling effort :cite:<code>Devlin.Chang.Lee.ea.2018</code>!
For images, we may train models
to tell the relative position
between two cropped regions
of the same image :cite:<code>Doersch.Gupta.Efros.2015</code>,
to predict an occluded part of an image
based on the remaining portions of the image,
or to predict whether two examples
are perturbed versions of the same underlying image.
Self-supervised models often learn representations
that are subsequently leveraged
by fine-tuning the resulting models
on some downstream task of interest.</p>
<h3 id="interacting-with-an-environment"><a class="header" href="#interacting-with-an-environment">Interacting with an Environment</a></h3>
<p>So far, we have not discussed where data actually comes from,
or what actually happens when a machine learning model generates an output.
That is because supervised learning and unsupervised learning
do not address these issues in a very sophisticated way.
In each case, we grab a big pile of data upfront,
then set our pattern recognition machines in motion
without ever interacting with the environment again.
Because all the learning takes place
after the algorithm is disconnected from the environment,
this is sometimes called <em>offline learning</em>.
For example, supervised learning assumes
the simple interaction pattern
depicted in :numref:<code>fig_data_collection</code>.</p>
<p><img src="chapter_introduction/../img/data-collection.svg" alt="Collecting data for supervised learning from an environment." />
:label:<code>fig_data_collection</code></p>
<p>This simplicity of offline learning has its charms.
The upside is that we can worry
about pattern recognition in isolation,
with no concern about complications arising
from interactions with a dynamic environment.
But this problem formulation is limiting.
If you grew up reading Asimov's Robot novels,
then you probably picture artificially intelligent agents
capable not only of making predictions,
but also of taking actions in the world.
We want to think about intelligent <em>agents</em>,
not just predictive models.
This means that we need to think about choosing <em>actions</em>,
not just making predictions.
In contrast to mere predictions,
actions actually impact the environment.
If we want to train an intelligent agent,
we must account for the way its actions might
impact the future observations of the agent, and so offline learning is inappropriate.</p>
<p>Considering the interaction with an environment
opens a whole set of new modeling questions.
The following are just a few examples.</p>
<ul>
<li>Does the environment remember what we did previously?</li>
<li>Does the environment want to help us, e.g., a user reading text into a speech recognizer?</li>
<li>Does the environment want to beat us, e.g., spammers adapting their emails to evade spam filters?</li>
<li>Does the environment have shifting dynamics? For example, would future data always resemble the past or would the patterns change over time, either naturally or in response to our automated tools?</li>
</ul>
<p>These questions raise the problem of <em>distribution shift</em>,
where training and test data are different.
An example of this, that many of us may have met, is when taking exams written by a lecturer,
while the homework was composed by their teaching assistants.
Next, we briefly describe reinforcement learning,
a rich framework for posing learning problems in which
an agent interacts with an environment.</p>
<h3 id="reinforcement-learning"><a class="header" href="#reinforcement-learning">Reinforcement Learning</a></h3>
<p>If you are interested in using machine learning
to develop an agent that interacts with an environment
and takes actions, then you are probably going to wind up
focusing on <em>reinforcement learning</em>.
This might include applications to robotics,
to dialogue systems,
and even to developing artificial intelligence (AI)
for video games.
<em>Deep reinforcement learning</em>, which applies
deep learning to reinforcement learning problems,
has surged in popularity.
The breakthrough deep Q-network, that beat humans
at Atari games using only the visual input :cite:<code>mnih2015human</code>,
and the AlphaGo program, which dethroned the world champion
at the board game Go :cite:<code>Silver.Huang.Maddison.ea.2016</code>,
are two prominent examples.</p>
<p>Reinforcement learning gives a very general statement of a problem
in which an agent interacts with an environment over a series of time steps.
At each time step, the agent receives some <em>observation</em>
from the environment and must choose an <em>action</em>
that is subsequently transmitted back to the environment
via some mechanism (sometimes called an <em>actuator</em>), when, after each loop,
the agent receives a reward from the environment.
This process is illustrated in :numref:<code>fig_rl-environment</code>.
The agent then receives a subsequent observation,
and chooses a subsequent action, and so on.
The behavior of a reinforcement learning agent is governed by a <em>policy</em>.
In brief, a <em>policy</em> is just a function that maps
from observations of the environment to actions.
The goal of reinforcement learning is to produce good policies.</p>
<p><img src="chapter_introduction/../img/rl-environment.svg" alt="The interaction between reinforcement learning and an environment." />
:label:<code>fig_rl-environment</code></p>
<p>It is hard to overstate the generality
of the reinforcement learning framework.
For example, supervised learning
can be recast as reinforcement learning.
Say we had a classification problem.
We could create a reinforcement learning agent
with one action corresponding to each class.
We could then create an environment which gave a reward
that was exactly equal to the loss function
from the original supervised learning problem.</p>
<p>Further, reinforcement learning
can also address many problems
that supervised learning cannot.
For example, in supervised learning,
we always expect that the training input
comes associated with the correct label.
But in reinforcement learning,
we do not assume that, for each observation
the environment tells us the optimal action.
In general, we just get some reward.
Moreover, the environment may not even tell us
which actions led to the reward.</p>
<p>Consider the game of chess.
The only real reward signal comes at the end of the game
when we either win, earning a reward of, say, $1$,
or when we lose, receiving a reward of, say, $-1$.
So reinforcement learners must deal
with the <em>credit assignment</em> problem:
determining which actions to credit or blame for an outcome.
The same goes for an employee
who gets a promotion on October 11.
That promotion likely reflects a number
of well-chosen actions over the previous year.
Getting promoted in the future requires figuring out
which actions along the way led to the earlier promotions.</p>
<p>Reinforcement learners may also have to deal
with the problem of partial observability.
That is, the current observation might not
tell you everything about your current state.
Say your cleaning robot found itself trapped
in one of many identical closets in your house.
Rescuing the robot involves inferring
its precise location which might require considering earlier observations prior to it entering the closet.</p>
<p>Finally, at any given point, reinforcement learners
might know of one good policy,
but there might be many other better policies
that the agent has never tried.
The reinforcement learner must constantly choose
whether to <em>exploit</em> the best (currently) known strategy as a policy,
or to <em>explore</em> the space of strategies,
potentially giving up some short-term reward
in exchange for knowledge.</p>
<p>The general reinforcement learning problem
has a very general setting.
Actions affect subsequent observations.
Rewards are only observed when they correspond to the chosen actions.
The environment may be either fully or partially observed.
Accounting for all this complexity at once may be asking too much.
Moreover, not every practical problem exhibits all this complexity.
As a result, researchers have studied a number of
special cases of reinforcement learning problems.</p>
<p>When the environment is fully observed,
we call the reinforcement learning problem a <em>Markov decision process</em>.
When the state does not depend on the previous actions,
we call it a <em>contextual bandit problem</em>.
When there is no state, just a set of available actions
with initially unknown rewards, we have the classic <em>multi-armed bandit problem</em>.</p>
<h2 id="roots"><a class="header" href="#roots">Roots</a></h2>
<p>We have just reviewed a small subset of problems
that machine learning can address.
For a diverse set of machine learning problems,
deep learning provides powerful tools for their solution.
Although many deep learning methods are recent inventions,
the core ideas behind learning from data
have been studied for centuries.
In fact, humans have held the desire to analyze data
and to predict future outcomes for
ages, and it is this desire that is at the root of much of natural science and mathematics.
Two examples are the Bernoulli distribution, named after
<a href="https://en.wikipedia.org/wiki/Jacob_Bernoulli">Jacob Bernoulli (1655--1705)</a>,
and the Gaussian distribution discovered
by <a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">Carl Friedrich Gauss (1777--1855)</a>.
Gauss invented, for instance, the least mean squares algorithm,
which is still used today for a multitude of problems
from insurance calculations to medical diagnostics.
Such tools enhanced the experimental approach
in the natural sciences---for instance, Ohm's law
relating current and voltage in a resistor
is perfectly described by a linear model.</p>
<p>Even in the middle ages, mathematicians
had a keen intuition of estimates.
For instance, the geometry book of <a href="https://www.maa.org/press/periodicals/convergence/mathematical-treasures-jacob-kobels-geometry">Jacob Köbel (1460--1533)</a>
illustrates averaging the length of 16 adult men's feet
to estimate the typical foot length in the population (:numref:<code>fig_koebel</code>).</p>
<p><img src="chapter_introduction/../img/koebel.jpg" alt="Estimating the length of a foot." />
:width:<code>500px</code>
:label:<code>fig_koebel</code></p>
<p>As a group of individuals exited a church,
16 adult men were asked to line up in a row
and have their feet measured.
The sum of these measurements was then divided by 16
to obtain an estimate for what now is called one foot.
This "algorithm" was later improved
to deal with misshapen feet;
The two men with the shortest and longest feet were sent away,
averaging only over the remainder.
This is among the earliest examples
of a trimmed mean estimate.</p>
<p>Statistics really took off with the availability and collection of data.
One of its pioneers, <a href="https://en.wikipedia.org/wiki/Ronald_Fisher">Ronald Fisher (1890--1962)</a>,
contributed significantly to its theory
and also its applications in genetics.
Many of his algorithms (such as linear discriminant analysis)
and concepts (such as the Fisher information matrix)
still hold a prominent place
in the foundations of modern statistics.
Even his data resources had a lasting impact.
The Iris dataset that Fisher released in 1936
is still sometimes used to demonstrate
machine learning algorithms.
Fisher was also a proponent of eugenics,
which should remind us that the morally dubious use of data science
has as long and enduring a history as its productive use
in industry and the natural sciences.</p>
<p>Other influences for machine learning
came from the information theory of
<a href="https://en.wikipedia.org/wiki/Claude_Shannon">Claude Shannon (1916--2001)</a>
and the theory of computation proposed by
<a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing (1912--1954)</a>.
Turing posed the question "can machines think?”
in his famous paper <em>Computing Machinery and Intelligence</em> :cite:<code>Turing.1950</code>.
Describing what is now known as the Turing test, he proposed that a machine
can be considered <em>intelligent</em> if it is difficult
for a human evaluator to distinguish between the replies
from a machine and those of a human, based purely on textual interactions.</p>
<p>Further influences came from neuroscience and psychology.
After all, humans clearly exhibit intelligent behavior.
Many scholars have asked whether one could explain
and possibly reverse engineer this capacity.
One of the first biologically inspired algorithms
was formulated by <a href="https://en.wikipedia.org/wiki/Donald_O._Hebb">Donald Hebb (1904--1985)</a>.
In his groundbreaking book <em>The Organization of Behavior</em> :cite:<code>Hebb.1949</code>,
he posited that neurons learn by positive reinforcement.
This became known as the Hebbian learning rule.
These ideas inspired later work, such as
Rosenblatt's perceptron learning algorithm,
and laid the foundations of many stochastic gradient descent algorithms
that underpin deep learning today:
reinforce desirable behavior and diminish undesirable behavior
to obtain good settings of the parameters in a neural network.</p>
<p>Biological inspiration is what gave <em>neural networks</em> their name.
For over a century (dating back to the models of Alexander Bain, 1873,
and James Sherrington, 1890), researchers have tried to assemble
computational circuits that resemble networks of interacting neurons.
Over time, the interpretation of biology has become less literal,
but the name stuck. At its heart lie a few key principles
that can be found in most networks today:</p>
<ul>
<li>The alternation of linear and nonlinear processing units, often referred to as <em>layers</em>.</li>
<li>The use of the chain rule (also known as <em>backpropagation</em>) for adjusting parameters in the entire network at once.</li>
</ul>
<p>After initial rapid progress, research in neural networks
languished from around 1995 until 2005.
This was mainly due to two reasons.
First, training a network is computationally very expensive.
While random-access memory was plentiful at the end of the past century,
computational power was scarce.
Second, datasets were relatively small.
In fact, Fisher's Iris dataset from 1936
was still a popular tool for testing the efficacy of algorithms.
The MNIST dataset with its 60,000 handwritten digits was considered huge.</p>
<p>Given the scarcity of data and computation,
strong statistical tools such as kernel methods,
decision trees, and graphical models
proved empirically superior in many applications.
Moreover, unlike neural networks,
they did not require weeks to train
and provided predictable results
with strong theoretical guarantees.</p>
<h2 id="the-road-to-deep-learning"><a class="header" href="#the-road-to-deep-learning">The Road to Deep Learning</a></h2>
<p>Much of this changed with the availability
of massive amounts of data,
thanks to the World Wide Web,
the advent of companies serving
hundreds of millions of users online,
a dissemination of low-cost, high-quality sensors,
inexpensive data storage (Kryder's law),
and cheap computation (Moore's law).
In particular, the landscape of computation in deep learning
was revolutionized by advances in GPUs that were originally engineered for computer gaming.
Suddenly algorithms and models
that seemed computationally infeasible
were within reach.
This is best illustrated in :numref:<code>tab_intro_decade</code>.</p>
<p>:Dataset vs. computer memory and computational power
:label:<code>tab_intro_decade</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Decade</th><th style="text-align: left">Dataset</th><th style="text-align: left">Memory</th><th style="text-align: left">Floating point calculations per second</th></tr></thead><tbody>
<tr><td style="text-align: left">1970</td><td style="text-align: left">100 (Iris)</td><td style="text-align: left">1 KB</td><td style="text-align: left">100 KF (Intel 8080)</td></tr>
<tr><td style="text-align: left">1980</td><td style="text-align: left">1 K (house prices in Boston)</td><td style="text-align: left">100 KB</td><td style="text-align: left">1 MF (Intel 80186)</td></tr>
<tr><td style="text-align: left">1990</td><td style="text-align: left">10 K (optical character recognition)</td><td style="text-align: left">10 MB</td><td style="text-align: left">10 MF (Intel 80486)</td></tr>
<tr><td style="text-align: left">2000</td><td style="text-align: left">10 M (web pages)</td><td style="text-align: left">100 MB</td><td style="text-align: left">1 GF (Intel Core)</td></tr>
<tr><td style="text-align: left">2010</td><td style="text-align: left">10 G (advertising)</td><td style="text-align: left">1 GB</td><td style="text-align: left">1 TF (NVIDIA C2050)</td></tr>
<tr><td style="text-align: left">2020</td><td style="text-align: left">1 T (social network)</td><td style="text-align: left">100 GB</td><td style="text-align: left">1 PF (NVIDIA DGX-2)</td></tr>
</tbody></table>
</div>
<p>Note that random-access memory has not kept pace with the growth in data.
At the same time, increases in computational power
have outpaced the growth in datasets.
This means that statistical models
need to become more memory efficient,
and so they are free to spend more computer cycles
optimizing parameters, thanks to
the increased compute budget.
Consequently, the sweet spot in machine learning and statistics
moved from (generalized) linear models and kernel methods
to deep neural networks.
This is also one of the reasons why many of the mainstays
of deep learning, such as multilayer perceptrons
:cite:<code>McCulloch.Pitts.1943</code>, convolutional neural networks
:cite:<code>LeCun.Bottou.Bengio.ea.1998</code>, long short-term memory
:cite:<code>Hochreiter.Schmidhuber.1997</code>,
and Q-Learning :cite:<code>Watkins.Dayan.1992</code>,
were essentially "rediscovered" in the past decade,
after lying comparatively dormant for considerable time.</p>
<p>The recent progress in statistical models, applications, and algorithms
has sometimes been likened to the Cambrian explosion:
a moment of rapid progress in the evolution of species.
Indeed, the state of the art is not just a mere consequence
of available resources applied to decades-old algorithms.
Note that the list of ideas below barely scratches the surface
of what has helped researchers achieve tremendous progress
over the past decade.</p>
<ul>
<li>Novel methods for capacity control, such as <em>dropout</em>
:cite:<code>Srivastava.Hinton.Krizhevsky.ea.2014</code>,
have helped to mitigate overfitting.
Here, noise is injected :cite:<code>Bishop.1995</code>
throughout the neural network during training.</li>
<li><em>Attention mechanisms</em> solved a second problem
that had plagued statistics for over a century:
how to increase the memory and complexity of a system without
increasing the number of learnable parameters.
Researchers found an elegant solution
by using what can only be viewed as
a <em>learnable pointer structure</em> :cite:<code>Bahdanau.Cho.Bengio.2014</code>.
Rather than having to remember an entire text sequence, e.g.,
for machine translation in a fixed-dimensional representation,
all that needed to be stored was a pointer to the intermediate state
of the translation process. This allowed for significantly
increased accuracy for long sequences, since the model
no longer needed to remember the entire sequence before
commencing the generation of a new one.</li>
<li>Built solely on attention mechanisms,
the <em>Transformer</em> architecture :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code> has demonstrated superior <em>scaling</em> behavior: it performs better with an increase in dataset size, model size, and amount of training compute :cite:<code>kaplan2020scaling</code>. This architecture has demonstrated compelling success in a wide range of areas,
such as natural language processing :cite:<code>Devlin.Chang.Lee.ea.2018,brown2020language</code>, computer vision :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021,liu2021swin</code>, speech recognition :cite:<code>gulati2020conformer</code>, reinforcement learning :cite:<code>chen2021decision</code>, and graph neural networks :cite:<code>dwivedi2020generalization</code>. For example, a single Transformer pretrained on modalities
as diverse as text, images, joint torques, and button presses
can play Atari, caption images, chat,
and control a robot :cite:<code>reed2022generalist</code>.</li>
<li>Modeling probabilities of text sequences, <em>language models</em> can predict text given other text. Scaling up the data, model, and compute has unlocked a growing number of capabilities of language models to perform desired tasks via human-like text generation based on input text :cite:<code>brown2020language,rae2021scaling,hoffmann2022training,chowdhery2022palm,openai2023gpt4,anil2023palm,touvron2023llama,touvron2023llama2</code>. For instance, aligning language models with human intent :cite:<code>ouyang2022training</code>, OpenAI's <a href="https://chat.openai.com/">ChatGPT</a> allows users to interact with it in a conversational way to solve problems, such as code debugging and creative writing.</li>
<li>Multi-stage designs, e.g., via the memory networks
:cite:<code>Sukhbaatar.Weston.Fergus.ea.2015</code>
and the neural programmer-interpreter :cite:<code>Reed.De-Freitas.2015</code>
permitted statistical modelers to describe iterative approaches to reasoning.
These tools allow for an internal state of the deep neural network
to be modified repeatedly,
thus carrying out subsequent steps
in a chain of reasoning, just as a processor
can modify memory for a computation.</li>
<li>A key development in <em>deep generative modeling</em> was the invention
of <em>generative adversarial networks</em>
:cite:<code>Goodfellow.Pouget-Abadie.Mirza.ea.2014</code>.
Traditionally, statistical methods for density estimation
and generative models focused on finding proper probability distributions
and (often approximate) algorithms for sampling from them.
As a result, these algorithms were largely limited by the lack of
flexibility inherent in the statistical models.
The crucial innovation in generative adversarial networks was to replace the sampler
by an arbitrary algorithm with differentiable parameters.
These are then adjusted in such a way that the discriminator
(effectively a two-sample test) cannot distinguish fake from real data.
Through the ability to use arbitrary algorithms to generate data,
density estimation was opened up to a wide variety of techniques.
Examples of galloping zebras :cite:<code>Zhu.Park.Isola.ea.2017</code>
and of fake celebrity faces :cite:<code>Karras.Aila.Laine.ea.2017</code>
are each testimony to this progress.
Even amateur doodlers can produce
photorealistic images just based on sketches describing the layout of a scene :cite:<code>Park.Liu.Wang.ea.2019</code>.</li>
<li>Furthermore, while the diffusion process gradually adds random noise to data samples, <em>diffusion models</em> :cite:<code>sohl2015deep,ho2020denoising</code> learn the denoising process to gradually construct data samples from random noise, reversing the diffusion process. They have started to replace generative adversarial networks in more recent deep generative models, such as in DALL-E 2 :cite:<code>ramesh2022hierarchical</code> and Imagen :cite:<code>saharia2022photorealistic</code> for creative art and image generation based on text descriptions.</li>
<li>In many cases, a single GPU is insufficient for processing the large amounts of data available for training.
Over the past decade the ability to build parallel and
distributed training algorithms has improved significantly.
One of the key challenges in designing scalable algorithms
is that the workhorse of deep learning optimization,
stochastic gradient descent, relies on relatively
small minibatches of data to be processed.
At the same time, small batches limit the efficiency of GPUs.
Hence, training on 1,024 GPUs with a minibatch size of,
say, 32 images per batch amounts to an aggregate minibatch
of about 32,000 images. Work, first by :citet:<code>Li.2017</code>
and subsequently by :citet:<code>You.Gitman.Ginsburg.2017</code>
and :citet:<code>Jia.Song.He.ea.2018</code> pushed the size up to 64,000 observations,
reducing training time for the ResNet-50 model
on the ImageNet dataset to less than 7 minutes.
By comparison, training times were initially of the order of days.</li>
<li>The ability to parallelize computation
has also contributed to progress in <em>reinforcement learning</em>.
This has led to significant progress in computers achieving
superhuman performance on tasks like Go, Atari games,
Starcraft, and in physics simulations (e.g., using MuJoCo)
where environment simulators are available.
See, e.g., :citet:<code>Silver.Huang.Maddison.ea.2016</code> for a description
of such achievements in AlphaGo. In a nutshell,
reinforcement learning works best
if plenty of (state, action, reward) tuples are available.
Simulation provides such an avenue.</li>
<li>Deep learning frameworks have played a crucial role
in disseminating ideas.
The first generation of open-source frameworks
for neural network modeling consisted of
<a href="https://github.com/BVLC/caffe">Caffe</a>,
<a href="https://github.com/torch">Torch</a>, and
<a href="https://github.com/Theano/Theano">Theano</a>.
Many seminal papers were written using these tools.
These have now been superseded by
<a href="https://github.com/tensorflow/tensorflow">TensorFlow</a> (often used via its high-level API <a href="https://github.com/keras-team/keras">Keras</a>), <a href="https://github.com/Microsoft/CNTK">CNTK</a>, <a href="https://github.com/caffe2/caffe2">Caffe 2</a>, and <a href="https://github.com/apache/incubator-mxnet">Apache MXNet</a>.
The third generation of frameworks consists
of so-called <em>imperative</em> tools for deep learning,
a trend that was arguably ignited by <a href="https://github.com/chainer/chainer">Chainer</a>,
which used a syntax similar to Python NumPy to describe models.
This idea was adopted by both <a href="https://github.com/pytorch/pytorch">PyTorch</a>,
the <a href="https://github.com/apache/incubator-mxnet">Gluon API</a> of MXNet,
and <a href="https://github.com/google/jax">JAX</a>.</li>
</ul>
<p>The division of labor between system researchers building better tools
and statistical modelers building better neural networks
has greatly simplified things. For instance,
training a linear logistic regression model
used to be a nontrivial homework problem,
worthy to give to new machine learning
Ph.D. students at Carnegie Mellon University in 2014.
By now, this task can be accomplished
with under 10 lines of code,
putting it firmly within the reach of any programmer.</p>
<h2 id="success-stories"><a class="header" href="#success-stories">Success Stories</a></h2>
<p>Artificial intelligence has a long history of delivering results
that would be difficult to accomplish otherwise.
For instance, mail sorting systems
using optical character recognition
have been deployed since the 1990s.
This is, after all, the source
of the famous MNIST dataset
of handwritten digits.
The same applies to reading checks for bank deposits and scoring
creditworthiness of applicants.
Financial transactions are checked for fraud automatically.
This forms the backbone of many e-commerce payment systems,
such as PayPal, Stripe, AliPay, WeChat, Apple, Visa, and MasterCard.
Computer programs for chess have been competitive for decades.
Machine learning feeds search, recommendation, personalization,
and ranking on the Internet.
In other words, machine learning is pervasive, albeit often hidden from sight.</p>
<p>It is only recently that AI
has been in the limelight, mostly due to
solutions to problems
that were considered intractable previously
and that are directly related to consumers.
Many of such advances are attributed to deep learning.</p>
<ul>
<li>Intelligent assistants, such as Apple's Siri,
Amazon's Alexa, and Google's assistant,
are able to respond to spoken requests
with a reasonable degree of accuracy.
This includes menial jobs, like turning on light switches,
and more complex tasks, such as arranging barber's appointments
and offering phone support dialog.
This is likely the most noticeable sign
that AI is affecting our lives.</li>
<li>A key ingredient in digital assistants
is their ability to recognize speech accurately.
The accuracy of such systems has gradually
increased to the point
of achieving parity with humans
for certain applications :cite:<code>Xiong.Wu.Alleva.ea.2018</code>.</li>
<li>Object recognition has likewise come a long way.
Identifying the object in a picture
was a fairly challenging task in 2010.
On the ImageNet benchmark researchers from NEC Labs
and University of Illinois at Urbana-Champaign
achieved a top-five error rate of 28% :cite:<code>Lin.Lv.Zhu.ea.2010</code>.
By 2017, this error rate was reduced to 2.25% :cite:<code>Hu.Shen.Sun.2018</code>.
Similarly, stunning results have been achieved
for identifying birdsong and for diagnosing skin cancer.</li>
<li>Prowess in games used to provide
a measuring stick for human ability.
Starting from TD-Gammon, a program for playing backgammon
using temporal difference reinforcement learning,
algorithmic and computational progress
has led to algorithms for a wide range of applications.
Compared with backgammon, chess has
a much more complex state space and set of actions.
DeepBlue beat Garry Kasparov using massive parallelism,
special-purpose hardware and efficient search
through the game tree :cite:<code>Campbell.Hoane-Jr.Hsu.2002</code>.
Go is more difficult still, due to its huge state space.
AlphaGo reached human parity in 2015,
using deep learning combined with Monte Carlo tree sampling :cite:<code>Silver.Huang.Maddison.ea.2016</code>.
The challenge in Poker was that the state space is large
and only partially observed
(we do not know the opponents' cards).
Libratus exceeded human performance in Poker
using efficiently structured strategies :cite:<code>Brown.Sandholm.2017</code>.</li>
<li>Another indication of progress in AI
is the advent of self-driving vehicles.
While full autonomy is not yet within reach,
excellent progress has been made in this direction,
with companies such as Tesla, NVIDIA,
and Waymo shipping products
that enable partial autonomy.
What makes full autonomy so challenging
is that proper driving requires
the ability to perceive, to reason
and to incorporate rules into a system.
At present, deep learning is used primarily
in the visual aspect of these problems.
The rest is heavily tuned by engineers.</li>
</ul>
<p>This barely scratches the surface
of significant applications of machine learning.
For instance, robotics, logistics, computational biology,
particle physics, and astronomy
owe some of their most impressive recent advances
at least in parts to machine learning, which is thus becoming
a ubiquitous tool for engineers and scientists.</p>
<p>Frequently, questions about a coming AI apocalypse
and the plausibility of a <em>singularity</em>
have been raised in non-technical articles.
The fear is that somehow machine learning systems
will become sentient and make decisions,
independently of their programmers,
that directly impact the lives of humans.
To some extent, AI already affects
the livelihood of humans in direct ways:
creditworthiness is assessed automatically,
autopilots mostly navigate vehicles, decisions about
whether to grant bail use statistical data as input.
More frivolously, we can ask Alexa to switch on the coffee machine.</p>
<p>Fortunately, we are far from a sentient AI system
that could deliberately manipulate its human creators.
First, AI systems are engineered,
trained, and deployed
in a specific, goal-oriented manner.
While their behavior might give the illusion
of general intelligence, it is a combination of rules, heuristics
and statistical models that underlie the design.
Second, at present, there are simply no tools for <em>artificial general intelligence</em>
that are able to improve themselves,
reason about themselves, and that are able to modify,
extend, and improve their own architecture
while trying to solve general tasks.</p>
<p>A much more pressing concern is how AI is being used in our daily lives.
It is likely that many routine tasks, currently fulfilled by humans, can and will be automated.
Farm robots will likely reduce the costs for organic farmers
but they will also automate harvesting operations.
This phase of the industrial revolution
may have profound consequences for large swaths of society,
since menial jobs provide much employment
in many countries.
Furthermore, statistical models, when applied without care,
can lead to racial, gender, or age bias and raise
reasonable concerns about procedural fairness
if automated to drive consequential decisions.
It is important to ensure that these algorithms are used with care.
With what we know today, this strikes us as a much more pressing concern
than the potential of malevolent superintelligence for destroying humanity.</p>
<h2 id="the-essence-of-deep-learning"><a class="header" href="#the-essence-of-deep-learning">The Essence of Deep Learning</a></h2>
<p>Thus far, we have talked in broad terms about machine learning.
Deep learning is the subset of machine learning
concerned with models based on many-layered neural networks.
It is <em>deep</em> in precisely the sense that its models
learn many <em>layers</em> of transformations.
While this might sound narrow,
deep learning has given rise
to a dizzying array of models, techniques,
problem formulations, and applications.
Many intuitions have been developed
to explain the benefits of depth.
Arguably, all machine learning
has many layers of computation,
the first consisting of feature processing steps.
What differentiates deep learning is that
the operations learned at each of the many layers
of representations are learned jointly from data.</p>
<p>The problems that we have discussed so far,
such as learning from the raw audio signal,
the raw pixel values of images,
or mapping between sentences of arbitrary lengths and
their counterparts in foreign languages,
are those where deep learning excels
and traditional methods falter.
It turns out that these many-layered models
are capable of addressing low-level perceptual data
in a way that previous tools could not.
Arguably the most significant commonality
in deep learning methods is <em>end-to-end training</em>.
That is, rather than assembling a system
based on components that are individually tuned,
one builds the system and then tunes their performance jointly.
For instance, in computer vision scientists
used to separate the process of <em>feature engineering</em>
from the process of building machine learning models.
The Canny edge detector :cite:<code>Canny.1987</code>
and Lowe's SIFT feature extractor :cite:<code>Lowe.2004</code>
reigned supreme for over a decade as algorithms
for mapping images into feature vectors.
In bygone days, the crucial part of applying machine learning to these problems
consisted of coming up with manually-engineered ways
of transforming the data into some form amenable to shallow models.
Unfortunately, there is only so much that humans can accomplish
by ingenuity in comparison with a consistent evaluation
over millions of choices carried out automatically by an algorithm.
When deep learning took over,
these feature extractors were replaced
by automatically tuned filters that yielded superior accuracy.</p>
<p>Thus, one key advantage of deep learning is that it replaces
not only the shallow models at the end of traditional learning pipelines,
but also the labor-intensive process of feature engineering.
Moreover, by replacing much of the domain-specific preprocessing,
deep learning has eliminated many of the boundaries
that previously separated computer vision, speech recognition,
natural language processing, medical informatics, and other application areas,
thereby offering a unified set of tools for tackling diverse problems.</p>
<p>Beyond end-to-end training, we are experiencing a transition
from parametric statistical descriptions to fully nonparametric models.
When data is scarce, one needs to rely on simplifying assumptions about reality
in order to obtain useful models.
When data is abundant, these can be replaced
by nonparametric models that better fit the data.
To some extent, this mirrors the progress
that physics experienced in the middle of the previous century
with the availability of computers.
Rather than solving by hand parametric approximations of how electrons behave,
one can now resort to numerical simulations of the associated partial differential equations.
This has led to much more accurate models,
albeit often at the expense of interpretation.</p>
<p>Another difference from previous work is the acceptance of suboptimal solutions,
dealing with nonconvex nonlinear optimization problems,
and the willingness to try things before proving them.
This new-found empiricism in dealing with statistical problems,
combined with a rapid influx of talent has led
to rapid progress in the development of practical algorithms,
albeit in many cases at the expense of modifying
and re-inventing tools that existed for decades.</p>
<p>In the end, the deep learning community prides itself
on sharing tools across academic and corporate boundaries,
releasing many excellent libraries, statistical models,
and trained networks as open source.
It is in this spirit that the notebooks forming this book
are freely available for distribution and use.
We have worked hard to lower the barriers of access
for anyone wishing to learn about deep learning
and we hope that our readers will benefit from this.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Machine learning studies how computer systems
can leverage experience (often data)
to improve performance at specific tasks.
It combines ideas from statistics, data mining, and optimization.
Often, it is used as a means of implementing AI solutions.
As a class of machine learning, representational learning
focuses on how to automatically find
the appropriate way to represent data.
Considered as multi-level representation learning
through learning many layers of transformations,
deep learning replaces not only the shallow models
at the end of traditional machine learning pipelines,
but also the labor-intensive process of feature engineering.
Much of the recent progress in deep learning
has been triggered by an abundance of data
arising from cheap sensors and Internet-scale applications,
and by significant progress in computation, mostly through GPUs.
Furthermore, the availability of efficient deep learning frameworks
has made design and implementation of whole system optimization significantly easier,
and this is a key component in obtaining high performance.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>Which parts of code that you are currently writing could be "learned",
i.e., improved by learning and automatically determining design choices
that are made in your code?
Does your code include heuristic design choices?
What data might you need to learn the desired behavior?</li>
<li>Which problems that you encounter have many examples for their solution,
yet no specific way for automating them?
These may be prime candidates for using deep learning.</li>
<li>Describe the relationships between algorithms, data, and computation. How do characteristics of the data and the current available computational resources influence the appropriateness of various algorithms?</li>
<li>Name some settings where end-to-end training is not currently the default approach but where it might be useful.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/22">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preliminaries"><a class="header" href="#preliminaries">Preliminaries</a></h1>
<p>:label:<code>chap_preliminaries</code></p>
<p>To prepare for your dive into deep learning,
you will need a few survival skills:
(i) techniques for storing and manipulating data;
(ii) libraries for ingesting
and preprocessing data from a variety of sources;
(iii) knowledge of the basic linear algebraic operations
that we apply to high-dimensional data elements;
(iv) just enough calculus to determine
which direction to adjust each parameter
in order to decrease the loss function;
(v) the ability to automatically compute derivatives
so that you can forget much of
the calculus you just learned;
(vi) some basic fluency in probability,
our primary language for reasoning under uncertainty;
and (vii) some aptitude for finding answers
in the official documentation when you get stuck.</p>
<p>In short, this chapter provides a rapid introduction
to the basics that you will need to follow
<em>most</em> of the technical content in this book.</p>
<pre><code class="language-toc">:maxdepth: 2

ndarray
pandas
linear-algebra
calculus
autograd
probability
lookup-api
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="data-manipulation"><a class="header" href="#data-manipulation">Data Manipulation</a></h1>
<p>:label:<code>sec_ndarray</code></p>
<p>In order to get anything done,
we need some way to store and manipulate data.
Generally, there are two important things
we need to do with data:
(i) acquire them;
and (ii) process them once they are inside the computer.
There is no point in acquiring data
without some way to store it,
so to start, let's get our hands dirty
with $n$-dimensional arrays,
which we also call <em>tensors</em>.
If you already know the NumPy
scientific computing package,
this will be a breeze.
For all modern deep learning frameworks,
the <em>tensor class</em> (<code>ndarray</code> in MXNet,
<code>Tensor</code> in PyTorch and TensorFlow)
resembles NumPy's <code>ndarray</code>,
with a few killer features added.
First, the tensor class
supports automatic differentiation.
Second, it leverages GPUs
to accelerate numerical computation,
whereas NumPy only runs on CPUs.
These properties make neural networks
both easy to code and fast to run.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>:begin_tab:<code>mxnet</code>
To start, we import the <code>np</code> (<code>numpy</code>) and
<code>npx</code> (<code>numpy_extension</code>) modules from MXNet.
Here, the <code>np</code> module includes
functions supported by NumPy,
while the <code>npx</code> module contains a set of extensions
developed to empower deep learning
within a NumPy-like environment.
When using tensors, we almost always
invoke the <code>set_np</code> function:
this is for compatibility of tensor processing
by other components of MXNet.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
(<strong>To start, we import the PyTorch library.
Note that the package name is <code>torch</code>.</strong>)
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
To start, we import <code>tensorflow</code>.
For brevity, practitioners
often assign the alias <code>tf</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import jax
from jax import numpy as jnp
</code></pre>
<p>[<strong>A tensor represents a (possibly multidimensional) array of numerical values.</strong>]
In the one-dimensional case, i.e., when only one axis is needed for the data,
a tensor is called a <em>vector</em>.
With two axes, a tensor is called a <em>matrix</em>.
With $k &gt; 2$ axes, we drop the specialized names
and just refer to the object as a $k^\textrm{th}$-<em>order tensor</em>.</p>
<p>:begin_tab:<code>mxnet</code>
MXNet provides a variety of functions
for creating new tensors
prepopulated with values.
For example, by invoking <code>arange(n)</code>,
we can create a vector of evenly spaced values,
starting at 0 (included)
and ending at <code>n</code> (not included).
By default, the interval size is $1$.
Unless otherwise specified,
new tensors are stored in main memory
and designated for CPU-based computation.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
PyTorch provides a variety of functions
for creating new tensors
prepopulated with values.
For example, by invoking <code>arange(n)</code>,
we can create a vector of evenly spaced values,
starting at 0 (included)
and ending at <code>n</code> (not included).
By default, the interval size is $1$.
Unless otherwise specified,
new tensors are stored in main memory
and designated for CPU-based computation.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
TensorFlow provides a variety of functions
for creating new tensors
prepopulated with values.
For example, by invoking <code>range(n)</code>,
we can create a vector of evenly spaced values,
starting at 0 (included)
and ending at <code>n</code> (not included).
By default, the interval size is $1$.
Unless otherwise specified,
new tensors are stored in main memory
and designated for CPU-based computation.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(12)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(12, dtype=torch.float32)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.range(12, dtype=tf.float32)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(12)
x
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Each of these values is called
an <em>element</em> of the tensor.
The tensor <code>x</code> contains 12 elements.
We can inspect the total number of elements
in a tensor via its <code>size</code> attribute.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Each of these values is called
an <em>element</em> of the tensor.
The tensor <code>x</code> contains 12 elements.
We can inspect the total number of elements
in a tensor via its <code>numel</code> method.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Each of these values is called
an <em>element</em> of the tensor.
The tensor <code>x</code> contains 12 elements.
We can inspect the total number of elements
in a tensor via the <code>size</code> function.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, jax
x.size
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x.numel()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.size(x)
</code></pre>
<p>(<strong>We can access a tensor's <em>shape</em></strong>)
(the length along each axis)
by inspecting its <code>shape</code> attribute.
Because we are dealing with a vector here,
the <code>shape</code> contains just a single element
and is identical to the size.</p>
<pre><code class="language-{.python .input}">%%tab all
x.shape
</code></pre>
<p>We can [<strong>change the shape of a tensor
without altering its size or values</strong>],
by invoking <code>reshape</code>.
For example, we can transform
our vector <code>x</code> whose shape is (12,)
to a matrix <code>X</code>  with shape (3, 4).
This new tensor retains all elements
but reconfigures them into a matrix.
Notice that the elements of our vector
are laid out one row at a time and thus
<code>x[3] == X[0, 3]</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
X = x.reshape(3, 4)
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = tf.reshape(x, (3, 4))
X
</code></pre>
<p>Note that specifying every shape component
to <code>reshape</code> is redundant.
Because we already know our tensor's size,
we can work out one component of the shape given the rest.
For example, given a tensor of size $n$
and target shape ($h$, $w$),
we know that $w = n/h$.
To automatically infer one component of the shape,
we can place a <code>-1</code> for the shape component
that should be inferred automatically.
In our case, instead of calling <code>x.reshape(3, 4)</code>,
we could have equivalently called <code>x.reshape(-1, 4)</code> or <code>x.reshape(3, -1)</code>.</p>
<p>Practitioners often need to work with tensors
initialized to contain all 0s or 1s.
[<strong>We can construct a tensor with all elements set to 0</strong>] (<del>or one</del>)
and a shape of (2, 3, 4) via the <code>zeros</code> function.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.zeros((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.zeros((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.zeros((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.zeros((2, 3, 4))
</code></pre>
<p>Similarly, we can create a tensor
with all 1s by invoking <code>ones</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.ones((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.ones((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.ones((2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.ones((2, 3, 4))
</code></pre>
<p>We often wish to
[<strong>sample each element randomly (and independently)</strong>]
from a given probability distribution.
For example, the parameters of neural networks
are often initialized randomly.
The following snippet creates a tensor
with elements drawn from
a standard Gaussian (normal) distribution
with mean 0 and standard deviation 1.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.random.normal(0, 1, size=(3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.randn(3, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.random.normal(shape=[3, 4])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# Any call of a random function in JAX requires a key to be
# specified, feeding the same key to a random function will
# always result in the same sample being generated
jax.random.normal(jax.random.PRNGKey(0), (3, 4))
</code></pre>
<p>Finally, we can construct tensors by
[<strong>supplying the exact values for each element</strong>]
by supplying (possibly nested) Python list(s)
containing numerical literals.
Here, we construct a matrix with a list of lists,
where the outermost list corresponds to axis 0,
and the inner list corresponds to axis 1.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.array([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.constant([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.array([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
</code></pre>
<h2 id="indexing-and-slicing"><a class="header" href="#indexing-and-slicing">Indexing and Slicing</a></h2>
<p>As with  Python lists,
we can access tensor elements
by indexing (starting with 0).
To access an element based on its position
relative to the end of the list,
we can use negative indexing.
Finally, we can access whole ranges of indices
via slicing (e.g., <code>X[start:stop]</code>),
where the returned value includes
the first index (<code>start</code>) <em>but not the last</em> (<code>stop</code>).
Finally, when only one index (or slice)
is specified for a $k^\textrm{th}$-order tensor,
it is applied along axis 0.
Thus, in the following code,
[<strong><code>[-1]</code> selects the last row and <code>[1:3]</code>
selects the second and third rows</strong>].</p>
<pre><code class="language-{.python .input}">%%tab all
X[-1], X[1:3]
</code></pre>
<p>:begin_tab:<code>mxnet, pytorch</code>
Beyond reading them, (<strong>we can also <em>write</em> elements of a matrix by specifying indices.</strong>)
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<code>Tensors</code> in TensorFlow are immutable, and cannot be assigned to.
<code>Variables</code> in TensorFlow are mutable containers of state that support
assignments. Keep in mind that gradients in TensorFlow do not flow backwards
through <code>Variable</code> assignments.</p>
<p>Beyond assigning a value to the entire <code>Variable</code>, we can write elements of a
<code>Variable</code> by specifying indices.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X[1, 2] = 17
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X_var = tf.Variable(X)
X_var[1, 2].assign(9)
X_var
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# JAX arrays are immutable. jax.numpy.ndarray.at index
# update operators create a new array with the corresponding
# modifications made
X_new_1 = X.at[1, 2].set(17)
X_new_1
</code></pre>
<p>If we want [<strong>to assign multiple elements the same value,
we apply the indexing on the left-hand side
of the assignment operation.</strong>]
For instance, <code>[:2, :]</code>  accesses
the first and second rows,
where <code>:</code> takes all the elements along axis 1 (column).
While we discussed indexing for matrices,
this also works for vectors
and for tensors of more than two dimensions.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X[:2, :] = 12
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X_var = tf.Variable(X)
X_var[:2, :].assign(tf.ones(X_var[:2,:].shape, dtype=tf.float32) * 12)
X_var
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X_new_2 = X_new_1.at[:2, :].set(12)
X_new_2
</code></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<p>Now that we know how to construct tensors
and how to read from and write to their elements,
we can begin to manipulate them
with various mathematical operations.
Among the most useful of these
are the <em>elementwise</em> operations.
These apply a standard scalar operation
to each element of a tensor.
For functions that take two tensors as inputs,
elementwise operations apply some standard binary operator
on each pair of corresponding elements.
We can create an elementwise function
from any function that maps
from a scalar to a scalar.</p>
<p>In mathematical notation, we denote such
<em>unary</em> scalar operators (taking one input)
by the signature
$f: \mathbb{R} \rightarrow \mathbb{R}$.
This just means that the function maps
from any real number onto some other real number.
Most standard operators, including unary ones like $e^x$, can be applied elementwise.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.exp(x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.exp(x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.exp(x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.exp(x)
</code></pre>
<p>Likewise, we denote <em>binary</em> scalar operators,
which map pairs of real numbers
to a (single) real number
via the signature
$f: \mathbb{R}, \mathbb{R} \rightarrow \mathbb{R}$.
Given any two vectors $\mathbf{u}$
and $\mathbf{v}$ <em>of the same shape</em>,
and a binary operator $f$, we can produce a vector
$\mathbf{c} = F(\mathbf{u},\mathbf{v})$
by setting $c_i \gets f(u_i, v_i)$ for all $i$,
where $c_i, u_i$, and $v_i$ are the $i^\textrm{th}$ elements
of vectors $\mathbf{c}, \mathbf{u}$, and $\mathbf{v}$.
Here, we produced the vector-valued
$F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d$
by <em>lifting</em> the scalar function
to an elementwise vector operation.
The common standard arithmetic operators
for addition (<code>+</code>), subtraction (<code>-</code>),
multiplication (<code>*</code>), division (<code>/</code>),
and exponentiation (<code>**</code>)
have all been <em>lifted</em> to elementwise operations
for identically-shaped tensors of arbitrary shape.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.array([1, 2, 4, 8])
y = np.array([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.constant([1.0, 2, 4, 8])
y = tf.constant([2.0, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.array([1.0, 2, 4, 8])
y = jnp.array([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
</code></pre>
<p>In addition to elementwise computations,
we can also perform linear algebraic operations,
such as dot products and matrix multiplications.
We will elaborate on these
in :numref:<code>sec_linear-algebra</code>.</p>
<p>We can also [<strong><em>concatenate</em> multiple tensors,</strong>]
stacking them end-to-end to form a larger one.
We just need to provide a list of tensors
and tell the system along which axis to concatenate.
The example below shows what happens when we concatenate
two matrices along rows (axis 0)
instead of columns (axis 1).
We can see that the first output's axis-0 length ($6$)
is the sum of the two input tensors' axis-0 lengths ($3 + 3$);
while the second output's axis-1 length ($8$)
is the sum of the two input tensors' axis-1 lengths ($4 + 4$).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
X = np.arange(12).reshape(3, 4)
Y = np.array([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
np.concatenate([X, Y], axis=0), np.concatenate([X, Y], axis=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = tf.reshape(tf.range(12, dtype=tf.float32), (3, 4))
Y = tf.constant([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
tf.concat([X, Y], axis=0), tf.concat([X, Y], axis=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = jnp.arange(12, dtype=jnp.float32).reshape((3, 4))
Y = jnp.array([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
jnp.concatenate((X, Y), axis=0), jnp.concatenate((X, Y), axis=1)
</code></pre>
<p>Sometimes, we want to
[<strong>construct a binary tensor via <em>logical statements</em>.</strong>]
Take <code>X == Y</code> as an example.
For each position <code>i, j</code>, if <code>X[i, j]</code> and <code>Y[i, j]</code> are equal,
then the corresponding entry in the result takes value <code>1</code>,
otherwise it takes value <code>0</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
X == Y
</code></pre>
<p>[<strong>Summing all the elements in the tensor</strong>] yields a tensor with only one element.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
X.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_sum(X)
</code></pre>
<h2 id="broadcasting"><a class="header" href="#broadcasting">Broadcasting</a></h2>
<p>:label:<code>subsec_broadcasting</code></p>
<p>By now, you know how to perform
elementwise binary operations
on two tensors of the same shape.
Under certain conditions,
even when shapes differ,
we can still [<strong>perform elementwise binary operations
by invoking the <em>broadcasting mechanism</em>.</strong>]
Broadcasting works according to
the following two-step procedure:
(i) expand one or both arrays
by copying elements along axes with length 1
so that after this transformation,
the two tensors have the same shape;
(ii) perform an elementwise operation
on the resulting arrays.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
a = np.arange(3).reshape(3, 1)
b = np.arange(2).reshape(1, 2)
a, b
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a, b
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
a = tf.reshape(tf.range(3), (3, 1))
b = tf.reshape(tf.range(2), (1, 2))
a, b
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
a = jnp.arange(3).reshape((3, 1))
b = jnp.arange(2).reshape((1, 2))
a, b
</code></pre>
<p>Since <code>a</code> and <code>b</code> are $3\times1$
and $1\times2$ matrices, respectively,
their shapes do not match up.
Broadcasting produces a larger $3\times2$ matrix
by replicating matrix <code>a</code> along the columns
and matrix <code>b</code> along the rows
before adding them elementwise.</p>
<pre><code class="language-{.python .input}">%%tab all
a + b
</code></pre>
<h2 id="saving-memory"><a class="header" href="#saving-memory">Saving Memory</a></h2>
<p>[<strong>Running operations can cause new memory to be
allocated to host results.</strong>]
For example, if we write <code>Y = X + Y</code>,
we dereference the tensor that <code>Y</code> used to point to
and instead point <code>Y</code> at the newly allocated memory.
We can demonstrate this issue with Python's <code>id()</code> function,
which gives us the exact address
of the referenced object in memory.
Note that after we run <code>Y = Y + X</code>,
<code>id(Y)</code> points to a different location.
That is because Python first evaluates <code>Y + X</code>,
allocating new memory for the result
and then points <code>Y</code> to this new location in memory.</p>
<pre><code class="language-{.python .input}">%%tab all
before = id(Y)
Y = Y + X
id(Y) == before
</code></pre>
<p>This might be undesirable for two reasons.
First, we do not want to run around
allocating memory unnecessarily all the time.
In machine learning, we often have
hundreds of megabytes of parameters
and update all of them multiple times per second.
Whenever possible, we want to perform these updates <em>in place</em>.
Second, we might point at the
same parameters from multiple variables.
If we do not update in place,
we must be careful to update all of these references,
lest we spring a memory leak
or inadvertently refer to stale parameters.</p>
<p>:begin_tab:<code>mxnet, pytorch</code>
Fortunately, (<strong>performing in-place operations</strong>) is easy.
We can assign the result of an operation
to a previously allocated array <code>Y</code>
by using slice notation: <code>Y[:] = &lt;expression&gt;</code>.
To illustrate this concept,
we overwrite the values of tensor <code>Z</code>,
after initializing it, using <code>zeros_like</code>,
to have the same shape as <code>Y</code>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<code>Variables</code> are mutable containers of state in TensorFlow. They provide
a way to store your model parameters.
We can assign the result of an operation
to a <code>Variable</code> with <code>assign</code>.
To illustrate this concept,
we overwrite the values of <code>Variable</code> <code>Z</code>
after initializing it, using <code>zeros_like</code>,
to have the same shape as <code>Y</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
Z = np.zeros_like(Y)
print('id(Z):', id(Z))
Z[:] = X + Y
print('id(Z):', id(Z))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Z = torch.zeros_like(Y)
print('id(Z):', id(Z))
Z[:] = X + Y
print('id(Z):', id(Z))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
Z = tf.Variable(tf.zeros_like(Y))
print('id(Z):', id(Z))
Z.assign(X + Y)
print('id(Z):', id(Z))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# JAX arrays do not allow in-place operations
</code></pre>
<p>:begin_tab:<code>mxnet, pytorch</code>
[<strong>If the value of <code>X</code> is not reused in subsequent computations,
we can also use <code>X[:] = X + Y</code> or <code>X += Y</code>
to reduce the memory overhead of the operation.</strong>]
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Even once you store state persistently in a <code>Variable</code>,
you may want to reduce your memory usage further by avoiding excess
allocations for tensors that are not your model parameters.
Because TensorFlow <code>Tensors</code> are immutable
and gradients do not flow through <code>Variable</code> assignments,
TensorFlow does not provide an explicit way to run
an individual operation in-place.</p>
<p>However, TensorFlow provides the <code>tf.function</code> decorator
to wrap computation inside of a TensorFlow graph
that gets compiled and optimized before running.
This allows TensorFlow to prune unused values,
and to reuse prior allocations that are no longer needed.
This minimizes the memory overhead of TensorFlow computations.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
before = id(X)
X += Y
id(X) == before
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@tf.function
def computation(X, Y):
    Z = tf.zeros_like(Y)  # This unused value will be pruned out
    A = X + Y  # Allocations will be reused when no longer needed
    B = A + Y
    C = B + Y
    return C + Y

computation(X, Y)
</code></pre>
<h2 id="conversion-to-other-python-objects"><a class="header" href="#conversion-to-other-python-objects">Conversion to Other Python Objects</a></h2>
<p>:begin_tab:<code>mxnet, tensorflow</code>
[<strong>Converting to a NumPy tensor (<code>ndarray</code>)</strong>], or vice versa, is easy.
The converted result does not share memory.
This minor inconvenience is actually quite important:
when you perform operations on the CPU or on GPUs,
you do not want to halt computation, waiting to see
whether the NumPy package of Python
might want to be doing something else
with the same chunk of memory.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>Converting to a NumPy tensor (<code>ndarray</code>)</strong>], or vice versa, is easy.
The torch tensor and NumPy array
will share their underlying memory,
and changing one through an in-place operation
will also change the other.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
A = X.asnumpy()
B = np.array(A)
type(A), type(B)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A = X.numpy()
B = torch.from_numpy(A)
type(A), type(B)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A = X.numpy()
B = tf.constant(A)
type(A), type(B)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
A = jax.device_get(X)
B = jax.device_put(A)
type(A), type(B)
</code></pre>
<p>To (<strong>convert a size-1 tensor to a Python scalar</strong>),
we can invoke the <code>item</code> function or Python's built-in functions.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
a = np.array([3.5])
a, a.item(), float(a), int(a)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
a = tf.constant([3.5]).numpy()
a, a.item(), float(a), int(a)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
a = jnp.array([3.5])
a, a.item(), float(a), int(a)
</code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>The tensor class is the main interface for storing and manipulating data in deep learning libraries.
Tensors provide a variety of functionalities including construction routines; indexing and slicing; basic mathematics operations; broadcasting; memory-efficient assignment; and conversion to and from other Python objects.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>Run the code in this section. Change the conditional statement <code>X == Y</code> to <code>X &lt; Y</code> or <code>X &gt; Y</code>, and then see what kind of tensor you can get.</li>
<li>Replace the two tensors that operate by element in the broadcasting mechanism with other shapes, e.g., 3-dimensional tensors. Is the result the same as expected?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/26">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/27">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/187">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17966">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="data-preprocessing"><a class="header" href="#data-preprocessing">Data Preprocessing</a></h1>
<p>:label:<code>sec_pandas</code></p>
<p>So far, we have been working with synthetic data
that arrived in ready-made tensors.
However, to apply deep learning in the wild
we must extract messy data
stored in arbitrary formats,
and preprocess it to suit our needs.
Fortunately, the <em>pandas</em> <a href="https://pandas.pydata.org/">library</a>
can do much of the heavy lifting.
This section, while no substitute
for a proper <em>pandas</em> <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html">tutorial</a>,
will give you a crash course
on some of the most common routines.</p>
<h2 id="reading-the-dataset"><a class="header" href="#reading-the-dataset">Reading the Dataset</a></h2>
<p>Comma-separated values (CSV) files are ubiquitous
for the storing of tabular (spreadsheet-like) data.
In them, each line corresponds to one record
and consists of several (comma-separated) fields, e.g.,
"Albert Einstein,March 14 1879,Ulm,Federal polytechnic school,field of gravitational physics".
To demonstrate how to load CSV files with <code>pandas</code>,
we (<strong>create a CSV file below</strong>) <code>../data/house_tiny.csv</code>.
This file represents a dataset of homes,
where each row corresponds to a distinct home
and the columns correspond to the number of rooms (<code>NumRooms</code>),
the roof type (<code>RoofType</code>), and the price (<code>Price</code>).</p>
<pre><code class="language-{.python .input}">%%tab all
import os

os.makedirs(os.path.join('..', 'data'), exist_ok=True)
data_file = os.path.join('..', 'data', 'house_tiny.csv')
with open(data_file, 'w') as f:
    f.write('''NumRooms,RoofType,Price
NA,NA,127500
2,NA,106000
4,Slate,178100
NA,NA,140000''')
</code></pre>
<p>Now let's import <code>pandas</code> and load the dataset with <code>read_csv</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
import pandas as pd

data = pd.read_csv(data_file)
print(data)
</code></pre>
<h2 id="data-preparation"><a class="header" href="#data-preparation">Data Preparation</a></h2>
<p>In supervised learning, we train models
to predict a designated <em>target</em> value,
given some set of <em>input</em> values.
Our first step in processing the dataset
is to separate out columns corresponding
to input versus target values.
We can select columns either by name or
via integer-location based indexing (<code>iloc</code>).</p>
<p>You might have noticed that <code>pandas</code> replaced
all CSV entries with value <code>NA</code>
with a special <code>NaN</code> (<em>not a number</em>) value.
This can also happen whenever an entry is empty,
e.g., "3,,,270000".
These are called <em>missing values</em>
and they are the "bed bugs" of data science,
a persistent menace that you will confront
throughout your career.
Depending upon the context,
missing values might be handled
either via <em>imputation</em> or <em>deletion</em>.
Imputation replaces missing values
with estimates of their values
while deletion simply discards
either those rows or those columns
that contain missing values.</p>
<p>Here are some common imputation heuristics.
[<strong>For categorical input fields,
we can treat <code>NaN</code> as a category.</strong>]
Since the <code>RoofType</code> column takes values <code>Slate</code> and <code>NaN</code>,
<code>pandas</code> can convert this column
into two columns <code>RoofType_Slate</code> and <code>RoofType_nan</code>.
A row whose roof type is <code>Slate</code> will set values
of <code>RoofType_Slate</code> and <code>RoofType_nan</code> to 1 and 0, respectively.
The converse holds for a row with a missing <code>RoofType</code> value.</p>
<pre><code class="language-{.python .input}">%%tab all
inputs, targets = data.iloc[:, 0:2], data.iloc[:, 2]
inputs = pd.get_dummies(inputs, dummy_na=True)
print(inputs)
</code></pre>
<p>For missing numerical values,
one common heuristic is to
[<strong>replace the <code>NaN</code> entries with
the mean value of the corresponding column</strong>].</p>
<pre><code class="language-{.python .input}">%%tab all
inputs = inputs.fillna(inputs.mean())
print(inputs)
</code></pre>
<h2 id="conversion-to-the-tensor-format"><a class="header" href="#conversion-to-the-tensor-format">Conversion to the Tensor Format</a></h2>
<p>Now that [<strong>all the entries in <code>inputs</code> and <code>targets</code> are numerical,
we can load them into a tensor</strong>] (recall :numref:<code>sec_ndarray</code>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np

X, y = np.array(inputs.to_numpy(dtype=float)), np.array(targets.to_numpy(dtype=float))
X, y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch

X = torch.tensor(inputs.to_numpy(dtype=float))
y = torch.tensor(targets.to_numpy(dtype=float))
X, y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf

X = tf.constant(inputs.to_numpy(dtype=float))
y = tf.constant(targets.to_numpy(dtype=float))
X, y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from jax import numpy as jnp

X = jnp.array(inputs.to_numpy(dtype=float))
y = jnp.array(targets.to_numpy(dtype=float))
X, y
</code></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>You now know how to partition data columns,
impute missing variables,
and load <code>pandas</code> data into tensors.
In :numref:<code>sec_kaggle_house</code>, you will
pick up some more data processing skills.
While this crash course kept things simple,
data processing can get hairy.
For example, rather than arriving in a single CSV file,
our dataset might be spread across multiple files
extracted from a relational database.
For instance, in an e-commerce application,
customer addresses might live in one table
and purchase data in another.
Moreover, practitioners face myriad data types
beyond categorical and numeric, for example,
text strings, images,
audio data, and point clouds.
Oftentimes, advanced tools and efficient algorithms
are required in order to prevent data processing from becoming
the biggest bottleneck in the machine learning pipeline.
These problems will arise when we get to
computer vision and natural language processing.
Finally, we must pay attention to data quality.
Real-world datasets are often plagued
by outliers, faulty measurements from sensors, and recording errors,
which must be addressed before
feeding the data into any model.
Data visualization tools such as <a href="https://seaborn.pydata.org/">seaborn</a>,
<a href="https://docs.bokeh.org/">Bokeh</a>, or <a href="https://matplotlib.org/">matplotlib</a>
can help you to manually inspect the data
and develop intuitions about
the type of problems you may need to address.</p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>Try loading datasets, e.g., Abalone from the <a href="https://archive.ics.uci.edu/ml/datasets">UCI Machine Learning Repository</a> and inspect their properties. What fraction of them has missing values? What fraction of the variables is numerical, categorical, or text?</li>
<li>Try indexing and selecting data columns by name rather than by column number. The pandas documentation on <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">indexing</a> has further details on how to do this.</li>
<li>How large a dataset do you think you could load this way? What might be the limitations? Hint: consider the time to read the data, representation, processing, and memory footprint. Try this out on your laptop. What happens if you try it out on a server?</li>
<li>How would you deal with data that has a very large number of categories? What if the category labels are all unique? Should you include the latter?</li>
<li>What alternatives to pandas can you think of? How about <a href="https://numpy.org/doc/stable/reference/generated/numpy.load.html">loading NumPy tensors from a file</a>? Check out <a href="https://python-pillow.org/">Pillow</a>, the Python Imaging Library.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/28">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/29">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/195">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17967">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h1>
<p>:label:<code>sec_linear-algebra</code></p>
<p>By now, we can load datasets into tensors
and manipulate these tensors
with basic mathematical operations.
To start building sophisticated models,
we will also need a few tools from linear algebra.
This section offers a gentle introduction
to the most essential concepts,
starting from scalar arithmetic
and ramping up to matrix multiplication.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from jax import numpy as jnp
</code></pre>
<h2 id="scalars"><a class="header" href="#scalars">Scalars</a></h2>
<p>Most everyday mathematics
consists of manipulating
numbers one at a time.
Formally, we call these values <em>scalars</em>.
For example, the temperature in Palo Alto
is a balmy $72$ degrees Fahrenheit.
If you wanted to convert the temperature to Celsius
you would evaluate the expression
$c = \frac{5}{9}(f - 32)$, setting $f$ to $72$.
In this equation, the values
$5$, $9$, and $32$ are constant scalars.
The variables $c$ and $f$
in general represent unknown scalars.</p>
<p>We denote scalars
by ordinary lower-cased letters
(e.g., $x$, $y$, and $z$)
and the space of all (continuous)
<em>real-valued</em> scalars by $\mathbb{R}$.
For expedience, we will skip past
rigorous definitions of <em>spaces</em>:
just remember that the expression $x \in \mathbb{R}$
is a formal way to say that $x$ is a real-valued scalar.
The symbol $\in$ (pronounced "in")
denotes membership in a set.
For example, $x, y \in {0, 1}$
indicates that $x$ and $y$ are variables
that can only take values $0$ or $1$.</p>
<p>(<strong>Scalars are implemented as tensors
that contain only one element.</strong>)
Below, we assign two scalars
and perform the familiar addition, multiplication,
division, and exponentiation operations.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.array(3.0)
y = np.array(2.0)

x + y, x * y, x / y, x ** y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.tensor(3.0)
y = torch.tensor(2.0)

x + y, x * y, x / y, x**y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.constant(3.0)
y = tf.constant(2.0)

x + y, x * y, x / y, x**y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.array(3.0)
y = jnp.array(2.0)

x + y, x * y, x / y, x**y
</code></pre>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>For current purposes, [<strong>you can think of a vector as a fixed-length array of scalars.</strong>]
As with their code counterparts,
we call these scalars the <em>elements</em> of the vector
(synonyms include <em>entries</em> and <em>components</em>).
When vectors represent examples from real-world datasets,
their values hold some real-world significance.
For example, if we were training a model to predict
the risk of a loan defaulting,
we might associate each applicant with a vector
whose components correspond to quantities
like their income, length of employment,
or number of previous defaults.
If we were studying the risk of heart attack,
each vector might represent a patient
and its components might correspond to
their most recent vital signs, cholesterol levels,
minutes of exercise per day, etc.
We denote vectors by bold lowercase letters,
(e.g., $\mathbf{x}$, $\mathbf{y}$, and $\mathbf{z}$).</p>
<p>Vectors are implemented as $1^{\textrm{st}}$-order tensors.
In general, such tensors can have arbitrary lengths,
subject to memory limitations. Caution: in Python, as in most programming languages, vector indices start at $0$, also known as <em>zero-based indexing</em>, whereas in linear algebra subscripts begin at $1$ (one-based indexing).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(3)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(3)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.range(3)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(3)
x
</code></pre>
<p>We can refer to an element of a vector by using a subscript.
For example, $x_2$ denotes the second element of $\mathbf{x}$.
Since $x_2$ is a scalar, we do not bold it.
By default, we visualize vectors
by stacking their elements vertically:</p>
<p>$$\mathbf{x} =\begin{bmatrix}x_{1}  \ \vdots  \x_{n}\end{bmatrix}.$$
:eqlabel:<code>eq_vec_def</code></p>
<p>Here $x_1, \ldots, x_n$ are elements of the vector.
Later on, we will distinguish between such <em>column vectors</em>
and <em>row vectors</em> whose elements are stacked horizontally.
Recall that [<strong>we access a tensor's elements via indexing.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
x[2]
</code></pre>
<p>To indicate that a vector contains $n$ elements,
we write $\mathbf{x} \in \mathbb{R}^n$.
Formally, we call $n$ the <em>dimensionality</em> of the vector.
[<strong>In code, this corresponds to the tensor's length</strong>],
accessible via Python's built-in <code>len</code> function.</p>
<pre><code class="language-{.python .input}">%%tab all
len(x)
</code></pre>
<p>We can also access the length via the <code>shape</code> attribute.
The shape is a tuple that indicates a tensor's length along each axis.
(<strong>Tensors with just one axis have shapes with just one element.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab all
x.shape
</code></pre>
<p>Oftentimes, the word "dimension" gets overloaded
to mean both the number of axes
and the length along a particular axis.
To avoid this confusion,
we use <em>order</em> to refer to the number of axes
and <em>dimensionality</em> exclusively to refer
to the number of components.</p>
<h2 id="matrices"><a class="header" href="#matrices">Matrices</a></h2>
<p>Just as scalars are $0^{\textrm{th}}$-order tensors
and vectors are $1^{\textrm{st}}$-order tensors,
matrices are $2^{\textrm{nd}}$-order tensors.
We denote matrices by bold capital letters
(e.g., $\mathbf{X}$, $\mathbf{Y}$, and $\mathbf{Z}$),
and represent them in code by tensors with two axes.
The expression $\mathbf{A} \in \mathbb{R}^{m \times n}$
indicates that a matrix $\mathbf{A}$
contains $m \times n$ real-valued scalars,
arranged as $m$ rows and $n$ columns.
When $m = n$, we say that a matrix is <em>square</em>.
Visually, we can illustrate any matrix as a table.
To refer to an individual element,
we subscript both the row and column indices, e.g.,
$a_{ij}$ is the value that belongs to $\mathbf{A}$'s
$i^{\textrm{th}}$ row and $j^{\textrm{th}}$ column:</p>
<p>$$\mathbf{A}=\begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \ \end{bmatrix}.$$
:eqlabel:<code>eq_matrix_def</code></p>
<p>In code, we represent a matrix $\mathbf{A} \in \mathbb{R}^{m \times n}$
by a $2^{\textrm{nd}}$-order tensor with shape ($m$, $n$).
[<strong>We can convert any appropriately sized $m \times n$ tensor
into an $m \times n$ matrix</strong>]
by passing the desired shape to <code>reshape</code>:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
A = np.arange(6).reshape(3, 2)
A
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A = torch.arange(6).reshape(3, 2)
A
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A = tf.reshape(tf.range(6), (3, 2))
A
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
A = jnp.arange(6).reshape(3, 2)
A
</code></pre>
<p>Sometimes we want to flip the axes.
When we exchange a matrix's rows and columns,
the result is called its <em>transpose</em>.
Formally, we signify a matrix $\mathbf{A}$'s transpose
by $\mathbf{A}^\top$ and if $\mathbf{B} = \mathbf{A}^\top$,
then $b_{ij} = a_{ji}$ for all $i$ and $j$.
Thus, the transpose of an $m \times n$ matrix
is an $n \times m$ matrix:</p>
<p>$$
\mathbf{A}^\top =
\begin{bmatrix}
a_{11} &amp; a_{21} &amp; \dots  &amp; a_{m1} \
a_{12} &amp; a_{22} &amp; \dots  &amp; a_{m2} \
\vdots &amp; \vdots &amp; \ddots  &amp; \vdots \
a_{1n} &amp; a_{2n} &amp; \dots  &amp; a_{mn}
\end{bmatrix}.
$$</p>
<p>In code, we can access any (<strong>matrix's transpose</strong>) as follows:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.T
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.transpose(A)
</code></pre>
<p>[<strong>Symmetric matrices are the subset of square matrices
that are equal to their own transposes:
$\mathbf{A} = \mathbf{A}^\top$.</strong>]
The following matrix is symmetric:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
A = np.array([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
A == A.T
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A = torch.tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
A == A.T
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A = tf.constant([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
A == tf.transpose(A)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
A = jnp.array([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
A == A.T
</code></pre>
<p>Matrices are useful for representing datasets.
Typically, rows correspond to individual records
and columns correspond to distinct attributes.</p>
<h2 id="tensors"><a class="header" href="#tensors">Tensors</a></h2>
<p>While you can go far in your machine learning journey
with only scalars, vectors, and matrices,
eventually you may need to work with
higher-order [<strong>tensors</strong>].
Tensors (<strong>give us a generic way of describing
extensions to $n^{\textrm{th}}$-order arrays.</strong>)
We call software objects of the <em>tensor class</em> "tensors"
precisely because they too can have arbitrary numbers of axes.
While it may be confusing to use the word
<em>tensor</em> for both the mathematical object
and its realization in code,
our meaning should usually be clear from context.
We denote general tensors by capital letters
with a special font face
(e.g., $\mathsf{X}$, $\mathsf{Y}$, and $\mathsf{Z}$)
and their indexing mechanism
(e.g., $x_{ijk}$ and $[\mathsf{X}]_{1, 2i-1, 3}$)
follows naturally from that of matrices.</p>
<p>Tensors will become more important
when we start working with images.
Each image arrives as a $3^{\textrm{rd}}$-order tensor
with axes corresponding to the height, width, and <em>channel</em>.
At each spatial location, the intensities
of each color (red, green, and blue)
are stacked along the channel.
Furthermore, a collection of images is represented
in code by a $4^{\textrm{th}}$-order tensor,
where distinct images are indexed
along the first axis.
Higher-order tensors are constructed, as were vectors and matrices,
by growing the number of shape components.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.arange(24).reshape(2, 3, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.arange(24).reshape(2, 3, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reshape(tf.range(24), (2, 3, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.arange(24).reshape(2, 3, 4)
</code></pre>
<h2 id="basic-properties-of-tensor-arithmetic"><a class="header" href="#basic-properties-of-tensor-arithmetic">Basic Properties of Tensor Arithmetic</a></h2>
<p>Scalars, vectors, matrices,
and higher-order tensors
all have some handy properties.
For example, elementwise operations
produce outputs that have the
same shape as their operands.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
A = np.arange(6).reshape(2, 3)
B = A.copy()  # Assign a copy of A to B by allocating new memory
A, A + B
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A = torch.arange(6, dtype=torch.float32).reshape(2, 3)
B = A.clone()  # Assign a copy of A to B by allocating new memory
A, A + B
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A = tf.reshape(tf.range(6, dtype=tf.float32), (2, 3))
B = A  # No cloning of A to B by allocating new memory
A, A + B
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
A = jnp.arange(6, dtype=jnp.float32).reshape(2, 3)
B = A
A, A + B
</code></pre>
<p>The [<strong>elementwise product of two matrices
is called their <em>Hadamard product</em></strong>] (denoted $\odot$).
We can spell out the entries
of the Hadamard product of two matrices
$\mathbf{A}, \mathbf{B} \in \mathbb{R}^{m \times n}$:</p>
<p>$$
\mathbf{A} \odot \mathbf{B} =
\begin{bmatrix}
a_{11}  b_{11} &amp; a_{12}  b_{12} &amp; \dots  &amp; a_{1n}  b_{1n} \
a_{21}  b_{21} &amp; a_{22}  b_{22} &amp; \dots  &amp; a_{2n}  b_{2n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
a_{m1}  b_{m1} &amp; a_{m2}  b_{m2} &amp; \dots  &amp; a_{mn}  b_{mn}
\end{bmatrix}.
$$</p>
<pre><code class="language-{.python .input}">%%tab all
A * B
</code></pre>
<p>[<strong>Adding or multiplying a scalar and a tensor</strong>] produces a result
with the same shape as the original tensor.
Here, each element of the tensor is added to (or multiplied by) the scalar.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
a = 2
X = np.arange(24).reshape(2, 3, 4)
a + X, (a * X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
a = 2
X = torch.arange(24).reshape(2, 3, 4)
a + X, (a * X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
a = 2
X = tf.reshape(tf.range(24), (2, 3, 4))
a + X, (a * X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
a = 2
X = jnp.arange(24).reshape(2, 3, 4)
a + X, (a * X).shape
</code></pre>
<h2 id="reduction"><a class="header" href="#reduction">Reduction</a></h2>
<p>:label:<code>subsec_lin-alg-reduction</code></p>
<p>Often, we wish to calculate [<strong>the sum of a tensor's elements.</strong>]
To express the sum of the elements in a vector $\mathbf{x}$ of length $n$,
we write $\sum_{i=1}^n x_i$. There is a simple function for it:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(3)
x, x.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(3, dtype=torch.float32)
x, x.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.range(3, dtype=tf.float32)
x, tf.reduce_sum(x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(3, dtype=jnp.float32)
x, x.sum()
</code></pre>
<p>To express [<strong>sums over the elements of tensors of arbitrary shape</strong>],
we simply sum over all its axes.
For example, the sum of the elements
of an $m \times n$ matrix $\mathbf{A}$
could be written $\sum_{i=1}^{m} \sum_{j=1}^{n} a_{ij}$.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.shape, A.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A.shape, tf.reduce_sum(A)
</code></pre>
<p>By default, invoking the sum function
<em>reduces</em> a tensor along all of its axes,
eventually producing a scalar.
Our libraries also allow us to [<strong>specify the axes
along which the tensor should be reduced.</strong>]
To sum over all elements along the rows (axis 0),
we specify <code>axis=0</code> in <code>sum</code>.
Since the input matrix reduces along axis 0
to generate the output vector,
this axis is missing from the shape of the output.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.shape, A.sum(axis=0).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A.shape, tf.reduce_sum(A, axis=0).shape
</code></pre>
<p>Specifying <code>axis=1</code> will reduce the column dimension (axis 1) by summing up elements of all the columns.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.shape, A.sum(axis=1).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A.shape, tf.reduce_sum(A, axis=1).shape
</code></pre>
<p>Reducing a matrix along both rows and columns via summation
is equivalent to summing up all the elements of the matrix.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.sum(axis=[0, 1]) == A.sum()  # Same as A.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_sum(A, axis=[0, 1]), tf.reduce_sum(A)  # Same as tf.reduce_sum(A)
</code></pre>
<p>[<strong>A related quantity is the <em>mean</em>, also called the <em>average</em>.</strong>]
We calculate the mean by dividing the sum
by the total number of elements.
Because computing the mean is so common,
it gets a dedicated library function
that works analogously to <code>sum</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, jax
A.mean(), A.sum() / A.size
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A.mean(), A.sum() / A.numel()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_mean(A), tf.reduce_sum(A) / tf.size(A).numpy()
</code></pre>
<p>Likewise, the function for calculating the mean
can also reduce a tensor along specific axes.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.mean(axis=0), A.sum(axis=0) / A.shape[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_mean(A, axis=0), tf.reduce_sum(A, axis=0) / A.shape[0]
</code></pre>
<h2 id="non-reduction-sum"><a class="header" href="#non-reduction-sum">Non-Reduction Sum</a></h2>
<p>:label:<code>subsec_lin-alg-non-reduction</code></p>
<p>Sometimes it can be useful to [<strong>keep the number of axes unchanged</strong>]
when invoking the function for calculating the sum or mean.
This matters when we want to use the broadcast mechanism.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
sum_A = A.sum(axis=1, keepdims=True)
sum_A, sum_A.shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
sum_A = tf.reduce_sum(A, axis=1, keepdims=True)
sum_A, sum_A.shape
</code></pre>
<p>For instance, since <code>sum_A</code> keeps its two axes after summing each row,
we can (<strong>divide <code>A</code> by <code>sum_A</code> with broadcasting</strong>)
to create a matrix where each row sums up to $1$.</p>
<pre><code class="language-{.python .input}">%%tab all
A / sum_A
</code></pre>
<p>If we want to calculate [<strong>the cumulative sum of elements of <code>A</code> along some axis</strong>],
say <code>axis=0</code> (row by row), we can call the <code>cumsum</code> function.
By design, this function does not reduce the input tensor along any axis.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
A.cumsum(axis=0)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.cumsum(A, axis=0)
</code></pre>
<h2 id="dot-products"><a class="header" href="#dot-products">Dot Products</a></h2>
<p>So far, we have only performed elementwise operations, sums, and averages.
And if this was all we could do, linear algebra
would not deserve its own section.
Fortunately, this is where things get more interesting.
One of the most fundamental operations is the dot product.
Given two vectors $\mathbf{x}, \mathbf{y} \in \mathbb{R}^d$,
their <em>dot product</em> $\mathbf{x}^\top \mathbf{y}$ (also known as <em>inner product</em>, $\langle \mathbf{x}, \mathbf{y}  \rangle$)
is a sum over the products of the elements at the same position:
$\mathbf{x}^\top \mathbf{y} = \sum_{i=1}^{d} x_i y_i$.</p>
<p>[<del>The <em>dot product</em> of two vectors is a sum over the products of the elements at the same position</del>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y = np.ones(3)
x, y, np.dot(x, y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
y = torch.ones(3, dtype = torch.float32)
x, y, torch.dot(x, y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
y = tf.ones(3, dtype=tf.float32)
x, y, tf.tensordot(x, y, axes=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = jnp.ones(3, dtype = jnp.float32)
x, y, jnp.dot(x, y)
</code></pre>
<p>Equivalently, (<strong>we can calculate the dot product of two vectors
by performing an elementwise multiplication followed by a sum:</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.sum(x * y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.sum(x * y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_sum(x * y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.sum(x * y)
</code></pre>
<p>Dot products are useful in a wide range of contexts.
For example, given some set of values,
denoted by a vector $\mathbf{x}  \in \mathbb{R}^n$,
and a set of weights, denoted by $\mathbf{w} \in \mathbb{R}^n$,
the weighted sum of the values in $\mathbf{x}$
according to the weights $\mathbf{w}$
could be expressed as the dot product $\mathbf{x}^\top \mathbf{w}$.
When the weights are nonnegative
and sum to $1$, i.e., $\left(\sum_{i=1}^{n} {w_i} = 1\right)$,
the dot product expresses a <em>weighted average</em>.
After normalizing two vectors to have unit length,
the dot products express the cosine of the angle between them.
Later in this section, we will formally introduce this notion of <em>length</em>.</p>
<h2 id="matrix--vector-products"><a class="header" href="#matrix--vector-products">Matrix--Vector Products</a></h2>
<p>Now that we know how to calculate dot products,
we can begin to understand the <em>product</em>
between an $m \times n$ matrix $\mathbf{A}$
and an $n$-dimensional vector $\mathbf{x}$.
To start off, we visualize our matrix
in terms of its row vectors</p>
<p>$$\mathbf{A}=
\begin{bmatrix}
\mathbf{a}^\top_{1} \
\mathbf{a}^\top_{2} \
\vdots \
\mathbf{a}^\top_m \
\end{bmatrix},$$</p>
<p>where each $\mathbf{a}^\top_{i} \in \mathbb{R}^n$
is a row vector representing the $i^\textrm{th}$ row
of the matrix $\mathbf{A}$.</p>
<p>[<strong>The matrix--vector product $\mathbf{A}\mathbf{x}$
is simply a column vector of length $m$,
whose $i^\textrm{th}$ element is the dot product
$\mathbf{a}^\top_i \mathbf{x}$:</strong>]</p>
<p>$$
\mathbf{A}\mathbf{x}
= \begin{bmatrix}
\mathbf{a}^\top_{1} \
\mathbf{a}^\top_{2} \
\vdots \
\mathbf{a}^\top_m \
\end{bmatrix}\mathbf{x}
= \begin{bmatrix}
\mathbf{a}^\top_{1} \mathbf{x}  \
\mathbf{a}^\top_{2} \mathbf{x} \
\vdots\
\mathbf{a}^\top_{m} \mathbf{x}\
\end{bmatrix}.
$$</p>
<p>We can think of multiplication with a matrix
$\mathbf{A}\in \mathbb{R}^{m \times n}$
as a transformation that projects vectors
from $\mathbb{R}^{n}$ to $\mathbb{R}^{m}$.
These transformations are remarkably useful.
For example, we can represent rotations
as multiplications by certain square matrices.
Matrix--vector products also describe
the key calculation involved in computing
the outputs of each layer in a neural network
given the outputs from the previous layer.</p>
<p>:begin_tab:<code>mxnet</code>
To express a matrix--vector product in code,
we use the same <code>dot</code> function.
The operation is inferred
based on the type of the arguments.
Note that the column dimension of <code>A</code>
(its length along axis 1)
must be the same as the dimension of <code>x</code> (its length).
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
To express a matrix--vector product in code,
we use the <code>mv</code> function.
Note that the column dimension of <code>A</code>
(its length along axis 1)
must be the same as the dimension of <code>x</code> (its length).
Python has a convenience operator <code>@</code>
that can execute both matrix--vector
and matrix--matrix products
(depending on its arguments).
Thus we can write <code>A@x</code>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
To express a matrix--vector product in code,
we use the <code>matvec</code> function.
Note that the column dimension of <code>A</code>
(its length along axis 1)
must be the same as the dimension of <code>x</code> (its length).
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
A.shape, x.shape, np.dot(A, x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
A.shape, x.shape, torch.mv(A, x), A@x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
A.shape, x.shape, tf.linalg.matvec(A, x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
A.shape, x.shape, jnp.matmul(A, x)
</code></pre>
<h2 id="matrix--matrix-multiplication"><a class="header" href="#matrix--matrix-multiplication">Matrix--Matrix Multiplication</a></h2>
<p>Once you have gotten the hang of dot products and matrix--vector products,
then <em>matrix--matrix multiplication</em> should be straightforward.</p>
<p>Say that we have two matrices
$\mathbf{A} \in \mathbb{R}^{n \times k}$
and $\mathbf{B} \in \mathbb{R}^{k \times m}$:</p>
<p>$$\mathbf{A}=\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1k} \
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2k} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nk} \
\end{bmatrix},\quad
\mathbf{B}=\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1m} \
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2m} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
b_{k1} &amp; b_{k2} &amp; \cdots &amp; b_{km} \
\end{bmatrix}.$$</p>
<p>Let $\mathbf{a}^\top_{i} \in \mathbb{R}^k$ denote
the row vector representing the $i^\textrm{th}$ row
of the matrix $\mathbf{A}$
and let $\mathbf{b}_{j} \in \mathbb{R}^k$ denote
the column vector from the $j^\textrm{th}$ column
of the matrix $\mathbf{B}$:</p>
<p>$$\mathbf{A}=
\begin{bmatrix}
\mathbf{a}^\top_{1} \
\mathbf{a}^\top_{2} \
\vdots \
\mathbf{a}^\top_n \
\end{bmatrix},
\quad \mathbf{B}=\begin{bmatrix}
\mathbf{b}<em>{1} &amp; \mathbf{b}</em>{2} &amp; \cdots &amp; \mathbf{b}_{m} \
\end{bmatrix}.
$$</p>
<p>To form the matrix product $\mathbf{C} \in \mathbb{R}^{n \times m}$,
we simply compute each element $c_{ij}$
as the dot product between
the $i^{\textrm{th}}$ row of $\mathbf{A}$
and the $j^{\textrm{th}}$ column of $\mathbf{B}$,
i.e., $\mathbf{a}^\top_i \mathbf{b}_j$:</p>
<p>$$\mathbf{C} = \mathbf{AB} = \begin{bmatrix}
\mathbf{a}^\top_{1} \
\mathbf{a}^\top_{2} \
\vdots \
\mathbf{a}^\top_n \
\end{bmatrix}
\begin{bmatrix}
\mathbf{b}<em>{1} &amp; \mathbf{b}</em>{2} &amp; \cdots &amp; \mathbf{b}<em>{m} \
\end{bmatrix}
= \begin{bmatrix}
\mathbf{a}^\top</em>{1} \mathbf{b}<em>1 &amp; \mathbf{a}^\top</em>{1}\mathbf{b}<em>2&amp; \cdots &amp; \mathbf{a}^\top</em>{1} \mathbf{b}<em>m \
\mathbf{a}^\top</em>{2}\mathbf{b}<em>1 &amp; \mathbf{a}^\top</em>{2} \mathbf{b}<em>2 &amp; \cdots &amp; \mathbf{a}^\top</em>{2} \mathbf{b}<em>m \
\vdots &amp; \vdots &amp; \ddots &amp;\vdots\
\mathbf{a}^\top</em>{n} \mathbf{b}<em>1 &amp; \mathbf{a}^\top</em>{n}\mathbf{b}<em>2&amp; \cdots&amp; \mathbf{a}^\top</em>{n} \mathbf{b}_m
\end{bmatrix}.
$$</p>
<p>[<strong>We can think of the matrix--matrix multiplication $\mathbf{AB}$
as performing $m$ matrix--vector products
or $m \times n$ dot products
and stitching the results together
to form an $n \times m$ matrix.</strong>]
In the following snippet,
we perform matrix multiplication on <code>A</code> and <code>B</code>.
Here, <code>A</code> is a matrix with two rows and three columns,
and <code>B</code> is a matrix with three rows and four columns.
After multiplication, we obtain a matrix with two rows and four columns.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
B = np.ones(shape=(3, 4))
np.dot(A, B)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
B = torch.ones(3, 4)
torch.mm(A, B), A@B
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
B = tf.ones((3, 4), tf.float32)
tf.matmul(A, B)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
B = jnp.ones((3, 4))
jnp.matmul(A, B)
</code></pre>
<p>The term <em>matrix--matrix multiplication</em> is
often simplified to <em>matrix multiplication</em>,
and should not be confused with the Hadamard product.</p>
<h2 id="norms"><a class="header" href="#norms">Norms</a></h2>
<p>:label:<code>subsec_lin-algebra-norms</code></p>
<p>Some of the most useful operators in linear algebra are <em>norms</em>.
Informally, the norm of a vector tells us how <em>big</em> it is.
For instance, the $\ell_2$ norm measures
the (Euclidean) length of a vector.
Here, we are employing a notion of <em>size</em> that concerns the magnitude of a vector's components
(not its dimensionality).</p>
<p>A norm is a function $| \cdot |$ that maps a vector
to a scalar and satisfies the following three properties:</p>
<ol>
<li>Given any vector $\mathbf{x}$, if we scale (all elements of) the vector
by a scalar $\alpha \in \mathbb{R}$, its norm scales accordingly:
$$|\alpha \mathbf{x}| = |\alpha| |\mathbf{x}|.$$</li>
<li>For any vectors $\mathbf{x}$ and $\mathbf{y}$:
norms satisfy the triangle inequality:
$$|\mathbf{x} + \mathbf{y}| \leq |\mathbf{x}| + |\mathbf{y}|.$$</li>
<li>The norm of a vector is nonnegative and it only vanishes if the vector is zero:
$$|\mathbf{x}| &gt; 0 \textrm{ for all } \mathbf{x} \neq 0.$$</li>
</ol>
<p>Many functions are valid norms and different norms
encode different notions of size.
The Euclidean norm that we all learned in elementary school geometry
when calculating the hypotenuse of a right triangle
is the square root of the sum of squares of a vector's elements.
Formally, this is called [<strong>the $\ell_2$ <em>norm</em></strong>] and expressed as</p>
<p>(<strong>$$|\mathbf{x}|<em>2 = \sqrt{\sum</em>{i=1}^n x_i^2}.$$</strong>)</p>
<p>The method <code>norm</code> calculates the $\ell_2$ norm.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
u = np.array([3, -4])
np.linalg.norm(u)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
u = torch.tensor([3.0, -4.0])
torch.norm(u)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
u = tf.constant([3.0, -4.0])
tf.norm(u)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
u = jnp.array([3.0, -4.0])
jnp.linalg.norm(u)
</code></pre>
<p>[<strong>The $\ell_1$ norm</strong>] is also common
and the associated measure is called the Manhattan distance.
By definition, the $\ell_1$ norm sums
the absolute values of a vector's elements:</p>
<p>(<strong>$$|\mathbf{x}|<em>1 = \sum</em>{i=1}^n \left|x_i \right|.$$</strong>)</p>
<p>Compared to the $\ell_2$ norm, it is less sensitive to outliers.
To compute the $\ell_1$ norm,
we compose the absolute value
with the sum operation.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.abs(u).sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.abs(u).sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reduce_sum(tf.abs(u))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.linalg.norm(u, ord=1) # same as jnp.abs(u).sum()
</code></pre>
<p>Both the $\ell_2$ and $\ell_1$ norms are special cases
of the more general $\ell_p$ <em>norms</em>:</p>
<p>$$|\mathbf{x}|<em>p = \left(\sum</em>{i=1}^n \left|x_i \right|^p \right)^{1/p}.$$</p>
<p>In the case of matrices, matters are more complicated.
After all, matrices can be viewed both as collections of individual entries
<em>and</em> as objects that operate on vectors and transform them into other vectors.
For instance, we can ask by how much longer
the matrix--vector product $\mathbf{X} \mathbf{v}$
could be relative to $\mathbf{v}$.
This line of thought leads to what is called the <em>spectral</em> norm.
For now, we introduce [<strong>the <em>Frobenius norm</em>,
which is much easier to compute</strong>] and defined as
the square root of the sum of the squares
of a matrix's elements:</p>
<p>[<strong>$$|\mathbf{X}|<em>\textrm{F} = \sqrt{\sum</em>{i=1}^m \sum_{j=1}^n x_{ij}^2}.$$</strong>]</p>
<p>The Frobenius norm behaves as if it were
an $\ell_2$ norm of a matrix-shaped vector.
Invoking the following function will calculate
the Frobenius norm of a matrix.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.linalg.norm(np.ones((4, 9)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.norm(torch.ones((4, 9)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.norm(tf.ones((4, 9)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jnp.linalg.norm(jnp.ones((4, 9)))
</code></pre>
<p>While we do not want to get too far ahead of ourselves,
we already can plant some intuition about why these concepts are useful.
In deep learning, we are often trying to solve optimization problems:
<em>maximize</em> the probability assigned to observed data;
<em>maximize</em> the revenue associated with a recommender model;
<em>minimize</em> the distance between predictions
and the ground truth observations;
<em>minimize</em> the distance between representations
of photos of the same person
while <em>maximizing</em> the distance between representations
of photos of different people.
These distances, which constitute
the objectives of deep learning algorithms,
are often expressed as norms.</p>
<h2 id="discussion-1"><a class="header" href="#discussion-1">Discussion</a></h2>
<p>In this section, we have reviewed all the linear algebra
that you will need to understand
a significant chunk of modern deep learning.
There is a lot more to linear algebra, though,
and much of it is useful for machine learning.
For example, matrices can be decomposed into factors,
and these decompositions can reveal
low-dimensional structure in real-world datasets.
There are entire subfields of machine learning
that focus on using matrix decompositions
and their generalizations to high-order tensors
to discover structure in datasets
and solve prediction problems.
But this book focuses on deep learning.
And we believe you will be more inclined
to learn more mathematics
once you have gotten your hands dirty
applying machine learning to real datasets.
So while we reserve the right
to introduce more mathematics later on,
we wrap up this section here.</p>
<p>If you are eager to learn more linear algebra,
there are many excellent books and online resources.
For a more advanced crash course, consider checking out
:citet:<code>Strang.1993</code>, :citet:<code>Kolter.2008</code>, and :citet:<code>Petersen.Pedersen.ea.2008</code>.</p>
<p>To recap:</p>
<ul>
<li>Scalars, vectors, matrices, and tensors are
the basic mathematical objects used in linear algebra
and have zero, one, two, and an arbitrary number of axes, respectively.</li>
<li>Tensors can be sliced or reduced along specified axes
via indexing, or operations such as <code>sum</code> and <code>mean</code>, respectively.</li>
<li>Elementwise products are called Hadamard products.
By contrast, dot products, matrix--vector products, and matrix--matrix products
are not elementwise operations and in general return objects
having shapes that are different from the the operands.</li>
<li>Compared to Hadamard products, matrix--matrix products
take considerably longer to compute (cubic rather than quadratic time).</li>
<li>Norms capture various notions of the magnitude of a vector (or matrix),
and are commonly applied to the difference of two vectors
to measure their distance apart.</li>
<li>Common vector norms include the $\ell_1$ and $\ell_2$ norms,
and common matrix norms include the <em>spectral</em> and <em>Frobenius</em> norms.</li>
</ul>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>Prove that the transpose of the transpose of a matrix is the matrix itself: $(\mathbf{A}^\top)^\top = \mathbf{A}$.</li>
<li>Given two matrices $\mathbf{A}$ and $\mathbf{B}$, show that sum and transposition commute: $\mathbf{A}^\top + \mathbf{B}^\top = (\mathbf{A} + \mathbf{B})^\top$.</li>
<li>Given any square matrix $\mathbf{A}$, is $\mathbf{A} + \mathbf{A}^\top$ always symmetric? Can you prove the result by using only the results of the previous two exercises?</li>
<li>We defined the tensor <code>X</code> of shape (2, 3, 4) in this section. What is the output of <code>len(X)</code>? Write your answer without implementing any code, then check your answer using code.</li>
<li>For a tensor <code>X</code> of arbitrary shape, does <code>len(X)</code> always correspond to the length of a certain axis of <code>X</code>? What is that axis?</li>
<li>Run <code>A / A.sum(axis=1)</code> and see what happens. Can you analyze the results?</li>
<li>When traveling between two points in downtown Manhattan, what is the distance that you need to cover in terms of the coordinates, i.e., in terms of avenues and streets? Can you travel diagonally?</li>
<li>Consider a tensor of shape (2, 3, 4). What are the shapes of the summation outputs along axes 0, 1, and 2?</li>
<li>Feed a tensor with three or more axes to the <code>linalg.norm</code> function and observe its output. What does this function compute for tensors of arbitrary shape?</li>
<li>Consider three large matrices, say $\mathbf{A} \in \mathbb{R}^{2^{10} \times 2^{16}}$, $\mathbf{B} \in \mathbb{R}^{2^{16} \times 2^{5}}$ and $\mathbf{C} \in \mathbb{R}^{2^{5} \times 2^{14}}$, initialized with Gaussian random variables. You want to compute the product $\mathbf{A} \mathbf{B} \mathbf{C}$. Is there any difference in memory footprint and speed, depending on whether you compute $(\mathbf{A} \mathbf{B}) \mathbf{C}$ or $\mathbf{A} (\mathbf{B} \mathbf{C})$? Why?</li>
<li>Consider three large matrices, say $\mathbf{A} \in \mathbb{R}^{2^{10} \times 2^{16}}$, $\mathbf{B} \in \mathbb{R}^{2^{16} \times 2^{5}}$ and $\mathbf{C} \in \mathbb{R}^{2^{5} \times 2^{16}}$. Is there any difference in speed depending on whether you compute $\mathbf{A} \mathbf{B}$ or $\mathbf{A} \mathbf{C}^\top$? Why? What changes if you initialize $\mathbf{C} = \mathbf{B}^\top$ without cloning memory? Why?</li>
<li>Consider three matrices, say $\mathbf{A}, \mathbf{B}, \mathbf{C} \in \mathbb{R}^{100 \times 200}$. Construct a tensor with three axes by stacking $[\mathbf{A}, \mathbf{B}, \mathbf{C}]$. What is the dimensionality? Slice out the second coordinate of the third axis to recover $\mathbf{B}$. Check that your answer is correct.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/30">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/31">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/196">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17968">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="calculus-1"><a class="header" href="#calculus-1">Calculus</a></h1>
<p>:label:<code>sec_calculus</code></p>
<p>For a long time, how to calculate
the area of a circle remained a mystery.
Then, in Ancient Greece, the mathematician Archimedes
came up with the clever idea
to inscribe a series of polygons
with increasing numbers of vertices
on the inside of a circle
(:numref:<code>fig_circle_area</code>).
For a polygon with $n$ vertices,
we obtain $n$ triangles.
The height of each triangle approaches the radius $r$
as we partition the circle more finely.
At the same time, its base approaches $2 \pi r/n$,
since the ratio between arc and secant approaches 1
for a large number of vertices.
Thus, the area of the polygon approaches
$n \cdot r \cdot \frac{1}{2} (2 \pi r/n) = \pi r^2$.</p>
<p><img src="chapter_preliminaries/../img/polygon-circle.svg" alt="Finding the area of a circle as a limit procedure." />
:label:<code>fig_circle_area</code></p>
<p>This limiting procedure is at the root of both
<em>differential calculus</em> and <em>integral calculus</em>.
The former can tell us how to increase
or decrease a function's value by
manipulating its arguments.
This comes in handy for the <em>optimization problems</em>
that we face in deep learning,
where we repeatedly update our parameters
in order to decrease the loss function.
Optimization addresses how to fit our models to training data,
and calculus is its key prerequisite.
However, do not forget that our ultimate goal
is to perform well on <em>previously unseen</em> data.
That problem is called <em>generalization</em>
and will be a key focus of other chapters.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from matplotlib_inline import backend_inline
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
from matplotlib_inline import backend_inline
import numpy as np
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from matplotlib_inline import backend_inline
import numpy as np
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
from matplotlib_inline import backend_inline
import numpy as np
</code></pre>
<h2 id="derivatives-and-differentiation"><a class="header" href="#derivatives-and-differentiation">Derivatives and Differentiation</a></h2>
<p>Put simply, a <em>derivative</em> is the rate of change
in a function with respect to changes in its arguments.
Derivatives can tell us how rapidly a loss function
would increase or decrease were we
to <em>increase</em> or <em>decrease</em> each parameter
by an infinitesimally small amount.
Formally, for functions $f: \mathbb{R} \rightarrow \mathbb{R}$,
that map from scalars to scalars,
[<strong>the <em>derivative</em> of $f$ at a point $x$ is defined as</strong>]</p>
<p>(<strong>$$f'(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h}.$$</strong>)
:eqlabel:<code>eq_derivative</code></p>
<p>This term on the right hand side is called a <em>limit</em>
and it tells us what happens
to the value of an expression
as a specified variable
approaches a particular value.
This limit tells us what
the ratio between a perturbation $h$
and the change in the function value
$f(x + h) - f(x)$ converges to
as we shrink its size to zero.</p>
<p>When $f'(x)$ exists, $f$ is said
to be <em>differentiable</em> at $x$;
and when $f'(x)$ exists for all $x$
on a set, e.g., the interval $[a,b]$,
we say that $f$ is differentiable on this set.
Not all functions are differentiable,
including many that we wish to optimize,
such as accuracy and the area under the
receiving operating characteristic (AUC).
However, because computing the derivative of the loss
is a crucial step in nearly all
algorithms for training deep neural networks,
we often optimize a differentiable <em>surrogate</em> instead.</p>
<p>We can interpret the derivative
$f'(x)$
as the <em>instantaneous</em> rate of change
of $f(x)$ with respect to $x$.
Let's develop some intuition with an example.
(<strong>Define $u = f(x) = 3x^2-4x$.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def f(x):
    return 3 * x ** 2 - 4 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def f(x):
    return 3 * x ** 2 - 4 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def f(x):
    return 3 * x ** 2 - 4 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def f(x):
    return 3 * x ** 2 - 4 * x
</code></pre>
<p>[<strong>Setting $x=1$, we see that $\frac{f(x+h) - f(x)}{h}$</strong>] (<strong>approaches $2$
as $h$ approaches $0$.</strong>)
While this experiment lacks
the rigor of a mathematical proof,
we can quickly see that indeed $f'(1) = 2$.</p>
<pre><code class="language-{.python .input}">%%tab all
for h in 10.0**np.arange(-1, -6, -1):
    print(f'h={h:.5f}, numerical limit={(f(1+h)-f(1))/h:.5f}')
</code></pre>
<p>There are several equivalent notational conventions for derivatives.
Given $y = f(x)$, the following expressions are equivalent:</p>
<p>$$f'(x) = y' = \frac{dy}{dx} = \frac{df}{dx} = \frac{d}{dx} f(x) = Df(x) = D_x f(x),$$</p>
<p>where the symbols $\frac{d}{dx}$ and $D$ are <em>differentiation operators</em>.
Below, we present the derivatives of some common functions:</p>
<p>$$\begin{aligned} \frac{d}{dx} C &amp; = 0 &amp;&amp; \textrm{for any constant $C$} \ \frac{d}{dx} x^n &amp; = n x^{n-1} &amp;&amp; \textrm{for } n \neq 0 \ \frac{d}{dx} e^x &amp; = e^x \ \frac{d}{dx} \ln x &amp; = x^{-1}. \end{aligned}$$</p>
<p>Functions composed from differentiable functions
are often themselves differentiable.
The following rules come in handy
for working with compositions
of any differentiable functions
$f$ and $g$, and constant $C$.</p>
<p>$$\begin{aligned} \frac{d}{dx} [C f(x)] &amp; = C \frac{d}{dx} f(x) &amp;&amp; \textrm{Constant multiple rule} \ \frac{d}{dx} [f(x) + g(x)] &amp; = \frac{d}{dx} f(x) + \frac{d}{dx} g(x) &amp;&amp; \textrm{Sum rule} \ \frac{d}{dx} [f(x) g(x)] &amp; = f(x) \frac{d}{dx} g(x) + g(x) \frac{d}{dx} f(x) &amp;&amp; \textrm{Product rule} \ \frac{d}{dx} \frac{f(x)}{g(x)} &amp; = \frac{g(x) \frac{d}{dx} f(x) - f(x) \frac{d}{dx} g(x)}{g^2(x)} &amp;&amp; \textrm{Quotient rule} \end{aligned}$$</p>
<p>Using this, we can apply the rules
to find the derivative of $3 x^2 - 4x$ via</p>
<p>$$\frac{d}{dx} [3 x^2 - 4x] = 3 \frac{d}{dx} x^2 - 4 \frac{d}{dx} x = 6x - 4.$$</p>
<p>Plugging in $x = 1$ shows that, indeed,
the derivative equals $2$ at this location.
Note that derivatives tell us
the <em>slope</em> of a function
at a particular location.</p>
<h2 id="visualization-utilities"><a class="header" href="#visualization-utilities">Visualization Utilities</a></h2>
<p>[<strong>We can visualize the slopes of functions using the <code>matplotlib</code> library</strong>].
We need to define a few functions.
As its name indicates, <code>use_svg_display</code>
tells <code>matplotlib</code> to output graphics
in SVG format for crisper images.
The comment <code>#@save</code> is a special modifier
that allows us to save any function,
class, or other code block to the <code>d2l</code> package
so that we can invoke it later
without repeating the code,
e.g., via <code>d2l.use_svg_display()</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
def use_svg_display():  #@save
    """Use the svg format to display a plot in Jupyter."""
    backend_inline.set_matplotlib_formats('svg')
</code></pre>
<p>Conveniently, we can set figure sizes with <code>set_figsize</code>.
Since the import statement <code>from matplotlib import pyplot as plt</code>
was marked via <code>#@save</code> in the <code>d2l</code> package, we can call <code>d2l.plt</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
def set_figsize(figsize=(3.5, 2.5)):  #@save
    """Set the figure size for matplotlib."""
    use_svg_display()
    d2l.plt.rcParams['figure.figsize'] = figsize
</code></pre>
<p>The <code>set_axes</code> function can associate axes
with properties, including labels, ranges,
and scales.</p>
<pre><code class="language-{.python .input}">%%tab all
#@save
def set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend):
    """Set the axes for matplotlib."""
    axes.set_xlabel(xlabel), axes.set_ylabel(ylabel)
    axes.set_xscale(xscale), axes.set_yscale(yscale)
    axes.set_xlim(xlim),     axes.set_ylim(ylim)
    if legend:
        axes.legend(legend)
    axes.grid()
</code></pre>
<p>With these three functions, we can define a <code>plot</code> function
to overlay multiple curves.
Much of the code here is just ensuring
that the sizes and shapes of inputs match.</p>
<pre><code class="language-{.python .input}">%%tab all
#@save
def plot(X, Y=None, xlabel=None, ylabel=None, legend=[], xlim=None,
         ylim=None, xscale='linear', yscale='linear',
         fmts=('-', 'm--', 'g-.', 'r:'), figsize=(3.5, 2.5), axes=None):
    """Plot data points."""

    def has_one_axis(X):  # True if X (tensor or list) has 1 axis
        return (hasattr(X, "ndim") and X.ndim == 1 or isinstance(X, list)
                and not hasattr(X[0], "__len__"))
    
    if has_one_axis(X): X = [X]
    if Y is None:
        X, Y = [[]] * len(X), X
    elif has_one_axis(Y):
        Y = [Y]
    if len(X) != len(Y):
        X = X * len(Y)
        
    set_figsize(figsize)
    if axes is None:
        axes = d2l.plt.gca()
    axes.cla()
    for x, y, fmt in zip(X, Y, fmts):
        axes.plot(x,y,fmt) if len(x) else axes.plot(y,fmt)
    set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)
</code></pre>
<p>Now we can [<strong>plot the function $u = f(x)$ and its tangent line $y = 2x - 3$ at $x=1$</strong>],
where the coefficient $2$ is the slope of the tangent line.</p>
<pre><code class="language-{.python .input}">%%tab all
x = np.arange(0, 3, 0.1)
plot(x, [f(x), 2 * x - 3], 'x', 'f(x)', legend=['f(x)', 'Tangent line (x=1)'])
</code></pre>
<h2 id="partial-derivatives-and-gradients"><a class="header" href="#partial-derivatives-and-gradients">Partial Derivatives and Gradients</a></h2>
<p>:label:<code>subsec_calculus-grad</code></p>
<p>Thus far, we have been differentiating
functions of just one variable.
In deep learning, we also need to work
with functions of <em>many</em> variables.
We briefly introduce notions of the derivative
that apply to such <em>multivariate</em> functions.</p>
<p>Let $y = f(x_1, x_2, \ldots, x_n)$ be a function with $n$ variables.
The <em>partial derivative</em> of $y$
with respect to its $i^\textrm{th}$ parameter $x_i$ is</p>
<p>$$ \frac{\partial y}{\partial x_i} = \lim_{h \rightarrow 0} \frac{f(x_1, \ldots, x_{i-1}, x_i+h, x_{i+1}, \ldots, x_n) - f(x_1, \ldots, x_i, \ldots, x_n)}{h}.$$</p>
<p>To calculate $\frac{\partial y}{\partial x_i}$,
we can treat $x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_n$ as constants
and calculate the derivative of $y$ with respect to $x_i$.
The following notational conventions for partial derivatives
are all common and all mean the same thing:</p>
<p>$$\frac{\partial y}{\partial x_i} = \frac{\partial f}{\partial x_i} = \partial_{x_i} f = \partial_i f = f_{x_i} = f_i = D_i f = D_{x_i} f.$$</p>
<p>We can concatenate partial derivatives
of a multivariate function
with respect to all its variables
to obtain a vector that is called
the <em>gradient</em> of the function.
Suppose that the input of function
$f: \mathbb{R}^n \rightarrow \mathbb{R}$
is an $n$-dimensional vector
$\mathbf{x} = [x_1, x_2, \ldots, x_n]^\top$
and the output is a scalar.
The gradient of the function $f$
with respect to $\mathbf{x}$
is a vector of $n$ partial derivatives:</p>
<p>$$\nabla_{\mathbf{x}} f(\mathbf{x}) = \left[\partial_{x_1} f(\mathbf{x}), \partial_{x_2} f(\mathbf{x}), \ldots
\partial_{x_n} f(\mathbf{x})\right]^\top.$$</p>
<p>When there is no ambiguity,
$\nabla_{\mathbf{x}} f(\mathbf{x})$
is typically replaced
by $\nabla f(\mathbf{x})$.
The following rules come in handy
for differentiating multivariate functions:</p>
<ul>
<li>For all $\mathbf{A} \in \mathbb{R}^{m \times n}$ we have $\nabla_{\mathbf{x}} \mathbf{A} \mathbf{x} = \mathbf{A}^\top$ and $\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A}  = \mathbf{A}$.</li>
<li>For square matrices $\mathbf{A} \in \mathbb{R}^{n \times n}$ we have that $\nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{A} \mathbf{x}  = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}$ and in particular
$\nabla_{\mathbf{x}} |\mathbf{x} |^2 = \nabla_{\mathbf{x}} \mathbf{x}^\top \mathbf{x} = 2\mathbf{x}$.</li>
</ul>
<p>Similarly, for any matrix $\mathbf{X}$,
we have $\nabla_{\mathbf{X}} |\mathbf{X} |_\textrm{F}^2 = 2\mathbf{X}$.</p>
<h2 id="chain-rule"><a class="header" href="#chain-rule">Chain Rule</a></h2>
<p>In deep learning, the gradients of concern
are often difficult to calculate
because we are working with
deeply nested functions
(of functions (of functions...)).
Fortunately, the <em>chain rule</em> takes care of this.
Returning to functions of a single variable,
suppose that $y = f(g(x))$
and that the underlying functions
$y=f(u)$ and $u=g(x)$
are both differentiable.
The chain rule states that</p>
<p>$$\frac{dy}{dx} = \frac{dy}{du} \frac{du}{dx}.$$</p>
<p>Turning back to multivariate functions,
suppose that $y = f(\mathbf{u})$ has variables
$u_1, u_2, \ldots, u_m$,
where each $u_i = g_i(\mathbf{x})$
has variables $x_1, x_2, \ldots, x_n$,
i.e.,  $\mathbf{u} = g(\mathbf{x})$.
Then the chain rule states that</p>
<p>$$\frac{\partial y}{\partial x_{i}} = \frac{\partial y}{\partial u_{1}} \frac{\partial u_{1}}{\partial x_{i}} + \frac{\partial y}{\partial u_{2}} \frac{\partial u_{2}}{\partial x_{i}} + \ldots + \frac{\partial y}{\partial u_{m}} \frac{\partial u_{m}}{\partial x_{i}} \ \textrm{ and so } \ \nabla_{\mathbf{x}} y =  \mathbf{A} \nabla_{\mathbf{u}} y,$$</p>
<p>where $\mathbf{A} \in \mathbb{R}^{n \times m}$ is a <em>matrix</em>
that contains the derivative of vector $\mathbf{u}$
with respect to vector $\mathbf{x}$.
Thus, evaluating the gradient requires
computing a vector--matrix product.
This is one of the key reasons why linear algebra
is such an integral building block
in building deep learning systems.</p>
<h2 id="discussion-2"><a class="header" href="#discussion-2">Discussion</a></h2>
<p>While we have just scratched the surface of a deep topic,
a number of concepts already come into focus:
first, the composition rules for differentiation
can be applied routinely, enabling
us to compute gradients <em>automatically</em>.
This task requires no creativity and thus
we can focus our cognitive powers elsewhere.
Second, computing the derivatives of vector-valued functions
requires us to multiply matrices as we trace
the dependency graph of variables from output to input.
In particular, this graph is traversed in a <em>forward</em> direction
when we evaluate a function
and in a <em>backwards</em> direction
when we compute gradients.
Later chapters will formally introduce backpropagation,
a computational procedure for applying the chain rule.</p>
<p>From the viewpoint of optimization, gradients allow us
to determine how to move the parameters of a model
in order to lower the loss,
and each step of the optimization algorithms used
throughout this book will require calculating the gradient.</p>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>So far we took the rules for derivatives for granted.
Using the definition and limits prove the properties
for (i) $f(x) = c$, (ii) $f(x) = x^n$, (iii) $f(x) = e^x$ and (iv) $f(x) = \log x$.</li>
<li>In the same vein, prove the product, sum, and quotient rule from first principles.</li>
<li>Prove that the constant multiple rule follows as a special case of the product rule.</li>
<li>Calculate the derivative of $f(x) = x^x$.</li>
<li>What does it mean that $f'(x) = 0$ for some $x$?
Give an example of a function $f$
and a location $x$ for which this might hold.</li>
<li>Plot the function $y = f(x) = x^3 - \frac{1}{x}$
and plot its tangent line at $x = 1$.</li>
<li>Find the gradient of the function
$f(\mathbf{x}) = 3x_1^2 + 5e^{x_2}$.</li>
<li>What is the gradient of the function
$f(\mathbf{x}) = |\mathbf{x}|_2$? What happens for $\mathbf{x} = \mathbf{0}$?</li>
<li>Can you write out the chain rule for the case
where $u = f(x, y, z)$ and $x = x(a, b)$, $y = y(a, b)$, and $z = z(a, b)$?</li>
<li>Given a function $f(x)$ that is invertible,
compute the derivative of its inverse $f^{-1}(x)$.
Here we have that $f^{-1}(f(x)) = x$ and conversely $f(f^{-1}(y)) = y$.
Hint: use these properties in your derivation.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/32">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/33">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/197">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17969">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="automatic-differentiation"><a class="header" href="#automatic-differentiation">Automatic Differentiation</a></h1>
<p>:label:<code>sec_autograd</code></p>
<p>Recall from :numref:<code>sec_calculus</code>
that calculating derivatives is the crucial step
in all the optimization algorithms
that we will use to train deep networks.
While the calculations are straightforward,
working them out by hand can be tedious and error-prone,
and these issues only grow
as our models become more complex.</p>
<p>Fortunately all modern deep learning frameworks
take this work off our plates
by offering <em>automatic differentiation</em>
(often shortened to <em>autograd</em>).
As we pass data through each successive function,
the framework builds a <em>computational graph</em>
that tracks how each value depends on others.
To calculate derivatives,
automatic differentiation
works backwards through this graph
applying the chain rule.
The computational algorithm for applying the chain rule
in this fashion is called <em>backpropagation</em>.</p>
<p>While autograd libraries have become
a hot concern over the past decade,
they have a long history.
In fact the earliest references to autograd
date back over half of a century :cite:<code>Wengert.1964</code>.
The core ideas behind modern backpropagation
date to a PhD thesis from 1980 :cite:<code>Speelpenning.1980</code>
and were further developed in the late 1980s :cite:<code>Griewank.1989</code>.
While backpropagation has become the default method
for computing gradients, it is not the only option.
For instance, the Julia programming language employs
forward propagation :cite:<code>Revels.Lubin.Papamarkou.2016</code>.
Before exploring methods,
let's first master the autograd package.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import autograd, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from jax import numpy as jnp
</code></pre>
<h2 id="a-simple-function"><a class="header" href="#a-simple-function">A Simple Function</a></h2>
<p>Let's assume that we are interested
in (<strong>differentiating the function
$y = 2\mathbf{x}^{\top}\mathbf{x}$
with respect to the column vector $\mathbf{x}$.</strong>)
To start, we assign <code>x</code> an initial value.</p>
<pre><code class="language-{.python .input  n=1}">%%tab mxnet
x = np.arange(4.0)
x
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab pytorch
x = torch.arange(4.0)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.range(4, dtype=tf.float32)
x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(4.0)
x
</code></pre>
<p>:begin_tab:<code>mxnet, pytorch, tensorflow</code>
[<strong>Before we calculate the gradient
of $y$ with respect to $\mathbf{x}$,
we need a place to store it.</strong>]
In general, we avoid allocating new memory
every time we take a derivative
because deep learning requires
successively computing derivatives
with respect to the same parameters
a great many times,
and we might risk running out of memory.
Note that the gradient of a scalar-valued function
with respect to a vector $\mathbf{x}$
is vector-valued with
the same shape as $\mathbf{x}$.
:end_tab:</p>
<pre><code class="language-{.python .input  n=8}">%%tab mxnet
# We allocate memory for a tensor's gradient by invoking `attach_grad`
x.attach_grad()
# After we calculate a gradient taken with respect to `x`, we will be able to
# access it via the `grad` attribute, whose values are initialized with 0s
x.grad
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab pytorch
# Can also create x = torch.arange(4.0, requires_grad=True)
x.requires_grad_(True)
x.grad  # The gradient is None by default
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.Variable(x)
</code></pre>
<p>(<strong>We now calculate our function of <code>x</code> and assign the result to <code>y</code>.</strong>)</p>
<pre><code class="language-{.python .input  n=10}">%%tab mxnet
# Our code is inside an `autograd.record` scope to build the computational
# graph
with autograd.record():
    y = 2 * np.dot(x, x)
y
</code></pre>
<pre><code class="language-{.python .input  n=11}">%%tab pytorch
y = 2 * torch.dot(x, x)
y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# Record all computations onto a tape
with tf.GradientTape() as t:
    y = 2 * tf.tensordot(x, x, axes=1)
y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = lambda x: 2 * jnp.dot(x, x)
y(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
[<strong>We can now take the gradient of <code>y</code>
with respect to <code>x</code></strong>] by calling
its <code>backward</code> method.
Next, we can access the gradient
via <code>x</code>'s <code>grad</code> attribute.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>We can now take the gradient of <code>y</code>
with respect to <code>x</code></strong>] by calling
its <code>backward</code> method.
Next, we can access the gradient
via <code>x</code>'s <code>grad</code> attribute.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
[<strong>We can now calculate the gradient of <code>y</code>
with respect to <code>x</code></strong>] by calling
the <code>gradient</code> method.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
[<strong>We can now take the gradient of <code>y</code>
with respect to <code>x</code></strong>] by passing through the
<code>grad</code> transform.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y.backward()
x.grad
</code></pre>
<pre><code class="language-{.python .input  n=12}">%%tab pytorch
y.backward()
x.grad
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x_grad = t.gradient(y, x)
x_grad
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from jax import grad
# The `grad` transform returns a Python function that
# computes the gradient of the original function
x_grad = grad(y)(x)
x_grad
</code></pre>
<p>(<strong>We already know that the gradient of the function $y = 2\mathbf{x}^{\top}\mathbf{x}$
with respect to $\mathbf{x}$ should be $4\mathbf{x}$.</strong>)
We can now verify that the automatic gradient computation
and the expected result are identical.</p>
<pre><code class="language-{.python .input  n=13}">%%tab mxnet
x.grad == 4 * x
</code></pre>
<pre><code class="language-{.python .input  n=14}">%%tab pytorch
x.grad == 4 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x_grad == 4 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x_grad == 4 * x
</code></pre>
<p>:begin_tab:<code>mxnet</code>
[<strong>Now let's calculate
another function of <code>x</code>
and take its gradient.</strong>]
Note that MXNet resets the gradient buffer
whenever we record a new gradient.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>Now let's calculate
another function of <code>x</code>
and take its gradient.</strong>]
Note that PyTorch does not automatically
reset the gradient buffer
when we record a new gradient.
Instead, the new gradient
is added to the already-stored gradient.
This behavior comes in handy
when we want to optimize the sum
of multiple objective functions.
To reset the gradient buffer,
we can call <code>x.grad.zero_()</code> as follows:
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
[<strong>Now let's calculate
another function of <code>x</code>
and take its gradient.</strong>]
Note that TensorFlow resets the gradient buffer
whenever we record a new gradient.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
with autograd.record():
    y = x.sum()
y.backward()
x.grad  # Overwritten by the newly calculated gradient
</code></pre>
<pre><code class="language-{.python .input  n=20}">%%tab pytorch
x.grad.zero_()  # Reset the gradient
y = x.sum()
y.backward()
x.grad
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with tf.GradientTape() as t:
    y = tf.reduce_sum(x)
t.gradient(y, x)  # Overwritten by the newly calculated gradient
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = lambda x: x.sum()
grad(y)(x)
</code></pre>
<h2 id="backward-for-non-scalar-variables"><a class="header" href="#backward-for-non-scalar-variables">Backward for Non-Scalar Variables</a></h2>
<p>When <code>y</code> is a vector,
the most natural representation
of the derivative of  <code>y</code>
with respect to a vector <code>x</code>
is a matrix called the <em>Jacobian</em>
that contains the partial derivatives
of each component of <code>y</code>
with respect to each component of <code>x</code>.
Likewise, for higher-order <code>y</code> and <code>x</code>,
the result of differentiation could be an even higher-order tensor.</p>
<p>While Jacobians do show up in some
advanced machine learning techniques,
more commonly we want to sum up
the gradients of each component of <code>y</code>
with respect to the full vector <code>x</code>,
yielding a vector of the same shape as <code>x</code>.
For example, we often have a vector
representing the value of our loss function
calculated separately for each example among
a <em>batch</em> of training examples.
Here, we just want to (<strong>sum up the gradients
computed individually for each example</strong>).</p>
<p>:begin_tab:<code>mxnet</code>
MXNet handles this problem by reducing all tensors to scalars
by summing before computing a gradient.
In other words, rather than returning the Jacobian
$\partial_{\mathbf{x}} \mathbf{y}$,
it returns the gradient of the sum
$\partial_{\mathbf{x}} \sum_i y_i$.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Because deep learning frameworks vary
in how they interpret gradients of
non-scalar tensors,
PyTorch takes some steps to avoid confusion.
Invoking <code>backward</code> on a non-scalar elicits an error
unless we tell PyTorch how to reduce the object to a scalar.
More formally, we need to provide some vector $\mathbf{v}$
such that <code>backward</code> will compute
$\mathbf{v}^\top \partial_{\mathbf{x}} \mathbf{y}$
rather than $\partial_{\mathbf{x}} \mathbf{y}$.
This next part may be confusing,
but for reasons that will become clear later,
this argument (representing $\mathbf{v}$) is named <code>gradient</code>.
For a more detailed description, see Yang Zhang's
<a href="https://zhang-yang.medium.com/the-gradient-argument-in-pytorchs-backward-function-explained-by-examples-68f266950c29">Medium post</a>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
By default, TensorFlow returns the gradient of the sum.
In other words, rather than returning
the Jacobian $\partial_{\mathbf{x}} \mathbf{y}$,
it returns the gradient of the sum
$\partial_{\mathbf{x}} \sum_i y_i$.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
with autograd.record():
    y = x * x  
y.backward()
x.grad  # Equals the gradient of y = sum(x * x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x.grad.zero_()
y = x * x
y.backward(gradient=torch.ones(len(y)))  # Faster: y.sum().backward()
x.grad
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with tf.GradientTape() as t:
    y = x * x
t.gradient(y, x)  # Same as y = tf.reduce_sum(x * x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = lambda x: x * x
# grad is only defined for scalar output functions
grad(lambda x: y(x).sum())(x)
</code></pre>
<h2 id="detaching-computation"><a class="header" href="#detaching-computation">Detaching Computation</a></h2>
<p>Sometimes, we wish to [<strong>move some calculations
outside of the recorded computational graph.</strong>]
For example, say that we use the input
to create some auxiliary intermediate terms
for which we do not want to compute a gradient.
In this case, we need to <em>detach</em>
the respective computational graph
from the final result.
The following toy example makes this clearer:
suppose we have <code>z = x * y</code> and <code>y = x * x</code>
but we want to focus on the <em>direct</em> influence of <code>x</code> on <code>z</code>
rather than the influence conveyed via <code>y</code>.
In this case, we can create a new variable <code>u</code>
that takes the same value as <code>y</code>
but whose <em>provenance</em> (how it was created)
has been wiped out.
Thus <code>u</code> has no ancestors in the graph
and gradients do not flow through <code>u</code> to <code>x</code>.
For example, taking the gradient of <code>z = x * u</code>
will yield the result <code>u</code>,
(not <code>3 * x * x</code> as you might have
expected since <code>z = x * x * x</code>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
with autograd.record():
    y = x * x
    u = y.detach()
    z = u * x
z.backward()
x.grad == u
</code></pre>
<pre><code class="language-{.python .input  n=21}">%%tab pytorch
x.grad.zero_()
y = x * x
u = y.detach()
z = u * x

z.sum().backward()
x.grad == u
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# Set persistent=True to preserve the compute graph. 
# This lets us run t.gradient more than once
with tf.GradientTape(persistent=True) as t:
    y = x * x
    u = tf.stop_gradient(y)
    z = u * x

x_grad = t.gradient(z, x)
x_grad == u
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import jax

y = lambda x: x * x
# jax.lax primitives are Python wrappers around XLA operations
u = jax.lax.stop_gradient(y(x))
z = lambda x: u * x

grad(lambda x: z(x).sum())(x) == y(x)
</code></pre>
<p>Note that while this procedure
detaches <code>y</code>'s ancestors
from the graph leading to <code>z</code>,
the computational graph leading to <code>y</code>
persists and thus we can calculate
the gradient of <code>y</code> with respect to <code>x</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y.backward()
x.grad == 2 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x.grad.zero_()
y.sum().backward()
x.grad == 2 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
t.gradient(y, x) == 2 * x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
grad(lambda x: y(x).sum())(x) == 2 * x
</code></pre>
<h2 id="gradients-and-python-control-flow"><a class="header" href="#gradients-and-python-control-flow">Gradients and Python Control Flow</a></h2>
<p>So far we reviewed cases where the path from input to output
was well defined via a function such as <code>z = x * x * x</code>.
Programming offers us a lot more freedom in how we compute results.
For instance, we can make them depend on auxiliary variables
or condition choices on intermediate results.
One benefit of using automatic differentiation
is that [<strong>even if</strong>] building the computational graph of
(<strong>a function required passing through a maze of Python control flow</strong>)
(e.g., conditionals, loops, and arbitrary function calls),
(<strong>we can still calculate the gradient of the resulting variable.</strong>)
To illustrate this, consider the following code snippet where
the number of iterations of the <code>while</code> loop
and the evaluation of the <code>if</code> statement
both depend on the value of the input <code>a</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def f(a):
    b = a * 2
    while np.linalg.norm(b) &lt; 1000:
        b = b * 2
    if b.sum() &gt; 0:
        c = b
    else:
        c = 100 * b
    return c
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def f(a):
    b = a * 2
    while b.norm() &lt; 1000:
        b = b * 2
    if b.sum() &gt; 0:
        c = b
    else:
        c = 100 * b
    return c
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def f(a):
    b = a * 2
    while tf.norm(b) &lt; 1000:
        b = b * 2
    if tf.reduce_sum(b) &gt; 0:
        c = b
    else:
        c = 100 * b
    return c
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def f(a):
    b = a * 2
    while jnp.linalg.norm(b) &lt; 1000:
        b = b * 2
    if b.sum() &gt; 0:
        c = b
    else:
        c = 100 * b
    return c
</code></pre>
<p>Below, we call this function, passing in a random value, as input.
Since the input is a random variable,
we do not know what form
the computational graph will take.
However, whenever we execute <code>f(a)</code>
on a specific input, we realize
a specific computational graph
and can subsequently run <code>backward</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
a = np.random.normal()
a.attach_grad()
with autograd.record():
    d = f(a)
d.backward()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
a = torch.randn(size=(), requires_grad=True)
d = f(a)
d.backward()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
a = tf.Variable(tf.random.normal(shape=()))
with tf.GradientTape() as t:
    d = f(a)
d_grad = t.gradient(d, a)
d_grad
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from jax import random
a = random.normal(random.PRNGKey(1), ())
d = f(a)
d_grad = grad(f)(a)
</code></pre>
<p>Even though our function <code>f</code> is, for demonstration purposes, a bit contrived,
its dependence on the input is quite simple:
it is a <em>linear</em> function of <code>a</code>
with piecewise defined scale.
As such, <code>f(a) / a</code> is a vector of constant entries
and, moreover, <code>f(a) / a</code> needs to match
the gradient of <code>f(a)</code> with respect to <code>a</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
a.grad == d / a
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
a.grad == d / a
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
d_grad == d / a
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
d_grad == d / a
</code></pre>
<p>Dynamic control flow is very common in deep learning.
For instance, when processing text, the computational graph
depends on the length of the input.
In these cases, automatic differentiation
becomes vital for statistical modeling
since it is impossible to compute the gradient <em>a priori</em>.</p>
<h2 id="discussion-3"><a class="header" href="#discussion-3">Discussion</a></h2>
<p>You have now gotten a taste of the power of automatic differentiation.
The development of libraries for calculating derivatives
both automatically and efficiently
has been a massive productivity booster
for deep learning practitioners,
liberating them so they can focus on less menial.
Moreover, autograd lets us design massive models
for which pen and paper gradient computations
would be prohibitively time consuming.
Interestingly, while we use autograd to <em>optimize</em> models
(in a statistical sense)
the <em>optimization</em> of autograd libraries themselves
(in a computational sense)
is a rich subject
of vital interest to framework designers.
Here, tools from compilers and graph manipulation
are leveraged to compute results
in the most expedient and memory-efficient manner.</p>
<p>For now, try to remember these basics: (i) attach gradients to those variables with respect to which we desire derivatives; (ii) record the computation of the target value; (iii) execute the backpropagation function; and  (iv) access the resulting gradient.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>Why is the second derivative much more expensive to compute than the first derivative?</li>
<li>After running the function for backpropagation, immediately run it again and see what happens. Investigate.</li>
<li>In the control flow example where we calculate the derivative of <code>d</code> with respect to <code>a</code>, what would happen if we changed the variable <code>a</code> to a random vector or a matrix? At this point, the result of the calculation <code>f(a)</code> is no longer a scalar. What happens to the result? How do we analyze this?</li>
<li>Let $f(x) = \sin(x)$. Plot the graph of $f$ and of its derivative $f'$. Do not exploit the fact that $f'(x) = \cos(x)$ but rather use automatic differentiation to get the result.</li>
<li>Let $f(x) = ((\log x^2) \cdot \sin x) + x^{-1}$. Write out a dependency graph tracing results from $x$ to $f(x)$.</li>
<li>Use the chain rule to compute the derivative $\frac{df}{dx}$ of the aforementioned function, placing each term on the dependency graph that you constructed previously.</li>
<li>Given the graph and the intermediate derivative results, you have a number of options when computing the gradient. Evaluate the result once starting from $x$ to $f$ and once from $f$ tracing back to $x$. The path from $x$ to $f$ is commonly known as <em>forward differentiation</em>, whereas the path from $f$ to $x$ is known as backward differentiation.</li>
<li>When might you want to use forward, and when backward, differentiation? Hint: consider the amount of intermediate data needed, the ability to parallelize steps, and the size of matrices and vectors involved.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/34">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/35">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/200">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17970">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="probability-and-statistics"><a class="header" href="#probability-and-statistics">Probability and Statistics</a></h1>
<p>:label:<code>sec_prob</code></p>
<p>One way or another,
machine learning is all about uncertainty.
In supervised learning, we want to predict
something unknown (the <em>target</em>)
given something known (the <em>features</em>).
Depending on our objective,
we might attempt to predict
the most likely value of the target.
Or we might predict the value with the smallest
expected distance from the target.
And sometimes we wish not only
to predict a specific value
but to <em>quantify our uncertainty</em>.
For example, given some features
describing a patient,
we might want to know <em>how likely</em> they are
to suffer a heart attack in the next year.
In unsupervised learning,
we often care about uncertainty.
To determine whether a set of measurements are anomalous,
it helps to know how likely one is
to observe values in a population of interest.
Furthermore, in reinforcement learning,
we wish to develop agents
that act intelligently in various environments.
This requires reasoning about
how an environment might be expected to change
and what rewards one might expect to encounter
in response to each of the available actions.</p>
<p><em>Probability</em> is the mathematical field
concerned with reasoning under uncertainty.
Given a probabilistic model of some process,
we can reason about the likelihood of various events.
The use of probabilities to describe
the frequencies of repeatable events
(like coin tosses)
is fairly uncontroversial.
In fact, <em>frequentist</em> scholars adhere
to an interpretation of probability
that applies <em>only</em> to such repeatable events.
By contrast <em>Bayesian</em> scholars
use the language of probability more broadly
to formalize reasoning under uncertainty.
Bayesian probability is characterized
by two unique features:
(i) assigning degrees of belief
to non-repeatable events,
e.g., what is the <em>probability</em>
that a dam will collapse?;
and (ii) subjectivity. While Bayesian
probability provides unambiguous rules
for how one should update their beliefs
in light of new evidence,
it allows for different individuals
to start off with different <em>prior</em> beliefs.
<em>Statistics</em> helps us to reason backwards,
starting off with collection and organization of data
and backing out to what inferences
we might draw about the process
that generated the data.
Whenever we analyze a dataset, hunting for patterns
that we hope might characterize a broader population,
we are employing statistical thinking.
Many courses, majors, theses, careers, departments,
companies, and institutions have been devoted
to the study of probability and statistics.
While this section only scratches the surface,
we will provide the foundation
that you need to begin building models.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.numpy.random import multinomial
import random
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import random
import torch
from torch.distributions.multinomial import Multinomial
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import random
import tensorflow as tf
from tensorflow_probability import distributions as tfd
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import random
import jax
from jax import numpy as jnp
import numpy as np
</code></pre>
<h2 id="a-simple-example-tossing-coins"><a class="header" href="#a-simple-example-tossing-coins">A Simple Example: Tossing Coins</a></h2>
<p>Imagine that we plan to toss a coin
and want to quantify how likely
we are to see heads (vs. tails).
If the coin is <em>fair</em>,
then both outcomes
(heads and tails),
are equally likely.
Moreover if we plan to toss the coin $n$ times
then the fraction of heads
that we <em>expect</em> to see
should exactly match
the <em>expected</em> fraction of tails.
One intuitive way to see this
is by symmetry:
for every possible outcome
with $n_\textrm{h}$ heads and $n_\textrm{t} = (n - n_\textrm{h})$ tails,
there is an equally likely outcome
with $n_\textrm{t}$ heads and $n_\textrm{h}$ tails.
Note that this is only possible
if on average we expect to see
$1/2$ of tosses come up heads
and $1/2$ come up tails.
Of course, if you conduct this experiment
many times with $n=1000000$ tosses each,
you might never see a trial
where $n_\textrm{h} = n_\textrm{t}$ exactly.</p>
<p>Formally, the quantity $1/2$ is called a <em>probability</em>
and here it captures the certainty with which
any given toss will come up heads.
Probabilities assign scores between $0$ and $1$
to outcomes of interest, called <em>events</em>.
Here the event of interest is $\textrm{heads}$
and we denote the corresponding probability $P(\textrm{heads})$.
A probability of $1$ indicates absolute certainty
(imagine a trick coin where both sides were heads)
and a probability of $0$ indicates impossibility
(e.g., if both sides were tails).
The frequencies $n_\textrm{h}/n$ and $n_\textrm{t}/n$ are not probabilities
but rather <em>statistics</em>.
Probabilities are <em>theoretical</em> quantities
that underly the data generating process.
Here, the probability $1/2$
is a property of the coin itself.
By contrast, statistics are <em>empirical</em> quantities
that are computed as functions of the observed data.
Our interests in probabilistic and statistical quantities
are inextricably intertwined.
We often design special statistics called <em>estimators</em>
that, given a dataset, produce <em>estimates</em>
of model parameters such as probabilities.
Moreover, when those estimators satisfy
a nice property called <em>consistency</em>,
our estimates will converge
to the corresponding probability.
In turn, these inferred probabilities
tell about the likely statistical properties
of data from the same population
that we might encounter in the future.</p>
<p>Suppose that we stumbled upon a real coin
for which we did not know
the true $P(\textrm{heads})$.
To investigate this quantity
with statistical methods,
we need to (i) collect some data;
and (ii) design an estimator.
Data acquisition here is easy;
we can toss the coin many times
and record all the outcomes.
Formally, drawing realizations
from some underlying random process
is called <em>sampling</em>.
As you might have guessed,
one natural estimator
is the ratio of
the number of observed <em>heads</em>
to the total number of tosses.</p>
<p>Now, suppose that the coin was in fact fair,
i.e., $P(\textrm{heads}) = 0.5$.
To simulate tosses of a fair coin,
we can invoke any random number generator.
There are some easy ways to draw samples
of an event with probability $0.5$.
For example Python's <code>random.random</code>
yields numbers in the interval $[0,1]$
where the probability of lying
in any sub-interval $[a, b] \subset [0,1]$
is equal to $b-a$.
Thus we can get out <code>0</code> and <code>1</code> with probability <code>0.5</code> each
by testing whether the returned float number is greater than <code>0.5</code>:</p>
<pre><code class="language-{.python .input}">%%tab all
num_tosses = 100
heads = sum([random.random() &gt; 0.5 for _ in range(num_tosses)])
tails = num_tosses - heads
print("heads, tails: ", [heads, tails])
</code></pre>
<p>More generally, we can simulate multiple draws
from any variable with a finite number
of possible outcomes
(like the toss of a coin or roll of a die)
by calling the multinomial function,
setting the first argument
to the number of draws
and the second as a list of probabilities
associated with each of the possible outcomes.
To simulate ten tosses of a fair coin,
we assign probability vector <code>[0.5, 0.5]</code>,
interpreting index 0 as heads
and index 1 as tails.
The function returns a vector
with length equal to the number
of possible outcomes (here, 2),
where the first component tells us
the number of occurrences of heads
and the second component tells us
the number of occurrences of tails.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
fair_probs = [0.5, 0.5]
multinomial(100, fair_probs)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
fair_probs = torch.tensor([0.5, 0.5])
Multinomial(100, fair_probs).sample()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
fair_probs = tf.ones(2) / 2
tfd.Multinomial(100, fair_probs).sample()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
fair_probs = [0.5, 0.5]
# jax.random does not have multinomial distribution implemented
np.random.multinomial(100, fair_probs)
</code></pre>
<p>Each time you run this sampling process,
you will receive a new random value
that may differ from the previous outcome.
Dividing by the number of tosses
gives us the <em>frequency</em>
of each outcome in our data.
Note that these frequencies,
just like the probabilities
that they are intended
to estimate, sum to $1$.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
multinomial(100, fair_probs) / 100
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Multinomial(100, fair_probs).sample() / 100
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tfd.Multinomial(100, fair_probs).sample() / 100
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
np.random.multinomial(100, fair_probs) / 100
</code></pre>
<p>Here, even though our simulated coin is fair
(we ourselves set the probabilities <code>[0.5, 0.5]</code>),
the counts of heads and tails may not be identical.
That is because we only drew a relatively small number of samples.
If we did not implement the simulation ourselves,
and only saw the outcome,
how would we know if the coin were slightly unfair
or if the possible deviation from $1/2$ was
just an artifact of the small sample size?
Let's see what happens when we simulate 10,000 tosses.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
counts = multinomial(10000, fair_probs).astype(np.float32)
counts / 10000
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
counts = Multinomial(10000, fair_probs).sample()
counts / 10000
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
counts = tfd.Multinomial(10000, fair_probs).sample()
counts / 10000
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
counts = np.random.multinomial(10000, fair_probs).astype(np.float32)
counts / 10000
</code></pre>
<p>In general, for averages of repeated events (like coin tosses),
as the number of repetitions grows,
our estimates are guaranteed to converge
to the true underlying probabilities.
The mathematical formulation of this phenomenon
is called the <em>law of large numbers</em>
and the <em>central limit theorem</em>
tells us that in many situations,
as the sample size $n$ grows,
these errors should go down
at a rate of $(1/\sqrt{n})$.
Let's get some more intuition by studying
how our estimate evolves as we grow
the number of tosses from 1 to 10,000.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
counts = Multinomial(1, fair_probs).sample((10000,))
cum_counts = counts.cumsum(dim=0)
estimates = cum_counts / cum_counts.sum(dim=1, keepdims=True)
estimates = estimates.numpy()

d2l.set_figsize((4.5, 3.5))
d2l.plt.plot(estimates[:, 0], label=("P(coin=heads)"))
d2l.plt.plot(estimates[:, 1], label=("P(coin=tails)"))
d2l.plt.axhline(y=0.5, color='black', linestyle='dashed')
d2l.plt.gca().set_xlabel('Samples')
d2l.plt.gca().set_ylabel('Estimated probability')
d2l.plt.legend();
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
counts = multinomial(1, fair_probs, size=10000)
cum_counts = counts.astype(np.float32).cumsum(axis=0)
estimates = cum_counts / cum_counts.sum(axis=1, keepdims=True)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
counts = tfd.Multinomial(1, fair_probs).sample(10000)
cum_counts = tf.cumsum(counts, axis=0)
estimates = cum_counts / tf.reduce_sum(cum_counts, axis=1, keepdims=True)
estimates = estimates.numpy()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
counts = np.random.multinomial(1, fair_probs, size=10000).astype(np.float32)
cum_counts = counts.cumsum(axis=0)
estimates = cum_counts / cum_counts.sum(axis=1, keepdims=True)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow, jax
d2l.set_figsize((4.5, 3.5))
d2l.plt.plot(estimates[:, 0], label=("P(coin=heads)"))
d2l.plt.plot(estimates[:, 1], label=("P(coin=tails)"))
d2l.plt.axhline(y=0.5, color='black', linestyle='dashed')
d2l.plt.gca().set_xlabel('Samples')
d2l.plt.gca().set_ylabel('Estimated probability')
d2l.plt.legend();
</code></pre>
<p>Each solid curve corresponds to one of the two values of the coin
and gives our estimated probability that the coin turns up that value
after each group of experiments.
The dashed black line gives the true underlying probability.
As we get more data by conducting more experiments,
the curves converge towards the true probability.
You might already begin to see the shape
of some of the more advanced questions
that preoccupy statisticians:
How quickly does this convergence happen?
If we had already tested many coins
manufactured at the same plant,
how might we incorporate this information?</p>
<h2 id="a-more-formal-treatment"><a class="header" href="#a-more-formal-treatment">A More Formal Treatment</a></h2>
<p>We have already gotten pretty far: posing
a probabilistic model,
generating synthetic data,
running a statistical estimator,
empirically assessing convergence,
and reporting error metrics (checking the deviation).
However, to go much further,
we will need to be more precise.</p>
<p>When dealing with randomness,
we denote the set of possible outcomes $\mathcal{S}$
and call it the <em>sample space</em> or <em>outcome space</em>.
Here, each element is a distinct possible <em>outcome</em>.
In the case of rolling a single coin,
$\mathcal{S} = {\textrm{heads}, \textrm{tails}}$.
For a single die, $\mathcal{S} = {1, 2, 3, 4, 5, 6}$.
When flipping two coins, possible outcomes are
${(\textrm{heads}, \textrm{heads}), (\textrm{heads}, \textrm{tails}), (\textrm{tails}, \textrm{heads}),  (\textrm{tails}, \textrm{tails})}$.
<em>Events</em> are subsets of the sample space.
For instance, the event "the first coin toss comes up heads"
corresponds to the set ${(\textrm{heads}, \textrm{heads}), (\textrm{heads}, \textrm{tails})}$.
Whenever the outcome $z$ of a random experiment satisfies
$z \in \mathcal{A}$, then event $\mathcal{A}$ has occurred.
For a single roll of a die, we could define the events
"seeing a $5$" ($\mathcal{A} = {5}$)
and "seeing an odd number"  ($\mathcal{B} = {1, 3, 5}$).
In this case, if the die came up $5$,
we would say that both $\mathcal{A}$ and $\mathcal{B}$ occurred.
On the other hand, if $z = 3$,
then $\mathcal{A}$ did not occur
but $\mathcal{B}$ did.</p>
<p>A <em>probability</em> function maps events
onto real values ${P: \mathcal{A} \subseteq \mathcal{S} \rightarrow [0,1]}$.
The probability, denoted $P(\mathcal{A})$, of an event $\mathcal{A}$
in the given sample space $\mathcal{S}$,
has the following properties:</p>
<ul>
<li>The probability of any event $\mathcal{A}$ is a nonnegative real number, i.e., $P(\mathcal{A}) \geq 0$;</li>
<li>The probability of the entire sample space is $1$, i.e., $P(\mathcal{S}) = 1$;</li>
<li>For any countable sequence of events $\mathcal{A}_1, \mathcal{A}_2, \ldots$ that are <em>mutually exclusive</em> (i.e., $\mathcal{A}_i \cap \mathcal{A}<em>j = \emptyset$ for all $i \neq j$), the probability that any of them happens is equal to the sum of their individual probabilities, i.e., $P(\bigcup</em>{i=1}^{\infty} \mathcal{A}<em>i) = \sum</em>{i=1}^{\infty} P(\mathcal{A}_i)$.</li>
</ul>
<p>These axioms of probability theory,
proposed by :citet:<code>Kolmogorov.1933</code>,
can be applied to rapidly derive a number of important consequences.
For instance, it follows immediately
that the probability of any event $\mathcal{A}$
<em>or</em> its complement $\mathcal{A}'$ occurring is 1
(because $\mathcal{A} \cup \mathcal{A}' = \mathcal{S}$).
We can also prove that $P(\emptyset) = 0$
because $1 = P(\mathcal{S} \cup \mathcal{S}') = P(\mathcal{S} \cup \emptyset) = P(\mathcal{S}) + P(\emptyset) = 1 + P(\emptyset)$.
Consequently, the probability of any event $\mathcal{A}$
<em>and</em> its complement $\mathcal{A}'$ occurring simultaneously
is $P(\mathcal{A} \cap \mathcal{A}') = 0$.
Informally, this tells us that impossible events
have zero probability of occurring.</p>
<h2 id="random-variables"><a class="header" href="#random-variables">Random Variables</a></h2>
<p>When we spoke about events like the roll of a die
coming up odds or the first coin toss coming up heads,
we were invoking the idea of a <em>random variable</em>.
Formally, random variables are mappings
from an underlying sample space
to a set of (possibly many) values.
You might wonder how a random variable
is different from the sample space,
since both are collections of outcomes.
Importantly, random variables can be much coarser
than the raw sample space.
We can define a binary random variable like "greater than 0.5"
even when the underlying sample space is infinite,
e.g., points on the line segment between $0$ and $1$.
Additionally, multiple random variables
can share the same underlying sample space.
For example "whether my home alarm goes off"
and "whether my house was burgled"
are both binary random variables
that share an underlying sample space.
Consequently, knowing the value taken by one random variable
can tell us something about the likely value of another random variable.
Knowing that the alarm went off,
we might suspect that the house was likely burgled.</p>
<p>Every value taken by a random variable corresponds
to a subset of the underlying sample space.
Thus the occurrence where the random variable $X$
takes value $v$, denoted by $X=v$, is an <em>event</em>
and $P(X=v)$ denotes its probability.
Sometimes this notation can get clunky,
and we can abuse notation when the context is clear.
For example, we might use $P(X)$ to refer broadly
to the <em>distribution</em> of $X$, i.e.,
the function that tells us the probability
that $X$ takes any given value.
Other times we write expressions
like $P(X,Y) = P(X) P(Y)$,
as a shorthand to express a statement
that is true for all of the values
that the random variables $X$ and $Y$ can take, i.e.,
for all $i,j$ it holds that $P(X=i \textrm{ and } Y=j) = P(X=i)P(Y=j)$.
Other times, we abuse notation by writing
$P(v)$ when the random variable is clear from the context.
Since an event in probability theory is a set of outcomes from the sample space,
we can specify a range of values for a random variable to take.
For example, $P(1 \leq X \leq 3)$ denotes the probability of the event ${1 \leq X \leq 3}$.</p>
<p>Note that there is a subtle difference
between <em>discrete</em> random variables,
like flips of a coin or tosses of a die,
and <em>continuous</em> ones,
like the weight and the height of a person
sampled at random from the population.
In this case we seldom really care about
someone's exact height.
Moreover, if we took precise enough measurements,
we would find that no two people on the planet
have the exact same height.
In fact, with fine enough measurements,
you would never have the same height
when you wake up and when you go to sleep.
There is little point in asking about
the exact probability that someone
is 1.801392782910287192 meters tall.
Instead, we typically care more about being able to say
whether someone's height falls into a given interval,
say between 1.79 and 1.81 meters.
In these cases we work with probability <em>densities</em>.
The height of exactly 1.80 meters
has no probability, but nonzero density.
To work out the probability assigned to an interval,
we must take an <em>integral</em> of the density
over that interval.</p>
<h2 id="multiple-random-variables"><a class="header" href="#multiple-random-variables">Multiple Random Variables</a></h2>
<p>You might have noticed that we could not even
make it through the previous section without
making statements involving interactions
among multiple random variables
(recall that $P(X,Y) = P(X) P(Y)$).
Most of machine learning
is concerned with such relationships.
Here, the sample space would be
the population of interest,
say customers who transact with a business,
photographs on the Internet,
or proteins known to biologists.
Each random variable would represent
the (unknown) value of a different attribute.
Whenever we sample an individual from the population,
we observe a realization of each of the random variables.
Because the values taken by random variables
correspond to subsets of the sample space
that could be overlapping, partially overlapping,
or entirely disjoint,
knowing the value taken by one random variable
can cause us to update our beliefs
about which values of another random variable are likely.
If a patient walks into a hospital
and we observe that they
are having trouble breathing
and have lost their sense of smell,
then we believe that they are more likely
to have COVID-19 than we might
if they had no trouble breathing
and a perfectly ordinary sense of smell.</p>
<p>When working with multiple random variables,
we can construct events corresponding
to every combination of values
that the variables can jointly take.
The probability function that assigns
probabilities to each of these combinations
(e.g. $A=a$ and $B=b$)
is called the <em>joint probability</em> function
and simply returns the probability assigned
to the intersection of the corresponding subsets
of the sample space.
The <em>joint probability</em> assigned to the event
where random variables $A$ and $B$
take values $a$ and $b$, respectively,
is denoted $P(A = a, B = b)$,
where the comma indicates "and".
Note that for any values $a$ and $b$,
it follows that</p>
<p>$$P(A=a, B=b) \leq P(A=a) \textrm{ and } P(A=a, B=b) \leq P(B = b),$$</p>
<p>since for $A=a$ and $B=b$ to happen,
$A=a$ has to happen <em>and</em> $B=b$ also has to happen.
Interestingly, the joint probability
tells us all that we can know about these
random variables in a probabilistic sense,
and can be used to derive many other
useful quantities, including recovering the
individual distributions $P(A)$ and $P(B)$.
To recover $P(A=a)$ we simply sum up
$P(A=a, B=v)$ over all values $v$
that the random variable $B$ can take:
$P(A=a) = \sum_v P(A=a, B=v)$.</p>
<p>The ratio $\frac{P(A=a, B=b)}{P(A=a)} \leq 1$
turns out to be extremely important.
It is called the <em>conditional probability</em>,
and is denoted via the "$\mid$" symbol:</p>
<p>$$P(B=b \mid A=a) = P(A=a,B=b)/P(A=a).$$</p>
<p>It tells us the new probability
associated with the event $B=b$,
once we condition on the fact $A=a$ took place.
We can think of this conditional probability
as restricting attention only to the subset
of the sample space associated with $A=a$
and then renormalizing so that
all probabilities sum to 1.
Conditional probabilities
are in fact just ordinary probabilities
and thus respect all of the axioms,
as long as we condition all terms
on the same event and thus
restrict attention to the same sample space.
For instance, for disjoint events
$\mathcal{B}$ and $\mathcal{B}'$, we have that
$P(\mathcal{B} \cup \mathcal{B}' \mid A = a) = P(\mathcal{B} \mid A = a) + P(\mathcal{B}' \mid A = a)$.</p>
<p>Using the definition of conditional probabilities,
we can derive the famous result called <em>Bayes' theorem</em>.
By construction, we have that $P(A, B) = P(B\mid A) P(A)$
and $P(A, B) = P(A\mid B) P(B)$.
Combining both equations yields
$P(B\mid A) P(A) = P(A\mid B) P(B)$ and hence</p>
<p>$$P(A \mid B) = \frac{P(B\mid A) P(A)}{P(B)}.$$</p>
<p>This simple equation has profound implications because
it allows us to reverse the order of conditioning.
If we know how to estimate $P(B\mid A)$, $P(A)$, and $P(B)$,
then we can estimate $P(A\mid B)$.
We often find it easier to estimate one term directly
but not the other and Bayes' theorem can come to the rescue here.
For instance, if we know the prevalence of symptoms for a given disease,
and the overall prevalences of the disease and symptoms, respectively,
we can determine how likely someone is
to have the disease based on their symptoms.
In some cases we might not have direct access to $P(B)$,
such as the prevalence of symptoms.
In this case a simplified version of Bayes' theorem comes in handy:</p>
<p>$$P(A \mid B) \propto P(B \mid A) P(A).$$</p>
<p>Since we know that $P(A \mid B)$ must be normalized to $1$, i.e., $\sum_a P(A=a \mid B) = 1$,
we can use it to compute</p>
<p>$$P(A \mid B) = \frac{P(B \mid A) P(A)}{\sum_a P(B \mid A=a) P(A = a)}.$$</p>
<p>In Bayesian statistics, we think of an observer
as possessing some (subjective) prior beliefs
about the plausibility of the available hypotheses
encoded in the <em>prior</em> $P(H)$,
and a <em>likelihood function</em> that says how likely
one is to observe any value of the collected evidence
for each of the hypotheses in the class $P(E \mid H)$.
Bayes' theorem is then interpreted as telling us
how to update the initial <em>prior</em> $P(H)$
in light of the available evidence $E$
to produce <em>posterior</em> beliefs
$P(H \mid E) = \frac{P(E \mid H) P(H)}{P(E)}$.
Informally, this can be stated as
"posterior equals prior times likelihood, divided by the evidence".
Now, because the evidence $P(E)$ is the same for all hypotheses,
we can get away with simply normalizing over the hypotheses.</p>
<p>Note that $\sum_a P(A=a \mid B) = 1$ also allows us to <em>marginalize</em> over random variables. That is, we can drop variables from a joint distribution such as $P(A, B)$. After all, we have that</p>
<p>$$\sum_a P(B \mid A=a) P(A=a) = \sum_a P(B, A=a) = P(B).$$</p>
<p>Independence is another fundamentally important concept
that forms the backbone of
many important ideas in statistics.
In short, two variables are <em>independent</em>
if conditioning on the value of $A$ does not
cause any change to the probability distribution
associated with $B$ and vice versa.
More formally, independence, denoted $A \perp B$,
requires that $P(A \mid B) = P(A)$ and, consequently,
that $P(A,B) = P(A \mid B) P(B) = P(A) P(B)$.
Independence is often an appropriate assumption.
For example, if the random variable $A$
represents the outcome from tossing one fair coin
and the random variable $B$
represents the outcome from tossing another,
then knowing whether $A$ came up heads
should not influence the probability
of $B$ coming up heads.</p>
<p>Independence is especially useful when it holds among the successive
draws of our data from some underlying distribution
(allowing us to make strong statistical conclusions)
or when it holds among various variables in our data,
allowing us to work with simpler models
that encode this independence structure.
On the other hand, estimating the dependencies
among random variables is often the very aim of learning.
We care to estimate the probability of disease given symptoms
specifically because we believe
that diseases and symptoms are <em>not</em> independent.</p>
<p>Note that because conditional probabilities are proper probabilities,
the concepts of independence and dependence also apply to them.
Two random variables $A$ and $B$ are <em>conditionally independent</em>
given a third variable $C$ if and only if $P(A, B \mid C) = P(A \mid C)P(B \mid C)$.
Interestingly, two variables can be independent in general
but become dependent when conditioning on a third.
This often occurs when the two random variables $A$ and $B$
correspond to causes of some third variable $C$.
For example, broken bones and lung cancer might be independent
in the general population but if we condition on being in the hospital
then we might find that broken bones are negatively correlated with lung cancer.
That is because the broken bone <em>explains away</em> why some person is in the hospital
and thus lowers the probability that they are hospitalized because of having lung cancer.</p>
<p>And conversely, two dependent random variables
can become independent upon conditioning on a third.
This often happens when two otherwise unrelated events
have a common cause.
Shoe size and reading level are highly correlated
among elementary school students,
but this correlation disappears if we condition on age.</p>
<h2 id="an-example"><a class="header" href="#an-example">An Example</a></h2>
<p>:label:<code>subsec_probability_hiv_app</code></p>
<p>Let's put our skills to the test.
Assume that a doctor administers an HIV test to a patient.
This test is fairly accurate and fails only with 1% probability
if the patient is healthy but reported as diseased,
i.e., healthy patients test positive in 1% of cases.
Moreover, it never fails to detect HIV if the patient actually has it.
We use $D_1 \in {0, 1}$ to indicate the diagnosis
($0$ if negative and $1$ if positive)
and $H \in {0, 1}$ to denote the HIV status.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Conditional probability</th><th style="text-align: right">$H=1$</th><th style="text-align: right">$H=0$</th></tr></thead><tbody>
<tr><td style="text-align: left">$P(D_1 = 1 \mid H)$</td><td style="text-align: right">1</td><td style="text-align: right">0.01</td></tr>
<tr><td style="text-align: left">$P(D_1 = 0 \mid H)$</td><td style="text-align: right">0</td><td style="text-align: right">0.99</td></tr>
</tbody></table>
</div>
<p>Note that the column sums are all 1 (but the row sums do not),
since they are conditional probabilities.
Let's compute the probability of the patient having HIV
if the test comes back positive, i.e., $P(H = 1 \mid D_1 = 1)$.
Intuitively this is going to depend on how common the disease is,
since it affects the number of false alarms.
Assume that the population is fairly free of the disease, e.g., $P(H=1) = 0.0015$.
To apply Bayes' theorem, we need to apply marginalization
to determine</p>
<p>$$\begin{aligned}
P(D_1 = 1)
=&amp; P(D_1=1, H=0) + P(D_1=1, H=1)  \
=&amp; P(D_1=1 \mid H=0) P(H=0) + P(D_1=1 \mid H=1) P(H=1) \
=&amp; 0.011485.
\end{aligned}
$$</p>
<p>This leads us to</p>
<p>$$P(H = 1 \mid D_1 = 1) = \frac{P(D_1=1 \mid H=1) P(H=1)}{P(D_1=1)} = 0.1306.$$</p>
<p>In other words, there is only a 13.06% chance
that the patient actually has HIV,
despite the test being pretty accurate.
As we can see, probability can be counterintuitive.
What should a patient do upon receiving such terrifying news?
Likely, the patient would ask the physician
to administer another test to get clarity.
The second test has different characteristics
and it is not as good as the first one.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Conditional probability</th><th style="text-align: right">$H=1$</th><th style="text-align: right">$H=0$</th></tr></thead><tbody>
<tr><td style="text-align: left">$P(D_2 = 1 \mid H)$</td><td style="text-align: right">0.98</td><td style="text-align: right">0.03</td></tr>
<tr><td style="text-align: left">$P(D_2 = 0 \mid H)$</td><td style="text-align: right">0.02</td><td style="text-align: right">0.97</td></tr>
</tbody></table>
</div>
<p>Unfortunately, the second test comes back positive, too.
Let's calculate the requisite probabilities to invoke Bayes' theorem
by assuming conditional independence:</p>
<p>$$\begin{aligned}
P(D_1 = 1, D_2 = 1 \mid H = 0)
&amp; = P(D_1 = 1 \mid H = 0) P(D_2 = 1 \mid H = 0)
=&amp; 0.0003, \
P(D_1 = 1, D_2 = 1 \mid H = 1)
&amp; = P(D_1 = 1 \mid H = 1) P(D_2 = 1 \mid H = 1)
=&amp; 0.98.
\end{aligned}
$$</p>
<p>Now we can apply marginalization to obtain the probability
that both tests come back positive:</p>
<p>$$\begin{aligned}
&amp;P(D_1 = 1, D_2 = 1)\
&amp;= P(D_1 = 1, D_2 = 1, H = 0) + P(D_1 = 1, D_2 = 1, H = 1)  \
&amp;= P(D_1 = 1, D_2 = 1 \mid H = 0)P(H=0) + P(D_1 = 1, D_2 = 1 \mid H = 1)P(H=1)\
&amp;= 0.00176955.
\end{aligned}
$$</p>
<p>Finally, the probability of the patient having HIV given that both tests are positive is</p>
<p>$$P(H = 1 \mid D_1 = 1, D_2 = 1)
= \frac{P(D_1 = 1, D_2 = 1 \mid H=1) P(H=1)}{P(D_1 = 1, D_2 = 1)}
= 0.8307.$$</p>
<p>That is, the second test allowed us to gain much higher confidence that not all is well.
Despite the second test being considerably less accurate than the first one,
it still significantly improved our estimate.
The assumption of both tests being conditionally independent of each other
was crucial for our ability to generate a more accurate estimate.
Take the extreme case where we run the same test twice.
In this situation we would expect the same outcome both times,
hence no additional insight is gained from running the same test again.
The astute reader might have noticed that the diagnosis behaved
like a classifier hiding in plain sight
where our ability to decide whether a patient is healthy
increases as we obtain more features (test outcomes).</p>
<h2 id="expectations"><a class="header" href="#expectations">Expectations</a></h2>
<p>Often, making decisions requires not just looking
at the probabilities assigned to individual events
but composing them together into useful aggregates
that can provide us with guidance.
For example, when random variables take continuous scalar values,
we often care about knowing what value to expect <em>on average</em>.
This quantity is formally called an <em>expectation</em>.
If we are making investments,
the first quantity of interest
might be the return we can expect,
averaging over all the possible outcomes
(and weighting by the appropriate probabilities).
For instance, say that with 50% probability,
an investment might fail altogether,
with 40% probability it might provide a 2$\times$ return,
and with 10% probability it might provide a 10$\times$ return 10$\times$.
To calculate the expected return,
we sum over all returns, multiplying each
by the probability that they will occur.
This yields the expectation
$0.5 \cdot 0 + 0.4 \cdot 2 + 0.1 \cdot 10 = 1.8$.
Hence the expected return is 1.8$\times$.</p>
<p>In general, the <em>expectation</em> (or average)
of the random variable $X$ is defined as</p>
<p>$$E[X] = E_{x \sim P}[x] = \sum_{x} x P(X = x).$$</p>
<p>Likewise, for densities we obtain $E[X] = \int x ;dp(x)$.
Sometimes we are interested in the expected value
of some function of $x$.
We can calculate these expectations as</p>
<p>$$E_{x \sim P}[f(x)] = \sum_x f(x) P(x) \textrm{ and } E_{x \sim P}[f(x)] = \int f(x) p(x) ;dx$$</p>
<p>for discrete probabilities and densities, respectively.
Returning to the investment example from above,
$f$ might be the <em>utility</em> (happiness)
associated with the return.
Behavior economists have long noted
that people associate greater disutility
with losing money than the utility gained
from earning one dollar relative to their baseline.
Moreover, the value of money tends to be sub-linear.
Possessing 100k dollars versus zero dollars
can make the difference between paying the rent,
eating well, and enjoying quality healthcare
versus suffering through homelessness.
On the other hand, the gains due to possessing
200k versus 100k are less dramatic.
Reasoning like this motivates the cliché
that "the utility of money is logarithmic".</p>
<p>If  the utility associated with a total loss were $-1$,
and the utilities associated with returns of $1$, $2$, and $10$
were $1$, $2$ and $4$, respectively,
then the expected happiness of investing
would be $0.5 \cdot (-1) + 0.4 \cdot 2 + 0.1 \cdot 4 = 0.7$
(an expected loss of utility of 30%).
If indeed this were your utility function,
you might be best off keeping the money in the bank.</p>
<p>For financial decisions,
we might also want to measure
how <em>risky</em> an investment is.
Here, we care not just about the expected value
but how much the actual values tend to <em>vary</em>
relative to this value.
Note that we cannot just take
the expectation of the difference
between the actual and expected values.
This is because the expectation of a difference
is the difference of the expectations,
i.e., $E[X - E[X]] = E[X] - E[E[X]] = 0$.
However, we can look at the expectation
of any non-negative function of this difference.
The <em>variance</em> of a random variable is calculated by looking
at the expected value of the <em>squared</em> differences:</p>
<p>$$\textrm{Var}[X] = E\left[(X - E[X])^2\right] = E[X^2] - E[X]^2.$$</p>
<p>Here the equality follows by expanding
$(X - E[X])^2 = X^2 - 2 X E[X] + E[X]^2$
and taking expectations for each term.
The square root of the variance is another
useful quantity called the <em>standard deviation</em>.
While this and the variance
convey the same information (either can be calculated from the other),
the standard deviation has the nice property
that it is expressed in the same units
as the original quantity represented
by the random variable.</p>
<p>Lastly, the variance of a function
of a random variable
is defined analogously as</p>
<p>$$\textrm{Var}<em>{x \sim P}[f(x)] = E</em>{x \sim P}[f^2(x)] - E_{x \sim P}[f(x)]^2.$$</p>
<p>Returning to our investment example,
we can now compute the variance of the investment.
It is given by $0.5 \cdot 0 + 0.4 \cdot 2^2 + 0.1 \cdot 10^2 - 1.8^2 = 8.36$.
For all intents and purposes this is a risky investment.
Note that by mathematical convention mean and variance
are often referenced as $\mu$ and $\sigma^2$.
This is particularly the case whenever we use it
to parametrize a Gaussian distribution.</p>
<p>In the same way as we introduced expectations
and variance for <em>scalar</em> random variables,
we can do so for vector-valued ones.
Expectations are easy, since we can apply them elementwise.
For instance, $\boldsymbol{\mu} \stackrel{\textrm{def}}{=} E_{\mathbf{x} \sim P}[\mathbf{x}]$
has coordinates $\mu_i = E_{\mathbf{x} \sim P}[x_i]$.
<em>Covariances</em> are more complicated.
We define them by taking expectations of the <em>outer product</em>
of the difference between random variables and their mean:</p>
<p>$$\boldsymbol{\Sigma} \stackrel{\textrm{def}}{=} \textrm{Cov}<em>{\mathbf{x} \sim P}[\mathbf{x}] = E</em>{\mathbf{x} \sim P}\left[(\mathbf{x} - \boldsymbol{\mu}) (\mathbf{x} - \boldsymbol{\mu})^\top\right].$$</p>
<p>This matrix $\boldsymbol{\Sigma}$ is referred to as the covariance matrix.
An easy way to see its effect is to consider some vector $\mathbf{v}$
of the same size as $\mathbf{x}$.
It follows that</p>
<p>$$\mathbf{v}^\top \boldsymbol{\Sigma} \mathbf{v} = E_{\mathbf{x} \sim P}\left[\mathbf{v}^\top(\mathbf{x} - \boldsymbol{\mu}) (\mathbf{x} - \boldsymbol{\mu})^\top \mathbf{v}\right] = \textrm{Var}_{x \sim P}[\mathbf{v}^\top \mathbf{x}].$$</p>
<p>As such, $\boldsymbol{\Sigma}$ allows us to compute the variance
for any linear function of $\mathbf{x}$
by a simple matrix multiplication.
The off-diagonal elements tell us how correlated the coordinates are:
a value of 0 means no correlation,
where a larger positive value
means that they are more strongly correlated.</p>
<h2 id="discussion-4"><a class="header" href="#discussion-4">Discussion</a></h2>
<p>In machine learning, there are many things to be uncertain about!
We can be uncertain about the value of a label given an input.
We can be uncertain about the estimated value of a parameter.
We can even be uncertain about whether data arriving at deployment
is even from the same distribution as the training data.</p>
<p>By <em>aleatoric uncertainty</em>, we mean uncertainty
that is intrinsic to the problem,
and due to genuine randomness
unaccounted for by the observed variables.
By <em>epistemic uncertainty</em>, we mean uncertainty
over a model's parameters, the sort of uncertainty
that we can hope to reduce by collecting more data.
We might have epistemic uncertainty
concerning the probability
that a coin turns up heads,
but even once we know this probability,
we are left with aleatoric uncertainty
about the outcome of any future toss.
No matter how long we watch someone tossing a fair coin,
we will never be more or less than 50% certain
that the next toss will come up heads.
These terms come from mechanical modeling,
(see e.g., :citet:<code>Der-Kiureghian.Ditlevsen.2009</code> for a review on this aspect of <a href="https://en.wikipedia.org/wiki/Uncertainty_quantification">uncertainty quantification</a>).
It is worth noting, however, that these terms constitute a slight abuse of language.
The term <em>epistemic</em> refers to anything concerning <em>knowledge</em>
and thus, in the philosophical sense, all uncertainty is epistemic.</p>
<p>We saw that sampling data from some unknown probability distribution
can provide us with information that can be used to estimate
the parameters of the data generating distribution.
That said, the rate at which this is possible can be quite slow.
In our coin tossing example (and many others)
we can do no better than to design estimators
that converge at a rate of $1/\sqrt{n}$,
where $n$ is the sample size (e.g., the number of tosses).
This means that by going from 10 to 1000 observations (usually a very achievable task)
we see a tenfold reduction of uncertainty,
whereas the next 1000 observations help comparatively little,
offering only a 1.41 times reduction.
This is a persistent feature of machine learning:
while there are often easy gains, it takes a very large amount of data,
and often with it an enormous amount of computation, to make further gains.
For an empirical review of this fact for large scale language models see :citet:<code>Revels.Lubin.Papamarkou.2016</code>.</p>
<p>We also sharpened our language and tools for statistical modeling.
In the process of that we learned about conditional probabilities
and about one of the most important equations in statistics---Bayes' theorem.
It is an effective tool for decoupling information conveyed by data
through a likelihood term $P(B \mid A)$ that addresses
how well observations $B$ match a choice of parameters $A$,
and a prior probability $P(A)$ which governs how plausible
a particular choice of $A$ was in the first place.
In particular, we saw how this rule can be applied
to assign probabilities to diagnoses,
based on the efficacy of the test <em>and</em>
the prevalence of the disease itself (i.e., our prior).</p>
<p>Lastly, we introduced a first set of nontrivial questions
about the effect of a specific probability distribution,
namely expectations and variances.
While there are many more than just linear and quadratic
expectations for a probability distribution,
these two already provide a good deal of knowledge
about the possible behavior of the distribution.
For instance, <a href="https://en.wikipedia.org/wiki/Chebyshev%27s_inequality">Chebyshev's inequality</a>
states that $P(|X - \mu| \geq k \sigma) \leq 1/k^2$,
where $\mu$ is the expectation, $\sigma^2$ is the variance of the distribution,
and $k &gt; 1$ is a confidence parameter of our choosing.
It tells us that draws from a distribution lie
with at least 50% probability
within a $[-\sqrt{2} \sigma, \sqrt{2} \sigma]$
interval centered on the expectation.</p>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<ol>
<li>Give an example where observing more data can reduce the amount of uncertainty about the outcome to an arbitrarily low level.</li>
<li>Give an example where observing more data will only reduce the amount of uncertainty up to a point and then no further. Explain why this is the case and where you expect this point to occur.</li>
<li>We empirically demonstrated convergence to the mean for the toss of a coin. Calculate the variance of the estimate of the probability that we see a head after drawing $n$ samples.
<ol>
<li>How does the variance scale with the number of observations?</li>
<li>Use Chebyshev's inequality to bound the deviation from the expectation.</li>
<li>How does it relate to the central limit theorem?</li>
</ol>
</li>
<li>Assume that we draw $m$ samples $x_i$ from a probability distribution with zero mean and unit variance. Compute the averages $z_m \stackrel{\textrm{def}}{=} m^{-1} \sum_{i=1}^m x_i$. Can we apply Chebyshev's inequality for every $z_m$ independently? Why not?</li>
<li>Given two events with probability $P(\mathcal{A})$ and $P(\mathcal{B})$, compute upper and lower bounds on $P(\mathcal{A} \cup \mathcal{B})$ and $P(\mathcal{A} \cap \mathcal{B})$. Hint: graph the situation using a <a href="https://en.wikipedia.org/wiki/Venn_diagram">Venn diagram</a>.</li>
<li>Assume that we have a sequence of random variables, say $A$, $B$, and $C$, where $B$ only depends on $A$, and $C$ only depends on $B$, can you simplify the joint probability $P(A, B, C)$? Hint: this is a <a href="https://en.wikipedia.org/wiki/Markov_chain">Markov chain</a>.</li>
<li>In :numref:<code>subsec_probability_hiv_app</code>, assume that the outcomes of the two tests are not independent. In particular assume that either test on its own has a false positive rate of 10% and a false negative rate of 1%. That is, assume that $P(D =1 \mid H=0) = 0.1$ and that $P(D = 0 \mid H=1) = 0.01$. Moreover, assume that for $H = 1$ (infected) the test outcomes are conditionally independent, i.e., that $P(D_1, D_2 \mid H=1) = P(D_1 \mid H=1) P(D_2 \mid H=1)$ but that for healthy patients the outcomes are coupled via $P(D_1 = D_2 = 1 \mid H=0) = 0.02$.
<ol>
<li>Work out the joint probability table for $D_1$ and $D_2$, given $H=0$ based on the information you have so far.</li>
<li>Derive the probability that the patient is diseased ($H=1$) after one test returns positive. You can assume the same baseline probability $P(H=1) = 0.0015$ as before.</li>
<li>Derive the probability that the patient is diseased ($H=1$) after both tests return positive.</li>
</ol>
</li>
<li>Assume that you are an asset manager for an investment bank and you have a choice of stocks $s_i$ to invest in. Your portfolio needs to add up to $1$ with weights $\alpha_i$ for each stock. The stocks have an average return $\boldsymbol{\mu} = E_{\mathbf{s} \sim P}[\mathbf{s}]$ and covariance $\boldsymbol{\Sigma} = \textrm{Cov}_{\mathbf{s} \sim P}[\mathbf{s}]$.
<ol>
<li>Compute the expected return for a given portfolio $\boldsymbol{\alpha}$.</li>
<li>If you wanted to maximize the return of the portfolio, how should you choose your investment?</li>
<li>Compute the <em>variance</em> of the portfolio.</li>
<li>Formulate an optimization problem of maximizing the return while keeping the variance constrained to an upper bound. This is the Nobel-Prize winning <a href="https://en.wikipedia.org/wiki/Markowitz_model">Markovitz portfolio</a> :cite:<code>Mangram.2013</code>. To solve it you will need a quadratic programming solver, something way beyond the scope of this book.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/36">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/37">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/198">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17971">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>:begin_tab:<code>mxnet</code>
While we cannot possibly introduce every single MXNet function and class
(and the information might become outdated quickly),
the <a href="https://mxnet.apache.org/versions/1.8.0/api">API documentation</a>
and additional <a href="https://mxnet.apache.org/versions/1.8.0/api/python/docs/tutorials/">tutorials</a> and examples
provide such documentation.
This section provides some guidance for how to explore the MXNet API.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
While we cannot possibly introduce every single PyTorch function and class
(and the information might become outdated quickly),
the <a href="https://pytorch.org/docs/stable/index.html">API documentation</a> and additional <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">tutorials</a> and examples
provide such documentation.
This section provides some guidance for how to explore the PyTorch API.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
While we cannot possibly introduce every single TensorFlow function and class
(and the information might become outdated quickly),
the <a href="https://www.tensorflow.org/api_docs">API documentation</a> and additional <a href="https://www.tensorflow.org/tutorials">tutorials</a> and examples
provide such documentation.
This section provides some guidance for how to explore the TensorFlow API.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import jax
</code></pre>
<h2 id="functions-and-classes-in-a-module"><a class="header" href="#functions-and-classes-in-a-module">Functions and Classes in a Module</a></h2>
<p>To know which functions and classes can be called in a module,
we invoke the <code>dir</code> function. For instance, we can
(<strong>query all properties in the module for generating random numbers</strong>):</p>
<pre><code class="language-{.python .input  n=1}">%%tab mxnet
print(dir(np.random))
</code></pre>
<pre><code class="language-{.python .input  n=1}">%%tab pytorch
print(dir(torch.distributions))
</code></pre>
<pre><code class="language-{.python .input  n=1}">%%tab tensorflow
print(dir(tf.random))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
print(dir(jax.random))
</code></pre>
<p>Generally, we can ignore functions that start and end with <code>__</code> (special objects in Python)
or functions that start with a single <code>_</code>(usually internal functions).
Based on the remaining function or attribute names,
we might hazard a guess that this module offers
various methods for generating random numbers,
including sampling from the uniform distribution (<code>uniform</code>),
normal distribution (<code>normal</code>), and multinomial distribution (<code>multinomial</code>).</p>
<h2 id="specific-functions-and-classes"><a class="header" href="#specific-functions-and-classes">Specific Functions and Classes</a></h2>
<p>For specific instructions on how to use a given function or class,
we can invoke the  <code>help</code> function. As an example, let's
[<strong>explore the usage instructions for tensors' <code>ones</code> function</strong>].</p>
<pre><code class="language-{.python .input}">%%tab mxnet
help(np.ones)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
help(torch.ones)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
help(tf.ones)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
help(jax.numpy.ones)
</code></pre>
<p>From the documentation, we can see that the <code>ones</code> function
creates a new tensor with the specified shape
and sets all the elements to the value of 1.
Whenever possible, you should (<strong>run a quick test</strong>)
to confirm your interpretation:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
np.ones(4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.ones(4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.ones(4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jax.numpy.ones(4)
</code></pre>
<p>In the Jupyter notebook, we can use <code>?</code> to display the document in another
window. For example, <code>list?</code> will create content
that is almost identical to <code>help(list)</code>,
displaying it in a new browser window.
In addition, if we use two question marks, such as <code>list??</code>,
the Python code implementing the function will also be displayed.</p>
<p>The official documentation provides plenty of descriptions and examples that are beyond this book.
We emphasize important use cases
that will get you started quickly with practical problems,
rather than completeness of coverage.
We also encourage you to study the source code of the libraries
to see examples of high-quality implementations of production code.
By doing this you will become a better engineer
in addition to becoming a better scientist.</p>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/38">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/39">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/199">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17972">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-neural-networks-for-regression"><a class="header" href="#linear-neural-networks-for-regression">Linear Neural Networks for Regression</a></h1>
<p>:label:<code>chap_regression</code></p>
<p>Before we worry about making our neural networks deep,
it will be helpful to implement some shallow ones,
for which the inputs connect directly to the outputs.
This will prove important for a few reasons.
First, rather than getting distracted by complicated architectures,
we can focus on the basics of neural network training,
including parametrizing the output layer, handling data,
specifying a loss function, and training the model.
Second, this class of shallow networks happens
to comprise the set of linear models,
which subsumes many classical methods of statistical prediction,
including linear and softmax regression.
Understanding these classical tools is pivotal
because they are widely used in many contexts
and we will often need to use them as baselines
when justifying the use of fancier architectures.
This chapter will focus narrowly on linear regression
and the next one will extend our modeling repertoire
by developing linear neural networks for classification.</p>
<pre><code class="language-toc">:maxdepth: 2

linear-regression
oo-design
synthetic-regression-data
linear-regression-scratch
linear-regression-concise
generalization
weight-decay
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="linear-regression"><a class="header" href="#linear-regression">Linear Regression</a></h1>
<p>:label:<code>sec_linear_regression</code></p>
<p><em>Regression</em> problems pop up whenever we want to predict a numerical value.
Common examples include predicting prices (of homes, stocks, etc.),
predicting the length of stay (for patients in the hospital),
forecasting demand (for retail sales), among numerous others.
Not every prediction problem is one of classical regression.
Later on, we will introduce classification problems,
where the goal is to predict membership among a set of categories.</p>
<p>As a running example, suppose that we wish
to estimate the prices of houses (in dollars)
based on their area (in square feet) and age (in years).
To develop a model for predicting house prices,
we need to get our hands on data,
including the sales price, area, and age for each home.
In the terminology of machine learning,
the dataset is called a <em>training dataset</em> or <em>training set</em>,
and each row (containing the data corresponding to one sale)
is called an <em>example</em> (or <em>data point</em>, <em>instance</em>, <em>sample</em>).
The thing we are trying to predict (price)
is called a <em>label</em> (or <em>target</em>).
The variables (age and area)
upon which the predictions are based
are called <em>features</em> (or <em>covariates</em>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import np
import time
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
import numpy as np
import time
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import math
import tensorflow as tf
import numpy as np
import time
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
from jax import numpy as jnp
import math
import time
</code></pre>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p><em>Linear regression</em> is both the simplest
and most popular among the standard tools
for tackling regression problems.
Dating back to the dawn of the 19th century :cite:<code>Legendre.1805,Gauss.1809</code>,
linear regression flows from a few simple assumptions.
First, we assume that the relationship
between features $\mathbf{x}$ and target $y$
is approximately linear,
i.e., that the conditional mean $E[Y \mid X=\mathbf{x}]$
can be expressed as a weighted sum
of the features $\mathbf{x}$.
This setup allows that the target value
may still deviate from its expected value
on account of observation noise.
Next, we can impose the assumption that any such noise
is well behaved, following a Gaussian distribution.
Typically, we will use $n$ to denote
the number of examples in our dataset.
We use superscripts to enumerate samples and targets,
and subscripts to index coordinates.
More concretely,
$\mathbf{x}^{(i)}$ denotes the $i^{\textrm{th}}$ sample
and $x_j^{(i)}$ denotes its $j^{\textrm{th}}$ coordinate.</p>
<h3 id="model"><a class="header" href="#model">Model</a></h3>
<p>:label:<code>subsec_linear_model</code></p>
<p>At the heart of every solution is a model
that describes how features can be transformed
into an estimate of the target.
The assumption of linearity means that
the expected value of the target (price) can be expressed
as a weighted sum of the features (area and age):</p>
<p>$$\textrm{price} = w_{\textrm{area}} \cdot \textrm{area} + w_{\textrm{age}} \cdot \textrm{age} + b.$$
:eqlabel:<code>eq_price-area</code></p>
<p>Here $w_{\textrm{area}}$ and $w_{\textrm{age}}$
are called <em>weights</em>, and $b$ is called a <em>bias</em>
(or <em>offset</em> or <em>intercept</em>).
The weights determine the influence of each feature on our prediction.
The bias determines the value of the estimate when all features are zero.
Even though we will never see any newly-built homes with precisely zero area,
we still need the bias because it allows us
to express all linear functions of our features
(rather than restricting us to lines that pass through the origin).
Strictly speaking, :eqref:<code>eq_price-area</code> is an <em>affine transformation</em> of input features, which is characterized by a <em>linear transformation</em> of features via a weighted sum, combined with a <em>translation</em> via the added bias.
Given a dataset, our goal is to choose
the weights $\mathbf{w}$ and the bias $b$
that, on average, make our model's predictions
fit the true prices observed in the data as closely as possible.</p>
<p>In disciplines where it is common to focus
on datasets with just a few features,
explicitly expressing models long-form,
as in :eqref:<code>eq_price-area</code>, is common.
In machine learning, we usually work
with high-dimensional datasets,
where it is more convenient to employ
compact linear algebra notation.
When our inputs consist of $d$ features,
we can assign each an index (between $1$ and $d$)
and express our prediction $\hat{y}$
(in general the "hat" symbol denotes an estimate) as</p>
<p>$$\hat{y} = w_1  x_1 + \cdots + w_d  x_d + b.$$</p>
<p>Collecting all features into a vector $\mathbf{x} \in \mathbb{R}^d$
and all weights into a vector $\mathbf{w} \in \mathbb{R}^d$,
we can express our model compactly via the dot product
between $\mathbf{w}$ and $\mathbf{x}$:</p>
<p>$$\hat{y} = \mathbf{w}^\top \mathbf{x} + b.$$
:eqlabel:<code>eq_linreg-y</code></p>
<p>In :eqref:<code>eq_linreg-y</code>, the vector $\mathbf{x}$
corresponds to the features of a single example.
We will often find it convenient
to refer to features of our entire dataset of $n$ examples
via the <em>design matrix</em> $\mathbf{X} \in \mathbb{R}^{n \times d}$.
Here, $\mathbf{X}$ contains one row for every example
and one column for every feature.
For a collection of features $\mathbf{X}$,
the predictions $\hat{\mathbf{y}} \in \mathbb{R}^n$
can be expressed via the matrix--vector product:</p>
<p>$${\hat{\mathbf{y}}} = \mathbf{X} \mathbf{w} + b,$$
:eqlabel:<code>eq_linreg-y-vec</code></p>
<p>where broadcasting (:numref:<code>subsec_broadcasting</code>) is applied during the summation.
Given features of a training dataset $\mathbf{X}$
and corresponding (known) labels $\mathbf{y}$,
the goal of linear regression is to find
the weight vector $\mathbf{w}$ and the bias term $b$
such that, given features of a new data example
sampled from the same distribution as $\mathbf{X}$,
the new example's label will (in expectation)
be predicted with the smallest error.</p>
<p>Even if we believe that the best model for
predicting $y$ given $\mathbf{x}$ is linear,
we would not expect to find a real-world dataset of $n$ examples where
$y^{(i)}$ exactly equals $\mathbf{w}^\top \mathbf{x}^{(i)}+b$
for all $1 \leq i \leq n$.
For example, whatever instruments we use to observe
the features $\mathbf{X}$ and labels $\mathbf{y}$, there might be a small amount of measurement error.
Thus, even when we are confident
that the underlying relationship is linear,
we will incorporate a noise term to account for such errors.</p>
<p>Before we can go about searching for the best <em>parameters</em>
(or <em>model parameters</em>) $\mathbf{w}$ and $b$,
we will need two more things:
(i) a measure of the quality of some given model;
and (ii) a procedure for updating the model to improve its quality.</p>
<h3 id="loss-function"><a class="header" href="#loss-function">Loss Function</a></h3>
<p>:label:<code>subsec_linear-regression-loss-function</code></p>
<p>Naturally, fitting our model to the data requires
that we agree on some measure of <em>fitness</em>
(or, equivalently, of <em>unfitness</em>).
<em>Loss functions</em> quantify the distance
between the <em>real</em> and <em>predicted</em> values of the target.
The loss will usually be a nonnegative number
where smaller values are better
and perfect predictions incur a loss of 0.
For regression problems, the most common loss function is the squared error.
When our prediction for an example $i$ is $\hat{y}^{(i)}$
and the corresponding true label is $y^{(i)}$,
the <em>squared error</em> is given by:</p>
<p>$$l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.$$
:eqlabel:<code>eq_mse</code></p>
<p>The constant $\frac{1}{2}$ makes no real difference
but proves to be notationally convenient,
since it cancels out when we take the derivative of the loss.
Because the training dataset is given to us,
and thus is out of our control,
the empirical error is only a function of the model parameters.
In :numref:<code>fig_fit_linreg</code>, we visualize the fit of a linear regression model
in a problem with one-dimensional inputs.</p>
<p><img src="chapter_linear-regression/../img/fit-linreg.svg" alt="Fitting a linear regression model to one-dimensional data." />
:label:<code>fig_fit_linreg</code></p>
<p>Note that large differences between
estimates $\hat{y}^{(i)}$ and targets $y^{(i)}$
lead to even larger contributions to the loss,
due to its quadratic form
(this quadraticity can be a double-edge sword; while it encourages the model to avoid large errors
it can also lead to excessive sensitivity to anomalous data).
To measure the quality of a model on the entire dataset of $n$ examples,
we simply average (or equivalently, sum)
the losses on the training set:</p>
<p>$$L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.$$</p>
<p>When training the model, we seek parameters ($\mathbf{w}^<em>, b^</em>$)
that minimize the total loss across all training examples:</p>
<p>$$\mathbf{w}^<em>, b^</em> = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).$$</p>
<h3 id="analytic-solution"><a class="header" href="#analytic-solution">Analytic Solution</a></h3>
<p>Unlike most of the models that we will cover,
linear regression presents us with
a surprisingly easy optimization problem.
In particular, we can find the optimal parameters
(as assessed on the training data)
analytically by applying a simple formula as follows.
First, we can subsume the bias $b$ into the parameter $\mathbf{w}$
by appending a column to the design matrix consisting of all 1s.
Then our prediction problem is to minimize $|\mathbf{y} - \mathbf{X}\mathbf{w}|^2$.
As long as the design matrix $\mathbf{X}$ has full rank
(no feature is linearly dependent on the others),
then there will be just one critical point on the loss surface
and it corresponds to the minimum of the loss over the entire domain.
Taking the derivative of the loss with respect to $\mathbf{w}$
and setting it equal to zero yields:</p>
<p>$$\begin{aligned}
\partial_{\mathbf{w}} |\mathbf{y} - \mathbf{X}\mathbf{w}|^2 =
2 \mathbf{X}^\top (\mathbf{X} \mathbf{w} - \mathbf{y}) = 0
\textrm{ and hence }
\mathbf{X}^\top \mathbf{y} = \mathbf{X}^\top \mathbf{X} \mathbf{w}.
\end{aligned}$$</p>
<p>Solving for $\mathbf{w}$ provides us with the optimal solution
for the optimization problem.
Note that this solution</p>
<p>$$\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}$$</p>
<p>will only be unique
when the matrix $\mathbf X^\top \mathbf X$ is invertible,
i.e., when the columns of the design matrix
are linearly independent :cite:<code>Golub.Van-Loan.1996</code>.</p>
<p>While simple problems like linear regression
may admit analytic solutions,
you should not get used to such good fortune.
Although analytic solutions allow for nice mathematical analysis,
the requirement of an analytic solution is so restrictive
that it would exclude almost all exciting aspects of deep learning.</p>
<h3 id="minibatch-stochastic-gradient-descent"><a class="header" href="#minibatch-stochastic-gradient-descent">Minibatch Stochastic Gradient Descent</a></h3>
<p>Fortunately, even in cases where we cannot solve the models analytically,
we can still often train models effectively in practice.
Moreover, for many tasks, those hard-to-optimize models
turn out to be so much better that figuring out how to train them
ends up being well worth the trouble.</p>
<p>The key technique for optimizing nearly every deep learning model,
and which we will call upon throughout this book,
consists of iteratively reducing the error
by updating the parameters in the direction
that incrementally lowers the loss function.
This algorithm is called <em>gradient descent</em>.</p>
<p>The most naive application of gradient descent
consists of taking the derivative of the loss function,
which is an average of the losses computed
on every single example in the dataset.
In practice, this can be extremely slow:
we must pass over the entire dataset before making a single update,
even if the update steps might be very powerful :cite:<code>Liu.Nocedal.1989</code>.
Even worse, if there is a lot of redundancy in the training data,
the benefit of a full update is limited.</p>
<p>The other extreme is to consider only a single example at a time and to take
update steps based on one observation at a time.
The resulting algorithm, <em>stochastic gradient descent</em> (SGD)
can be an effective strategy :cite:<code>Bottou.2010</code>, even for large datasets.
Unfortunately, SGD has drawbacks, both computational and statistical.
One problem arises from the fact that processors are a lot faster
multiplying and adding numbers than they are
at moving data from main memory to processor cache.
It is up to an order of magnitude more efficient to
perform a matrix--vector multiplication
than a corresponding number of vector--vector operations.
This means that it can take a lot longer to process
one sample at a time compared to a full batch.
A second problem is that some of the layers,
such as batch normalization (to be described in :numref:<code>sec_batch_norm</code>),
only work well when we have access
to more than one observation at a time.</p>
<p>The solution to both problems is to pick an intermediate strategy:
rather than taking a full batch or only a single sample at a time,
we take a <em>minibatch</em> of observations :cite:<code>Li.Zhang.Chen.ea.2014</code>.
The specific choice of the size of the said minibatch depends on many factors,
such as the amount of memory, the number of accelerators,
the choice of layers, and the total dataset size.
Despite all that, a number between 32 and 256,
preferably a multiple of a large power of $2$, is a good start.
This leads us to <em>minibatch stochastic gradient descent</em>.</p>
<p>In its most basic form, in each iteration $t$,
we first randomly sample a minibatch $\mathcal{B}_t$
consisting of a fixed number $|\mathcal{B}|$ of training examples.
We then compute the derivative (gradient) of the average loss
on the minibatch with respect to the model parameters.
Finally, we multiply the gradient
by a predetermined small positive value $\eta$,
called the <em>learning rate</em>,
and subtract the resulting term from the current parameter values.
We can express the update as follows:</p>
<p>$$(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}<em>t} \partial</em>{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).$$</p>
<p>In summary, minibatch SGD proceeds as follows:
(i) initialize the values of the model parameters, typically at random;
(ii) iteratively sample random minibatches from the data,
updating the parameters in the direction of the negative gradient.
For quadratic losses and affine transformations,
this has a closed-form expansion:</p>
<p>$$\begin{aligned} \mathbf{w} &amp; \leftarrow \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}<em>t} \partial</em>{\mathbf{w}} l^{(i)}(\mathbf{w}, b) &amp;&amp; = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}<em>t} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum</em>{i \in \mathcal{B}<em>t} \partial_b l^{(i)}(\mathbf{w}, b) &amp;&amp;  = b - \frac{\eta}{|\mathcal{B}|} \sum</em>{i \in \mathcal{B}_t} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}$$
:eqlabel:<code>eq_linreg_batch_update</code></p>
<p>Since we pick a minibatch $\mathcal{B}$
we need to normalize by its size $|\mathcal{B}|$.
Frequently minibatch size and learning rate are user-defined.
Such tunable parameters that are not updated
in the training loop are called <em>hyperparameters</em>.
They can be tuned automatically by a number of techniques, such as Bayesian optimization
:cite:<code>Frazier.2018</code>. In the end, the quality of the solution is
typically assessed on a separate <em>validation dataset</em> (or <em>validation set</em>).</p>
<p>After training for some predetermined number of iterations
(or until some other stopping criterion is met),
we record the estimated model parameters,
denoted $\hat{\mathbf{w}}, \hat{b}$.
Note that even if our function is truly linear and noiseless,
these parameters will not be the exact minimizers of the loss, nor even deterministic.
Although the algorithm converges slowly towards the minimizers
it typically will not find them exactly in a finite number of steps.
Moreover, the minibatches $\mathcal{B}$
used for updating the parameters are chosen at random.
This breaks determinism.</p>
<p>Linear regression happens to be a learning problem
with a global minimum
(whenever $\mathbf{X}$ is full rank, or equivalently,
whenever $\mathbf{X}^\top \mathbf{X}$ is invertible).
However, the loss surfaces for deep networks contain many saddle points and minima.
Fortunately, we typically do not care about finding
an exact set of parameters but merely any set of parameters
that leads to accurate predictions (and thus low loss).
In practice, deep learning practitioners
seldom struggle to find parameters
that minimize the loss <em>on training sets</em>
:cite:<code>Izmailov.Podoprikhin.Garipov.ea.2018,Frankle.Carbin.2018</code>.
The more formidable task is to find parameters
that lead to accurate predictions on previously unseen data,
a challenge called <em>generalization</em>.
We return to these topics throughout the book.</p>
<h3 id="predictions"><a class="header" href="#predictions">Predictions</a></h3>
<p>Given the model $\hat{\mathbf{w}}^\top \mathbf{x} + \hat{b}$,
we can now make <em>predictions</em> for a new example,
e.g., predicting the sales price of a previously unseen house
given its area $x_1$ and age $x_2$.
Deep learning practitioners have taken to calling the prediction phase <em>inference</em>
but this is a bit of a misnomer---<em>inference</em> refers broadly
to any conclusion reached on the basis of evidence,
including both the values of the parameters
and the likely label for an unseen instance.
If anything, in the statistics literature
<em>inference</em> more often denotes parameter inference
and this overloading of terminology creates unnecessary confusion
when deep learning practitioners talk to statisticians.
In the following we will stick to <em>prediction</em> whenever possible.</p>
<h2 id="vectorization-for-speed"><a class="header" href="#vectorization-for-speed">Vectorization for Speed</a></h2>
<p>When training our models, we typically want to process
whole minibatches of examples simultaneously.
Doing this efficiently requires that (<strong>we</strong>) (<del>should</del>)
(<strong>vectorize the calculations and leverage
fast linear algebra libraries
rather than writing costly for-loops in Python.</strong>)</p>
<p>To see why this matters so much,
let's (<strong>consider two methods for adding vectors.</strong>)
To start, we instantiate two 10,000-dimensional vectors
containing all 1s.
In the first method, we loop over the vectors with a Python for-loop.
In the second, we rely on a single call to <code>+</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
n = 10000
a = d2l.ones(n)
b = d2l.ones(n)
</code></pre>
<p>Now we can benchmark the workloads.
First, [<strong>we add them, one coordinate at a time,
using a for-loop.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
c = d2l.zeros(n)
t = time.time()
for i in range(n):
    c[i] = a[i] + b[i]
f'{time.time() - t:.5f} sec'
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
c = tf.Variable(d2l.zeros(n))
t = time.time()
for i in range(n):
    c[i].assign(a[i] + b[i])
f'{time.time() - t:.5f} sec'
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# JAX arrays are immutable, meaning that once created their contents
# cannot be changed. For updating individual elements, JAX provides
# an indexed update syntax that returns an updated copy
c = d2l.zeros(n)
t = time.time()
for i in range(n):
    c = c.at[i].set(a[i] + b[i])
f'{time.time() - t:.5f} sec'
</code></pre>
<p>(<strong>Alternatively, we rely on the reloaded <code>+</code> operator to compute the elementwise sum.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab all
t = time.time()
d = a + b
f'{time.time() - t:.5f} sec'
</code></pre>
<p>The second method is dramatically faster than the first.
Vectorizing code often yields order-of-magnitude speedups.
Moreover, we push more of the mathematics to the library
so we do not have to write as many calculations ourselves,
reducing the potential for errors and increasing portability of the code.</p>
<h2 id="the-normal-distribution-and-squared-loss"><a class="header" href="#the-normal-distribution-and-squared-loss">The Normal Distribution and Squared Loss</a></h2>
<p>:label:<code>subsec_normal_distribution_and_squared_loss</code></p>
<p>So far we have given a fairly functional motivation
of the squared loss objective:
the optimal parameters return the conditional expectation $E[Y\mid X]$
whenever the underlying pattern is truly linear,
and the loss assigns large penalties for outliers.
We can also provide a more formal motivation
for the squared loss objective
by making probabilistic assumptions
about the distribution of noise.</p>
<p>Linear regression was invented at the turn of the 19th century.
While it has long been debated whether Gauss or Legendre
first thought up the idea,
it was Gauss who also discovered the normal distribution
(also called the <em>Gaussian</em>).
It turns out that the normal distribution
and linear regression with squared loss
share a deeper connection than common parentage.</p>
<p>To begin, recall that a normal distribution
with mean $\mu$ and variance $\sigma^2$ (standard deviation $\sigma$)
is given as</p>
<p>$$p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).$$</p>
<p>Below [<strong>we define a function to compute the normal distribution</strong>].</p>
<pre><code class="language-{.python .input}">%%tab all
def normal(x, mu, sigma):
    p = 1 / math.sqrt(2 * math.pi * sigma**2)
    if tab.selected('jax'):
        return p * jnp.exp(-0.5 * (x - mu)**2 / sigma**2)
    if tab.selected('pytorch', 'mxnet', 'tensorflow'):
        return p * np.exp(-0.5 * (x - mu)**2 / sigma**2)
</code></pre>
<p>We can now (<strong>visualize the normal distributions</strong>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
# Use NumPy again for visualization
x = np.arange(-7, 7, 0.01)

# Mean and standard deviation pairs
params = [(0, 1), (0, 2), (3, 1)]
d2l.plot(x.asnumpy(), [normal(x, mu, sigma).asnumpy() for mu, sigma in params], xlabel='x',
         ylabel='p(x)', figsize=(4.5, 2.5),
         legend=[f'mean {mu}, std {sigma}' for mu, sigma in params])
</code></pre>
<pre><code class="language-{.python .input}">
%%tab pytorch, tensorflow, jax
if tab.selected('jax'):
    # Use JAX NumPy for visualization
    x = jnp.arange(-7, 7, 0.01)
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    # Use NumPy again for visualization
    x = np.arange(-7, 7, 0.01)

# Mean and standard deviation pairs
params = [(0, 1), (0, 2), (3, 1)]
d2l.plot(x, [normal(x, mu, sigma) for mu, sigma in params], xlabel='x',
         ylabel='p(x)', figsize=(4.5, 2.5),
         legend=[f'mean {mu}, std {sigma}' for mu, sigma in params])
</code></pre>
<p>Note that changing the mean corresponds
to a shift along the $x$-axis,
and increasing the variance
spreads the distribution out,
lowering its peak.</p>
<p>One way to motivate linear regression with squared loss
is to assume that observations arise from noisy measurements,
where the noise $\epsilon$ follows the normal distribution
$\mathcal{N}(0, \sigma^2)$:</p>
<p>$$y = \mathbf{w}^\top \mathbf{x} + b + \epsilon \textrm{ where } \epsilon \sim \mathcal{N}(0, \sigma^2).$$</p>
<p>Thus, we can now write out the <em>likelihood</em>
of seeing a particular $y$ for a given $\mathbf{x}$ via</p>
<p>$$P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).$$</p>
<p>As such, the likelihood factorizes.
According to <em>the principle of maximum likelihood</em>,
the best values of parameters $\mathbf{w}$ and $b$ are those
that maximize the <em>likelihood</em> of the entire dataset:</p>
<p>$$P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)} \mid \mathbf{x}^{(i)}).$$</p>
<p>The equality follows since all pairs $(\mathbf{x}^{(i)}, y^{(i)})$
were drawn independently of each other.
Estimators chosen according to the principle of maximum likelihood
are called <em>maximum likelihood estimators</em>.
While, maximizing the product of many exponential functions,
might look difficult,
we can simplify things significantly, without changing the objective,
by maximizing the logarithm of the likelihood instead.
For historical reasons, optimizations are more often expressed
as minimization rather than maximization.
So, without changing anything,
we can <em>minimize</em> the <em>negative log-likelihood</em>,
which we can express as follows:</p>
<p>$$-\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.$$</p>
<p>If we assume that $\sigma$ is fixed,
we can ignore the first term,
because it does not depend on $\mathbf{w}$ or $b$.
The second term is identical
to the squared error loss introduced earlier,
except for the multiplicative constant $\frac{1}{\sigma^2}$.
Fortunately, the solution does not depend on $\sigma$ either.
It follows that minimizing the mean squared error
is equivalent to the maximum likelihood estimation
of a linear model under the assumption of additive Gaussian noise.</p>
<h2 id="linear-regression-as-a-neural-network"><a class="header" href="#linear-regression-as-a-neural-network">Linear Regression as a Neural Network</a></h2>
<p>While linear models are not sufficiently rich
to express the many complicated networks
that we will introduce in this book,
(artificial) neural networks are rich enough
to subsume linear models as networks
in which every feature is represented by an input neuron,
all of which are connected directly to the output.</p>
<p>:numref:<code>fig_single_neuron</code> depicts
linear regression as a neural network.
The diagram highlights the connectivity pattern,
such as how each input is connected to the output,
but not the specific values taken by the weights or biases.</p>
<p><img src="chapter_linear-regression/../img/singleneuron.svg" alt="Linear regression is a single-layer neural network." />
:label:<code>fig_single_neuron</code></p>
<p>The inputs are $x_1, \ldots, x_d$.
We refer to $d$ as the <em>number of inputs</em>
or the <em>feature dimensionality</em> in the input layer.
The output of the network is $o_1$.
Because we are just trying to predict
a single numerical value,
we have only one output neuron.
Note that the input values are all <em>given</em>.
There is just a single <em>computed</em> neuron.
In summary, we can think of linear regression
as a single-layer fully connected neural network.
We will encounter networks
with far more layers
in later chapters.</p>
<h3 id="biology"><a class="header" href="#biology">Biology</a></h3>
<p>Because linear regression predates computational neuroscience,
it might seem anachronistic to describe
linear regression in terms of neural networks.
Nonetheless, they were a natural place to start
when the cyberneticists and neurophysiologists
Warren McCulloch and Walter Pitts began to develop
models of artificial neurons.
Consider the cartoonish picture
of a biological neuron in :numref:<code>fig_Neuron</code>,
consisting of <em>dendrites</em> (input terminals),
the <em>nucleus</em> (CPU), the <em>axon</em> (output wire),
and the <em>axon terminals</em> (output terminals),
enabling connections to other neurons via <em>synapses</em>.</p>
<p><img src="chapter_linear-regression/../img/neuron.svg" alt="The real neuron (source: &quot;Anatomy and Physiology&quot; by the US National Cancer Institute&#39;s Surveillance, Epidemiology and End Results (SEER) Program)." />
:label:<code>fig_Neuron</code></p>
<p>Information $x_i$ arriving from other neurons
(or environmental sensors) is received in the dendrites.
In particular, that information is weighted
by <em>synaptic weights</em> $w_i$,
determining the effect of the inputs,
e.g., activation or inhibition via the product $x_i w_i$.
The weighted inputs arriving from multiple sources
are aggregated in the nucleus
as a weighted sum $y = \sum_i x_i w_i + b$,
possibly subject to some nonlinear postprocessing via a function $\sigma(y)$.
This information is then sent via the axon to the axon terminals,
where it reaches its destination
(e.g., an actuator such as a muscle)
or it is fed into another neuron via its dendrites.</p>
<p>Certainly, the high-level idea that many such units
could be combined, provided they have the correct connectivity and learning algorithm,
to produce far more interesting and complex behavior
than any one neuron alone could express
arises from our study of real biological neural systems.
At the same time, most research in deep learning today
draws inspiration from a much wider source.
We invoke :citet:<code>Russell.Norvig.2016</code>
who pointed out that although airplanes might have been <em>inspired</em> by birds,
ornithology has not been the primary driver
of aeronautics innovation for some centuries.
Likewise, inspiration in deep learning these days
comes in equal or greater measure
from mathematics, linguistics, psychology,
statistics, computer science, and many other fields.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this section, we introduced
traditional linear regression,
where the parameters of a linear function
are chosen to minimize squared loss on the training set.
We also motivated this choice of objective
both via some practical considerations
and through an interpretation
of linear regression as maximimum likelihood estimation
under an assumption of linearity and Gaussian noise.
After discussing both computational considerations
and connections to statistics,
we showed how such linear models could be expressed
as simple neural networks where the inputs
are directly wired to the output(s).
While we will soon move past linear models altogether,
they are sufficient to introduce most of the components
that all of our models require:
parametric forms, differentiable objectives,
optimization via minibatch stochastic gradient descent,
and ultimately, evaluation on previously unseen data.</p>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ol>
<li>Assume that we have some data $x_1, \ldots, x_n \in \mathbb{R}$. Our goal is to find a constant $b$ such that $\sum_i (x_i - b)^2$ is minimized.
<ol>
<li>Find an analytic solution for the optimal value of $b$.</li>
<li>How does this problem and its solution relate to the normal distribution?</li>
<li>What if we change the loss from $\sum_i (x_i - b)^2$ to $\sum_i |x_i-b|$? Can you find the optimal solution for $b$?</li>
</ol>
</li>
<li>Prove that the affine functions that can be expressed by $\mathbf{x}^\top \mathbf{w} + b$ are equivalent to linear functions on $(\mathbf{x}, 1)$.</li>
<li>Assume that you want to find quadratic functions of $\mathbf{x}$, i.e., $f(\mathbf{x}) = b + \sum_i w_i x_i + \sum_{j \leq i} w_{ij} x_{i} x_{j}$. How would you formulate this in a deep network?</li>
<li>Recall that one of the conditions for the linear regression problem to be solvable was that the design matrix $\mathbf{X}^\top \mathbf{X}$ has full rank.
<ol>
<li>What happens if this is not the case?</li>
<li>How could you fix it? What happens if you add a small amount of coordinate-wise independent Gaussian noise to all entries of $\mathbf{X}$?</li>
<li>What is the expected value of the design matrix $\mathbf{X}^\top \mathbf{X}$ in this case?</li>
<li>What happens with stochastic gradient descent when $\mathbf{X}^\top \mathbf{X}$ does not have full rank?</li>
</ol>
</li>
<li>Assume that the noise model governing the additive noise $\epsilon$ is the exponential distribution. That is, $p(\epsilon) = \frac{1}{2} \exp(-|\epsilon|)$.
<ol>
<li>Write out the negative log-likelihood of the data under the model $-\log P(\mathbf y \mid \mathbf X)$.</li>
<li>Can you find a closed form solution?</li>
<li>Suggest a minibatch stochastic gradient descent algorithm to solve this problem. What could possibly go wrong (hint: what happens near the stationary point as we keep on updating the parameters)? Can you fix this?</li>
</ol>
</li>
<li>Assume that we want to design a neural network with two layers by composing two linear layers. That is, the output of the first layer becomes the input of the second layer. Why would such a naive composition not work?</li>
<li>What happens if you want to use regression for realistic price estimation of houses or stock prices?
<ol>
<li>Show that the additive Gaussian noise assumption is not appropriate. Hint: can we have negative prices? What about fluctuations?</li>
<li>Why would regression to the logarithm of the price be much better, i.e., $y = \log \textrm{price}$?</li>
<li>What do you need to worry about when dealing with pennystock, i.e., stock with very low prices? Hint: can you trade at all possible prices? Why is this a bigger problem for cheap stock? For more information review the celebrated Black--Scholes model for option pricing :cite:<code>Black.Scholes.1973</code>.</li>
</ol>
</li>
<li>Suppose we want to use regression to estimate the <em>number</em> of apples sold in a grocery store.
<ol>
<li>What are the problems with a Gaussian additive noise model? Hint: you are selling apples, not oil.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson distribution</a> captures distributions over counts. It is given by $p(k \mid \lambda) = \lambda^k e^{-\lambda}/k!$. Here $\lambda$ is the rate function and $k$ is the number of events you see. Prove that $\lambda$ is the expected value of counts $k$.</li>
<li>Design a loss function associated with the Poisson distribution.</li>
<li>Design a loss function for estimating $\log \lambda$ instead.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/40">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/258">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/259">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="object-oriented-design-for-implementation"><a class="header" href="#object-oriented-design-for-implementation">Object-Oriented Design for Implementation</a></h1>
<p>:label:<code>sec_oo-design</code></p>
<p>In our introduction to linear regression,
we walked through various components
including
the data, the model, the loss function,
and the optimization algorithm.
Indeed,
linear regression is
one of the simplest machine learning models.
Training it,
however, uses many of the same components that other models in this book require.
Therefore,
before diving into the implementation details
it is worth
designing some of the APIs
that we use throughout.
Treating components in deep learning
as objects,
we can start by
defining classes for these objects
and their interactions.
This object-oriented design
for implementation
will greatly
streamline the presentation and you might even want to use it in your projects.</p>
<p>Inspired by open-source libraries such as <a href="https://www.pytorchlightning.ai/">PyTorch Lightning</a>,
at a high level
we wish to have three classes:
(i) <code>Module</code> contains models, losses, and optimization methods;
(ii) <code>DataModule</code> provides data loaders for training and validation;
(iii) both classes are combined using the <code>Trainer</code> class, which allows us to
train models on a variety of hardware platforms.
Most code in this book adapts <code>Module</code> and <code>DataModule</code>. We will touch upon the <code>Trainer</code> class only when we discuss GPUs, CPUs, parallel training, and optimization algorithms.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
import time
import numpy as np
from d2l import mxnet as d2l
from mxnet.gluon import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import time
import numpy as np
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import time
import numpy as np
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from dataclasses import field
from d2l import jax as d2l
from flax import linen as nn
from flax.training import train_state
from jax import numpy as jnp
import numpy as np
import jax
import time
from typing import Any
</code></pre>
<h2 id="utilities"><a class="header" href="#utilities">Utilities</a></h2>
<p>:label:<code>oo-design-utilities</code></p>
<p>We need a few utilities to simplify object-oriented programming in Jupyter notebooks. One of the challenges is that class definitions tend to be fairly long blocks of code. Notebook readability demands short code fragments, interspersed with explanations, a requirement incompatible with the style of programming common for Python libraries. The first
utility function allows us to register functions as methods in a class <em>after</em> the class has been created. In fact, we can do so <em>even after</em> we have created instances of the class! It allows us to split the implementation of a class into multiple code blocks.</p>
<pre><code class="language-{.python .input}">%%tab all
def add_to_class(Class):  #@save
    """Register functions as methods in created class."""
    def wrapper(obj):
        setattr(Class, obj.__name__, obj)
    return wrapper
</code></pre>
<p>Let's have a quick look at how to use it. We plan to implement a class <code>A</code> with a method <code>do</code>. Instead of having code for both <code>A</code> and <code>do</code> in the same code block, we can first declare the class <code>A</code> and create an instance <code>a</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
class A:
    def __init__(self):
        self.b = 1

a = A()
</code></pre>
<p>Next we define the method <code>do</code> as we normally would, but not in class <code>A</code>'s scope. Instead, we decorate this method by <code>add_to_class</code> with class <code>A</code> as its argument. In doing so, the method is able to access the member variables of <code>A</code> just as we would expect had it been included as part of <code>A</code>'s definition. Let's see what happens when we invoke it for the instance <code>a</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
@add_to_class(A)
def do(self):
    print('Class attribute "b" is', self.b)

a.do()
</code></pre>
<p>The second one is a utility class that saves all arguments in a class's <code>__init__</code> method as class attributes. This allows us to extend constructor call signatures implicitly without additional code.</p>
<pre><code class="language-{.python .input}">%%tab all
class HyperParameters:  #@save
    """The base class of hyperparameters."""
    def save_hyperparameters(self, ignore=[]):
        raise NotImplemented
</code></pre>
<p>We defer its implementation into :numref:<code>sec_utils</code>. To use it, we define our class that inherits from <code>HyperParameters</code> and calls <code>save_hyperparameters</code> in the <code>__init__</code> method.</p>
<pre><code class="language-{.python .input}">%%tab all
# Call the fully implemented HyperParameters class saved in d2l
class B(d2l.HyperParameters):
    def __init__(self, a, b, c):
        self.save_hyperparameters(ignore=['c'])
        print('self.a =', self.a, 'self.b =', self.b)
        print('There is no self.c =', not hasattr(self, 'c'))

b = B(a=1, b=2, c=3)
</code></pre>
<p>The final utility allows us to plot experiment progress interactively while it is going on. In deference to the much more powerful (and complex) <a href="https://www.tensorflow.org/tensorboard">TensorBoard</a> we name it <code>ProgressBoard</code>. The  implementation is deferred to :numref:<code>sec_utils</code>. For now, let's simply see it in action.</p>
<p>The <code>draw</code> method plots a point <code>(x, y)</code> in the figure, with <code>label</code> specified in the legend. The optional <code>every_n</code> smooths the line by only showing $1/n$ points in the figure. Their values are averaged from the $n$ neighbor points in the original figure.</p>
<pre><code class="language-{.python .input}">%%tab all
class ProgressBoard(d2l.HyperParameters):  #@save
    """The board that plots data points in animation."""
    def __init__(self, xlabel=None, ylabel=None, xlim=None,
                 ylim=None, xscale='linear', yscale='linear',
                 ls=['-', '--', '-.', ':'], colors=['C0', 'C1', 'C2', 'C3'],
                 fig=None, axes=None, figsize=(3.5, 2.5), display=True):
        self.save_hyperparameters()

    def draw(self, x, y, label, every_n=1):
        raise NotImplemented
</code></pre>
<p>In the following example, we draw <code>sin</code> and <code>cos</code> with a different smoothness. If you run this code block, you will see the lines grow in animation.</p>
<pre><code class="language-{.python .input}">%%tab all
board = d2l.ProgressBoard('x')
for x in np.arange(0, 10, 0.1):
    board.draw(x, np.sin(x), 'sin', every_n=2)
    board.draw(x, np.cos(x), 'cos', every_n=10)
</code></pre>
<h2 id="models-1"><a class="header" href="#models-1">Models</a></h2>
<p>:label:<code>subsec_oo-design-models</code></p>
<p>The <code>Module</code> class is the base class of all models we will implement. At the very least we need three methods. The first, <code>__init__</code>, stores the learnable parameters, the <code>training_step</code> method accepts a data batch to return the loss value, and finally, <code>configure_optimizers</code> returns the optimization method, or a list of them, that is used to update the learnable parameters. Optionally we can define <code>validation_step</code> to report the evaluation measures.
Sometimes we put the code for computing the output into a separate <code>forward</code> method to make it more reusable.</p>
<p>:begin_tab:<code>jax</code>
With the introduction of <a href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a>
in Python 3.7, classes decorated with <code>@dataclass</code> automatically add magic
methods such as <code>__init__</code> and <code>__repr__</code>. The member variables are defined
using type annotations. All Flax modules are Python 3.7 dataclasses.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class Module(d2l.nn_Module, d2l.HyperParameters):  #@save
    """The base class of models."""
    def __init__(self, plot_train_per_epoch=2, plot_valid_per_epoch=1):
        super().__init__()
        self.save_hyperparameters()
        self.board = ProgressBoard()

    def loss(self, y_hat, y):
        raise NotImplementedError

    def forward(self, X):
        assert hasattr(self, 'net'), 'Neural network is defined'
        return self.net(X)

    def plot(self, key, value, train):
        """Plot a point in animation."""
        assert hasattr(self, 'trainer'), 'Trainer is not inited'
        self.board.xlabel = 'epoch'
        if train:
            x = self.trainer.train_batch_idx / \
                self.trainer.num_train_batches
            n = self.trainer.num_train_batches / \
                self.plot_train_per_epoch
        else:
            x = self.trainer.epoch + 1
            n = self.trainer.num_val_batches / \
                self.plot_valid_per_epoch
        self.board.draw(x, d2l.numpy(d2l.to(value, d2l.cpu())),
                        ('train_' if train else 'val_') + key,
                        every_n=int(n))

    def training_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('loss', l, train=True)
        return l

    def validation_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('loss', l, train=False)

    def configure_optimizers(self):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow, jax
class Module(d2l.nn_Module, d2l.HyperParameters):  #@save
    """The base class of models."""
    if tab.selected('mxnet', 'tensorflow'):
        def __init__(self, plot_train_per_epoch=2, plot_valid_per_epoch=1):
            super().__init__()
            self.save_hyperparameters()
            self.board = ProgressBoard()
        if tab.selected('tensorflow'):
            self.training = None

    if tab.selected('jax'):
        # No need for save_hyperparam when using Python dataclass
        plot_train_per_epoch: int = field(default=2, init=False)
        plot_valid_per_epoch: int = field(default=1, init=False)
        # Use default_factory to make sure new plots are generated on each run
        board: ProgressBoard = field(default_factory=lambda: ProgressBoard(),
                                     init=False)

    def loss(self, y_hat, y):
        raise NotImplementedError

    if tab.selected('mxnet', 'tensorflow'):
        def forward(self, X):
            assert hasattr(self, 'net'), 'Neural network is defined'
            return self.net(X)

    if tab.selected('tensorflow'):
        def call(self, X, *args, **kwargs):
            if kwargs and "training" in kwargs:
                self.training = kwargs['training']
            return self.forward(X, *args)

    if tab.selected('jax'):
        # JAX &amp; Flax do not have a forward-method-like syntax. Flax uses setup
        # and built-in __call__ magic methods for forward pass. Adding here
        # for consistency
        def forward(self, X, *args, **kwargs):
            assert hasattr(self, 'net'), 'Neural network is defined'
            return self.net(X, *args, **kwargs)

        def __call__(self, X, *args, **kwargs):
            return self.forward(X, *args, **kwargs)

    def plot(self, key, value, train):
        """Plot a point in animation."""
        assert hasattr(self, 'trainer'), 'Trainer is not inited'
        self.board.xlabel = 'epoch'
        if train:
            x = self.trainer.train_batch_idx / \
                self.trainer.num_train_batches
            n = self.trainer.num_train_batches / \
                self.plot_train_per_epoch
        else:
            x = self.trainer.epoch + 1
            n = self.trainer.num_val_batches / \
                self.plot_valid_per_epoch
        if tab.selected('mxnet', 'tensorflow'):
            self.board.draw(x, d2l.numpy(value), (
                'train_' if train else 'val_') + key, every_n=int(n))
        if tab.selected('jax'):
            self.board.draw(x, d2l.to(value, d2l.cpu()),
                            ('train_' if train else 'val_') + key,
                            every_n=int(n))

    if tab.selected('mxnet', 'tensorflow'):
        def training_step(self, batch):
            l = self.loss(self(*batch[:-1]), batch[-1])
            self.plot('loss', l, train=True)
            return l

        def validation_step(self, batch):
            l = self.loss(self(*batch[:-1]), batch[-1])
            self.plot('loss', l, train=False)

    if tab.selected('jax'):
        def training_step(self, params, batch, state):
            l, grads = jax.value_and_grad(self.loss)(params, batch[:-1],
                                                     batch[-1], state)
            self.plot("loss", l, train=True)
            return l, grads

        def validation_step(self, params, batch, state):
            l = self.loss(params, batch[:-1], batch[-1], state)
            self.plot('loss', l, train=False)
        
        def apply_init(self, dummy_input, key):
            """To be defined later in :numref:`sec_lazy_init`"""
            raise NotImplementedError

    def configure_optimizers(self):
        raise NotImplementedError
</code></pre>
<p>:begin_tab:<code>mxnet</code>
You may notice that <code>Module</code> is a subclass of <code>nn.Block</code>, the base class of neural networks in Gluon.
It provides convenient features for handling neural networks. For example, if we define a <code>forward</code> method, such as <code>forward(self, X)</code>, then for an instance <code>a</code> we can invoke this method by <code>a(X)</code>. This works since it calls the <code>forward</code> method in the built-in <code>__call__</code> method. You can find more details and examples about <code>nn.Block</code> in :numref:<code>sec_model_construction</code>.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
You may notice that <code>Module</code> is a subclass of <code>nn.Module</code>, the base class of neural networks in PyTorch.
It provides convenient features for handling neural networks. For example, if we define a <code>forward</code> method, such as <code>forward(self, X)</code>, then for an instance <code>a</code> we can invoke this method by <code>a(X)</code>. This works since it calls the <code>forward</code> method in the built-in <code>__call__</code> method. You can find more details and examples about <code>nn.Module</code> in :numref:<code>sec_model_construction</code>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
You may notice that <code>Module</code> is a subclass of <code>tf.keras.Model</code>, the base class of neural networks in TensorFlow.
It provides convenient features for handling neural networks. For example, it invokes the <code>call</code> method in the built-in <code>__call__</code> method. Here we redirect <code>call</code> to the <code>forward</code> method, saving its arguments as a class attribute. We do this to make our code more similar to other framework implementations.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
You may notice that <code>Module</code> is a subclass of <code>linen.Module</code>, the base class of neural networks in Flax.
It provides convenient features for handling neural networks. For example, it handles the model parameters, provides the <code>nn.compact</code> decorator to simplify code, invokes the <code>__call__</code> method among other things.
Here we also redirect <code>__call__</code> to the <code>forward</code> method. We do this to make our code more similar to other framework implementations.
:end_tab:</p>
<h2 id="data-1"><a class="header" href="#data-1">Data</a></h2>
<p>:label:<code>oo-design-data</code></p>
<p>The <code>DataModule</code> class is the base class for data. Quite frequently the <code>__init__</code> method is used to prepare the data. This includes downloading and preprocessing if needed. The <code>train_dataloader</code> returns the data loader for the training dataset. A data loader is a (Python) generator that yields a data batch each time it is used. This batch is then fed into the <code>training_step</code> method of <code>Module</code> to compute the loss. There is an optional <code>val_dataloader</code> to return the validation dataset loader. It behaves in the same manner, except that it yields data batches for the <code>validation_step</code> method in <code>Module</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
class DataModule(d2l.HyperParameters):  #@save
    """The base class of data."""
    if tab.selected('mxnet', 'pytorch'):
        def __init__(self, root='../data', num_workers=4):
            self.save_hyperparameters()

    if tab.selected('tensorflow', 'jax'):
        def __init__(self, root='../data'):
            self.save_hyperparameters()

    def get_dataloader(self, train):
        raise NotImplementedError

    def train_dataloader(self):
        return self.get_dataloader(train=True)

    def val_dataloader(self):
        return self.get_dataloader(train=False)
</code></pre>
<h2 id="training"><a class="header" href="#training">Training</a></h2>
<p>:label:<code>oo-design-training</code></p>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
The <code>Trainer</code> class trains the learnable parameters in the <code>Module</code> class with data specified in <code>DataModule</code>. The key method is <code>fit</code>, which accepts two arguments: <code>model</code>, an instance of <code>Module</code>, and <code>data</code>, an instance of <code>DataModule</code>. It then iterates over the entire dataset <code>max_epochs</code> times to train the model. As before, we will defer the implementation of this method to later chapters.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
The <code>Trainer</code> class trains the learnable parameters <code>params</code> with data specified in <code>DataModule</code>. The key method is <code>fit</code>, which accepts three arguments: <code>model</code>, an instance of <code>Module</code>, <code>data</code>, an instance of <code>DataModule</code>, and <code>key</code>, a JAX <code>PRNGKeyArray</code>. We make the <code>key</code> argument optional here to simplify the interface, but it is recommended to always pass and initialize the model parameters with a root key in JAX and Flax. It then iterates over the entire dataset <code>max_epochs</code> times to train the model. As before, we will defer the implementation of this method to later chapters.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab all
class Trainer(d2l.HyperParameters):  #@save
    """The base class for training models with data."""
    def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0):
        self.save_hyperparameters()
        assert num_gpus == 0, 'No GPU support yet'

    def prepare_data(self, data):
        self.train_dataloader = data.train_dataloader()
        self.val_dataloader = data.val_dataloader()
        self.num_train_batches = len(self.train_dataloader)
        self.num_val_batches = (len(self.val_dataloader)
                                if self.val_dataloader is not None else 0)

    def prepare_model(self, model):
        model.trainer = self
        model.board.xlim = [0, self.max_epochs]
        self.model = model

    if tab.selected('pytorch', 'mxnet', 'tensorflow'):
        def fit(self, model, data):
            self.prepare_data(data)
            self.prepare_model(model)
            self.optim = model.configure_optimizers()
            self.epoch = 0
            self.train_batch_idx = 0
            self.val_batch_idx = 0
            for self.epoch in range(self.max_epochs):
                self.fit_epoch()

    if tab.selected('jax'):
        def fit(self, model, data, key=None):
            self.prepare_data(data)
            self.prepare_model(model)
            self.optim = model.configure_optimizers()

            if key is None:
                root_key = d2l.get_key()
            else:
                root_key = key
            params_key, dropout_key = jax.random.split(root_key)
            key = {'params': params_key, 'dropout': dropout_key}

            dummy_input = next(iter(self.train_dataloader))[:-1]
            variables = model.apply_init(dummy_input, key=key)
            params = variables['params']

            if 'batch_stats' in variables.keys():
                # Here batch_stats will be used later (e.g., for batch norm)
                batch_stats = variables['batch_stats']
            else:
                batch_stats = {}

            # Flax uses optax under the hood for a single state obj TrainState.
            # More will be discussed later in the dropout and batch
            # normalization section
            class TrainState(train_state.TrainState):
                batch_stats: Any
                dropout_rng: jax.random.PRNGKeyArray

            self.state = TrainState.create(apply_fn=model.apply,
                                           params=params,
                                           batch_stats=batch_stats,
                                           dropout_rng=dropout_key,
                                           tx=model.configure_optimizers())
            self.epoch = 0
            self.train_batch_idx = 0
            self.val_batch_idx = 0
            for self.epoch in range(self.max_epochs):
                self.fit_epoch()

    def fit_epoch(self):
        raise NotImplementedError
</code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>To highlight the object-oriented design
for our future deep learning implementation,
the above classes simply show how their objects
store data and interact with each other.
We will keep enriching implementations of these classes,
such as via <code>@add_to_class</code>,
in the rest of the book.
Moreover,
these fully implemented classes
are saved in the <a href="https://github.com/d2l-ai/d2l-en/tree/master/d2l">D2L library</a>,
a <em>lightweight toolkit</em> that makes structured modeling for deep learning easy.
In particular, it facilitates reusing many components between projects without changing much at all. For instance, we can replace just the optimizer, just the model, just the dataset, etc.;
this degree of modularity pays dividends throughout the book in terms of conciseness and simplicity (this is why we added it) and it can do the same for your own projects.</p>
<h2 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h2>
<ol>
<li>Locate full implementations of the above classes that are saved in the <a href="https://github.com/d2l-ai/d2l-en/tree/master/d2l">D2L library</a>. We strongly recommend that you look at the implementation in detail once you have gained some more familiarity with deep learning modeling.</li>
<li>Remove the <code>save_hyperparameters</code> statement in the <code>B</code> class. Can you still print <code>self.a</code> and <code>self.b</code>? Optional: if you have dived into the full implementation of the <code>HyperParameters</code> class, can you explain why?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/6645">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/6646">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/6647">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17974">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="synthetic-regression-data"><a class="header" href="#synthetic-regression-data">Synthetic Regression Data</a></h1>
<p>:label:<code>sec_synthetic-regression-data</code></p>
<p>Machine learning is all about extracting information from data.
So you might wonder, what could we possibly learn from synthetic data?
While we might not care intrinsically about the patterns
that we ourselves baked into an artificial data generating model,
such datasets are nevertheless useful for didactic purposes,
helping us to evaluate the properties of our learning
algorithms and to confirm that our implementations work as expected.
For example, if we create data for which the correct parameters are known <em>a priori</em>,
then we can check that our model can in fact recover them.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx, gluon
import random
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import random
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
import random
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import numpy as np
import random
import tensorflow as tf
import tensorflow_datasets as tfds
</code></pre>
<h2 id="generating-the-dataset"><a class="header" href="#generating-the-dataset">Generating the Dataset</a></h2>
<p>For this example, we will work in low dimension
for succinctness.
The following code snippet generates 1000 examples
with 2-dimensional features drawn
from a standard normal distribution.
The resulting design matrix $\mathbf{X}$
belongs to $\mathbb{R}^{1000 \times 2}$.
We generate each label by applying
a <em>ground truth</em> linear function,
corrupting them via additive noise $\boldsymbol{\epsilon}$,
drawn independently and identically for each example:</p>
<p>(<strong>$$\mathbf{y}= \mathbf{X} \mathbf{w} + b + \boldsymbol{\epsilon}.$$</strong>)</p>
<p>For convenience we assume that $\boldsymbol{\epsilon}$ is drawn
from a normal distribution with mean $\mu= 0$
and standard deviation $\sigma = 0.01$.
Note that for object-oriented design
we add the code to the <code>__init__</code> method of a subclass of <code>d2l.DataModule</code> (introduced in :numref:<code>oo-design-data</code>).
It is good practice to allow the setting of any additional hyperparameters.
We accomplish this with <code>save_hyperparameters()</code>.
The <code>batch_size</code> will be determined later.</p>
<pre><code class="language-{.python .input}">%%tab all
class SyntheticRegressionData(d2l.DataModule):  #@save
    """Synthetic data for linear regression."""
    def __init__(self, w, b, noise=0.01, num_train=1000, num_val=1000, 
                 batch_size=32):
        super().__init__()
        self.save_hyperparameters()
        n = num_train + num_val
        if tab.selected('pytorch') or tab.selected('mxnet'):                
            self.X = d2l.randn(n, len(w))
            noise = d2l.randn(n, 1) * noise
        if tab.selected('tensorflow'):
            self.X = tf.random.normal((n, w.shape[0]))
            noise = tf.random.normal((n, 1)) * noise
        if tab.selected('jax'):
            key = jax.random.PRNGKey(0)
            key1, key2 = jax.random.split(key)
            self.X = jax.random.normal(key1, (n, w.shape[0]))
            noise = jax.random.normal(key2, (n, 1)) * noise
        self.y = d2l.matmul(self.X, d2l.reshape(w, (-1, 1))) + b + noise
</code></pre>
<p>Below, we set the true parameters to $\mathbf{w} = [2, -3.4]^\top$ and $b = 4.2$.
Later, we can check our estimated parameters against these <em>ground truth</em> values.</p>
<pre><code class="language-{.python .input}">%%tab all
data = SyntheticRegressionData(w=d2l.tensor([2, -3.4]), b=4.2)
</code></pre>
<p>[<strong>Each row in <code>features</code> consists of a vector in $\mathbb{R}^2$ and each row in <code>labels</code> is a scalar.</strong>] Let's have a look at the first entry.</p>
<pre><code class="language-{.python .input}">%%tab all
print('features:', data.X[0],'\nlabel:', data.y[0])
</code></pre>
<h2 id="reading-the-dataset-1"><a class="header" href="#reading-the-dataset-1">Reading the Dataset</a></h2>
<p>Training machine learning models often requires multiple passes over a dataset,
grabbing one minibatch of examples at a time.
This data is then used to update the model.
To illustrate how this works, we
[<strong>implement the <code>get_dataloader</code> method,</strong>]
registering it in the <code>SyntheticRegressionData</code> class via <code>add_to_class</code> (introduced in :numref:<code>oo-design-utilities</code>).
It (<strong>takes a batch size, a matrix of features,
and a vector of labels, and generates minibatches of size <code>batch_size</code>.</strong>)
As such, each minibatch consists of a tuple of features and labels.
Note that we need to be mindful of whether we're in training or validation mode:
in the former, we will want to read the data in random order,
whereas for the latter, being able to read data in a pre-defined order
may be important for debugging purposes.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(SyntheticRegressionData)
def get_dataloader(self, train):
    if train:
        indices = list(range(0, self.num_train))
        # The examples are read in random order
        random.shuffle(indices)
    else:
        indices = list(range(self.num_train, self.num_train+self.num_val))
    for i in range(0, len(indices), self.batch_size):
        if tab.selected('mxnet', 'pytorch', 'jax'):
            batch_indices = d2l.tensor(indices[i: i+self.batch_size])
            yield self.X[batch_indices], self.y[batch_indices]
        if tab.selected('tensorflow'):
            j = tf.constant(indices[i : i+self.batch_size])
            yield tf.gather(self.X, j), tf.gather(self.y, j)
</code></pre>
<p>To build some intuition, let's inspect the first minibatch of
data. Each minibatch of features provides us with both its size and the dimensionality of input features.
Likewise, our minibatch of labels will have a matching shape given by <code>batch_size</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
X, y = next(iter(data.train_dataloader()))
print('X shape:', X.shape, '\ny shape:', y.shape)
</code></pre>
<p>While seemingly innocuous, the invocation
of <code>iter(data.train_dataloader())</code>
illustrates the power of Python's object-oriented design.
Note that we added a method to the <code>SyntheticRegressionData</code> class
<em>after</em> creating the <code>data</code> object.
Nonetheless, the object benefits from
the <em>ex post facto</em> addition of functionality to the class.</p>
<p>Throughout the iteration we obtain distinct minibatches
until the entire dataset has been exhausted (try this).
While the iteration implemented above is good for didactic purposes,
it is inefficient in ways that might get us into trouble with real problems.
For example, it requires that we load all the data in memory
and that we perform lots of random memory access.
The built-in iterators implemented in a deep learning framework
are considerably more efficient and they can deal
with sources such as data stored in files,
data received via a stream,
and data generated or processed on the fly.
Next let's try to implement the same method using built-in iterators.</p>
<h2 id="concise-implementation-of-the-data-loader"><a class="header" href="#concise-implementation-of-the-data-loader">Concise Implementation of the Data Loader</a></h2>
<p>Rather than writing our own iterator,
we can [<strong>call the existing API in a framework to load data.</strong>]
As before, we need a dataset with features <code>X</code> and labels <code>y</code>.
Beyond that, we set <code>batch_size</code> in the built-in data loader
and let it take care of shuffling examples  efficiently.</p>
<p>:begin_tab:<code>jax</code>
JAX is all about NumPy like API with device acceleration and the functional
transformations, so at least the current version doesn’t include data loading
methods. With other  libraries we already have great data loaders out there,
and JAX suggests using them instead. Here we will grab TensorFlow’s data loader,
and modify it slightly to make it work with JAX.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(d2l.DataModule)  #@save
def get_tensorloader(self, tensors, train, indices=slice(0, None)):
    tensors = tuple(a[indices] for a in tensors)
    if tab.selected('mxnet'):
        dataset = gluon.data.ArrayDataset(*tensors)
        return gluon.data.DataLoader(dataset, self.batch_size,
                                     shuffle=train)
    if tab.selected('pytorch'):
        dataset = torch.utils.data.TensorDataset(*tensors)
        return torch.utils.data.DataLoader(dataset, self.batch_size,
                                           shuffle=train)
    if tab.selected('jax'):
        # Use Tensorflow Datasets &amp; Dataloader. JAX or Flax do not provide
        # any dataloading functionality
        shuffle_buffer = tensors[0].shape[0] if train else 1
        return tfds.as_numpy(
            tf.data.Dataset.from_tensor_slices(tensors).shuffle(
                buffer_size=shuffle_buffer).batch(self.batch_size))

    if tab.selected('tensorflow'):
        shuffle_buffer = tensors[0].shape[0] if train else 1
        return tf.data.Dataset.from_tensor_slices(tensors).shuffle(
            buffer_size=shuffle_buffer).batch(self.batch_size)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(SyntheticRegressionData)  #@save
def get_dataloader(self, train):
    i = slice(0, self.num_train) if train else slice(self.num_train, None)
    return self.get_tensorloader((self.X, self.y), train, i)
</code></pre>
<p>The new data loader behaves just like the previous one, except that it is more efficient and has some added functionality.</p>
<pre><code class="language-{.python .input  n=4}">%%tab all
X, y = next(iter(data.train_dataloader()))
print('X shape:', X.shape, '\ny shape:', y.shape)
</code></pre>
<p>For instance, the data loader provided by the framework API
supports the built-in <code>__len__</code> method,
so we can query its length,
i.e., the number of batches.</p>
<pre><code class="language-{.python .input}">%%tab all
len(data.train_dataloader())
</code></pre>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Data loaders are a convenient way of abstracting out
the process of loading and manipulating data.
This way the same machine learning <em>algorithm</em>
is capable of processing many different types and sources of data
without the need for modification.
One of the nice things about data loaders
is that they can be composed.
For instance, we might be loading images
and then have a postprocessing filter
that crops them or modifies them in other ways.
As such, data loaders can be used
to describe an entire data processing pipeline.</p>
<p>As for the model itself, the two-dimensional linear model
is about the simplest we might encounter.
It lets us test out the accuracy of regression models
without worrying about having insufficient amounts of data
or an underdetermined system of equations.
We will put this to good use in the next section.</p>
<h2 id="exercises-10"><a class="header" href="#exercises-10">Exercises</a></h2>
<ol>
<li>What will happen if the number of examples cannot be divided by the batch size. How would you change this behavior by specifying a different argument by using the framework's API?</li>
<li>Suppose that we want to generate a huge dataset, where both the size of the parameter vector <code>w</code> and the number of examples <code>num_examples</code> are large.
<ol>
<li>What happens if we cannot hold all data in memory?</li>
<li>How would you shuffle the data if it is held on disk? Your task is to design an <em>efficient</em> algorithm that does not require too many random reads or writes. Hint: <a href="https://en.wikipedia.org/wiki/Pseudorandom_permutation">pseudorandom permutation generators</a> allow you to design a reshuffle without the need to store the permutation table explicitly :cite:<code>Naor.Reingold.1999</code>.</li>
</ol>
</li>
<li>Implement a data generator that produces new data on the fly, every time the iterator is called.</li>
<li>How would you design a random data generator that generates <em>the same</em> data each time it is called?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/6662">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/6663">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/6664">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17975">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="linear-regression-implementation-from-scratch"><a class="header" href="#linear-regression-implementation-from-scratch">Linear Regression Implementation from Scratch</a></h1>
<p>:label:<code>sec_linear_scratch</code></p>
<p>We are now ready to work through
a fully functioning implementation
of linear regression.
In this section,
(<strong>we will implement the entire method from scratch,
including (i) the model; (ii) the loss function;
(iii) a minibatch stochastic gradient descent optimizer;
and (iv) the training function
that stitches all of these pieces together.</strong>)
Finally, we will run our synthetic data generator
from :numref:<code>sec_synthetic-regression-data</code>
and apply our model
on the resulting dataset.
While modern deep learning frameworks
can automate nearly all of this work,
implementing things from scratch is the only way
to make sure that you really know what you are doing.
Moreover, when it is time to customize models,
defining our own layers or loss functions,
understanding how things work under the hood will prove handy.
In this section, we will rely only
on tensors and automatic differentiation.
Later, we will introduce a more concise implementation,
taking advantage of the bells and whistles of deep learning frameworks
while retaining the structure of what follows below.</p>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input  n=5}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
import optax
</code></pre>
<h2 id="defining-the-model"><a class="header" href="#defining-the-model">Defining the Model</a></h2>
<p>[<strong>Before we can begin optimizing our model's parameters</strong>] by minibatch SGD,
(<strong>we need to have some parameters in the first place.</strong>)
In the following we initialize weights by drawing
random numbers from a normal distribution with mean 0
and a standard deviation of 0.01.
The magic number 0.01 often works well in practice,
but you can specify a different value
through the argument <code>sigma</code>.
Moreover we set the bias to 0.
Note that for object-oriented design
we add the code to the <code>__init__</code> method of a subclass of <code>d2l.Module</code> (introduced in :numref:<code>subsec_oo-design-models</code>).</p>
<pre><code class="language-{.python .input  n=6}">%%tab pytorch, mxnet, tensorflow
class LinearRegressionScratch(d2l.Module):  #@save
    """The linear regression model implemented from scratch."""
    def __init__(self, num_inputs, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.w = d2l.normal(0, sigma, (num_inputs, 1))
            self.b = d2l.zeros(1)
            self.w.attach_grad()
            self.b.attach_grad()
        if tab.selected('pytorch'):
            self.w = d2l.normal(0, sigma, (num_inputs, 1), requires_grad=True)
            self.b = d2l.zeros(1, requires_grad=True)
        if tab.selected('tensorflow'):
            w = tf.random.normal((num_inputs, 1), mean=0, stddev=0.01)
            b = tf.zeros(1)
            self.w = tf.Variable(w, trainable=True)
            self.b = tf.Variable(b, trainable=True)
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab jax
class LinearRegressionScratch(d2l.Module):  #@save
    """The linear regression model implemented from scratch."""
    num_inputs: int
    lr: float
    sigma: float = 0.01

    def setup(self):
        self.w = self.param('w', nn.initializers.normal(self.sigma),
                            (self.num_inputs, 1))
        self.b = self.param('b', nn.initializers.zeros, (1))
</code></pre>
<p>Next we must [<strong>define our model,
relating its input and parameters to its output.</strong>]
Using the same notation as :eqref:<code>eq_linreg-y-vec</code>
for our linear model we simply take the matrix--vector product
of the input features $\mathbf{X}$
and the model weights $\mathbf{w}$,
and add the offset $b$ to each example.
The product $\mathbf{Xw}$ is a vector and $b$ is a scalar.
Because of the broadcasting mechanism
(see :numref:<code>subsec_broadcasting</code>),
when we add a vector and a scalar,
the scalar is added to each component of the vector.
The resulting <code>forward</code> method
is registered in the <code>LinearRegressionScratch</code> class
via <code>add_to_class</code> (introduced in :numref:<code>oo-design-utilities</code>).</p>
<pre><code class="language-{.python .input  n=8}">%%tab all
@d2l.add_to_class(LinearRegressionScratch)  #@save
def forward(self, X):
    return d2l.matmul(X, self.w) + self.b
</code></pre>
<h2 id="defining-the-loss-function"><a class="header" href="#defining-the-loss-function">Defining the Loss Function</a></h2>
<p>Since [<strong>updating our model requires taking
the gradient of our loss function,</strong>]
we ought to (<strong>define the loss function first.</strong>)
Here we use the squared loss function
in :eqref:<code>eq_mse</code>.
In the implementation, we need to transform the true value <code>y</code>
into the predicted value's shape <code>y_hat</code>.
The result returned by the following method
will also have the same shape as <code>y_hat</code>.
We also return the averaged loss value
among all examples in the minibatch.</p>
<pre><code class="language-{.python .input  n=9}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(LinearRegressionScratch)  #@save
def loss(self, y_hat, y):
    l = (y_hat - y) ** 2 / 2
    return d2l.reduce_mean(l)
</code></pre>
<pre><code class="language-{.python .input  n=10}">%%tab jax
@d2l.add_to_class(LinearRegressionScratch)  #@save
def loss(self, params, X, y, state):
    y_hat = state.apply_fn({'params': params}, *X)  # X unpacked from a tuple
    l = (y_hat - d2l.reshape(y, y_hat.shape)) ** 2 / 2
    return d2l.reduce_mean(l)
</code></pre>
<h2 id="defining-the-optimization-algorithm"><a class="header" href="#defining-the-optimization-algorithm">Defining the Optimization Algorithm</a></h2>
<p>As discussed in :numref:<code>sec_linear_regression</code>,
linear regression has a closed-form solution.
However, our goal here is to illustrate
how to train more general neural networks,
and that requires that we teach you
how to use minibatch SGD.
Hence we will take this opportunity
to introduce your first working example of SGD.
At each step, using a minibatch
randomly drawn from our dataset,
we estimate the gradient of the loss
with respect to the parameters.
Next, we update the parameters
in the direction that may reduce the loss.</p>
<p>The following code applies the update,
given a set of parameters, a learning rate <code>lr</code>.
Since our loss is computed as an average over the minibatch,
we do not need to adjust the learning rate against the batch size.
In later chapters we will investigate
how learning rates should be adjusted
for very large minibatches as they arise
in distributed large-scale learning.
For now, we can ignore this dependency.</p>
<p>:begin_tab:<code>mxnet</code>
We define our <code>SGD</code> class,
a subclass of <code>d2l.HyperParameters</code> (introduced in :numref:<code>oo-design-utilities</code>),
to have a similar API
as the built-in SGD optimizer.
We update the parameters in the <code>step</code> method.
It accepts a <code>batch_size</code> argument that can be ignored.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
We define our <code>SGD</code> class,
a subclass of <code>d2l.HyperParameters</code> (introduced in :numref:<code>oo-design-utilities</code>),
to have a similar API
as the built-in SGD optimizer.
We update the parameters in the <code>step</code> method.
The <code>zero_grad</code> method sets all gradients to 0,
which must be run before a backpropagation step.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
We define our <code>SGD</code> class,
a subclass of <code>d2l.HyperParameters</code> (introduced in :numref:<code>oo-design-utilities</code>),
to have a similar API
as the built-in SGD optimizer.
We update the parameters in the <code>apply_gradients</code> method.
It accepts a list of parameter and gradient pairs.
:end_tab:</p>
<pre><code class="language-{.python .input  n=11}">%%tab mxnet, pytorch
class SGD(d2l.HyperParameters):  #@save
    """Minibatch stochastic gradient descent."""
    def __init__(self, params, lr):
        self.save_hyperparameters()

    if tab.selected('mxnet'):
        def step(self, _):
            for param in self.params:
                param -= self.lr * param.grad

    if tab.selected('pytorch'):
        def step(self):
            for param in self.params:
                param -= self.lr * param.grad

        def zero_grad(self):
            for param in self.params:
                if param.grad is not None:
                    param.grad.zero_()
</code></pre>
<pre><code class="language-{.python .input  n=12}">%%tab tensorflow
class SGD(d2l.HyperParameters):  #@save
    """Minibatch stochastic gradient descent."""
    def __init__(self, lr):
        self.save_hyperparameters()

    def apply_gradients(self, grads_and_vars):
        for grad, param in grads_and_vars:
            param.assign_sub(self.lr * grad)
</code></pre>
<pre><code class="language-{.python .input  n=13}">%%tab jax
class SGD(d2l.HyperParameters):  #@save
    """Minibatch stochastic gradient descent."""
    # The key transformation of Optax is the GradientTransformation
    # defined by two methods, the init and the update.
    # The init initializes the state and the update transforms the gradients.
    # https://github.com/deepmind/optax/blob/master/optax/_src/transform.py
    def __init__(self, lr):
        self.save_hyperparameters()

    def init(self, params):
        # Delete unused params
        del params
        return optax.EmptyState

    def update(self, updates, state, params=None):
        del params
        # When state.apply_gradients method is called to update flax's
        # train_state object, it internally calls optax.apply_updates method
        # adding the params to the update equation defined below.
        updates = jax.tree_util.tree_map(lambda g: -self.lr * g, updates)
        return updates, state

    def __call__():
        return optax.GradientTransformation(self.init, self.update)
</code></pre>
<p>We next define the <code>configure_optimizers</code> method, which returns an instance of the <code>SGD</code> class.</p>
<pre><code class="language-{.python .input  n=14}">%%tab all
@d2l.add_to_class(LinearRegressionScratch)  #@save
def configure_optimizers(self):
    if tab.selected('mxnet') or tab.selected('pytorch'):
        return SGD([self.w, self.b], self.lr)
    if tab.selected('tensorflow', 'jax'):
        return SGD(self.lr)
</code></pre>
<h2 id="training-1"><a class="header" href="#training-1">Training</a></h2>
<p>Now that we have all of the parts in place
(parameters, loss function, model, and optimizer),
we are ready to [<strong>implement the main training loop.</strong>]
It is crucial that you understand this code fully
since you will employ similar training loops
for every other deep learning model
covered in this book.
In each <em>epoch</em>, we iterate through
the entire training dataset,
passing once through every example
(assuming that the number of examples
is divisible by the batch size).
In each <em>iteration</em>, we grab a minibatch of training examples,
and compute its loss through the model's <code>training_step</code> method.
Then we compute the gradients with respect to each parameter.
Finally, we will call the optimization algorithm
to update the model parameters.
In summary, we will execute the following loop:</p>
<ul>
<li>Initialize parameters $(\mathbf{w}, b)$</li>
<li>Repeat until done
<ul>
<li>Compute gradient $\mathbf{g} \leftarrow \partial_{(\mathbf{w},b)} \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} l(\mathbf{x}^{(i)}, y^{(i)}, \mathbf{w}, b)$</li>
<li>Update parameters $(\mathbf{w}, b) \leftarrow (\mathbf{w}, b) - \eta \mathbf{g}$</li>
</ul>
</li>
</ul>
<p>Recall that the synthetic regression dataset
that we generated in :numref:<code>sec_synthetic-regression-data</code>
does not provide a validation dataset.
In most cases, however,
we will want a validation dataset
to measure our model quality.
Here we pass the validation dataloader
once in each epoch to measure the model performance.
Following our object-oriented design,
the <code>prepare_batch</code> and <code>fit_epoch</code> methods
are registered in the <code>d2l.Trainer</code> class
(introduced in :numref:<code>oo-design-training</code>).</p>
<pre><code class="language-{.python .input  n=15}">%%tab all    
@d2l.add_to_class(d2l.Trainer)  #@save
def prepare_batch(self, batch):
    return batch
</code></pre>
<pre><code class="language-{.python .input  n=16}">%%tab pytorch
@d2l.add_to_class(d2l.Trainer)  #@save
def fit_epoch(self):
    self.model.train()        
    for batch in self.train_dataloader:        
        loss = self.model.training_step(self.prepare_batch(batch))
        self.optim.zero_grad()
        with torch.no_grad():
            loss.backward()
            if self.gradient_clip_val &gt; 0:  # To be discussed later
                self.clip_gradients(self.gradient_clip_val, self.model)
            self.optim.step()
        self.train_batch_idx += 1
    if self.val_dataloader is None:
        return
    self.model.eval()
    for batch in self.val_dataloader:
        with torch.no_grad():            
            self.model.validation_step(self.prepare_batch(batch))
        self.val_batch_idx += 1
</code></pre>
<pre><code class="language-{.python .input  n=17}">%%tab mxnet
@d2l.add_to_class(d2l.Trainer)  #@save
def fit_epoch(self):
    for batch in self.train_dataloader:
        with autograd.record():
            loss = self.model.training_step(self.prepare_batch(batch))
        loss.backward()
        if self.gradient_clip_val &gt; 0:
            self.clip_gradients(self.gradient_clip_val, self.model)
        self.optim.step(1)
        self.train_batch_idx += 1
    if self.val_dataloader is None:
        return
    for batch in self.val_dataloader:        
        self.model.validation_step(self.prepare_batch(batch))
        self.val_batch_idx += 1
</code></pre>
<pre><code class="language-{.python .input  n=18}">%%tab tensorflow
@d2l.add_to_class(d2l.Trainer)  #@save
def fit_epoch(self):
    self.model.training = True
    for batch in self.train_dataloader:            
        with tf.GradientTape() as tape:
            loss = self.model.training_step(self.prepare_batch(batch))
        grads = tape.gradient(loss, self.model.trainable_variables)
        if self.gradient_clip_val &gt; 0:
            grads = self.clip_gradients(self.gradient_clip_val, grads)
        self.optim.apply_gradients(zip(grads, self.model.trainable_variables))
        self.train_batch_idx += 1
    if self.val_dataloader is None:
        return
    self.model.training = False
    for batch in self.val_dataloader:        
        self.model.validation_step(self.prepare_batch(batch))
        self.val_batch_idx += 1
</code></pre>
<pre><code class="language-{.python .input  n=19}">%%tab jax
@d2l.add_to_class(d2l.Trainer)  #@save
def fit_epoch(self):
    self.model.training = True
    if self.state.batch_stats:
        # Mutable states will be used later (e.g., for batch norm)
        for batch in self.train_dataloader:
            (_, mutated_vars), grads = self.model.training_step(self.state.params,
                                                           self.prepare_batch(batch),
                                                           self.state)
            self.state = self.state.apply_gradients(grads=grads)
            # Can be ignored for models without Dropout Layers
            self.state = self.state.replace(
                dropout_rng=jax.random.split(self.state.dropout_rng)[0])
            self.state = self.state.replace(batch_stats=mutated_vars['batch_stats'])
            self.train_batch_idx += 1
    else:
        for batch in self.train_dataloader:
            _, grads = self.model.training_step(self.state.params,
                                                self.prepare_batch(batch),
                                                self.state)
            self.state = self.state.apply_gradients(grads=grads)
            # Can be ignored for models without Dropout Layers
            self.state = self.state.replace(
                dropout_rng=jax.random.split(self.state.dropout_rng)[0])
            self.train_batch_idx += 1

    if self.val_dataloader is None:
        return
    self.model.training = False
    for batch in self.val_dataloader:
        self.model.validation_step(self.state.params,
                                   self.prepare_batch(batch),
                                   self.state)
        self.val_batch_idx += 1
</code></pre>
<p>We are almost ready to train the model,
but first we need some training data.
Here we use the <code>SyntheticRegressionData</code> class
and pass in some ground truth parameters.
Then we train our model with
the learning rate <code>lr=0.03</code>
and set <code>max_epochs=3</code>.
Note that in general, both the number of epochs
and the learning rate are hyperparameters.
In general, setting hyperparameters is tricky
and we will usually want to use a three-way split,
one set for training,
a second for hyperparameter selection,
and the third reserved for the final evaluation.
We elide these details for now but will revise them
later.</p>
<pre><code class="language-{.python .input  n=20}">%%tab all
model = LinearRegressionScratch(2, lr=0.03)
data = d2l.SyntheticRegressionData(w=d2l.tensor([2, -3.4]), b=4.2)
trainer = d2l.Trainer(max_epochs=3)
trainer.fit(model, data)
</code></pre>
<p>Because we synthesized the dataset ourselves,
we know precisely what the true parameters are.
Thus, we can [<strong>evaluate our success in training
by comparing the true parameters
with those that we learned</strong>] through our training loop.
Indeed they turn out to be very close to each other.</p>
<pre><code class="language-{.python .input  n=21}">%%tab pytorch
with torch.no_grad():
    print(f'error in estimating w: {data.w - d2l.reshape(model.w, data.w.shape)}')
    print(f'error in estimating b: {data.b - model.b}')
</code></pre>
<pre><code class="language-{.python .input  n=22}">%%tab mxnet, tensorflow
print(f'error in estimating w: {data.w - d2l.reshape(model.w, data.w.shape)}')
print(f'error in estimating b: {data.b - model.b}')
</code></pre>
<pre><code class="language-{.python .input  n=23}">%%tab jax
params = trainer.state.params
print(f"error in estimating w: {data.w - d2l.reshape(params['w'], data.w.shape)}")
print(f"error in estimating b: {data.b - params['b']}")
</code></pre>
<p>We should not take the ability to exactly recover
the ground truth parameters for granted.
In general, for deep models unique solutions
for the parameters do not exist,
and even for linear models,
exactly recovering the parameters
is only possible when no feature
is linearly dependent on the others.
However, in machine learning,
we are often less concerned
with recovering true underlying parameters,
but rather with parameters
that lead to highly accurate prediction :cite:<code>Vapnik.1992</code>.
Fortunately, even on difficult optimization problems,
stochastic gradient descent can often find remarkably good solutions,
owing partly to the fact that, for deep networks,
there exist many configurations of the parameters
that lead to highly accurate prediction.</p>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>In this section, we took a significant step
towards designing deep learning systems
by implementing a fully functional
neural network model and training loop.
In this process, we built a data loader,
a model, a loss function, an optimization procedure,
and a visualization and monitoring tool.
We did this by composing a Python object
that contains all relevant components for training a model.
While this is not yet a professional-grade implementation
it is perfectly functional and code like this
could already help you to solve small problems quickly.
In the coming sections, we will see how to do this
both <em>more concisely</em> (avoiding boilerplate code)
and <em>more efficiently</em> (using our GPUs to their full potential).</p>
<h2 id="exercises-11"><a class="header" href="#exercises-11">Exercises</a></h2>
<ol>
<li>What would happen if we were to initialize the weights to zero. Would the algorithm still work? What if we
initialized the parameters with variance $1000$ rather than $0.01$?</li>
<li>Assume that you are <a href="https://en.wikipedia.org/wiki/Georg_Ohm">Georg Simon Ohm</a> trying to come up
with a model for resistance that relates voltage and current. Can you use automatic
differentiation to learn the parameters of your model?</li>
<li>Can you use <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck's Law</a> to determine the temperature of an object
using spectral energy density? For reference, the spectral density $B$ of radiation emanating from a black body is
$B(\lambda, T) = \frac{2 hc^2}{\lambda^5} \cdot \left(\exp \frac{h c}{\lambda k T} - 1\right)^{-1}$. Here
$\lambda$ is the wavelength, $T$ is the temperature, $c$ is the speed of light, $h$ is Planck's constant, and $k$ is the
Boltzmann constant. You measure the energy for different wavelengths $\lambda$ and you now need to fit the spectral
density curve to Planck's law.</li>
<li>What are the problems you might encounter if you wanted to compute the second derivatives of the loss? How would
you fix them?</li>
<li>Why is the <code>reshape</code> method needed in the <code>loss</code> function?</li>
<li>Experiment using different learning rates to find out how quickly the loss function value drops. Can you reduce the
error by increasing the number of epochs of training?</li>
<li>If the number of examples cannot be divided by the batch size, what happens to <code>data_iter</code> at the end of an epoch?</li>
<li>Try implementing a different loss function, such as the absolute value loss <code>(y_hat - d2l.reshape(y, y_hat.shape)).abs().sum()</code>.
<ol>
<li>Check what happens for regular data.</li>
<li>Check whether there is a difference in behavior if you actively perturb some entries, such as $y_5 = 10000$, of $\mathbf{y}$.</li>
<li>Can you think of a cheap solution for combining the best aspects of squared loss and absolute value loss?
Hint: how can you avoid really large gradient values?</li>
</ol>
</li>
<li>Why do we need to reshuffle the dataset? Can you design a case where a maliciously constructed dataset would break the optimization algorithm otherwise?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/42">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/43">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/201">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17976">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="concise-implementation-of-linear-regression"><a class="header" href="#concise-implementation-of-linear-regression">Concise Implementation of Linear Regression</a></h1>
<p>:label:<code>sec_linear_concise</code></p>
<p>Deep learning has witnessed a sort of Cambrian explosion
over the past decade.
The sheer number of techniques, applications and algorithms by far surpasses the
progress of previous decades.
This is due to a fortuitous combination of multiple factors,
one of which is the powerful free tools
offered by a number of open-source deep learning frameworks.
Theano :cite:<code>Bergstra.Breuleux.Bastien.ea.2010</code>,
DistBelief :cite:<code>Dean.Corrado.Monga.ea.2012</code>,
and Caffe :cite:<code>Jia.Shelhamer.Donahue.ea.2014</code>
arguably represent the
first generation of such models
that found widespread adoption.
In contrast to earlier (seminal) works like
SN2 (Simulateur Neuristique) :cite:<code>Bottou.Le-Cun.1988</code>,
which provided a Lisp-like programming experience,
modern frameworks offer automatic differentiation
and the convenience of Python.
These frameworks allow us to automate and modularize
the repetitive work of implementing gradient-based learning algorithms.</p>
<p>In :numref:<code>sec_linear_scratch</code>, we relied only on
(i) tensors for data storage and linear algebra;
and (ii) automatic differentiation for calculating gradients.
In practice, because data iterators, loss functions, optimizers,
and neural network layers
are so common, modern libraries implement these components for us as well.
In this section, (<strong>we will show you how to implement
the linear regression model</strong>) from :numref:<code>sec_linear_scratch</code>
(<strong>concisely by using high-level APIs</strong>) of deep learning frameworks.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import numpy as np
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import numpy as np
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
import optax
</code></pre>
<h2 id="defining-the-model-1"><a class="header" href="#defining-the-model-1">Defining the Model</a></h2>
<p>When we implemented linear regression from scratch
in :numref:<code>sec_linear_scratch</code>,
we defined our model parameters explicitly
and coded up the calculations to produce output
using basic linear algebra operations.
You <em>should</em> know how to do this.
But once your models get more complex,
and once you have to do this nearly every day,
you will be glad of the assistance.
The situation is similar to coding up your own blog from scratch.
Doing it once or twice is rewarding and instructive,
but you would be a lousy web developer
if you spent a month reinventing the wheel.</p>
<p>For standard operations,
we can [<strong>use a framework's predefined layers,</strong>]
which allow us to focus
on the layers used to construct the model
rather than worrying about their implementation.
Recall the architecture of a single-layer network
as described in :numref:<code>fig_single_neuron</code>.
The layer is called <em>fully connected</em>,
since each of its inputs is connected
to each of its outputs
by means of a matrix--vector multiplication.</p>
<p>:begin_tab:<code>mxnet</code>
In Gluon, the fully connected layer is defined in the <code>Dense</code> class.
Since we only want to generate a single scalar output,
we set that number to 1.
It is worth noting that, for convenience,
Gluon does not require us to specify
the input shape for each layer.
Hence we do not need to tell Gluon
how many inputs go into this linear layer.
When we first pass data through our model,
e.g., when we execute <code>net(X)</code> later,
Gluon will automatically infer the number of inputs to each layer and
thus instantiate the correct model.
We will describe how this works in more detail later.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In PyTorch, the fully connected layer is defined in <code>Linear</code> and <code>LazyLinear</code> classes (available since version 1.8.0).
The latter
allows users to specify <em>merely</em>
the output dimension,
while the former
additionally asks for
how many inputs go into this layer.
Specifying input shapes is inconvenient and may require nontrivial calculations
(such as in convolutional layers).
Thus, for simplicity, we will use such "lazy" layers
whenever we can.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
In Keras, the fully connected layer is defined in the <code>Dense</code> class.
Since we only want to generate a single scalar output,
we set that number to 1.
It is worth noting that, for convenience,
Keras does not require us to specify
the input shape for each layer.
We do not need to tell Keras
how many inputs go into this linear layer.
When we first try to pass data through our model,
e.g., when we execute <code>net(X)</code> later,
Keras will automatically infer
the number of inputs to each layer.
We will describe how this works in more detail later.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class LinearRegression(d2l.Module):  #@save
    """The linear regression model implemented with high-level APIs."""
    def __init__(self, lr):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Dense(1)
            self.net.initialize(init.Normal(sigma=0.01))
        if tab.selected('tensorflow'):
            initializer = tf.initializers.RandomNormal(stddev=0.01)
            self.net = tf.keras.layers.Dense(1, kernel_initializer=initializer)
        if tab.selected('pytorch'):
            self.net = nn.LazyLinear(1)
            self.net.weight.data.normal_(0, 0.01)
            self.net.bias.data.fill_(0)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class LinearRegression(d2l.Module):  #@save
    """The linear regression model implemented with high-level APIs."""
    lr: float

    def setup(self):
        self.net = nn.Dense(1, kernel_init=nn.initializers.normal(0.01))
</code></pre>
<p>In the <code>forward</code> method we just invoke the built-in <code>__call__</code> method of the predefined layers to compute the outputs.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(LinearRegression)  #@save
def forward(self, X):
    return self.net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(LinearRegression)  #@save
def forward(self, X):
    return self.net(X)
</code></pre>
<h2 id="defining-the-loss-function-1"><a class="header" href="#defining-the-loss-function-1">Defining the Loss Function</a></h2>
<p>:begin_tab:<code>mxnet</code>
The <code>loss</code> module defines many useful loss functions.
For speed and convenience, we forgo implementing our own
and choose the built-in <code>loss.L2Loss</code> instead.
Because the <code>loss</code> that it returns is
the squared error for each example,
we use <code>mean</code>to average the loss across over the minibatch.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>The <code>MSELoss</code> class computes the mean squared error (without the $1/2$ factor in :eqref:<code>eq_mse</code>).</strong>]
By default, <code>MSELoss</code> returns the average loss over examples.
It is faster (and easier to use) than implementing our own.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
The <code>MeanSquaredError</code> class computes the mean squared error (without the $1/2$ factor in :eqref:<code>eq_mse</code>).
By default, it returns the average loss over examples.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(LinearRegression)  #@save
def loss(self, y_hat, y):
    if tab.selected('mxnet'):
        fn = gluon.loss.L2Loss()
        return fn(y_hat, y).mean()
    if tab.selected('pytorch'):
        fn = nn.MSELoss()
        return fn(y_hat, y)
    if tab.selected('tensorflow'):
        fn = tf.keras.losses.MeanSquaredError()
        return fn(y, y_hat)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(LinearRegression)  #@save
def loss(self, params, X, y, state):
    y_hat = state.apply_fn({'params': params}, *X)
    return d2l.reduce_mean(optax.l2_loss(y_hat, y))
</code></pre>
<h2 id="defining-the-optimization-algorithm-1"><a class="header" href="#defining-the-optimization-algorithm-1">Defining the Optimization Algorithm</a></h2>
<p>:begin_tab:<code>mxnet</code>
Minibatch SGD is a standard tool
for optimizing neural networks
and thus Gluon supports it alongside a number of
variations on this algorithm through its <code>Trainer</code> class.
Note that Gluon's <code>Trainer</code> class stands
for the optimization algorithm,
while the <code>Trainer</code> class we created in :numref:<code>sec_oo-design</code>
contains the training method,
i.e., repeatedly call the optimizer
to update the model parameters.
When we instantiate <code>Trainer</code>,
we specify the parameters to optimize over,
obtainable from our model <code>net</code> via <code>net.collect_params()</code>,
the optimization algorithm we wish to use (<code>sgd</code>),
and a dictionary of hyperparameters
required by our optimization algorithm.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Minibatch SGD is a standard tool
for optimizing neural networks
and thus PyTorch supports it alongside a number of
variations on this algorithm in the <code>optim</code> module.
When we (<strong>instantiate an <code>SGD</code> instance,</strong>)
we specify the parameters to optimize over,
obtainable from our model via <code>self.parameters()</code>,
and the learning rate (<code>self.lr</code>)
required by our optimization algorithm.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Minibatch SGD is a standard tool
for optimizing neural networks
and thus Keras supports it alongside a number of
variations on this algorithm in the <code>optimizers</code> module.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(LinearRegression)  #@save
def configure_optimizers(self):
    if tab.selected('mxnet'):
        return gluon.Trainer(self.collect_params(),
                             'sgd', {'learning_rate': self.lr})
    if tab.selected('pytorch'):
        return torch.optim.SGD(self.parameters(), self.lr)
    if tab.selected('tensorflow'):
        return tf.keras.optimizers.SGD(self.lr)
    if tab.selected('jax'):
        return optax.sgd(self.lr)
</code></pre>
<h2 id="training-2"><a class="header" href="#training-2">Training</a></h2>
<p>You might have noticed that expressing our model through
high-level APIs of a deep learning framework
requires fewer lines of code.
We did not have to allocate parameters individually,
define our loss function, or implement minibatch SGD.
Once we start working with much more complex models,
the advantages of the high-level API will grow considerably.</p>
<p>Now that we have all the basic pieces in place,
[<strong>the training loop itself is the same
as the one we implemented from scratch.</strong>]
So we just call the <code>fit</code> method (introduced in :numref:<code>oo-design-training</code>),
which relies on the implementation of the <code>fit_epoch</code> method
in :numref:<code>sec_linear_scratch</code>,
to train our model.</p>
<pre><code class="language-{.python .input}">%%tab all
model = LinearRegression(lr=0.03)
data = d2l.SyntheticRegressionData(w=d2l.tensor([2, -3.4]), b=4.2)
trainer = d2l.Trainer(max_epochs=3)
trainer.fit(model, data)
</code></pre>
<p>Below, we
[<strong>compare the model parameters learned
by training on finite data
and the actual parameters</strong>]
that generated our dataset.
To access parameters,
we access the weights and bias
of the layer that we need.
As in our implementation from scratch,
note that our estimated parameters
are close to their true counterparts.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(LinearRegression)  #@save
def get_w_b(self):
    if tab.selected('mxnet'):
        return (self.net.weight.data(), self.net.bias.data())
    if tab.selected('pytorch'):
        return (self.net.weight.data, self.net.bias.data)
    if tab.selected('tensorflow'):
        return (self.get_weights()[0], self.get_weights()[1])

w, b = model.get_w_b()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(LinearRegression)  #@save
def get_w_b(self, state):
    net = state.params['net']
    return net['kernel'], net['bias']

w, b = model.get_w_b(trainer.state)
</code></pre>
<pre><code class="language-{.python .input}">print(f'error in estimating w: {data.w - d2l.reshape(w, data.w.shape)}')
print(f'error in estimating b: {data.b - b}')
</code></pre>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>This section contains the first
implementation of a deep network (in this book)
to tap into the conveniences afforded
by modern deep learning frameworks,
such as MXNet :cite:<code>Chen.Li.Li.ea.2015</code>,
JAX :cite:<code>Frostig.Johnson.Leary.2018</code>,
PyTorch :cite:<code>Paszke.Gross.Massa.ea.2019</code>,
and Tensorflow :cite:<code>Abadi.Barham.Chen.ea.2016</code>.
We used framework defaults for loading data, defining a layer,
a loss function, an optimizer and a training loop.
Whenever the framework provides all necessary features,
it is generally a good idea to use them,
since the library implementations of these components
tend to be heavily optimized for performance
and properly tested for reliability.
At the same time, try not to forget
that these modules <em>can</em> be implemented directly.
This is especially important for aspiring researchers
who wish to live on the leading edge of model development,
where you will be inventing new components
that cannot possibly exist in any current library.</p>
<p>:begin_tab:<code>mxnet</code>
In Gluon, the <code>data</code> module provides tools for data processing,
the <code>nn</code> module defines a large number of neural network layers,
and the <code>loss</code> module defines many common loss functions.
Moreover, the <code>initializer</code> gives access
to many choices for parameter initialization.
Conveniently for the user,
dimensionality and storage are automatically inferred.
A consequence of this lazy initialization is that
you must not attempt to access parameters
before they have been instantiated (and initialized).
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In PyTorch, the <code>data</code> module provides tools for data processing,
the <code>nn</code> module defines a large number of neural network layers and common loss functions.
We can initialize the parameters by replacing their values
with methods ending with <code>_</code>.
Note that we need to specify the input dimensions of the network.
While this is trivial for now, it can have significant knock-on effects
when we want to design complex networks with many layers.
Careful considerations of how to parametrize these networks
is needed to allow portability.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
In TensorFlow, the <code>data</code> module provides tools for data processing,
the <code>keras</code> module defines a large number of neural network layers and common loss functions.
Moreover, the <code>initializers</code> module provides various methods for model parameter initialization.
Dimensionality and storage for networks are automatically inferred
(but be careful not to attempt to access parameters before they have been initialized).
:end_tab:</p>
<h2 id="exercises-12"><a class="header" href="#exercises-12">Exercises</a></h2>
<ol>
<li>How would you need to change the learning rate if you replace the aggregate loss over the minibatch
with an average over the loss on the minibatch?</li>
<li>Review the framework documentation to see which loss functions are provided. In particular,
replace the squared loss with Huber's robust loss function. That is, use the loss function
$$l(y,y') = \begin{cases}|y-y'| -\frac{\sigma}{2} &amp; \textrm{ if } |y-y'| &gt; \sigma \ \frac{1}{2 \sigma} (y-y')^2 &amp; \textrm{ otherwise}\end{cases}$$</li>
<li>How do you access the gradient of the weights of the model?</li>
<li>What is the effect on the solution if you change the learning rate and the number of epochs? Does it keep on improving?</li>
<li>How does the solution change as you vary the amount of data generated?
<ol>
<li>Plot the estimation error for $\hat{\mathbf{w}} - \mathbf{w}$ and $\hat{b} - b$ as a function of the amount of data. Hint: increase the amount of data logarithmically rather than linearly, i.e., 5, 10, 20, 50, ..., 10,000 rather than 1000, 2000, ..., 10,000.</li>
<li>Why is the suggestion in the hint appropriate?</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/44">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/45">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/204">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17977">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalization"><a class="header" href="#generalization">Generalization</a></h1>
<p>:label:<code>sec_generalization_basics</code></p>
<p>Consider two college students diligently
preparing for their final exam.
Commonly, this preparation will consist
of practicing and testing their abilities
by taking exams administered in previous years.
Nonetheless, doing well on past exams is no guarantee
that they will excel when it matters.
For instance, imagine a student, Extraordinary Ellie,
whose preparation consisted entirely
of memorizing the answers
to previous years' exam questions.
Even if Ellie were endowed
with an extraordinary memory,
and thus could perfectly recall the answer
to any <em>previously seen</em> question,
she might nevertheless freeze
when faced with a new (<em>previously unseen</em>) question.
By comparison, imagine another student,
Inductive Irene, with comparably poor
memorization skills,
but a knack for picking up patterns.
Note that if the exam truly consisted of
recycled questions from a previous year,
Ellie would handily outperform Irene.
Even if Irene's inferred patterns
yielded 90% accurate predictions,
they could never compete with
Ellie's 100% recall.
However, even if the exam consisted
entirely of fresh questions,
Irene might maintain her 90% average.</p>
<p>As machine learning scientists,
our goal is to discover <em>patterns</em>.
But how can we be sure that we have
truly discovered a <em>general</em> pattern
and not simply memorized our data?
Most of the time, our predictions are only useful
if our model discovers such a pattern.
We do not want to predict yesterday's stock prices, but tomorrow's.
We do not need to recognize
already diagnosed diseases
for previously seen patients,
but rather previously undiagnosed
ailments in previously unseen patients.
This problem---how to discover patterns that <em>generalize</em>---is
the fundamental problem of machine learning,
and arguably of all of statistics.
We might cast this problem as just one slice
of a far grander question
that engulfs all of science:
when are we ever justified
in making the leap from particular observations
to more general statements?</p>
<p>In real life, we must fit our models
using a finite collection of data.
The typical scales of that data
vary wildly across domains.
For many important medical problems,
we can only access a few thousand data points.
When studying rare diseases,
we might be lucky to access hundreds.
By contrast, the largest public datasets
consisting of labeled photographs,
e.g., ImageNet :cite:<code>Deng.Dong.Socher.ea.2009</code>,
contain millions of images.
And some unlabeled image collections
such as the Flickr YFC100M dataset
can be even larger, containing
over 100 million images :cite:<code>thomee2016yfcc100m</code>.
However, even at this extreme scale,
the number of available data points
remains infinitesimally small
compared to the space of all possible images
at a megapixel resolution.
Whenever we work with finite samples,
we must keep in mind the risk
that we might fit our training data,
only to discover that we failed
to discover a generalizable pattern.</p>
<p>The phenomenon of fitting closer to our training data
than to the underlying distribution is called <em>overfitting</em>,
and techniques for combatting overfitting
are often called <em>regularization</em> methods.
While it is no substitute for a proper introduction
to statistical learning theory (see :citet:<code>Vapnik98,boucheron2005theory</code>),
we will give you just enough intuition to get going.
We will revisit generalization in many chapters
throughout the book,
exploring both what is known about
the principles underlying generalization
in various models,
and also heuristic techniques
that have been found (empirically)
to yield improved generalization
on tasks of practical interest.</p>
<h2 id="training-error-and-generalization-error"><a class="header" href="#training-error-and-generalization-error">Training Error and Generalization Error</a></h2>
<p>In the standard supervised learning setting,
we assume that the training data and the test data
are drawn <em>independently</em> from <em>identical</em> distributions.
This is commonly called the <em>IID assumption</em>.
While this assumption is strong,
it is worth noting that, absent any such assumption,
we would be dead in the water.
Why should we believe that training data
sampled from distribution $P(X,Y)$
should tell us how to make predictions on
test data generated by a <em>different distribution</em> $Q(X,Y)$?
Making such leaps turns out to require
strong assumptions about how $P$ and $Q$ are related.
Later on we will discuss some assumptions
that allow for shifts in distribution
but first we need to understand the IID case,
where $P(\cdot) = Q(\cdot)$.</p>
<p>To begin with, we need to differentiate between
the <em>training error</em> $R_\textrm{emp}$,
which is a <em>statistic</em>
calculated on the training dataset,
and the <em>generalization error</em> $R$,
which is an <em>expectation</em> taken
with respect to the underlying distribution.
You can think of the generalization error as
what you would see  if you applied your model
to an infinite stream of additional data examples
drawn from the same underlying data distribution.
Formally the training error is expressed as a <em>sum</em> (with the same notation as :numref:<code>sec_linear_regression</code>):</p>
<p>$$R_\textrm{emp}[\mathbf{X}, \mathbf{y}, f] = \frac{1}{n} \sum_{i=1}^n l(\mathbf{x}^{(i)}, y^{(i)}, f(\mathbf{x}^{(i)})),$$</p>
<p>while the generalization error is expressed as an integral:</p>
<p>$$R[p, f] = E_{(\mathbf{x}, y) \sim P} [l(\mathbf{x}, y, f(\mathbf{x}))] =
\int \int l(\mathbf{x}, y, f(\mathbf{x})) p(\mathbf{x}, y) ;d\mathbf{x} dy.$$</p>
<p>Problematically, we can never calculate
the generalization error $R$ exactly.
Nobody ever tells us the precise form
of the density function $p(\mathbf{x}, y)$.
Moreover, we cannot sample an infinite stream of data points.
Thus, in practice, we must <em>estimate</em> the generalization error
by applying our model to an independent test set
constituted of a random selection of examples
$\mathbf{X}'$ and labels $\mathbf{y}'$
that were withheld from our training set.
This consists of applying the same formula
that was used for calculating the empirical training error
but to a test set $\mathbf{X}', \mathbf{y}'$.</p>
<p>Crucially, when we evaluate our classifier on the test set,
we are working with a <em>fixed</em> classifier
(it does not depend on the sample of the test set),
and thus estimating its error
is simply the problem of mean estimation.
However the same cannot be said
for the training set.
Note that the model we wind up with
depends explicitly on the selection of the training set
and thus the training error will in general
be a biased estimate of the true error
on the underlying population.
The central question of generalization
is then when should we expect our training error
to be close to the population error
(and thus the generalization error).</p>
<h3 id="model-complexity"><a class="header" href="#model-complexity">Model Complexity</a></h3>
<p>In classical theory, when we have
simple models and abundant data,
the training and generalization errors tend to be close.
However, when we work with
more complex models and/or fewer examples,
we expect the training error to go down
but the generalization gap to grow.
This should not be surprising.
Imagine a model class so expressive that
for any dataset of $n$ examples,
we can find a set of parameters
that can perfectly fit arbitrary labels,
even if randomly assigned.
In this case, even if we fit our training data perfectly,
how can we conclude anything about the generalization error?
For all we know, our generalization error
might be no better than random guessing.</p>
<p>In general, absent any restriction on our model class,
we cannot conclude, based on fitting the training data alone,
that our model has discovered any generalizable pattern :cite:<code>vapnik1994measuring</code>.
On the other hand, if our model class
was not capable of fitting arbitrary labels,
then it must have discovered a pattern.
Learning-theoretic ideas about model complexity
derived some inspiration from the ideas
of Karl Popper, an influential philosopher of science,
who formalized the criterion of falsifiability.
According to Popper, a theory
that can explain any and all observations
is not a scientific theory at all!
After all, what has it told us about the world
if it has not ruled out any possibility?
In short, what we want is a hypothesis
that <em>could not</em> explain any observations
we might conceivably make
and yet nevertheless happens to be compatible
with those observations that we <em>in fact</em> make.</p>
<p>Now what precisely constitutes an appropriate
notion of model complexity is a complex matter.
Often, models with more parameters
are able to fit a greater number
of arbitrarily assigned labels.
However, this is not necessarily true.
For instance, kernel methods operate in spaces
with infinite numbers of parameters,
yet their complexity is controlled
by other means :cite:<code>Scholkopf.Smola.2002</code>.
One notion of complexity that often proves useful
is the range of values that the parameters can take.
Here, a model whose parameters are permitted
to take arbitrary values
would be more complex.
We will revisit this idea in the next section,
when we introduce <em>weight decay</em>,
your first practical regularization technique.
Notably, it can be difficult to compare
complexity among members of substantially different model classes
(say, decision trees vs. neural networks).</p>
<p>At this point, we must stress another important point
that we will revisit when introducing deep neural networks.
When a model is capable of fitting arbitrary labels,
low training error does not necessarily
imply low generalization error.
<em>However, it does not necessarily
imply high generalization error either!</em>
All we can say with confidence is that
low training error alone is not enough
to certify low generalization error.
Deep neural networks turn out to be just such models:
while they generalize well in practice,
they are too powerful to allow us to conclude
much on the basis of training error alone.
In these cases we must rely more heavily
on our holdout data to certify generalization
after the fact.
Error on the holdout data, i.e., validation set,
is called the <em>validation error</em>.</p>
<h2 id="underfitting-or-overfitting"><a class="header" href="#underfitting-or-overfitting">Underfitting or Overfitting?</a></h2>
<p>When we compare the training and validation errors,
we want to be mindful of two common situations.
First, we want to watch out for cases
when our training error and validation error are both substantial
but there is a little gap between them.
If the model is unable to reduce the training error,
that could mean that our model is too simple
(i.e., insufficiently expressive)
to capture the pattern that we are trying to model.
Moreover, since the <em>generalization gap</em> ($R_\textrm{emp} - R$)
between our training and generalization errors is small,
we have reason to believe that we could get away with a more complex model.
This phenomenon is known as <em>underfitting</em>.</p>
<p>On the other hand, as we discussed above,
we want to watch out for the cases
when our training error is significantly lower
than our validation error, indicating severe <em>overfitting</em>.
Note that overfitting is not always a bad thing.
In deep learning especially,
the best predictive models often perform
far better on training data than on holdout data.
Ultimately, we usually care about
driving the generalization error lower,
and only care about the gap insofar
as it becomes an obstacle to that end.
Note that if the training error is zero,
then the generalization gap is precisely equal to the generalization error
and we can make progress only by reducing the gap.</p>
<h3 id="polynomial-curve-fitting"><a class="header" href="#polynomial-curve-fitting">Polynomial Curve Fitting</a></h3>
<p>:label:<code>subsec_polynomial-curve-fitting</code></p>
<p>To illustrate some classical intuition
about overfitting and model complexity,
consider the following:
given training data consisting of a single feature $x$
and a corresponding real-valued label $y$,
we try to find the polynomial of degree $d$</p>
<p>$$\hat{y}= \sum_{i=0}^d x^i w_i$$</p>
<p>for estimating the label $y$.
This is just a linear regression problem
where our features are given by the powers of $x$,
the model's weights are given by $w_i$,
and the bias is given by $w_0$ since $x^0 = 1$ for all $x$.
Since this is just a linear regression problem,
we can use the squared error as our loss function.</p>
<p>A higher-order polynomial function is more complex
than a lower-order polynomial function,
since the higher-order polynomial has more parameters
and the model function's selection range is wider.
Fixing the training dataset,
higher-order polynomial functions should always
achieve lower (at worst, equal) training error
relative to lower-degree polynomials.
In fact, whenever each data example
has a distinct value of $x$,
a polynomial function with degree
equal to the number of data examples
can fit the training set perfectly.
We compare the relationship between polynomial degree (model complexity)
and both underfitting and overfitting in :numref:<code>fig_capacity_vs_error</code>.</p>
<p><img src="chapter_linear-regression/../img/capacity-vs-error.svg" alt="Influence of model complexity on underfitting and overfitting." />
:label:<code>fig_capacity_vs_error</code></p>
<h3 id="dataset-size"><a class="header" href="#dataset-size">Dataset Size</a></h3>
<p>As the above bound already indicates,
another big consideration
to bear in mind is dataset size.
Fixing our model, the fewer samples
we have in the training dataset,
the more likely (and more severely)
we are to encounter overfitting.
As we increase the amount of training data,
the generalization error typically decreases.
Moreover, in general, more data never hurts.
For a fixed task and data distribution,
model complexity should not increase
more rapidly than the amount of data.
Given more data, we might  attempt
to fit a more complex model.
Absent sufficient data, simpler models
may be more difficult to beat.
For many tasks, deep learning
only outperforms linear models
when many thousands of training examples are available.
In part, the current success of deep learning
owes considerably to the abundance of massive datasets
arising from Internet companies, cheap storage,
connected devices, and the broad digitization of the economy.</p>
<h2 id="model-selection"><a class="header" href="#model-selection">Model Selection</a></h2>
<p>:label:<code>subsec_generalization-model-selection</code></p>
<p>Typically, we select our final model
only after evaluating multiple models
that differ in various ways
(different architectures, training objectives,
selected features, data preprocessing,
learning rates, etc.).
Choosing among many models is aptly
called <em>model selection</em>.</p>
<p>In principle, we should not touch our test set
until after we have chosen all our hyperparameters.
Were we to use the test data in the model selection process,
there is a risk that we might overfit the test data.
Then we would be in serious trouble.
If we overfit our training data,
there is always the evaluation on test data to keep us honest.
But if we overfit the test data, how would we ever know?
See :citet:<code>ong2005learning</code> for an example of how
this can lead to absurd results even for models where the complexity
can be tightly controlled.</p>
<p>Thus, we should never rely on the test data for model selection.
And yet we cannot rely solely on the training data
for model selection either because
we cannot estimate the generalization error
on the very data that we use to train the model.</p>
<p>In practical applications, the picture gets muddier.
While ideally we would only touch the test data once,
to assess the very best model or to compare
a small number of models with each other,
real-world test data is seldom discarded after just one use.
We can seldom afford a new test set for each round of experiments.
In fact, recycling benchmark data for decades
can have a significant impact on the
development of algorithms,
e.g., for <a href="https://paperswithcode.com/sota/image-classification-on-imagenet">image classification</a>
and <a href="https://paperswithcode.com/sota/image-classification-on-mnist">optical character recognition</a>.</p>
<p>The common practice for addressing the problem of <em>training on the test set</em>
is to split our data three ways,
incorporating a <em>validation set</em>
in addition to the training and test datasets.
The result is a murky business where the boundaries
between validation and test data are worryingly ambiguous.
Unless explicitly stated otherwise, in the experiments in this book
we are really working with what should rightly be called
training data and validation data, with no true test sets.
Therefore, the accuracy reported in each experiment of the book is really
the validation accuracy and not a true test set accuracy.</p>
<h3 id="cross-validation"><a class="header" href="#cross-validation">Cross-Validation</a></h3>
<p>When training data is scarce,
we might not even be able to afford to hold out
enough data to constitute a proper validation set.
One popular solution to this problem is to employ
$K$<em>-fold cross-validation</em>.
Here, the original training data is split into $K$ non-overlapping subsets.
Then model training and validation are executed $K$ times,
each time training on $K-1$ subsets and validating
on a different subset (the one not used for training in that round).
Finally, the training and validation errors are estimated
by averaging over the results from the $K$ experiments.</p>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>This section explored some of the  underpinnings
of generalization in  machine learning.
Some of these ideas become complicated
and counterintuitive when we get to deeper models; here, models are capable of overfitting data badly,
and the relevant notions of complexity
can be both implicit and counterintuitive
(e.g., larger architectures with more parameters
generalizing better).
We leave you with a few rules of thumb:</p>
<ol>
<li>Use validation sets (or $K$<em>-fold cross-validation</em>) for model selection;</li>
<li>More complex models often require more data;</li>
<li>Relevant notions of complexity include both the number of parameters and the range of values that they are allowed to take;</li>
<li>Keeping all else equal, more data almost always leads to better generalization;</li>
<li>This entire talk of generalization is all predicated on the IID assumption. If we relax this assumption, allowing for distributions to shift between the train and testing periods, then we cannot say anything about generalization absent a further (perhaps milder) assumption.</li>
</ol>
<h2 id="exercises-13"><a class="header" href="#exercises-13">Exercises</a></h2>
<ol>
<li>When can you solve the problem of polynomial regression exactly?</li>
<li>Give at least five examples where dependent random variables make treating the problem as IID data inadvisable.</li>
<li>Can you ever expect to see zero training error? Under which circumstances would you see zero generalization error?</li>
<li>Why is $K$-fold cross-validation very expensive to compute?</li>
<li>Why is the $K$-fold cross-validation error estimate biased?</li>
<li>The VC dimension is defined as the maximum number of points that can be classified with arbitrary labels ${\pm 1}$ by a function of a class of functions. Why might this not be a good idea for measuring how complex the class of functions is? Hint: consider the magnitude of the functions.</li>
<li>Your manager gives you a difficult dataset on which your current algorithm does not perform so well. How would you justify to him that you need more data? Hint: you cannot increase the data but you can decrease it.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/96">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/97">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/234">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17978">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="weight-decay"><a class="header" href="#weight-decay">Weight Decay</a></h1>
<p>:label:<code>sec_weight_decay</code></p>
<p>Now that we have characterized the problem of overfitting,
we can introduce our first <em>regularization</em> technique.
Recall that we can always mitigate overfitting
by collecting more training data.
However, that can be costly, time consuming,
or entirely out of our control,
making it impossible in the short run.
For now, we can assume that we already have
as much high-quality data as our resources permit
and focus the tools at our disposal
when the dataset is taken as a given.</p>
<p>Recall that in our polynomial regression example
(:numref:<code>subsec_polynomial-curve-fitting</code>)
we could limit our model's capacity
by tweaking the degree
of the fitted polynomial.
Indeed, limiting the number of features
is a popular technique for mitigating overfitting.
However, simply tossing aside features
can be too blunt an instrument.
Sticking with the polynomial regression
example, consider what might happen
with high-dimensional input.
The natural extensions of polynomials
to multivariate data are called <em>monomials</em>,
which are simply products of powers of variables.
The degree of a monomial is the sum of the powers.
For example, $x_1^2 x_2$, and $x_3 x_5^2$
are both monomials of degree 3.</p>
<p>Note that the number of terms with degree $d$
blows up rapidly as $d$ grows larger.
Given $k$ variables, the number of monomials
of degree $d$ is ${k - 1 + d} \choose {k - 1}$.
Even small changes in degree, say from $2$ to $3$,
dramatically increase the complexity of our model.
Thus we often need a more fine-grained tool
for adjusting function complexity.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import optax
</code></pre>
<h2 id="norms-and-weight-decay"><a class="header" href="#norms-and-weight-decay">Norms and Weight Decay</a></h2>
<p>(<strong>Rather than directly manipulating the number of parameters,
<em>weight decay</em>, operates by restricting the values
that the parameters can take.</strong>)
More commonly called $\ell_2$ regularization
outside of deep learning circles
when optimized by minibatch stochastic gradient descent,
weight decay might be the most widely used technique
for regularizing parametric machine learning models.
The technique is motivated by the basic intuition
that among all functions $f$,
the function $f = 0$
(assigning the value $0$ to all inputs)
is in some sense the <em>simplest</em>,
and that we can measure the complexity
of a function by the distance of its parameters from zero.
But how precisely should we measure
the distance between a function and zero?
There is no single right answer.
In fact, entire branches of mathematics,
including parts of functional analysis
and the theory of Banach spaces,
are devoted to addressing such issues.</p>
<p>One simple interpretation might be
to measure the complexity of a linear function
$f(\mathbf{x}) = \mathbf{w}^\top \mathbf{x}$
by some norm of its weight vector, e.g., $| \mathbf{w} |^2$.
Recall that we introduced the $\ell_2$ norm and $\ell_1$ norm,
which are special cases of the more general $\ell_p$ norm,
in :numref:<code>subsec_lin-algebra-norms</code>.
The most common method for ensuring a small weight vector
is to add its norm as a penalty term
to the problem of minimizing the loss.
Thus we replace our original objective,
<em>minimizing the prediction loss on the training labels</em>,
with new objective,
<em>minimizing the sum of the prediction loss and the penalty term</em>.
Now, if our weight vector grows too large,
our learning algorithm might focus
on minimizing the weight norm $| \mathbf{w} |^2$
rather than minimizing the training error.
That is exactly what we want.
To illustrate things in code,
we revive our previous example
from :numref:<code>sec_linear_regression</code> for linear regression.
There, our loss was given by</p>
<p>$$L(\mathbf{w}, b) = \frac{1}{n}\sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.$$</p>
<p>Recall that $\mathbf{x}^{(i)}$ are the features,
$y^{(i)}$ is the label for any data example $i$, and $(\mathbf{w}, b)$
are the weight and bias parameters, respectively.
To penalize the size of the weight vector,
we must somehow add $| \mathbf{w} |^2$ to the loss function,
but how should the model trade off the
standard loss for this new additive penalty?
In practice, we characterize this trade-off
via the <em>regularization constant</em> $\lambda$,
a nonnegative hyperparameter
that we fit using validation data:</p>
<p>$$L(\mathbf{w}, b) + \frac{\lambda}{2} |\mathbf{w}|^2.$$</p>
<p>For $\lambda = 0$, we recover our original loss function.
For $\lambda &gt; 0$, we restrict the size of $| \mathbf{w} |$.
We divide by $2$ by convention:
when we take the derivative of a quadratic function,
the $2$ and $1/2$ cancel out, ensuring that the expression
for the update looks nice and simple.
The astute reader might wonder why we work with the squared
norm and not the standard norm (i.e., the Euclidean distance).
We do this for computational convenience.
By squaring the $\ell_2$ norm, we remove the square root,
leaving the sum of squares of
each component of the weight vector.
This makes the derivative of the penalty easy to compute:
the sum of derivatives equals the derivative of the sum.</p>
<p>Moreover, you might ask why we work with the $\ell_2$ norm
in the first place and not, say, the $\ell_1$ norm.
In fact, other choices are valid and
popular throughout statistics.
While $\ell_2$-regularized linear models constitute
the classic <em>ridge regression</em> algorithm,
$\ell_1$-regularized linear regression
is a similarly fundamental method in statistics,
popularly known as <em>lasso regression</em>.
One reason to work with the $\ell_2$ norm
is that it places an outsize penalty
on large components of the weight vector.
This biases our learning algorithm
towards models that distribute weight evenly
across a larger number of features.
In practice, this might make them more robust
to measurement error in a single variable.
By contrast, $\ell_1$ penalties lead to models
that concentrate weights on a small set of features
by clearing the other weights to zero.
This gives us an effective method for <em>feature selection</em>,
which may be desirable for other reasons.
For example, if our model only relies on a few features,
then we may not need to collect, store, or transmit data
for the other (dropped) features.</p>
<p>Using the same notation in :eqref:<code>eq_linreg_batch_update</code>,
minibatch stochastic gradient descent updates
for $\ell_2$-regularized regression as follows:</p>
<p>$$\begin{aligned}
\mathbf{w} &amp; \leftarrow \left(1- \eta\lambda \right) \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right).
\end{aligned}$$</p>
<p>As before, we update $\mathbf{w}$ based on the amount
by which our estimate differs from the observation.
However, we also shrink the size of $\mathbf{w}$ towards zero.
That is why the method is sometimes called "weight decay":
given the penalty term alone,
our optimization algorithm <em>decays</em>
the weight at each step of training.
In contrast to feature selection,
weight decay offers us a mechanism for continuously adjusting the complexity of a function.
Smaller values of $\lambda$ correspond
to less constrained $\mathbf{w}$,
whereas larger values of $\lambda$
constrain $\mathbf{w}$ more considerably.
Whether we include a corresponding bias penalty $b^2$
can vary across implementations,
and may vary across layers of a neural network.
Often, we do not regularize the bias term.
Besides,
although $\ell_2$ regularization may not be equivalent to weight decay for other optimization algorithms,
the idea of regularization through
shrinking the size of weights
still holds true.</p>
<h2 id="high-dimensional-linear-regression"><a class="header" href="#high-dimensional-linear-regression">High-Dimensional Linear Regression</a></h2>
<p>We can illustrate the benefits of weight decay
through a simple synthetic example.</p>
<p>First, we [<strong>generate some data as before</strong>]:</p>
<p>(<strong>$$y = 0.05 + \sum_{i = 1}^d 0.01 x_i + \epsilon \textrm{ where }
\epsilon \sim \mathcal{N}(0, 0.01^2).$$</strong>)</p>
<p>In this synthetic dataset, our label is given
by an underlying linear function of our inputs,
corrupted by Gaussian noise
with zero mean and standard deviation 0.01.
For illustrative purposes,
we can make the effects of overfitting pronounced,
by increasing the dimensionality of our problem to $d = 200$
and working with a small training set with only 20 examples.</p>
<pre><code class="language-{.python .input}">%%tab all
class Data(d2l.DataModule):
    def __init__(self, num_train, num_val, num_inputs, batch_size):
        self.save_hyperparameters()                
        n = num_train + num_val 
        if tab.selected('mxnet') or tab.selected('pytorch'):
            self.X = d2l.randn(n, num_inputs)
            noise = d2l.randn(n, 1) * 0.01
        if tab.selected('tensorflow'):
            self.X = d2l.normal((n, num_inputs))
            noise = d2l.normal((n, 1)) * 0.01
        if tab.selected('jax'):
            self.X = jax.random.normal(jax.random.PRNGKey(0), (n, num_inputs))
            noise = jax.random.normal(jax.random.PRNGKey(0), (n, 1)) * 0.01
        w, b = d2l.ones((num_inputs, 1)) * 0.01, 0.05
        self.y = d2l.matmul(self.X, w) + b + noise

    def get_dataloader(self, train):
        i = slice(0, self.num_train) if train else slice(self.num_train, None)
        return self.get_tensorloader([self.X, self.y], train, i)
</code></pre>
<h2 id="implementation-from-scratch"><a class="header" href="#implementation-from-scratch">Implementation from Scratch</a></h2>
<p>Now, let's try implementing weight decay from scratch.
Since minibatch stochastic gradient descent
is our optimizer,
we just need to add the squared $\ell_2$ penalty
to the original loss function.</p>
<h3 id="defining-ell_2-norm-penalty"><a class="header" href="#defining-ell_2-norm-penalty">(<strong>Defining $\ell_2$ Norm Penalty</strong>)</a></h3>
<p>Perhaps the most convenient way of implementing this penalty
is to square all terms in place and sum them.</p>
<pre><code class="language-{.python .input}">%%tab all
def l2_penalty(w):
    return d2l.reduce_sum(w**2) / 2
</code></pre>
<h3 id="defining-the-model-2"><a class="header" href="#defining-the-model-2">Defining the Model</a></h3>
<p>In the final model,
the linear regression and the squared loss have not changed since :numref:<code>sec_linear_scratch</code>,
so we will just define a subclass of <code>d2l.LinearRegressionScratch</code>. The only change here is that our loss now includes the penalty term.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class WeightDecayScratch(d2l.LinearRegressionScratch):
    def __init__(self, num_inputs, lambd, lr, sigma=0.01):
        super().__init__(num_inputs, lr, sigma)
        self.save_hyperparameters()
        
    def loss(self, y_hat, y):
        return (super().loss(y_hat, y) +
                self.lambd * l2_penalty(self.w))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class WeightDecayScratch(d2l.LinearRegressionScratch):
    lambd: int = 0
        
    def loss(self, params, X, y, state):
        return (super().loss(params, X, y, state) +
                self.lambd * l2_penalty(params['w']))
</code></pre>
<p>The following code fits our model on the training set with 20 examples and evaluates it on the validation set with 100 examples.</p>
<pre><code class="language-{.python .input}">%%tab all
data = Data(num_train=20, num_val=100, num_inputs=200, batch_size=5)
trainer = d2l.Trainer(max_epochs=10)

def train_scratch(lambd):    
    model = WeightDecayScratch(num_inputs=200, lambd=lambd, lr=0.01)
    model.board.yscale='log'
    trainer.fit(model, data)
    if tab.selected('pytorch', 'mxnet', 'tensorflow'):
        print('L2 norm of w:', float(l2_penalty(model.w)))
    if tab.selected('jax'):
        print('L2 norm of w:',
              float(l2_penalty(trainer.state.params['w'])))
</code></pre>
<h3 id="training-without-regularization"><a class="header" href="#training-without-regularization">[<strong>Training without Regularization</strong>]</a></h3>
<p>We now run this code with <code>lambd = 0</code>,
disabling weight decay.
Note that we overfit badly,
decreasing the training error but not the
validation error---a textbook case of overfitting.</p>
<pre><code class="language-{.python .input}">%%tab all
train_scratch(0)
</code></pre>
<h3 id="using-weight-decay"><a class="header" href="#using-weight-decay">[<strong>Using Weight Decay</strong>]</a></h3>
<p>Below, we run with substantial weight decay.
Note that the training error increases
but the validation error decreases.
This is precisely the effect
we expect from regularization.</p>
<pre><code class="language-{.python .input}">%%tab all
train_scratch(3)
</code></pre>
<h2 id="concise-implementation"><a class="header" href="#concise-implementation">[<strong>Concise Implementation</strong>]</a></h2>
<p>Because weight decay is ubiquitous
in neural network optimization,
the deep learning framework makes it especially convenient,
integrating weight decay into the optimization algorithm itself
for easy use in combination with any loss function.
Moreover, this integration serves a computational benefit,
allowing implementation tricks to add weight decay to the algorithm,
without any additional computational overhead.
Since the weight decay portion of the update
depends only on the current value of each parameter,
the optimizer must touch each parameter once anyway.</p>
<p>:begin_tab:<code>mxnet</code>
Below, we specify
the weight decay hyperparameter directly
through <code>wd</code> when instantiating our <code>Trainer</code>.
By default, Gluon decays both
weights and biases simultaneously.
Note that the hyperparameter <code>wd</code>
will be multiplied by <code>wd_mult</code>
when updating model parameters.
Thus, if we set <code>wd_mult</code> to zero,
the bias parameter $b$ will not decay.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Below, we specify
the weight decay hyperparameter directly
through <code>weight_decay</code> when instantiating our optimizer.
By default, PyTorch decays both
weights and biases simultaneously, but
we can configure the optimizer to handle different parameters
according to different policies.
Here, we only set <code>weight_decay</code> for
the weights (the <code>net.weight</code> parameters), hence the
bias (the <code>net.bias</code> parameter) will not decay.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Below, we create an $\ell_2$ regularizer with
the weight decay hyperparameter <code>wd</code> and apply it to the layer's weights
through the <code>kernel_regularizer</code> argument.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class WeightDecay(d2l.LinearRegression):
    def __init__(self, wd, lr):
        super().__init__(lr)
        self.save_hyperparameters()
        self.wd = wd
        
    def configure_optimizers(self):
        self.collect_params('.*bias').setattr('wd_mult', 0)
        return gluon.Trainer(self.collect_params(),
                             'sgd', 
                             {'learning_rate': self.lr, 'wd': self.wd})
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class WeightDecay(d2l.LinearRegression):
    def __init__(self, wd, lr):
        super().__init__(lr)
        self.save_hyperparameters()
        self.wd = wd

    def configure_optimizers(self):
        return torch.optim.SGD([
            {'params': self.net.weight, 'weight_decay': self.wd},
            {'params': self.net.bias}], lr=self.lr)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class WeightDecay(d2l.LinearRegression):
    def __init__(self, wd, lr):
        super().__init__(lr)
        self.save_hyperparameters()
        self.net = tf.keras.layers.Dense(
            1, kernel_regularizer=tf.keras.regularizers.l2(wd),
            kernel_initializer=tf.keras.initializers.RandomNormal(0, 0.01)
        )
        
    def loss(self, y_hat, y):
        return super().loss(y_hat, y) + self.net.losses
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class WeightDecay(d2l.LinearRegression):
    wd: int = 0
    
    def configure_optimizers(self):
        # Weight Decay is not available directly within optax.sgd, but
        # optax allows chaining several transformations together
        return optax.chain(optax.additive_weight_decay(self.wd),
                           optax.sgd(self.lr))
</code></pre>
<p>[<strong>The plot looks similar to that when
we implemented weight decay from scratch</strong>].
However, this version runs faster
and is easier to implement,
benefits that will become more
pronounced as you address larger problems
and this work becomes more routine.</p>
<pre><code class="language-{.python .input}">%%tab all
model = WeightDecay(wd=3, lr=0.01)
model.board.yscale='log'
trainer.fit(model, data)

if tab.selected('jax'):
    print('L2 norm of w:', float(l2_penalty(model.get_w_b(trainer.state)[0])))
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    print('L2 norm of w:', float(l2_penalty(model.get_w_b()[0])))
</code></pre>
<p>So far, we have touched upon one notion of
what constitutes a simple linear function.
However, even for simple nonlinear functions, the situation can be much more complex. To see this, the concept of <a href="https://en.wikipedia.org/wiki/Reproducing_kernel_Hilbert_space">reproducing kernel Hilbert space (RKHS)</a>
allows one to apply tools introduced
for linear functions in a nonlinear context.
Unfortunately, RKHS-based algorithms
tend to scale poorly to large, high-dimensional data.
In this book we will often adopt the common heuristic
whereby weight decay is applied
to all layers of a deep network.</p>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>Regularization is a common method for dealing with overfitting. Classical regularization techniques add a penalty term to the loss function (when training) to reduce the complexity of the learned model.
One particular choice for keeping the model simple is using an $\ell_2$ penalty. This leads to weight decay in the update steps of the minibatch stochastic gradient descent algorithm.
In practice, the weight decay functionality is provided in optimizers from deep learning frameworks.
Different sets of parameters can have different update behaviors within the same training loop.</p>
<h2 id="exercises-14"><a class="header" href="#exercises-14">Exercises</a></h2>
<ol>
<li>Experiment with the value of $\lambda$ in the estimation problem in this section. Plot training and validation accuracy as a function of $\lambda$. What do you observe?</li>
<li>Use a validation set to find the optimal value of $\lambda$. Is it really the optimal value? Does this matter?</li>
<li>What would the update equations look like if instead of $|\mathbf{w}|^2$ we used $\sum_i |w_i|$ as our penalty of choice ($\ell_1$ regularization)?</li>
<li>We know that $|\mathbf{w}|^2 = \mathbf{w}^\top \mathbf{w}$. Can you find a similar equation for matrices (see the Frobenius norm in :numref:<code>subsec_lin-algebra-norms</code>)?</li>
<li>Review the relationship between training error and generalization error. In addition to weight decay, increased training, and the use of a model of suitable complexity, what other ways might help us deal with overfitting?</li>
<li>In Bayesian statistics we use the product of prior and likelihood to arrive at a posterior via $P(w \mid x) \propto P(x \mid w) P(w)$. How can you identify $P(w)$ with regularization?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/98">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/99">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/236">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17979">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-neural-networks-for-classification"><a class="header" href="#linear-neural-networks-for-classification">Linear Neural Networks for Classification</a></h1>
<p>:label:<code>chap_classification</code></p>
<p>Now that you have worked through all of the mechanics
you are ready to apply the skills you have learned to broader kinds of tasks.
Even as we pivot towards classification,
most of the plumbing remains the same:
loading the data, passing it through the model,
generating output, calculating the loss,
taking gradients with respect to weights,
and updating the model.
However, the precise form of the targets,
the parametrization of the output layer,
and the choice of loss function will adapt
to suit the <em>classification</em> setting.</p>
<pre><code class="language-toc">:maxdepth: 2

softmax-regression
image-classification-dataset
classification
softmax-regression-scratch
softmax-regression-concise
generalization-classification
environment-and-distribution-shift
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="softmax-regression"><a class="header" href="#softmax-regression">Softmax Regression</a></h1>
<p>:label:<code>sec_softmax</code></p>
<p>In :numref:<code>sec_linear_regression</code>, we introduced linear regression,
working through implementations from scratch in :numref:<code>sec_linear_scratch</code>
and again using high-level APIs of a deep learning framework
in :numref:<code>sec_linear_concise</code> to do the heavy lifting.</p>
<p>Regression is the hammer we reach for when
we want to answer <em>how much?</em> or <em>how many?</em> questions.
If you want to predict the number of dollars (price)
at which a house will be sold,
or the number of wins a baseball team might have,
or the number of days that a patient
will remain hospitalized before being discharged,
then you are probably looking for a regression model.
However, even within regression models,
there are important distinctions.
For instance, the price of a house
will never be negative and changes might often be <em>relative</em> to its baseline price.
As such, it might be more effective to regress
on the logarithm of the price.
Likewise, the number of days a patient spends in hospital
is a <em>discrete nonnegative</em> random variable.
As such, least mean squares might not be an ideal approach either.
This sort of time-to-event modeling
comes with a host of other complications that are dealt with
in a specialized subfield called <em>survival modeling</em>.</p>
<p>The point here is not to overwhelm you but just
to let you know that there is a lot more to estimation
than simply minimizing squared errors.
And more broadly, there is a lot more to supervised learning than regression.
In this section, we focus on <em>classification</em> problems
where we put aside <em>how much?</em> questions
and instead focus on <em>which category?</em> questions.</p>
<ul>
<li>Does this email belong in the spam folder or the inbox?</li>
<li>Is this customer more likely to sign up
or not to sign up for a subscription service?</li>
<li>Does this image depict a donkey, a dog, a cat, or a rooster?</li>
<li>Which movie is Aston most likely to watch next?</li>
<li>Which section of the book are you going to read next?</li>
</ul>
<p>Colloquially, machine learning practitioners
overload the word <em>classification</em>
to describe two subtly different problems:
(i) those where we are interested only in
hard assignments of examples to categories (classes);
and (ii) those where we wish to make soft assignments,
i.e., to assess the probability that each category applies.
The distinction tends to get blurred, in part,
because often, even when we only care about hard assignments,
we still use models that make soft assignments.</p>
<p>Even more, there are cases where more than one label might be true.
For instance, a news article might simultaneously cover
the topics of entertainment, business, and space flight,
but not the topics of medicine or sports.
Thus, categorizing it into one of the above categories
on their own would not be very useful.
This problem is commonly known as <a href="https://en.wikipedia.org/wiki/Multi-label_classification">multi-label classification</a>.
See :citet:<code>Tsoumakas.Katakis.2007</code> for an overview
and :citet:<code>Huang.Xu.Yu.2015</code>
for an effective algorithm when tagging images.</p>
<h2 id="classification-1"><a class="header" href="#classification-1">Classification</a></h2>
<p>:label:<code>subsec_classification-problem</code></p>
<p>To get our feet wet, let's start with
a simple image classification problem.
Here, each input consists of a $2\times2$ grayscale image.
We can represent each pixel value with a single scalar,
giving us four features $x_1, x_2, x_3, x_4$.
Further, let's assume that each image belongs to one
among the categories "cat", "chicken", and "dog".</p>
<p>Next, we have to choose how to represent the labels.
We have two obvious choices.
Perhaps the most natural impulse would be
to choose $y \in {1, 2, 3}$,
where the integers represent
${\textrm{dog}, \textrm{cat}, \textrm{chicken}}$ respectively.
This is a great way of <em>storing</em> such information on a computer.
If the categories had some natural ordering among them,
say if we were trying to predict
${\textrm{baby}, \textrm{toddler}, \textrm{adolescent}, \textrm{young adult}, \textrm{adult}, \textrm{geriatric}}$,
then it might even make sense to cast this as
an <a href="https://en.wikipedia.org/wiki/Ordinal_regression">ordinal regression</a> problem
and keep the labels in this format.
See :citet:<code>Moon.Smola.Chang.ea.2010</code> for an overview
of different types of ranking loss functions
and :citet:<code>Beutel.Murray.Faloutsos.ea.2014</code> for a Bayesian approach
that addresses responses with more than one mode.</p>
<p>In general, classification problems do not come
with natural orderings among the classes.
Fortunately, statisticians long ago invented a simple way
to represent categorical data: the <em>one-hot encoding</em>.
A one-hot encoding is a vector
with as many components as we have categories.
The component corresponding to a particular instance's category is set to 1
and all other components are set to 0.
In our case, a label $y$ would be a three-dimensional vector,
with $(1, 0, 0)$ corresponding to "cat", $(0, 1, 0)$ to "chicken",
and $(0, 0, 1)$ to "dog":</p>
<p>$$y \in {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.$$</p>
<h3 id="linear-model"><a class="header" href="#linear-model">Linear Model</a></h3>
<p>In order to estimate the conditional probabilities
associated with all the possible classes,
we need a model with multiple outputs, one per class.
To address classification with linear models,
we will need as many affine functions as we have outputs.
Strictly speaking, we only need one fewer,
since the final category has to be the difference
between $1$ and the sum of the other categories,
but for reasons of symmetry
we use a slightly redundant parametrization.
Each output corresponds to its own affine function.
In our case, since we have 4 features and 3 possible output categories,
we need 12 scalars to represent the weights ($w$ with subscripts),
and 3 scalars to represent the biases ($b$ with subscripts). This yields:</p>
<p>$$
\begin{aligned}
o_1 &amp;= x_1 w_{11} + x_2 w_{12} + x_3 w_{13} + x_4 w_{14} + b_1,\
o_2 &amp;= x_1 w_{21} + x_2 w_{22} + x_3 w_{23} + x_4 w_{24} + b_2,\
o_3 &amp;= x_1 w_{31} + x_2 w_{32} + x_3 w_{33} + x_4 w_{34} + b_3.
\end{aligned}
$$</p>
<p>The corresponding neural network diagram
is shown in :numref:<code>fig_softmaxreg</code>.
Just as in linear regression,
we use a single-layer neural network.
And since the calculation of each output, $o_1, o_2$, and $o_3$,
depends on every input, $x_1$, $x_2$, $x_3$, and $x_4$,
the output layer can also be described as a <em>fully connected layer</em>.</p>
<p><img src="chapter_linear-classification/../img/softmaxreg.svg" alt="Softmax regression is a single-layer neural network." />
:label:<code>fig_softmaxreg</code></p>
<p>For a more concise notation we use vectors and matrices:
$\mathbf{o} = \mathbf{W} \mathbf{x} + \mathbf{b}$ is
much better suited for mathematics and code.
Note that we have gathered all of our weights into a $3 \times 4$ matrix and all biases
$\mathbf{b} \in \mathbb{R}^3$ in a vector.</p>
<h3 id="the-softmax"><a class="header" href="#the-softmax">The Softmax</a></h3>
<p>:label:<code>subsec_softmax_operation</code></p>
<p>Assuming a suitable loss function,
we could try, directly, to minimize the difference
between $\mathbf{o}$ and the labels $\mathbf{y}$.
While it turns out that treating classification
as a vector-valued regression problem works surprisingly well,
it is nonetheless unsatisfactory in the following ways:</p>
<ul>
<li>There is no guarantee that the outputs $o_i$ sum up to $1$ in the way we expect probabilities to behave.</li>
<li>There is no guarantee that the outputs $o_i$ are even nonnegative, even if their outputs sum up to $1$, or that they do not exceed $1$.</li>
</ul>
<p>Both aspects render the estimation problem difficult to solve
and the solution very brittle to outliers.
For instance, if we assume that there
is a positive linear dependency
between the number of bedrooms and the likelihood
that someone will buy a house,
the probability might exceed $1$
when it comes to buying a mansion!
As such, we need a mechanism to "squish" the outputs.</p>
<p>There are many ways we might accomplish this goal.
For instance, we could assume that the outputs
$\mathbf{o}$ are corrupted versions of $\mathbf{y}$,
where the corruption occurs by means of adding noise $\boldsymbol{\epsilon}$
drawn from a normal distribution.
In other words, $\mathbf{y} = \mathbf{o} + \boldsymbol{\epsilon}$,
where $\epsilon_i \sim \mathcal{N}(0, \sigma^2)$.
This is the so-called <a href="https://en.wikipedia.org/wiki/Probit_model">probit model</a>,
first introduced by :citet:<code>Fechner.1860</code>.
While appealing, it does not work quite as well
nor lead to a particularly nice optimization problem,
when compared to the softmax.</p>
<p>Another way to accomplish this goal
(and to ensure nonnegativity) is to use
an exponential function $P(y = i) \propto \exp o_i$.
This does indeed satisfy the requirement
that the conditional class probability
increases with increasing $o_i$, it is monotonic,
and all probabilities are nonnegative.
We can then transform these values so that they add up to $1$
by dividing each by their sum.
This process is called <em>normalization</em>.
Putting these two pieces together
gives us the <em>softmax</em> function:</p>
<p>$$\hat{\mathbf{y}} = \mathrm{softmax}(\mathbf{o}) \quad \textrm{where}\quad \hat{y}_i = \frac{\exp(o_i)}{\sum_j \exp(o_j)}.$$
:eqlabel:<code>eq_softmax_y_and_o</code></p>
<p>Note that the largest coordinate of $\mathbf{o}$
corresponds to the most likely class according to $\hat{\mathbf{y}}$.
Moreover, because the softmax operation
preserves the ordering among its arguments,
we do not need to compute the softmax
to determine which class has been assigned the highest probability. Thus,</p>
<p>$$
\operatorname*{argmax}_j \hat y_j = \operatorname*{argmax}_j o_j.
$$</p>
<p>The idea of a softmax dates back to :citet:<code>Gibbs.1902</code>,
who adapted ideas from physics.
Dating even further back, Boltzmann,
the father of modern statistical physics,
used this trick to model a distribution
over energy states in gas molecules.
In particular, he discovered that the prevalence
of a state of energy in a thermodynamic ensemble,
such as the molecules in a gas,
is proportional to $\exp(-E/kT)$.
Here, $E$ is the energy of a state,
$T$ is the temperature, and $k$ is the Boltzmann constant.
When statisticians talk about increasing or decreasing
the "temperature" of a statistical system,
they refer to changing $T$
in order to favor lower or higher energy states.
Following Gibbs' idea, energy equates to error.
Energy-based models :cite:<code>Ranzato.Boureau.Chopra.ea.2007</code>
use this point of view when describing
problems in deep learning.</p>
<h3 id="vectorization"><a class="header" href="#vectorization">Vectorization</a></h3>
<p>:label:<code>subsec_softmax_vectorization</code></p>
<p>To improve computational efficiency,
we vectorize calculations in minibatches of data.
Assume that we are given a minibatch $\mathbf{X} \in \mathbb{R}^{n \times d}$
of $n$ examples with dimensionality (number of inputs) $d$.
Moreover, assume that we have $q$ categories in the output.
Then the weights satisfy $\mathbf{W} \in \mathbb{R}^{d \times q}$
and the bias satisfies $\mathbf{b} \in \mathbb{R}^{1\times q}$.</p>
<p>$$ \begin{aligned} \mathbf{O} &amp;= \mathbf{X} \mathbf{W} + \mathbf{b}, \ \hat{\mathbf{Y}} &amp; = \mathrm{softmax}(\mathbf{O}). \end{aligned} $$
:eqlabel:<code>eq_minibatch_softmax_reg</code></p>
<p>This accelerates the dominant operation into
a matrix--matrix product $\mathbf{X} \mathbf{W}$.
Moreover, since each row in $\mathbf{X}$ represents a data example,
the softmax operation itself can be computed <em>rowwise</em>:
for each row of $\mathbf{O}$, exponentiate all entries
and then normalize them by the sum.
Note, though, that care must be taken
to avoid exponentiating and taking logarithms of large numbers,
since this can cause numerical overflow or underflow.
Deep learning frameworks take care of this automatically.</p>
<h2 id="loss-function-1"><a class="header" href="#loss-function-1">Loss Function</a></h2>
<p>:label:<code>subsec_softmax-regression-loss-func</code></p>
<p>Now that we have a mapping from features $\mathbf{x}$
to probabilities $\mathbf{\hat{y}}$,
we need a way to optimize the accuracy of this mapping.
We will rely on maximum likelihood estimation,
the very same method that we encountered
when providing a probabilistic justification
for the mean squared error loss in
:numref:<code>subsec_normal_distribution_and_squared_loss</code>.</p>
<h3 id="log-likelihood"><a class="header" href="#log-likelihood">Log-Likelihood</a></h3>
<p>The softmax function gives us a vector $\hat{\mathbf{y}}$,
which we can interpret as the (estimated) conditional probabilities
of each class, given any input $\mathbf{x}$,
such as $\hat{y}_1$ = $P(y=\textrm{cat} \mid \mathbf{x})$.
In the following we assume that for a dataset
with features $\mathbf{X}$ the labels $\mathbf{Y}$
are represented using a one-hot encoding label vector.
We can compare the estimates with reality
by checking how probable the actual classes are
according to our model, given the features:</p>
<p>$$
P(\mathbf{Y} \mid \mathbf{X}) = \prod_{i=1}^n P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}).
$$</p>
<p>We are allowed to use the factorization
since we assume that each label is drawn independently
from its respective distribution $P(\mathbf{y}\mid\mathbf{x}^{(i)})$.
Since maximizing the product of terms is awkward,
we take the negative logarithm to obtain the equivalent problem
of minimizing the negative log-likelihood:</p>
<p>$$
-\log P(\mathbf{Y} \mid \mathbf{X}) = \sum_{i=1}^n -\log P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)})
= \sum_{i=1}^n l(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)}),
$$</p>
<p>where for any pair of label $\mathbf{y}$
and model prediction $\hat{\mathbf{y}}$
over $q$ classes, the loss function $l$ is</p>
<p>$$ l(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{j=1}^q y_j \log \hat{y}_j. $$
:eqlabel:<code>eq_l_cross_entropy</code></p>
<p>For reasons explained later on,
the loss function in :eqref:<code>eq_l_cross_entropy</code>
is commonly called the <em>cross-entropy loss</em>.
Since $\mathbf{y}$ is a one-hot vector of length $q$,
the sum over all its coordinates $j$ vanishes for all but one term.
Note that the loss $l(\mathbf{y}, \hat{\mathbf{y}})$
is bounded from below by $0$
whenever $\hat{\mathbf{y}}$ is a probability vector:
no single entry is larger than $1$,
hence their negative logarithm cannot be lower than $0$;
$l(\mathbf{y}, \hat{\mathbf{y}}) = 0$ only if we predict
the actual label with <em>certainty</em>.
This can never happen for any finite setting of the weights
because taking a softmax output towards $1$
requires taking the corresponding input $o_i$ to infinity
(or all other outputs $o_j$ for $j \neq i$ to negative infinity).
Even if our model could assign an output probability of $0$,
any error made when assigning such high confidence
would incur infinite loss ($-\log 0 = \infty$).</p>
<h3 id="softmax-and-cross-entropy-loss"><a class="header" href="#softmax-and-cross-entropy-loss">Softmax and Cross-Entropy Loss</a></h3>
<p>:label:<code>subsec_softmax_and_derivatives</code></p>
<p>Since the softmax function
and the corresponding cross-entropy loss are so common,
it is worth understanding a bit better how they are computed.
Plugging :eqref:<code>eq_softmax_y_and_o</code> into the definition of the loss
in :eqref:<code>eq_l_cross_entropy</code>
and using the definition of the softmax we obtain</p>
<p>$$
\begin{aligned}
l(\mathbf{y}, \hat{\mathbf{y}}) &amp;=  - \sum_{j=1}^q y_j \log \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} \
&amp;= \sum_{j=1}^q y_j \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j \
&amp;= \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j.
\end{aligned}
$$</p>
<p>To understand a bit better what is going on,
consider the derivative with respect to any logit $o_j$. We get</p>
<p>$$
\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) = \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} - y_j = \mathrm{softmax}(\mathbf{o})_j - y_j.
$$</p>
<p>In other words, the derivative is the difference
between the probability assigned by our model,
as expressed by the softmax operation,
and what actually happened, as expressed
by elements in the one-hot label vector.
In this sense, it is very similar
to what we saw in regression,
where the gradient was the difference
between the observation $y$ and estimate $\hat{y}$.
This is not a coincidence.
In any exponential family model,
the gradients of the log-likelihood are given by precisely this term.
This fact makes computing gradients easy in practice.</p>
<p>Now consider the case where we observe not just a single outcome
but an entire distribution over outcomes.
We can use the same representation as before for the label $\mathbf{y}$.
The only difference is that rather
than a vector containing only binary entries,
say $(0, 0, 1)$, we now have a generic probability vector,
say $(0.1, 0.2, 0.7)$.
The math that we used previously to define the loss $l$
in :eqref:<code>eq_l_cross_entropy</code>
still works well,
just that the interpretation is slightly more general.
It is the expected value of the loss for a distribution over labels.
This loss is called the <em>cross-entropy loss</em> and it is
one of the most commonly used losses for classification problems.
We can demystify the name by introducing just the basics of information theory.
In a nutshell, it measures the number of bits needed to encode what we see, $\mathbf{y}$,
relative to what we predict that should happen, $\hat{\mathbf{y}}$.
We provide a very basic explanation in the following. For further
details on information theory see
:citet:<code>Cover.Thomas.1999</code> or :citet:<code>mackay2003information</code>.</p>
<h2 id="information-theory-basics"><a class="header" href="#information-theory-basics">Information Theory Basics</a></h2>
<p>:label:<code>subsec_info_theory_basics</code></p>
<p>Many deep learning papers use intuition and terms from information theory.
To make sense of them, we need some common language.
This is a survival guide.
<em>Information theory</em> deals with the problem
of encoding, decoding, transmitting,
and manipulating information (also known as data).</p>
<h3 id="entropy"><a class="header" href="#entropy">Entropy</a></h3>
<p>The central idea in information theory is to quantify the
amount of information contained in data.
This places a  limit on our ability to compress data.
For a distribution $P$ its <em>entropy</em>, $H[P]$, is defined as:</p>
<p>$$H[P] = \sum_j - P(j) \log P(j).$$
:eqlabel:<code>eq_softmax_reg_entropy</code></p>
<p>One of the fundamental theorems of information theory states
that in order to encode data drawn randomly from the distribution $P$,
we need at least $H[P]$ "nats" to encode it :cite:<code>Shannon.1948</code>.
If you wonder what a "nat" is, it is the equivalent of bit
but when using a code with base $e$ rather than one with base 2.
Thus, one nat is $\frac{1}{\log(2)} \approx 1.44$ bit.</p>
<h3 id="surprisal"><a class="header" href="#surprisal">Surprisal</a></h3>
<p>You might be wondering what compression has to do with prediction.
Imagine that we have a stream of data that we want to compress.
If it is always easy for us to predict the next token,
then this data is easy to compress.
Take the extreme example where every token in the stream
always takes the same value.
That is a very boring data stream!
And not only it is boring, but it is also easy to predict.
Because the tokens are always the same,
we do not have to transmit any information
to communicate the contents of the stream.
Easy to predict, easy to compress.</p>
<p>However if we cannot perfectly predict every event,
then we might sometimes be surprised.
Our surprise is greater when an event is assigned lower probability.
Claude Shannon settled on $\log \frac{1}{P(j)} = -\log P(j)$
to quantify one's <em>surprisal</em> at observing an event $j$
having assigned it a (subjective) probability $P(j)$.
The entropy defined in :eqref:<code>eq_softmax_reg_entropy</code>
is then the <em>expected surprisal</em>
when one assigned the correct probabilities
that truly match the data-generating process.</p>
<h3 id="cross-entropy-revisited"><a class="header" href="#cross-entropy-revisited">Cross-Entropy Revisited</a></h3>
<p>So if entropy is the level of surprise experienced
by someone who knows the true probability,
then you might be wondering, what is cross-entropy?
The cross-entropy <em>from</em> $P$ <em>to</em> $Q$, denoted $H(P, Q)$,
is the expected surprisal of an observer with subjective probabilities $Q$
upon seeing data that was actually generated according to probabilities $P$.
This is given by $H(P, Q) \stackrel{\textrm{def}}{=} \sum_j - P(j) \log Q(j)$.
The lowest possible cross-entropy is achieved when $P=Q$.
In this case, the cross-entropy from $P$ to $Q$ is $H(P, P)= H(P)$.</p>
<p>In short, we can think of the cross-entropy classification objective
in two ways: (i) as maximizing the likelihood of the observed data;
and (ii) as minimizing our surprisal (and thus the number of bits)
required to communicate the labels.</p>
<h2 id="summary-and-discussion"><a class="header" href="#summary-and-discussion">Summary and Discussion</a></h2>
<p>In this section, we encountered the first nontrivial loss function,
allowing us to optimize over <em>discrete</em> output spaces.
Key in its design was that we took a probabilistic approach,
treating discrete categories as instances of draws from a probability distribution.
As a side effect, we encountered the softmax,
a convenient activation function that transforms
outputs of an ordinary neural network layer
into valid discrete probability distributions.
We saw that the derivative of the cross-entropy loss
when combined with softmax
behaves very similarly
to the derivative of squared error;
namely by taking the difference between
the expected behavior and its prediction.
And, while we were only able to
scratch the very surface of it,
we encountered exciting connections
to statistical physics and information theory.</p>
<p>While this is enough to get you on your way,
and hopefully enough to whet your appetite,
we hardly dived deep here.
Among other things, we skipped over computational considerations.
Specifically, for any fully connected layer with $d$ inputs and $q$ outputs,
the parametrization and computational cost is $\mathcal{O}(dq)$,
which can be prohibitively high in practice.
Fortunately, this cost of transforming $d$ inputs into $q$ outputs
can be reduced through approximation and compression.
For instance Deep Fried Convnets :cite:<code>Yang.Moczulski.Denil.ea.2015</code>
uses a combination of permutations,
Fourier transforms, and scaling
to reduce the cost from quadratic to log-linear.
Similar techniques work for more advanced
structural matrix approximations :cite:<code>sindhwani2015structured</code>.
Lastly, we can use quaternion-like decompositions
to reduce the cost to $\mathcal{O}(\frac{dq}{n})$,
again if we are willing to trade off a small amount of accuracy
for computational and storage cost :cite:<code>Zhang.Tay.Zhang.ea.2021</code>
based on a compression factor $n$.
This is an active area of research.
What makes it challenging is that
we do not necessarily strive
for the most compact representation
or the smallest number of floating point operations
but rather for the solution
that can be executed most efficiently on modern GPUs.</p>
<h2 id="exercises-15"><a class="header" href="#exercises-15">Exercises</a></h2>
<ol>
<li>We can explore the connection between exponential families and softmax in some more depth.
<ol>
<li>Compute the second derivative of the cross-entropy loss $l(\mathbf{y},\hat{\mathbf{y}})$ for softmax.</li>
<li>Compute the variance of the distribution given by $\mathrm{softmax}(\mathbf{o})$ and show that it matches the second derivative computed above.</li>
</ol>
</li>
<li>Assume that we have three classes which occur with equal probability, i.e., the probability vector is $(\frac{1}{3}, \frac{1}{3}, \frac{1}{3})$.
<ol>
<li>What is the problem if we try to design a binary code for it?</li>
<li>Can you design a better code? Hint: what happens if we try to encode two independent observations? What if we encode $n$ observations jointly?</li>
</ol>
</li>
<li>When encoding signals transmitted over a physical wire, engineers do not always use binary codes. For instance, <a href="https://en.wikipedia.org/wiki/Ternary_signal">PAM-3</a> uses three signal levels ${-1, 0, 1}$ as opposed to two levels ${0, 1}$. How many ternary units do you need to transmit an integer in the range ${0, \ldots, 7}$? Why might this be a better idea in terms of electronics?</li>
<li>The <a href="https://en.wikipedia.org/wiki/Bradley%E2%80%93Terry_model">Bradley--Terry model</a> uses
a logistic model to capture preferences. For a user to choose between apples and oranges one
assumes scores $o_{\textrm{apple}}$ and $o_{\textrm{orange}}$. Our requirements are that larger scores should lead to a higher likelihood in choosing the associated item and that
the item with the largest score is the most likely one to be chosen :cite:<code>Bradley.Terry.1952</code>.
<ol>
<li>Prove that softmax satisfies this requirement.</li>
<li>What happens if you want to allow for a default option of choosing neither apples nor oranges? Hint: now the user has three choices.</li>
</ol>
</li>
<li>Softmax gets its name from the following mapping: $\textrm{RealSoftMax}(a, b) = \log (\exp(a) + \exp(b))$.
<ol>
<li>Prove that $\textrm{RealSoftMax}(a, b) &gt; \mathrm{max}(a, b)$.</li>
<li>How small can you make the difference between both functions? Hint: without loss of
generality you can set $b = 0$ and $a \geq b$.</li>
<li>Prove that this holds for $\lambda^{-1} \textrm{RealSoftMax}(\lambda a, \lambda b)$, provided that $\lambda &gt; 0$.</li>
<li>Show that for $\lambda \to \infty$ we have $\lambda^{-1} \textrm{RealSoftMax}(\lambda a, \lambda b) \to \mathrm{max}(a, b)$.</li>
<li>Construct an analogous softmin function.</li>
<li>Extend this to more than two numbers.</li>
</ol>
</li>
<li>The function $g(\mathbf{x}) \stackrel{\textrm{def}}{=} \log \sum_i \exp x_i$ is sometimes also referred to as the <a href="https://en.wikipedia.org/wiki/Partition_function_(mathematics)">log-partition function</a>.
<ol>
<li>Prove that the function is convex. Hint: to do so, use the fact that the first derivative amounts to the probabilities from the softmax function and show that the second derivative is the variance.</li>
<li>Show that $g$ is translation invariant, i.e., $g(\mathbf{x} + b) = g(\mathbf{x})$.</li>
<li>What happens if some of the coordinates $x_i$ are very large? What happens if they're all very small?</li>
<li>Show that if we choose $b = \mathrm{max}_i x_i$ we end up with a numerically stable implementation.</li>
</ol>
</li>
<li>Assume that we have some probability distribution $P$. Suppose we pick another distribution $Q$ with $Q(i) \propto P(i)^\alpha$ for $\alpha &gt; 0$.
<ol>
<li>Which choice of $\alpha$ corresponds to doubling the temperature? Which choice corresponds to halving it?</li>
<li>What happens if we let the temperature approach $0$?</li>
<li>What happens if we let the temperature approach $\infty$?</li>
</ol>
</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/46">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="the-image-classification-dataset"><a class="header" href="#the-image-classification-dataset">The Image Classification Dataset</a></h1>
<p>:label:<code>sec_fashion_mnist</code></p>
<p>(~~The MNIST dataset is one of the widely used dataset for image classification, while it is too simple as a benchmark dataset. We will use the similar, but more complex Fashion-MNIST dataset ~~)</p>
<p>One widely used dataset for image classification is the  <a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST dataset</a> :cite:<code>LeCun.Bottou.Bengio.ea.1998</code> of handwritten digits. At the time of its release in the 1990s it posed a formidable challenge to most machine learning algorithms, consisting of 60,000 images of $28 \times 28$ pixels resolution (plus a test dataset of 10,000 images). To put things into perspective, back in 1995, a Sun SPARCStation 5 with a whopping 64MB of RAM and a blistering 5 MFLOPs was considered state of the art equipment for machine learning at AT&amp;T Bell Laboratories. Achieving high accuracy on digit recognition was a key component in automating letter sorting for the USPS in the 1990s. Deep networks such as LeNet-5 :cite:<code>LeCun.Jackel.Bottou.ea.1995</code>, support vector machines with invariances :cite:<code>Scholkopf.Burges.Vapnik.1996</code>, and tangent distance classifiers :cite:<code>Simard.LeCun.Denker.ea.1998</code> all could reach error rates below 1%.</p>
<p>For over a decade, MNIST served as <em>the</em> point of reference for comparing machine learning algorithms.
While it had a good run as a benchmark dataset,
even simple models by today's standards achieve classification accuracy over 95%,
making it unsuitable for distinguishing between strong models and weaker ones. Even more, the dataset allows for <em>very</em> high levels of accuracy, not typically seen in many classification problems. This skewed algorithmic development towards specific families of algorithms that can take advantage of clean datasets, such as active set methods and boundary-seeking active set algorithms.
Today, MNIST serves as more of a sanity check than as a benchmark. ImageNet :cite:<code>Deng.Dong.Socher.ea.2009</code> poses a much
more relevant challenge. Unfortunately, ImageNet is too large for many of the examples and illustrations in this book, as it would take too long to train to make the examples interactive. As a substitute we will focus our discussion in the coming sections on the qualitatively similar, but much smaller Fashion-MNIST
dataset :cite:<code>Xiao.Rasul.Vollgraf.2017</code> which was released in 2017. It contains images of 10 categories of clothing at $28 \times 28$ pixels resolution.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
import time
from d2l import mxnet as d2l
from mxnet import gluon, npx
from mxnet.gluon.data.vision import transforms
npx.set_np()

d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
import time
from d2l import torch as d2l
import torch
import torchvision
from torchvision import transforms

d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
import time
from d2l import tensorflow as d2l
import tensorflow as tf

d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import numpy as np
import time
import tensorflow as tf
import tensorflow_datasets as tfds

d2l.use_svg_display()
</code></pre>
<h2 id="loading-the-dataset"><a class="header" href="#loading-the-dataset">Loading the Dataset</a></h2>
<p>Since the Fashion-MNIST dataset is so useful, all major frameworks provide preprocessed versions of it. We can  [<strong>download and read it into memory using built-in framework utilities.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class FashionMNIST(d2l.DataModule):  #@save
    """The Fashion-MNIST dataset."""
    def __init__(self, batch_size=64, resize=(28, 28)):
        super().__init__()
        self.save_hyperparameters()
        trans = transforms.Compose([transforms.Resize(resize),
                                    transforms.ToTensor()])
        self.train = gluon.data.vision.FashionMNIST(
            train=True).transform_first(trans)
        self.val = gluon.data.vision.FashionMNIST(
            train=False).transform_first(trans)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class FashionMNIST(d2l.DataModule):  #@save
    """The Fashion-MNIST dataset."""
    def __init__(self, batch_size=64, resize=(28, 28)):
        super().__init__()
        self.save_hyperparameters()
        trans = transforms.Compose([transforms.Resize(resize),
                                    transforms.ToTensor()])
        self.train = torchvision.datasets.FashionMNIST(
            root=self.root, train=True, transform=trans, download=True)
        self.val = torchvision.datasets.FashionMNIST(
            root=self.root, train=False, transform=trans, download=True)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
class FashionMNIST(d2l.DataModule):  #@save
    """The Fashion-MNIST dataset."""
    def __init__(self, batch_size=64, resize=(28, 28)):
        super().__init__()
        self.save_hyperparameters()
        self.train, self.val = tf.keras.datasets.fashion_mnist.load_data()
</code></pre>
<p>Fashion-MNIST consists of images from 10 categories, each represented
by 6000 images in the training dataset and by 1000 in the test dataset.
A <em>test dataset</em> is used for evaluating model performance (it must not be used for training).
Consequently the training set and the test set
contain 60,000 and 10,000 images, respectively.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
data = FashionMNIST(resize=(32, 32))
len(data.train), len(data.val)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
data = FashionMNIST(resize=(32, 32))
len(data.train[0]), len(data.val[0])
</code></pre>
<p>The images are grayscale and upscaled to $32 \times 32$ pixels in resolution above. This is similar to the original MNIST dataset which consisted of (binary) black and white images. Note, though, that most modern image data has three channels (red, green, blue) and that hyperspectral images can have in excess of 100 channels (the HyMap sensor has 126 channels).
By convention we store an image as a $c \times h \times w$ tensor, where $c$ is the number of color channels, $h$ is the height and $w$ is the width.</p>
<pre><code class="language-{.python .input}">%%tab all
data.train[0][0].shape
</code></pre>
<p>[<del>Two utility functions to visualize the dataset</del>]</p>
<p>The categories of Fashion-MNIST have human-understandable names.
The following convenience method converts between numeric labels and their names.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(FashionMNIST)  #@save
def text_labels(self, indices):
    """Return text labels."""
    labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat',
              'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot']
    return [labels[int(i)] for i in indices]
</code></pre>
<h2 id="reading-a-minibatch"><a class="header" href="#reading-a-minibatch">Reading a Minibatch</a></h2>
<p>To make our life easier when reading from the training and test sets,
we use the built-in data iterator rather than creating one from scratch.
Recall that at each iteration, a data iterator
[<strong>reads a minibatch of data with size <code>batch_size</code>.</strong>]
We also randomly shuffle the examples for the training data iterator.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(FashionMNIST)  #@save
def get_dataloader(self, train):
    data = self.train if train else self.val
    return gluon.data.DataLoader(data, self.batch_size, shuffle=train,
                                 num_workers=self.num_workers)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(FashionMNIST)  #@save
def get_dataloader(self, train):
    data = self.train if train else self.val
    return torch.utils.data.DataLoader(data, self.batch_size, shuffle=train,
                                       num_workers=self.num_workers)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
@d2l.add_to_class(FashionMNIST)  #@save
def get_dataloader(self, train):
    data = self.train if train else self.val
    process = lambda X, y: (tf.expand_dims(X, axis=3) / 255,
                            tf.cast(y, dtype='int32'))
    resize_fn = lambda X, y: (tf.image.resize_with_pad(X, *self.resize), y)
    shuffle_buf = len(data[0]) if train else 1
    if tab.selected('tensorflow'):
        return tf.data.Dataset.from_tensor_slices(process(*data)).batch(
            self.batch_size).map(resize_fn).shuffle(shuffle_buf)
    if tab.selected('jax'):
        return tfds.as_numpy(
            tf.data.Dataset.from_tensor_slices(process(*data)).batch(
                self.batch_size).map(resize_fn).shuffle(shuffle_buf))
</code></pre>
<p>To see how this works, let's load a minibatch of images by invoking the <code>train_dataloader</code> method. It contains 64 images.</p>
<pre><code class="language-{.python .input}">%%tab all
X, y = next(iter(data.train_dataloader()))
print(X.shape, X.dtype, y.shape, y.dtype)
</code></pre>
<p>Let's look at the time it takes to read the images. Even though it is a built-in loader, it is not blazingly fast. Nonetheless, this is sufficient since processing images with a deep network takes quite a bit longer. Hence it is good enough that training a network will not be I/O constrained.</p>
<pre><code class="language-{.python .input}">%%tab all
tic = time.time()
for X, y in data.train_dataloader():
    continue
f'{time.time() - tic:.2f} sec'
</code></pre>
<h2 id="visualization"><a class="header" href="#visualization">Visualization</a></h2>
<p>We will often be using the Fashion-MNIST dataset. A convenience function <code>show_images</code> can be used to visualize the images and the associated labels.
Skipping implementation details, we just show the interface below: we only need to know how to invoke <code>d2l.show_images</code> rather than how it works
for such utility functions.</p>
<pre><code class="language-{.python .input}">%%tab all
def show_images(imgs, num_rows, num_cols, titles=None, scale=1.5):  #@save
    """Plot a list of images."""
    raise NotImplementedError
</code></pre>
<p>Let's put it to good use. In general, it is a good idea to visualize and inspect data that you are training on.
Humans are very good at spotting oddities and because of that, visualization serves as an additional safeguard against mistakes and errors in the design of experiments. Here are [<strong>the images and their corresponding labels</strong>] (in text)
for the first few examples in the training dataset.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(FashionMNIST)  #@save
def visualize(self, batch, nrows=1, ncols=8, labels=[]):
    X, y = batch
    if not labels:
        labels = self.text_labels(y)
    if tab.selected('mxnet', 'pytorch'):
        d2l.show_images(X.squeeze(1), nrows, ncols, titles=labels)
    if tab.selected('tensorflow'):
        d2l.show_images(tf.squeeze(X), nrows, ncols, titles=labels)
    if tab.selected('jax'):
        d2l.show_images(jnp.squeeze(X), nrows, ncols, titles=labels)

batch = next(iter(data.val_dataloader()))
data.visualize(batch)
</code></pre>
<p>We are now ready to work with the Fashion-MNIST dataset in the sections that follow.</p>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>We now have a slightly more realistic dataset to use for classification. Fashion-MNIST is an apparel classification dataset consisting of images representing 10 categories. We will use this dataset in subsequent sections and chapters to evaluate various network designs, from a simple linear model to advanced residual networks. As we commonly do with images, we read them as a tensor of shape (batch size, number of channels, height, width). For now, we only have one channel as the images are grayscale (the visualization above uses a false color palette for improved visibility).</p>
<p>Lastly, data iterators are a key component for efficient performance. For instance, we might use GPUs for efficient image decompression, video transcoding, or other preprocessing. Whenever possible, you should rely on well-implemented data iterators that exploit high-performance computing to avoid slowing down your training loop.</p>
<h2 id="exercises-16"><a class="header" href="#exercises-16">Exercises</a></h2>
<ol>
<li>Does reducing the <code>batch_size</code> (for instance, to 1) affect the reading performance?</li>
<li>The data iterator performance is important. Do you think the current implementation is fast enough? Explore various options to improve it. Use a system profiler to find out where the bottlenecks are.</li>
<li>Check out the framework's online API documentation. Which other datasets are available?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/48">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/49">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/224">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17980">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="the-base-classification-model"><a class="header" href="#the-base-classification-model">The Base Classification Model</a></h1>
<p>:label:<code>sec_classification</code></p>
<p>You may have noticed that the implementations from scratch and the concise implementation using framework functionality were quite similar in the case of regression. The same is true for classification. Since many models in this book deal with classification, it is worth adding functionalities to support this setting specifically. This section provides a base class for classification models to simplify future code.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, np, npx, gluon
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from functools import partial
from jax import numpy as jnp
import jax
import optax
</code></pre>
<h2 id="the-classifier-class"><a class="header" href="#the-classifier-class">The <code>Classifier</code> Class</a></h2>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
We define the <code>Classifier</code> class below. In the <code>validation_step</code> we report both the loss value and the classification accuracy on a validation batch. We draw an update for every <code>num_val_batches</code> batches. This has the benefit of generating the averaged loss and accuracy on the whole validation data. These average numbers are not exactly correct if the final batch contains fewer examples, but we ignore this minor difference to keep the code simple.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
We define the <code>Classifier</code> class below. In the <code>validation_step</code> we report both the loss value and the classification accuracy on a validation batch. We draw an update for every <code>num_val_batches</code> batches. This has the benefit of generating the averaged loss and accuracy on the whole validation data. These average numbers are not exactly correct if the last batch contains fewer examples, but we ignore this minor difference to keep the code simple.</p>
<p>We also redefine the <code>training_step</code> method for JAX since all models that will
subclass <code>Classifier</code> later will have a loss that returns auxiliary data.
This auxiliary data can be used for models with batch normalization
(to be explained in :numref:<code>sec_batch_norm</code>), while in all other cases
we will make the loss also return a placeholder (empty dictionary) to
represent the auxiliary data.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class Classifier(d2l.Module):  #@save
    """The base class of classification models."""
    def validation_step(self, batch):
        Y_hat = self(*batch[:-1])
        self.plot('loss', self.loss(Y_hat, batch[-1]), train=False)
        self.plot('acc', self.accuracy(Y_hat, batch[-1]), train=False)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Classifier(d2l.Module):  #@save
    """The base class of classification models."""
    def training_step(self, params, batch, state):
        # Here value is a tuple since models with BatchNorm layers require
        # the loss to return auxiliary data
        value, grads = jax.value_and_grad(
            self.loss, has_aux=True)(params, batch[:-1], batch[-1], state)
        l, _ = value
        self.plot("loss", l, train=True)
        return value, grads

    def validation_step(self, params, batch, state):
        # Discard the second returned value. It is used for training models
        # with BatchNorm layers since loss also returns auxiliary data
        l, _ = self.loss(params, batch[:-1], batch[-1], state)
        self.plot('loss', l, train=False)
        self.plot('acc', self.accuracy(params, batch[:-1], batch[-1], state),
                  train=False)
</code></pre>
<p>By default we use a stochastic gradient descent optimizer, operating on minibatches, just as we did in the context of linear regression.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(d2l.Module)  #@save
def configure_optimizers(self):
    params = self.parameters()
    if isinstance(params, list):
        return d2l.SGD(params, self.lr)
    return gluon.Trainer(params, 'sgd', {'learning_rate': self.lr})
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(d2l.Module)  #@save
def configure_optimizers(self):
    return torch.optim.SGD(self.parameters(), lr=self.lr)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(d2l.Module)  #@save
def configure_optimizers(self):
    return tf.keras.optimizers.SGD(self.lr)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Module)  #@save
def configure_optimizers(self):
    return optax.sgd(self.lr)
</code></pre>
<h2 id="accuracy"><a class="header" href="#accuracy">Accuracy</a></h2>
<p>Given the predicted probability distribution <code>y_hat</code>,
we typically choose the class with the highest predicted probability
whenever we must output a hard prediction.
Indeed, many applications require that we make a choice.
For instance, Gmail must categorize an email into "Primary", "Social", "Updates", "Forums", or "Spam".
It might estimate probabilities internally,
but at the end of the day it has to choose one among the classes.</p>
<p>When predictions are consistent with the label class <code>y</code>, they are correct.
The classification accuracy is the fraction of all predictions that are correct.
Although it can be difficult to optimize accuracy directly (it is not differentiable),
it is often the performance measure that we care about the most. It is often <em>the</em>
relevant quantity in benchmarks. As such, we will nearly always report it when training classifiers.</p>
<p>Accuracy is computed as follows.
First, if <code>y_hat</code> is a matrix,
we assume that the second dimension stores prediction scores for each class.
We use <code>argmax</code> to obtain the predicted class by the index for the largest entry in each row.
Then we [<strong>compare the predicted class with the ground truth <code>y</code> elementwise.</strong>]
Since the equality operator <code>==</code> is sensitive to data types,
we convert <code>y_hat</code>'s data type to match that of <code>y</code>.
The result is a tensor containing entries of 0 (false) and 1 (true).
Taking the sum yields the number of correct predictions.</p>
<pre><code class="language-{.python .input  n=9}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(Classifier)  #@save
def accuracy(self, Y_hat, Y, averaged=True):
    """Compute the number of correct predictions."""
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    preds = d2l.astype(d2l.argmax(Y_hat, axis=1), Y.dtype)
    compare = d2l.astype(preds == d2l.reshape(Y, -1), d2l.float32)
    return d2l.reduce_mean(compare) if averaged else compare
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab jax
@d2l.add_to_class(Classifier)  #@save
@partial(jax.jit, static_argnums=(0, 5))
def accuracy(self, params, X, Y, state, averaged=True):
    """Compute the number of correct predictions."""
    Y_hat = state.apply_fn({'params': params,
                            'batch_stats': state.batch_stats},  # BatchNorm Only
                           *X)
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    preds = d2l.astype(d2l.argmax(Y_hat, axis=1), Y.dtype)
    compare = d2l.astype(preds == d2l.reshape(Y, -1), d2l.float32)
    return d2l.reduce_mean(compare) if averaged else compare
</code></pre>
<pre><code class="language-{.python .input  n=10}">%%tab mxnet

@d2l.add_to_class(d2l.Module)  #@save
def get_scratch_params(self):
    params = []
    for attr in dir(self):
        a = getattr(self, attr)
        if isinstance(a, np.ndarray):
            params.append(a)
        if isinstance(a, d2l.Module):
            params.extend(a.get_scratch_params())
    return params

@d2l.add_to_class(d2l.Module)  #@save
def parameters(self):
    params = self.collect_params()
    return params if isinstance(params, gluon.parameter.ParameterDict) and len(
        params.keys()) else self.get_scratch_params()
</code></pre>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>Classification is a sufficiently common problem that it warrants its own convenience functions. Of central importance in classification is the <em>accuracy</em> of the classifier. Note that while we often care primarily about accuracy, we train classifiers to optimize a variety of other objectives for statistical and computational reasons. However, regardless of which loss function was minimized during training, it is useful to have a convenience method for assessing the accuracy of our classifier empirically.</p>
<h2 id="exercises-17"><a class="header" href="#exercises-17">Exercises</a></h2>
<ol>
<li>Denote by $L_\textrm{v}$ the validation loss, and let $L_\textrm{v}^\textrm{q}$ be its quick and dirty estimate computed by the loss function averaging in this section. Lastly, denote by $l_\textrm{v}^\textrm{b}$ the loss on the last minibatch. Express $L_\textrm{v}$ in terms of $L_\textrm{v}^\textrm{q}$, $l_\textrm{v}^\textrm{b}$, and the sample and minibatch sizes.</li>
<li>Show that the quick and dirty estimate $L_\textrm{v}^\textrm{q}$ is unbiased. That is, show that $E[L_\textrm{v}] = E[L_\textrm{v}^\textrm{q}]$. Why would you still want to use $L_\textrm{v}$ instead?</li>
<li>Given a multiclass classification loss, denoting by $l(y,y')$ the penalty of estimating $y'$ when we see $y$ and given a probabilty $p(y \mid x)$, formulate the rule for an optimal selection of $y'$. Hint: express the expected loss, using $l$ and $p(y \mid x)$.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/6808">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/6809">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/6810">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17981">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="softmax-regression-implementation-from-scratch"><a class="header" href="#softmax-regression-implementation-from-scratch">Softmax Regression Implementation from Scratch</a></h1>
<p>:label:<code>sec_softmax_scratch</code></p>
<p>Because softmax regression is so fundamental,
we believe that you ought to know
how to implement it yourself.
Here, we limit ourselves to defining the
softmax-specific aspects of the model
and reuse the other components
from our linear regression section,
including the training loop.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, np, npx, gluon
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
from functools import partial
</code></pre>
<h2 id="the-softmax-1"><a class="header" href="#the-softmax-1">The Softmax</a></h2>
<p>Let's begin with the most important part:
the mapping from scalars to probabilities.
For a refresher, recall the operation of the sum operator
along specific dimensions in a tensor,
as discussed in :numref:<code>subsec_lin-alg-reduction</code>
and :numref:<code>subsec_lin-alg-non-reduction</code>.
[<strong>Given a matrix <code>X</code> we can sum over all elements (by default) or only
over elements in the same axis.</strong>]
The <code>axis</code> variable lets us compute row and column sums:</p>
<pre><code class="language-{.python .input}">%%tab all
X = d2l.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
d2l.reduce_sum(X, 0, keepdims=True), d2l.reduce_sum(X, 1, keepdims=True)
</code></pre>
<p>Computing the softmax requires three steps:
(i) exponentiation of each term;
(ii) a sum over each row to compute the normalization constant for each example;
(iii) division of each row by its normalization constant,
ensuring that the result sums to 1:</p>
<p>(**
$$\mathrm{softmax}(\mathbf{X})<em>{ij} = \frac{\exp(\mathbf{X}</em>{ij})}{\sum_k \exp(\mathbf{X}_{ik})}.$$
**)</p>
<p>The (logarithm of the) denominator
is called the (log) <em>partition function</em>.
It was introduced in <a href="https://en.wikipedia.org/wiki/Partition_function_(statistical_mechanics)">statistical physics</a>
to sum over all possible states in a thermodynamic ensemble.
The implementation is straightforward:</p>
<pre><code class="language-{.python .input}">%%tab all
def softmax(X):
    X_exp = d2l.exp(X)
    partition = d2l.reduce_sum(X_exp, 1, keepdims=True)
    return X_exp / partition  # The broadcasting mechanism is applied here
</code></pre>
<p>For any input <code>X</code>, [<strong>we turn each element
into a nonnegative number.
Each row sums up to 1,</strong>]
as is required for a probability. Caution: the code above is <em>not</em> robust against very large or very small arguments. While it is sufficient to illustrate what is happening, you should <em>not</em> use this code verbatim for any serious purpose. Deep learning frameworks have such protections built in and we will be using the built-in softmax going forward.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
X = d2l.rand(2, 5)
X_prob = softmax(X)
X_prob, d2l.reduce_sum(X_prob, 1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, pytorch
X = d2l.rand((2, 5))
X_prob = softmax(X)
X_prob, d2l.reduce_sum(X_prob, 1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = jax.random.uniform(jax.random.PRNGKey(d2l.get_seed()), (2, 5))
X_prob = softmax(X)
X_prob, d2l.reduce_sum(X_prob, 1)
</code></pre>
<h2 id="the-model"><a class="header" href="#the-model">The Model</a></h2>
<p>We now have everything that we need
to implement [<strong>the softmax regression model.</strong>]
As in our linear regression example,
each instance will be represented
by a fixed-length vector.
Since the raw data here consists
of $28 \times 28$ pixel images,
[<strong>we flatten each image,
treating them as vectors of length 784.</strong>]
In later chapters, we will introduce
convolutional neural networks,
which exploit the spatial structure
in a more satisfying way.</p>
<p>In softmax regression,
the number of outputs from our network
should be equal to the number of classes.
(<strong>Since our dataset has 10 classes,
our network has an output dimension of 10.</strong>)
Consequently, our weights constitute a $784 \times 10$ matrix
plus a $1 \times 10$ row vector for the biases.
As with linear regression,
we initialize the weights <code>W</code>
with Gaussian noise.
The biases are initialized as zeros.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class SoftmaxRegressionScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W = np.random.normal(0, sigma, (num_inputs, num_outputs))
        self.b = np.zeros(num_outputs)
        self.W.attach_grad()
        self.b.attach_grad()

    def collect_params(self):
        return [self.W, self.b]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class SoftmaxRegressionScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W = torch.normal(0, sigma, size=(num_inputs, num_outputs),
                              requires_grad=True)
        self.b = torch.zeros(num_outputs, requires_grad=True)

    def parameters(self):
        return [self.W, self.b]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class SoftmaxRegressionScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W = tf.random.normal((num_inputs, num_outputs), 0, sigma)
        self.b = tf.zeros(num_outputs)
        self.W = tf.Variable(self.W)
        self.b = tf.Variable(self.b)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class SoftmaxRegressionScratch(d2l.Classifier):
    num_inputs: int
    num_outputs: int
    lr: float
    sigma: float = 0.01

    def setup(self):
        self.W = self.param('W', nn.initializers.normal(self.sigma),
                            (self.num_inputs, self.num_outputs))
        self.b = self.param('b', nn.initializers.zeros, self.num_outputs)
</code></pre>
<p>The code below defines how the network
maps each input to an output.
Note that we flatten each $28 \times 28$ pixel image in the batch
into a vector using <code>reshape</code>
before passing the data through our model.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(SoftmaxRegressionScratch)
def forward(self, X):
    X = d2l.reshape(X, (-1, self.W.shape[0]))
    return softmax(d2l.matmul(X, self.W) + self.b)
</code></pre>
<h2 id="the-cross-entropy-loss"><a class="header" href="#the-cross-entropy-loss">The Cross-Entropy Loss</a></h2>
<p>Next we need to implement the cross-entropy loss function
(introduced in :numref:<code>subsec_softmax-regression-loss-func</code>).
This may be the most common loss function
in all of deep learning.
At the moment, applications of deep learning
easily cast as classification problems
far outnumber those better treated as regression problems.</p>
<p>Recall that cross-entropy takes the negative log-likelihood
of the predicted probability assigned to the true label.
For efficiency we avoid Python for-loops and use indexing instead.
In particular, the one-hot encoding in $\mathbf{y}$
allows us to select the matching terms in $\hat{\mathbf{y}}$.</p>
<p>To see this in action we [<strong>create sample data <code>y_hat</code>
with 2 examples of predicted probabilities over 3 classes and their corresponding labels <code>y</code>.</strong>]
The correct labels are $0$ and $2$ respectively (i.e., the first and third class).
[<strong>Using <code>y</code> as the indices of the probabilities in <code>y_hat</code>,</strong>]
we can pick out terms efficiently.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
y = d2l.tensor([0, 2])
y_hat = d2l.tensor([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]])
y_hat[[0, 1], y]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
y_hat = tf.constant([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]])
y = tf.constant([0, 2])
tf.boolean_mask(y_hat, tf.one_hot(y, depth=y_hat.shape[-1]))
</code></pre>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
Now we can (<strong>implement the cross-entropy loss function</strong>) by averaging over the logarithms of the selected probabilities.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Now we can (<strong>implement the cross-entropy loss function</strong>) by averaging over the logarithms of the selected probabilities.</p>
<p>Note that to make use of <code>jax.jit</code> to speed up JAX implementations, and
to make sure <code>loss</code> is a pure function, the <code>cross_entropy</code> function is re-defined
inside the <code>loss</code> to avoid usage of any global variables or functions
which may render the <code>loss</code> function impure.
We refer interested readers to the <a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions">JAX documentation</a> on <code>jax.jit</code> and pure functions.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
def cross_entropy(y_hat, y):
    return -d2l.reduce_mean(d2l.log(y_hat[list(range(len(y_hat))), y]))

cross_entropy(y_hat, y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def cross_entropy(y_hat, y):
    return -tf.reduce_mean(tf.math.log(tf.boolean_mask(
        y_hat, tf.one_hot(y, depth=y_hat.shape[-1]))))

cross_entropy(y_hat, y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(SoftmaxRegressionScratch)
def loss(self, y_hat, y):
    return cross_entropy(y_hat, y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(SoftmaxRegressionScratch)
@partial(jax.jit, static_argnums=(0))
def loss(self, params, X, y, state):
    def cross_entropy(y_hat, y):
        return -d2l.reduce_mean(d2l.log(y_hat[list(range(len(y_hat))), y]))
    y_hat = state.apply_fn({'params': params}, *X)
    # The returned empty dictionary is a placeholder for auxiliary data,
    # which will be used later (e.g., for batch norm)
    return cross_entropy(y_hat, y), {}
</code></pre>
<h2 id="training-3"><a class="header" href="#training-3">Training</a></h2>
<p>We reuse the <code>fit</code> method defined in :numref:<code>sec_linear_scratch</code> to [<strong>train the model with 10 epochs.</strong>]
Note that the number of epochs (<code>max_epochs</code>),
the minibatch size (<code>batch_size</code>),
and learning rate (<code>lr</code>)
are adjustable hyperparameters.
That means that while these values are not
learned during our primary training loop,
they still influence the performance
of our model, both vis-à-vis training
and generalization performance.
In practice you will want to choose these values
based on the <em>validation</em> split of the data
and then, ultimately, to evaluate your final model
on the <em>test</em> split.
As discussed in :numref:<code>subsec_generalization-model-selection</code>,
we will regard the test data of Fashion-MNIST
as the validation set, thus
reporting validation loss and validation accuracy
on this split.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.FashionMNIST(batch_size=256)
model = SoftmaxRegressionScratch(num_inputs=784, num_outputs=10, lr=0.1)
trainer = d2l.Trainer(max_epochs=10)
trainer.fit(model, data)
</code></pre>
<h2 id="prediction"><a class="header" href="#prediction">Prediction</a></h2>
<p>Now that training is complete,
our model is ready to [<strong>classify some images.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
X, y = next(iter(data.val_dataloader()))
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    preds = d2l.argmax(model(X), axis=1)
if tab.selected('jax'):
    preds = d2l.argmax(model.apply({'params': trainer.state.params}, X), axis=1)
preds.shape
</code></pre>
<p>We are more interested in the images we label <em>incorrectly</em>. We visualize them by
comparing their actual labels
(first line of text output)
with the predictions from the model
(second line of text output).</p>
<pre><code class="language-{.python .input}">%%tab all
wrong = d2l.astype(preds, y.dtype) != y
X, y, preds = X[wrong], y[wrong], preds[wrong]
labels = [a+'\n'+b for a, b in zip(
    data.text_labels(y), data.text_labels(preds))]
data.visualize([X, y], labels=labels)
</code></pre>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>By now we are starting to get some experience
with solving linear regression
and classification problems.
With it, we have reached what would arguably be
the state of the art of 1960--1970s of statistical modeling.
In the next section, we will show you how to leverage
deep learning frameworks to implement this model
much more efficiently.</p>
<h2 id="exercises-18"><a class="header" href="#exercises-18">Exercises</a></h2>
<ol>
<li>In this section, we directly implemented the softmax function based on the mathematical definition of the softmax operation. As discussed in :numref:<code>sec_softmax</code> this can cause numerical instabilities.
<ol>
<li>Test whether <code>softmax</code> still works correctly if an input has a value of $100$.</li>
<li>Test whether <code>softmax</code> still works correctly if the largest of all inputs is smaller than $-100$.</li>
<li>Implement a fix by looking at the value relative to the largest entry in the argument.</li>
</ol>
</li>
<li>Implement a <code>cross_entropy</code> function that follows the definition of the cross-entropy loss function $\sum_i y_i \log \hat{y}_i$.
<ol>
<li>Try it out in the code example of this section.</li>
<li>Why do you think it runs more slowly?</li>
<li>Should you use it? When would it make sense to?</li>
<li>What do you need to be careful of? Hint: consider the domain of the logarithm.</li>
</ol>
</li>
<li>Is it always a good idea to return the most likely label? For example, would you do this for medical diagnosis? How would you try to address this?</li>
<li>Assume that we want to use softmax regression to predict the next word based on some features. What are some problems that might arise from a large vocabulary?</li>
<li>Experiment with the hyperparameters of the code in this section. In particular:
<ol>
<li>Plot how the validation loss changes as you change the learning rate.</li>
<li>Do the validation and training loss change as you change the minibatch size? How large or small do you need to go before you see an effect?</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/50">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/51">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/225">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17982">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="concise-implementation-of-softmax-regression"><a class="header" href="#concise-implementation-of-softmax-regression">Concise Implementation of Softmax Regression</a></h1>
<p>:label:<code>sec_softmax_concise</code></p>
<p>Just as high-level deep learning frameworks
made it easier to implement linear regression
(see :numref:<code>sec_linear_concise</code>),
they are similarly convenient here.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, init, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from functools import partial
import jax
from jax import numpy as jnp
import optax
</code></pre>
<h2 id="defining-the-model-3"><a class="header" href="#defining-the-model-3">Defining the Model</a></h2>
<p>As in :numref:<code>sec_linear_concise</code>,
we construct our fully connected layer
using the built-in layer.
The built-in <code>__call__</code> method then invokes <code>forward</code>
whenever we need to apply the network to some input.</p>
<p>:begin_tab:<code>mxnet</code>
Even though the input <code>X</code> is a fourth-order tensor,
the built-in <code>Dense</code> layer
will automatically convert <code>X</code> into a second-order tensor
by keeping the dimensionality along the first axis unchanged.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
We use a <code>Flatten</code> layer to convert the fourth-order tensor <code>X</code> to second order
by keeping the dimensionality along the first axis unchanged.</p>
<p>:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
We use a <code>Flatten</code> layer to convert the fourth-order tensor <code>X</code>
by keeping the dimension along the first axis unchanged.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Flax allows users to write the network class in a more compact way
using <code>@nn.compact</code> dectorator. With <code>@nn.compact</code>, one
can simply write all network logic inside a single “forward pass”
method, without needing to define the standard <code>setup</code> method in
the dataclass.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class SoftmaxRegression(d2l.Classifier):  #@save
    """The softmax regression model."""
    def __init__(self, num_outputs, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential(nn.Flatten(),
                                 nn.LazyLinear(num_outputs))

    def forward(self, X):
        return self.net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
class SoftmaxRegression(d2l.Classifier):  #@save
    """The softmax regression model."""
    def __init__(self, num_outputs, lr):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Dense(num_outputs)
            self.net.initialize()
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential()
            self.net.add(tf.keras.layers.Flatten())
            self.net.add(tf.keras.layers.Dense(num_outputs))

    def forward(self, X):
        return self.net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class SoftmaxRegression(d2l.Classifier):  #@save
    num_outputs: int
    lr: float

    @nn.compact
    def __call__(self, X):
        X = X.reshape((X.shape[0], -1))  # Flatten
        X = nn.Dense(self.num_outputs)(X)
        return X
</code></pre>
<h2 id="softmax-revisited"><a class="header" href="#softmax-revisited">Softmax Revisited</a></h2>
<p>:label:<code>subsec_softmax-implementation-revisited</code></p>
<p>In :numref:<code>sec_softmax_scratch</code> we calculated our model's output
and applied the cross-entropy loss. While this is perfectly
reasonable mathematically, it is risky computationally, because of
numerical underflow and overflow in the exponentiation.</p>
<p>Recall that the softmax function computes probabilities via
$\hat y_j = \frac{\exp(o_j)}{\sum_k \exp(o_k)}$.
If some of the $o_k$ are very large, i.e., very positive,
then $\exp(o_k)$ might be larger than the largest number
we can have for certain data types. This is called <em>overflow</em>. Likewise,
if every argument is a very large negative number, we will get <em>underflow</em>.
For instance, single precision floating point numbers approximately
cover the range of $10^{-38}$ to $10^{38}$. As such, if the largest term in $\mathbf{o}$
lies outside the interval $[-90, 90]$, the result will not be stable.
A way round this problem is to subtract $\bar{o} \stackrel{\textrm{def}}{=} \max_k o_k$ from
all entries:</p>
<p>$$
\hat y_j = \frac{\exp o_j}{\sum_k \exp o_k} =
\frac{\exp(o_j - \bar{o}) \exp \bar{o}}{\sum_k \exp (o_k - \bar{o}) \exp \bar{o}} =
\frac{\exp(o_j - \bar{o})}{\sum_k \exp (o_k - \bar{o})}.
$$</p>
<p>By construction we know that $o_j - \bar{o} \leq 0$ for all $j$. As such, for a $q$-class
classification problem, the denominator is contained in the interval $[1, q]$. Moreover, the
numerator never exceeds $1$, thus preventing numerical overflow. Numerical underflow only
occurs when $\exp(o_j - \bar{o})$ numerically evaluates as $0$. Nonetheless, a few steps down
the road we might find ourselves in trouble when we want to compute $\log \hat{y}_j$ as $\log 0$.
In particular, in backpropagation,
we might find ourselves faced with a screenful
of the dreaded <code>NaN</code> (Not a Number) results.</p>
<p>Fortunately, we are saved by the fact that
even though we are computing exponential functions,
we ultimately intend to take their log
(when calculating the cross-entropy loss).
By combining softmax and cross-entropy,
we can escape the numerical stability issues altogether. We have:</p>
<p>$$
\log \hat{y}_j =
\log \frac{\exp(o_j - \bar{o})}{\sum_k \exp (o_k - \bar{o})} =
o_j - \bar{o} - \log \sum_k \exp (o_k - \bar{o}).
$$</p>
<p>This avoids both overflow and underflow.
We will want to keep the conventional softmax function handy
in case we ever want to evaluate the output probabilities by our model.
But instead of passing softmax probabilities into our new loss function,
we just
[<strong>pass the logits and compute the softmax and its log
all at once inside the cross-entropy loss function,</strong>]
which does smart things like the <a href="https://en.wikipedia.org/wiki/LogSumExp">"LogSumExp trick"</a>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(d2l.Classifier)  #@save
def loss(self, Y_hat, Y, averaged=True):
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    Y = d2l.reshape(Y, (-1,))
    if tab.selected('mxnet'):
        fn = gluon.loss.SoftmaxCrossEntropyLoss()
        l = fn(Y_hat, Y)
        return l.mean() if averaged else l
    if tab.selected('pytorch'):
        return F.cross_entropy(
            Y_hat, Y, reduction='mean' if averaged else 'none')
    if tab.selected('tensorflow'):
        fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)
        return fn(Y, Y_hat)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Classifier)  #@save
@partial(jax.jit, static_argnums=(0, 5))
def loss(self, params, X, Y, state, averaged=True):
    # To be used later (e.g., for batch norm)
    Y_hat = state.apply_fn({'params': params}, *X,
                           mutable=False, rngs=None)
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    Y = d2l.reshape(Y, (-1,))
    fn = optax.softmax_cross_entropy_with_integer_labels
    # The returned empty dictionary is a placeholder for auxiliary data,
    # which will be used later (e.g., for batch norm)
    return (fn(Y_hat, Y).mean(), {}) if averaged else (fn(Y_hat, Y), {})
</code></pre>
<h2 id="training-4"><a class="header" href="#training-4">Training</a></h2>
<p>Next we train our model. We use Fashion-MNIST images, flattened to 784-dimensional feature vectors.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.FashionMNIST(batch_size=256)
model = SoftmaxRegression(num_outputs=10, lr=0.1)
trainer = d2l.Trainer(max_epochs=10)
trainer.fit(model, data)
</code></pre>
<p>As before, this algorithm converges to a solution
that is reasonably accurate,
albeit this time with fewer lines of code than before.</p>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>High-level APIs are very convenient at hiding from their user potentially dangerous aspects, such as numerical stability. Moreover, they allow users to design models concisely with very few lines of code. This is both a blessing and a curse. The obvious benefit is that it makes things highly accessible, even to engineers who never took a single class of statistics in their life (in fact, they are part of the target audience of the book). But hiding the sharp edges also comes with a price: a disincentive to add new and different components on your own, since there is little muscle memory for doing it. Moreover, it makes it more difficult to <em>fix</em> things whenever the protective padding of
a framework fails to cover all the corner cases entirely. Again, this is due to lack of familiarity.</p>
<p>As such, we strongly urge you to review <em>both</em> the bare bones and the elegant versions of many of the implementations that follow. While we emphasize ease of understanding, the implementations are nonetheless usually quite performant (convolutions are the big exception here). It is our intention to allow you to build on these when you invent something new that no framework can give you.</p>
<h2 id="exercises-19"><a class="header" href="#exercises-19">Exercises</a></h2>
<ol>
<li>Deep learning uses many different number formats, including FP64 double precision (used extremely rarely),
FP32 single precision, BFLOAT16 (good for compressed representations), FP16 (very unstable), TF32 (a new format from NVIDIA), and INT8. Compute the smallest and largest argument of the exponential function for which the result does not lead to numerical underflow or overflow.</li>
<li>INT8 is a very limited format consisting of nonzero numbers from $1$ to $255$. How could you extend its dynamic range without using more bits? Do standard multiplication and addition still work?</li>
<li>Increase the number of epochs for training. Why might the validation accuracy decrease after a while? How could we fix this?</li>
<li>What happens as you increase the learning rate? Compare the loss curves for several learning rates. Which one works better? When?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/52">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/53">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/260">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17983">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalization-in-classification"><a class="header" href="#generalization-in-classification">Generalization in Classification</a></h1>
<p>:label:<code>chap_classification_generalization</code></p>
<p>So far, we have focused on how to tackle multiclass classification problems
by training (linear) neural networks with multiple outputs and softmax functions.
Interpreting our model's outputs as probabilistic predictions,
we motivated and derived the cross-entropy loss function,
which calculates the negative log likelihood
that our model (for a fixed set of parameters)
assigns to the actual labels.
And finally, we put these tools into practice
by fitting our model to the training set.
However, as always, our goal is to learn <em>general patterns</em>,
as assessed empirically on previously unseen data (the test set).
High accuracy on the training set means nothing.
Whenever each of our inputs is unique
(and indeed this is true for most high-dimensional datasets),
we can attain perfect accuracy on the training set
by just memorizing the dataset on the first training epoch,
and subsequently looking up the label whenever we see a new image.
And yet, memorizing the exact labels
associated with the exact training examples
does not tell us how to classify new examples.
Absent further guidance, we might have to fall back
on random guessing whenever we encounter new examples.</p>
<p>A number of burning questions demand immediate attention:</p>
<ol>
<li>How many test examples do we need to give a good estimate of the accuracy of our classifiers on the underlying population?</li>
<li>What happens if we keep evaluating models on the same test repeatedly?</li>
<li>Why should we expect that fitting our linear models to the training set
should fare any better than our naive memorization scheme?</li>
</ol>
<p>Whereas :numref:<code>sec_generalization_basics</code> introduced
the basics of overfitting and generalization
in the context of linear regression,
this chapter will go a little deeper,
introducing some of the foundational ideas
of statistical learning theory.
It turns out that we often can guarantee generalization <em>a priori</em>:
for many models,
and for any desired upper bound
on the generalization gap $\epsilon$,
we can often determine some required number of samples $n$
such that if our training set contains at least $n$
samples, our empirical error will lie
within $\epsilon$ of the true error,
<em>for any data generating distribution</em>.
Unfortunately, it also turns out
that while these sorts of guarantees provide
a profound set of intellectual building blocks,
they are of limited practical utility
to the deep learning practitioner.
In short, these guarantees suggest
that ensuring generalization
of deep neural networks <em>a priori</em>
requires an absurd number of examples
(perhaps trillions or more),
even when we find that, on the tasks we care about,
deep neural networks typically generalize
remarkably well with far fewer examples (thousands).
Thus deep learning practitioners often forgo
<em>a priori</em> guarantees altogether,
instead employing methods
that have generalized well
on similar problems in the past,
and certifying generalization <em>post hoc</em>
through empirical evaluations.
When we get to :numref:<code>chap_perceptrons</code>,
we will revisit generalization
and provide a light introduction
to the vast scientific literature
that has sprung in attempts
to explain why deep neural networks generalize in practice.</p>
<h2 id="the-test-set"><a class="header" href="#the-test-set">The Test Set</a></h2>
<p>Since we have already begun to rely on test sets
as the gold standard method
for assessing generalization error,
let's get started by discussing
the properties of such error estimates.
Let's focus on a fixed classifier $f$,
without worrying about how it was obtained.
Moreover suppose that we possess
a <em>fresh</em> dataset of examples $\mathcal{D} = {(\mathbf{x}^{(i)},y^{(i)})}_{i=1}^n$
that were not used to train the classifier $f$.
The <em>empirical error</em> of our classifier $f$ on $\mathcal{D}$
is simply the fraction of instances
for which the prediction $f(\mathbf{x}^{(i)})$
disagrees with the true label $y^{(i)}$,
and is given by the following expression:</p>
<p>$$\epsilon_\mathcal{D}(f) = \frac{1}{n}\sum_{i=1}^n \mathbf{1}(f(\mathbf{x}^{(i)}) \neq y^{(i)}).$$</p>
<p>By contrast, the <em>population error</em>
is the <em>expected</em> fraction
of examples in the underlying population
(some distribution $P(X,Y)$  characterized
by probability density function $p(\mathbf{x},y)$)
for which our classifier disagrees
with the true label:</p>
<p>$$\epsilon(f) =  E_{(\mathbf{x}, y) \sim P} \mathbf{1}(f(\mathbf{x}) \neq y) =
\int\int \mathbf{1}(f(\mathbf{x}) \neq y) p(\mathbf{x}, y) ;d\mathbf{x} dy.$$</p>
<p>While $\epsilon(f)$ is the quantity that we actually care about,
we cannot observe it directly,
just as we cannot directly
observe the average height in a large population
without measuring every single person.
We can only estimate this quantity based on samples.
Because our test set $\mathcal{D}$
is statistically representative
of the underlying population,
we can view $\epsilon_\mathcal{D}(f)$ as a statistical
estimator of the population error $\epsilon(f)$.
Moreover, because our quantity of interest $\epsilon(f)$
is an expectation (of the random variable $\mathbf{1}(f(X) \neq Y)$)
and the corresponding estimator $\epsilon_\mathcal{D}(f)$
is the sample average,
estimating the population error
is simply the classic problem of mean estimation,
which you may recall from :numref:<code>sec_prob</code>.</p>
<p>An important classical result from probability theory
called the <em>central limit theorem</em> guarantees
that whenever we possess $n$ random samples $a_1, ..., a_n$
drawn from any distribution with mean $\mu$ and standard deviation $\sigma$,
then, as the number of samples $n$ approaches infinity,
the sample average $\hat{\mu}$ approximately
tends towards a normal distribution centered
at the true mean and with standard deviation $\sigma/\sqrt{n}$.
Already, this tells us something important:
as the number of examples grows large,
our test error $\epsilon_\mathcal{D}(f)$
should approach the true error $\epsilon(f)$
at a rate of $\mathcal{O}(1/\sqrt{n})$.
Thus, to estimate our test error twice as precisely,
we must collect four times as large a test set.
To reduce our test error by a factor of one hundred,
we must collect ten thousand times as large a test set.
In general, such a rate of $\mathcal{O}(1/\sqrt{n})$
is often the best we can hope for in statistics.</p>
<p>Now that we know something about the asymptotic rate
at which our test error $\epsilon_\mathcal{D}(f)$ converges to the true error $\epsilon(f)$,
we can zoom in on some important details.
Recall that the random variable of interest
$\mathbf{1}(f(X) \neq Y)$
can only take values $0$ and $1$
and thus is a Bernoulli random variable,
characterized by a parameter
indicating the probability that it takes value $1$.
Here, $1$ means that our classifier made an error,
so the parameter of our random variable
is actually the true error rate $\epsilon(f)$.
The variance $\sigma^2$ of a Bernoulli
depends on its parameter (here, $\epsilon(f)$)
according to the expression $\epsilon(f)(1-\epsilon(f))$.
While $\epsilon(f)$ is initially unknown,
we know that it cannot be greater than $1$.
A little investigation of this function
reveals that our variance is highest
when the true error rate is close to $0.5$
and can be far lower when it is
close to $0$ or close to $1$.
This tells us that the asymptotic standard deviation
of our estimate $\epsilon_\mathcal{D}(f)$ of the error $\epsilon(f)$
(over the choice of the $n$ test samples)
cannot be any greater than $\sqrt{0.25/n}$.</p>
<p>If we ignore the fact that this rate characterizes
behavior as the test set size approaches infinity
rather than when we possess finite samples,
this tells us that if we want our test error $\epsilon_\mathcal{D}(f)$
to approximate the population error $\epsilon(f)$
such that one standard deviation corresponds
to an interval of $\pm 0.01$,
then we should collect roughly 2500 samples.
If we want to fit two standard deviations
in that range and thus be 95% confident
that $\epsilon_\mathcal{D}(f) \in \epsilon(f) \pm 0.01$,
then we will need 10,000 samples!</p>
<p>This turns out to be the size of the test sets
for many popular benchmarks in machine learning.
You might be surprised to find out that thousands
of applied deep learning papers get published every year
making a big deal out of error rate improvements of $0.01$ or less.
Of course, when the error rates are much closer to $0$,
then an improvement of $0.01$ can indeed be a big deal.</p>
<p>One pesky feature of our analysis thus far
is that it really only tells us about asymptotics,
i.e., how the relationship between $\epsilon_\mathcal{D}$ and $\epsilon$
evolves as our sample size goes to infinity.
Fortunately, because our random variable is bounded,
we can obtain valid finite sample bounds
by applying an inequality due to Hoeffding (1963):</p>
<p>$$P(\epsilon_\mathcal{D}(f) - \epsilon(f) \geq t) &lt; \exp\left( - 2n t^2 \right).$$</p>
<p>Solving for the smallest dataset size
that would allow us to conclude
with 95% confidence that the distance $t$
between our estimate $\epsilon_\mathcal{D}(f)$
and the true error rate $\epsilon(f)$
does not exceed $0.01$,
you will find that roughly 15,000 examples are required
as compared to the 10,000 examples suggested
by the asymptotic analysis above.
If you go deeper into statistics
you will find that this trend holds generally.
Guarantees that hold even in finite samples
are typically slightly more conservative.
Note that in the scheme of things,
these numbers are not so far apart,
reflecting the general usefulness
of asymptotic analysis for giving
us ballpark figures even if they are not
guarantees we can take to court.</p>
<h2 id="test-set-reuse"><a class="header" href="#test-set-reuse">Test Set Reuse</a></h2>
<p>In some sense, you are now set up to succeed
at conducting empirical machine learning research.
Nearly all practical models are developed
and validated based on test set performance
and you are now a master of the test set.
For any fixed classifier $f$,
you know how to evaluate its test error $\epsilon_\mathcal{D}(f)$,
and know precisely what can (and cannot)
be said about its population error $\epsilon(f)$.</p>
<p>So let's say that you take this knowledge
and prepare to train your first model $f_1$.
Knowing just how confident you need to be
in the performance of your classifier's error rate
you apply our analysis above to determine
an appropriate number of examples
to set aside for the test set.
Moreover, let's assume that you took the lessons from
:numref:<code>sec_generalization_basics</code> to heart
and made sure to preserve the sanctity of the test set
by conducting all of your preliminary analysis,
hyperparameter tuning, and even selection
among multiple competing model architectures
on a validation set.
Finally you evaluate your model $f_1$
on the test set and report an unbiased
estimate of the population error
with an associated confidence interval.</p>
<p>So far everything seems to be going well.
However, that night you wake up at 3am
with a brilliant idea for a new modeling approach.
The next day, you code up your new model,
tune its hyperparameters on the validation set
and not only are you getting your new model $f_2$ to work
but its error rate appears to be much lower than $f_1$'s.
However, the thrill of discovery suddenly fades
as you prepare for the final evaluation.
You do not have a test set!</p>
<p>Even though the original test set $\mathcal{D}$
is still sitting on your server,
you now face two formidable problems.
First, when you collected your test set,
you determined the required level of precision
under the assumption that you were evaluating
a single classifier $f$.
However, if you get into the business
of evaluating multiple classifiers $f_1, ..., f_k$
on the same test set,
you must consider the problem of false discovery.
Before, you might have been 95% sure
that $\epsilon_\mathcal{D}(f) \in \epsilon(f) \pm 0.01$
for a single classifier $f$
and thus the probability of a misleading result
was a mere 5%.
With $k$ classifiers in the mix,
it can be hard to guarantee
that there is not even one among them
whose test set performance is misleading.
With 20 classifiers under consideration,
you might have no power at all
to rule out the possibility
that at least one among them
received a misleading score.
This problem relates to multiple hypothesis testing,
which despite a vast literature in statistics,
remains a persistent problem plaguing scientific research.</p>
<p>If that is not enough to worry you,
there is a special reason to distrust
the results that you get on subsequent evaluations.
Recall that our analysis of test set performance
rested on the assumption that the classifier
was chosen absent any contact with the test set
and thus we could view the test set
as drawn randomly from the underlying population.
Here, not only are you testing multiple functions,
the subsequent function $f_2$ was chosen
after you observed the test set performance of $f_1$.
Once information from the test set has leaked to the modeler,
it can never be a true test set again in the strictest sense.
This problem is called <em>adaptive overfitting</em> and has recently emerged
as a topic of intense interest to learning theorists and statisticians
:cite:<code>dwork2015preserving</code>.
Fortunately, while it is possible
to leak all information out of a holdout set,
and the theoretical worst case scenarios are bleak,
these analyses may be too conservative.
In practice, take care to create real test sets,
to consult them as infrequently as possible,
to account for multiple hypothesis testing
when reporting confidence intervals,
and to dial up your vigilance more aggressively
when the stakes are high and your dataset size is small.
When running a series of benchmark challenges,
it is often good practice to maintain
several test sets so that after each round,
the old test set can be demoted to a validation set.</p>
<h2 id="statistical-learning-theory"><a class="header" href="#statistical-learning-theory">Statistical Learning Theory</a></h2>
<p>Put simply, <em>test sets are all that we really have</em>,
and yet this fact seems strangely unsatisfying.
First, we seldom possess a <em>true test set</em>---unless
we are the ones creating the dataset,
someone else has probably already evaluated
their own classifier on our ostensible "test set".
And even when we have first dibs,
we soon find ourselves frustrated, wishing we could
evaluate our subsequent modeling attempts
without the gnawing feeling
that we cannot trust our numbers.
Moreover, even a true test set can only tell us <em>post hoc</em>
whether a classifier has in fact generalized to the population,
not whether we have any reason to expect <em>a priori</em>
that it should generalize.</p>
<p>With these misgivings in mind,
you might now be sufficiently primed
to see the appeal of <em>statistical learning theory</em>,
the mathematical subfield of machine learning
whose practitioners aim to elucidate the
fundamental principles that explain
why/when models trained on empirical data
can/will generalize to unseen data.
One of the primary aims
of statistical learning researchers
has been to bound the generalization gap,
relating the properties of the model class
to the number of samples in the dataset.</p>
<p>Learning theorists aim to bound the difference
between the <em>empirical error</em> $\epsilon_\mathcal{S}(f_\mathcal{S})$
of a learned classifier $f_\mathcal{S}$,
both trained and evaluated
on the training set $\mathcal{S}$,
and the true error $\epsilon(f_\mathcal{S})$
of that same classifier on the underlying population.
This might look similar to the evaluation problem
that we just addressed but there is a major difference.
Earlier, the classifier $f$ was fixed
and we only needed a dataset
for evaluative purposes.
And indeed, any fixed classifier does generalize:
its error on a (previously unseen) dataset
is an unbiased estimate of the population error.
But what can we say when a classifier
is trained and evaluated on the same dataset?
Can we ever be confident that the training error
will be close to the testing error?</p>
<p>Suppose that our learned classifier $f_\mathcal{S}$ must be chosen
from some pre-specified set of functions $\mathcal{F}$.
Recall from our discussion of test sets
that while it is easy to estimate
the error of a single classifier,
things get hairy when we begin
to consider collections of classifiers.
Even if the empirical error
of any one (fixed) classifier
will be close to its true error
with high probability,
once we consider a collection of classifiers,
we need to worry about the possibility
that <em>just one</em> of them
will receive a badly estimated error.
The worry is that we might pick such a classifier
and thereby grossly underestimate
the population error.
Moreover, even for linear models,
because their parameters are continuously valued,
we are typically choosing from
an infinite class of functions ($|\mathcal{F}| = \infty$).</p>
<p>One ambitious solution to the problem
is to develop analytic tools
for proving uniform convergence, i.e.,
that with high probability,
the empirical error rate for every classifier in the class $f\in\mathcal{F}$
will <em>simultaneously</em> converge to its true error rate.
In other words, we seek a theoretical principle
that would allow us to state that
with probability at least $1-\delta$
(for some small $\delta$)
no classifier's error rate $\epsilon(f)$
(among all classifiers in the class $\mathcal{F}$)
will be misestimated by more
than some  small amount $\alpha$.
Clearly, we cannot make such statements
for all model classes $\mathcal{F}$.
Recall the class of memorization machines
that always achieve empirical error $0$
but never outperform random guessing
on the underlying population.</p>
<p>In a sense the class of memorizers is too flexible.
No such a uniform convergence result could possibly hold.
On the other hand, a fixed classifier is useless---it
generalizes perfectly, but fits neither
the training data nor the test data.
The central question of learning
has thus historically been framed as a trade-off
between more flexible (higher variance) model classes
that better fit the training data but risk overfitting,
versus more rigid (higher bias) model classes
that generalize well but risk underfitting.
A central question in learning theory
has been to develop the appropriate
mathematical analysis to quantify
where a model sits along this spectrum,
and to provide the associated guarantees.</p>
<p>In a series of seminal papers,
Vapnik and Chervonenkis extended
the theory on the convergence
of relative frequencies
to more general classes of functions
:cite:<code>VapChe64,VapChe68,VapChe71,VapChe74b,VapChe81,VapChe91</code>.
One of the key contributions of this line of work
is the Vapnik--Chervonenkis (VC) dimension,
which measures (one notion of)
the complexity (flexibility) of a model class.
Moreover, one of their key results bounds
the difference between the empirical error
and the population error as a function
of the VC dimension and the number of samples:</p>
<p>$$P\left(R[p, f] - R_\textrm{emp}[\mathbf{X}, \mathbf{Y}, f] &lt; \alpha\right) \geq 1-\delta
\ \textrm{ for }\ \alpha \geq c \sqrt{(\textrm{VC} - \log \delta)/n}.$$</p>
<p>Here $\delta &gt; 0$ is the probability that the bound is violated,
$\alpha$ is the upper bound on the generalization gap,
and $n$ is the dataset size.
Lastly, $c &gt; 0$ is a constant that depends
only on the scale of the loss that can be incurred.
One use of the bound might be to plug in desired
values of $\delta$ and $\alpha$
to determine how many samples to collect.
The VC dimension quantifies the largest
number of data points for which we can assign
any arbitrary (binary) labeling
and for each find some model $f$ in the class
that agrees with that labeling.
For example, linear models on $d$-dimensional inputs
have VC dimension $d+1$.
It is easy to see that a line can assign
any possible labeling to three points in two dimensions,
but not to four.
Unfortunately, the theory tends to be
overly pessimistic for more complex models
and obtaining this guarantee typically requires
far more examples than are actually needed
to achieve the desired error rate.
Note also that fixing the model class and $\delta$,
our error rate again decays
with the usual $\mathcal{O}(1/\sqrt{n})$ rate.
It seems unlikely that we could do better in terms of $n$.
However, as we vary the model class,
VC dimension can present
a pessimistic picture
of the generalization gap.</p>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<p>The most straightforward way to evaluate a model
is to consult a test set comprised of previously unseen data.
Test set evaluations provide an unbiased estimate of the true error
and converge at the desired $\mathcal{O}(1/\sqrt{n})$ rate as the test set grows.
We can provide approximate confidence intervals
based on exact asymptotic distributions
or valid finite sample confidence intervals
based on (more conservative) finite sample guarantees.
Indeed test set evaluation is the bedrock
of modern machine learning research.
However, test sets are seldom true test sets
(used by multiple researchers again and again).
Once the same test set is used
to evaluate multiple models,
controlling for false discovery can be difficult.
This can cause huge problems in theory.
In practice, the significance of the problem
depends on the size of the holdout sets in question
and whether they are merely being used to choose hyperparameters
or if they are leaking information more directly.
Nevertheless, it is good practice to curate real test sets (or multiple)
and to be as conservative as possible about how often they are used.</p>
<p>Hoping to provide a more satisfying solution,
statistical learning theorists have developed methods
for guaranteeing uniform convergence over a model class.
If indeed every model's empirical error simultaneously
converges to its true error,
then we are free to choose the model that performs
best, minimizing the training error,
knowing that it too will perform similarly well
on the holdout data.
Crucially, any one of such results must depend
on some property of the model class.
Vladimir Vapnik and Alexey Chernovenkis
introduced the VC dimension,
presenting uniform convergence results
that hold for all models in a VC class.
The training errors for all models in the class
are (simultaneously) guaranteed
to be close to their true errors,
and guaranteed to grow even closer
at $\mathcal{O}(1/\sqrt{n})$ rates.
Following the revolutionary discovery of VC dimension,
numerous alternative complexity measures have been proposed,
each facilitating an analogous generalization guarantee.
See :citet:<code>boucheron2005theory</code> for a detailed discussion
of several advanced ways of measuring function complexity.
Unfortunately, while these complexity measures
have become broadly useful tools in statistical theory,
they turn out to be powerless
(as straightforwardly applied)
for explaining why deep neural networks generalize.
Deep neural networks often have millions of parameters (or more),
and can easily assign random labels to large collections of points.
Nevertheless, they generalize well on practical problems
and, surprisingly, they often generalize better,
when they are larger and deeper,
despite incurring higher VC dimensions.
In the next chapter, we will revisit generalization
in the context of deep learning.</p>
<h2 id="exercises-20"><a class="header" href="#exercises-20">Exercises</a></h2>
<ol>
<li>If we wish to estimate the error of a fixed model $f$
to within $0.0001$ with probability greater than 99.9%,
how many samples do we need?</li>
<li>Suppose that somebody else possesses a labeled test set
$\mathcal{D}$ and only makes available the unlabeled inputs (features).
Now suppose that you can only access the test set labels
by running a model $f$ (with no restrictions placed on the model class)
on each of the unlabeled inputs
and receiving the corresponding error $\epsilon_\mathcal{D}(f)$.
How many models would you need to evaluate
before you leak the entire test set
and thus could appear to have error $0$,
regardless of your true error?</li>
<li>What is the VC dimension of the class of fifth-order polynomials?</li>
<li>What is the VC dimension of axis-aligned rectangles on two-dimensional data?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/6829">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-and-distribution-shift"><a class="header" href="#environment-and-distribution-shift">Environment and Distribution Shift</a></h1>
<p>:label:<code>sec_environment-and-distribution-shift</code></p>
<p>In the previous sections, we worked through
a number of hands-on applications of machine learning,
fitting models to a variety of datasets.
And yet, we never stopped to contemplate
either where data came from in the first place
or what we ultimately plan to do
with the outputs from our models.
Too often, machine learning developers
in possession of data rush to develop models
without pausing to consider these fundamental issues.</p>
<p>Many failed machine learning deployments
can be traced back to this failure.
Sometimes models appear to perform marvelously
as measured by test set accuracy
but fail catastrophically in deployment
when the distribution of data suddenly shifts.
More insidiously, sometimes the very deployment of a model
can be the catalyst that perturbs the data distribution.
Say, for example, that we trained a model
to predict who will repay rather than default on a loan,
finding that an applicant's choice of footwear
was associated with the risk of default
(Oxfords indicate repayment, sneakers indicate default).
We might be inclined
thereafter to grant a loan
to any applicant wearing Oxfords
and to deny all applicants wearing sneakers.</p>
<p>In this case, our ill-considered leap from
pattern recognition to decision-making
and our failure to critically consider the environment
might have disastrous consequences.
For starters, as soon as we began
making decisions based on footwear,
customers would catch on and change their behavior.
Before long, all applicants would be wearing Oxfords,
without any coincident improvement in credit-worthiness.
Take a minute to digest this because similar issues abound
in many applications of machine learning:
by introducing our model-based decisions to the environment,
we might break the model.</p>
<p>While we cannot possibly give these topics
a complete treatment in one section,
we aim here to expose some common concerns,
and to stimulate the critical thinking
required to detect such situations early,
mitigate damage, and use machine learning responsibly.
Some of the solutions are simple
(ask for the "right" data),
some are technically difficult
(implement a reinforcement learning system),
and others require that we step outside the realm of
statistical prediction altogether and
grapple with difficult philosophical questions
concerning the ethical application of algorithms.</p>
<h2 id="types-of-distribution-shift"><a class="header" href="#types-of-distribution-shift">Types of Distribution Shift</a></h2>
<p>To begin, we stick with the passive prediction setting
considering the various ways that data distributions might shift
and what might be done to salvage model performance.
In one classic setup, we assume that our training data
was sampled from some distribution $p_S(\mathbf{x},y)$
but that our test data will consist
of unlabeled examples drawn from
some different distribution $p_T(\mathbf{x},y)$.
Already, we must confront a sobering reality.
Absent any assumptions on how $p_S$
and $p_T$ relate to each other,
learning a robust classifier is impossible.</p>
<p>Consider a binary classification problem,
where we wish to distinguish between dogs and cats.
If the distribution can shift in arbitrary ways,
then our setup permits the pathological case
in which the distribution over inputs remains
constant: $p_S(\mathbf{x}) = p_T(\mathbf{x})$,
but the labels are all flipped:
$p_S(y \mid \mathbf{x}) = 1 - p_T(y \mid \mathbf{x})$.
In other words, if God can suddenly decide
that in the future all "cats" are now dogs
and what we previously called "dogs" are now cats---without
any change in the distribution of inputs $p(\mathbf{x})$,
then we cannot possibly distinguish this setting
from one in which the distribution did not change at all.</p>
<p>Fortunately, under some restricted assumptions
on the ways our data might change in the future,
principled algorithms can detect shift
and sometimes even adapt on the fly,
improving on the accuracy of the original classifier.</p>
<h3 id="covariate-shift"><a class="header" href="#covariate-shift">Covariate Shift</a></h3>
<p>Among categories of distribution shift,
covariate shift may be the most widely studied.
Here, we assume that while the distribution of inputs
may change over time, the labeling function,
i.e., the conditional distribution
$P(y \mid \mathbf{x})$ does not change.
Statisticians call this <em>covariate shift</em>
because the problem arises due to a
shift in the distribution of the covariates (features).
While we can sometimes reason about distribution shift
without invoking causality, we note that covariate shift
is the natural assumption to invoke in settings
where we believe that $\mathbf{x}$ causes $y$.</p>
<p>Consider the challenge of distinguishing cats and dogs.
Our training data might consist of images of the kind in :numref:<code>fig_cat-dog-train</code>.</p>
<p><img src="chapter_linear-classification/../img/cat-dog-train.png" alt="Training data for distinguishing cats and dogs (illustrations: Lafeez Hossain / 500px / Getty Images; ilkermetinkursova / iStock / Getty Images Plus; GlobalP / iStock / Getty Images Plus; Musthafa Aboobakuru / 500px / Getty Images)." />
:label:<code>fig_cat-dog-train</code></p>
<p>At test time we are asked to classify the images in :numref:<code>fig_cat-dog-test</code>.</p>
<p><img src="chapter_linear-classification/../img/cat-dog-test.png" alt="Test data for distinguishing cats and dogs (illustrations: SIBAS_minich / iStock / Getty Images Plus; Ghrzuzudu / iStock / Getty Images Plus; id-work / DigitalVision Vectors / Getty Images; Yime / iStock / Getty Images Plus)." />
:label:<code>fig_cat-dog-test</code></p>
<p>The training set consists of photos,
while the test set contains only cartoons.
Training on a dataset with substantially different
characteristics from the test set
can spell trouble absent a coherent plan
for how to adapt to the new domain.</p>
<h3 id="label-shift"><a class="header" href="#label-shift">Label Shift</a></h3>
<p><em>Label shift</em> describes the converse problem.
Here, we assume that the label marginal $P(y)$
can change
but the class-conditional distribution
$P(\mathbf{x} \mid y)$ remains fixed across domains.
Label shift is a reasonable assumption to make
when we believe that $y$ causes $\mathbf{x}$.
For example, we may want to predict diagnoses
given their symptoms (or other manifestations),
even as the relative prevalence of diagnoses
are changing over time.
Label shift is the appropriate assumption here
because diseases cause symptoms.
In some degenerate cases the label shift
and covariate shift assumptions can hold simultaneously.
For example, when the label is deterministic,
the covariate shift assumption will be satisfied,
even when $y$ causes $\mathbf{x}$.
Interestingly, in these cases,
it is often advantageous to work with methods
that flow from the label shift assumption.
That is because these methods tend
to involve manipulating objects that look like labels (often low-dimensional),
as opposed to objects that look like inputs,
which tend to be high-dimensional in deep learning.</p>
<h3 id="concept-shift"><a class="header" href="#concept-shift">Concept Shift</a></h3>
<p>We may also encounter the related problem of <em>concept shift</em>,
which arises when the very definitions of labels can change.
This sounds weird---a <em>cat</em> is a <em>cat</em>, no?
However, other categories are subject to changes in usage over time.
Diagnostic criteria for mental illness,
what passes for fashionable, and job titles,
are all subject to considerable
amounts of concept shift.
It turns out that if we navigate around the United States,
shifting the source of our data by geography,
we will find considerable concept shift regarding
the distribution of names for <em>soft drinks</em>
as shown in :numref:<code>fig_popvssoda</code>.</p>
<p><img src="chapter_linear-classification/../img/popvssoda.png" alt="Concept shift for soft drink names in the United States (CC-BY: Alan McConchie, PopVsSoda.com)." />
:width:<code>400px</code>
:label:<code>fig_popvssoda</code></p>
<p>If we were to build a machine translation system,
the distribution $P(y \mid \mathbf{x})$ might be different
depending on our location.
This problem can be tricky to spot.
We might hope to exploit knowledge
that shift only takes place gradually
either in a temporal or geographic sense.</p>
<h2 id="examples-of-distribution-shift"><a class="header" href="#examples-of-distribution-shift">Examples of Distribution Shift</a></h2>
<p>Before delving into formalism and algorithms,
we can discuss some concrete situations
where covariate or concept shift might not be obvious.</p>
<h3 id="medical-diagnostics"><a class="header" href="#medical-diagnostics">Medical Diagnostics</a></h3>
<p>Imagine that you want to design an algorithm to detect cancer.
You collect data from healthy and sick people
and you train your algorithm.
It works fine, giving you high accuracy
and you conclude that you are ready
for a successful career in medical diagnostics.
<em>Not so fast.</em></p>
<p>The distributions that gave rise to the training data
and those you will encounter in the wild might differ considerably.
This happened to an unfortunate startup
that some of we authors worked with years ago.
They were developing a blood test for a disease
that predominantly affects older men
and hoped to study it using blood samples
that they had collected from patients.
However, it is considerably more difficult
to obtain blood samples from healthy men
than from sick patients already in the system.
To compensate, the startup solicited
blood donations from students on a university campus
to serve as healthy controls in developing their test.
Then they asked whether we could help them
to build a classifier for detecting the disease.</p>
<p>As we explained to them,
it would indeed be easy to distinguish
between the healthy and sick cohorts
with near-perfect accuracy.
However, that is because the test subjects
differed in age, hormone levels,
physical activity, diet, alcohol consumption,
and many more factors unrelated to the disease.
This was unlikely to be the case with real patients.
Due to their sampling procedure,
we could expect to encounter extreme covariate shift.
Moreover, this case was unlikely to be
correctable via conventional methods.
In short, they wasted a significant sum of money.</p>
<h3 id="self-driving-cars"><a class="header" href="#self-driving-cars">Self-Driving Cars</a></h3>
<p>Say a company wanted to leverage machine learning
for developing self-driving cars.
One key component here is a roadside detector.
Since real annotated data is expensive to get,
they had the (smart and questionable) idea
to use synthetic data from a game rendering engine
as additional training data.
This worked really well on "test data"
drawn from the rendering engine.
Alas, inside a real car it was a disaster.
As it turned out, the roadside had been rendered
with a very simplistic texture.
More importantly, <em>all</em> the roadside had been rendered
with the <em>same</em> texture and the roadside detector
learned about this "feature" very quickly.</p>
<p>A similar thing happened to the US Army
when they first tried to detect tanks in the forest.
They took aerial photographs of the forest without tanks,
then drove the tanks into the forest
and took another set of pictures.
The classifier appeared to work <em>perfectly</em>.
Unfortunately, it had merely learned
how to distinguish trees with shadows
from trees without shadows---the first set
of pictures was taken in the early morning,
the second set at noon.</p>
<h3 id="nonstationary-distributions"><a class="header" href="#nonstationary-distributions">Nonstationary Distributions</a></h3>
<p>A much more subtle situation arises
when the distribution changes slowly
(also known as <em>nonstationary distribution</em>)
and the model is not updated adequately.
Below are some typical cases.</p>
<ul>
<li>We train a computational advertising model and then fail to update it frequently (e.g., we forget to incorporate that an obscure new device called an iPad was just launched).</li>
<li>We build a spam filter. It works well at detecting all spam that we have seen so far. But then the spammers wise up and craft new messages that look unlike anything we have seen before.</li>
<li>We build a product recommendation system. It works throughout the winter but then continues to recommend Santa hats long after Christmas.</li>
</ul>
<h3 id="more-anecdotes"><a class="header" href="#more-anecdotes">More Anecdotes</a></h3>
<ul>
<li>We build a face detector. It works well on all benchmarks. Unfortunately it fails on test data---the offending examples are close-ups where the face fills the entire image (no such data was in the training set).</li>
<li>We build a web search engine for the US market and want to deploy it in the UK.</li>
<li>We train an image classifier by compiling a large dataset where each among a large set of classes is equally represented in the dataset, say 1000 categories, represented by 1000 images each. Then we deploy the system in the real world, where the actual label distribution of photographs is decidedly non-uniform.</li>
</ul>
<h2 id="correction-of-distribution-shift"><a class="header" href="#correction-of-distribution-shift">Correction of Distribution Shift</a></h2>
<p>As we have discussed, there are many cases
where training and test distributions
$P(\mathbf{x}, y)$ are different.
In some cases, we get lucky and the models work
despite covariate, label, or concept shift.
In other cases, we can do better by employing
principled strategies to cope with the shift.
The remainder of this section grows considerably more technical.
The impatient reader could continue on to the next section
as this material is not prerequisite to subsequent concepts.</p>
<h3 id="empirical-risk-and--risk"><a class="header" href="#empirical-risk-and--risk">Empirical Risk and  Risk</a></h3>
<p>:label:<code>subsec_empirical-risk-and-risk</code></p>
<p>Let's first reflect on what exactly
is happening during model training:
we iterate over features and associated labels
of training data
${(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)}$
and update the parameters of a model $f$ after every minibatch.
For simplicity we do not consider regularization,
so we largely minimize the loss on the training:</p>
<p>$$\mathop{\mathrm{minimize}}<em>f \frac{1}{n} \sum</em>{i=1}^n l(f(\mathbf{x}_i), y_i),$$
:eqlabel:<code>eq_empirical-risk-min</code></p>
<p>where $l$ is the loss function
measuring "how bad" the prediction $f(\mathbf{x}_i)$ is given the associated label $y_i$.
Statisticians call the term in :eqref:<code>eq_empirical-risk-min</code> <em>empirical risk</em>.
The <em>empirical risk</em> is an average loss over the training data
for approximating the <em>risk</em>,
which is the
expectation of the loss over the entire population of data drawn from their true distribution
$p(\mathbf{x},y)$:</p>
<p>$$E_{p(\mathbf{x}, y)} [l(f(\mathbf{x}), y)] = \int\int l(f(\mathbf{x}), y) p(\mathbf{x}, y) ;d\mathbf{x}dy.$$
:eqlabel:<code>eq_true-risk</code></p>
<p>However, in practice we typically cannot obtain the entire population of data.
Thus, <em>empirical risk minimization</em>,
which is minimizing the empirical risk in :eqref:<code>eq_empirical-risk-min</code>,
is a practical strategy for machine learning,
with the hope of approximately
minimizing the risk.</p>
<h3 id="covariate-shift-correction"><a class="header" href="#covariate-shift-correction">Covariate Shift Correction</a></h3>
<p>:label:<code>subsec_covariate-shift-correction</code></p>
<p>Assume that we want to estimate
some dependency $P(y \mid \mathbf{x})$
for which we have labeled data $(\mathbf{x}_i, y_i)$.
Unfortunately, the observations $\mathbf{x}_i$ are drawn
from some <em>source distribution</em> $q(\mathbf{x})$
rather than the <em>target distribution</em> $p(\mathbf{x})$.
Fortunately,
the dependency assumption means
that the conditional distribution does not change: $p(y \mid \mathbf{x}) = q(y \mid \mathbf{x})$.
If the source distribution $q(\mathbf{x})$ is "wrong",
we can correct for that by using the following simple identity in the risk:</p>
<p>$$
\begin{aligned}
\int\int l(f(\mathbf{x}), y) p(y \mid \mathbf{x})p(\mathbf{x}) ;d\mathbf{x}dy =
\int\int l(f(\mathbf{x}), y) q(y \mid \mathbf{x})q(\mathbf{x})\frac{p(\mathbf{x})}{q(\mathbf{x})} ;d\mathbf{x}dy.
\end{aligned}
$$</p>
<p>In other words, we need to reweigh each data example
by the ratio of the
probability
that it would have been drawn from the correct distribution to that from the wrong one:</p>
<p>$$\beta_i \stackrel{\textrm{def}}{=} \frac{p(\mathbf{x}_i)}{q(\mathbf{x}_i)}.$$</p>
<p>Plugging in the weight $\beta_i$ for
each data example $(\mathbf{x}_i, y_i)$
we can train our model using
<em>weighted empirical risk minimization</em>:</p>
<p>$$\mathop{\mathrm{minimize}}<em>f \frac{1}{n} \sum</em>{i=1}^n \beta_i l(f(\mathbf{x}_i), y_i).$$
:eqlabel:<code>eq_weighted-empirical-risk-min</code></p>
<p>Alas, we do not know that ratio,
so before we can do anything useful we need to estimate it.
Many methods are available,
including some fancy operator-theoretic approaches
that attempt to recalibrate the expectation operator directly
using a minimum-norm or a maximum entropy principle.
Note that for any such approach, we need samples
drawn from both distributions---the "true" $p$, e.g.,
by access to test data, and the one used
for generating the training set $q$ (the latter is trivially available).
Note however, that we only need features $\mathbf{x} \sim p(\mathbf{x})$;
we do not need to access labels $y \sim p(y)$.</p>
<p>In this case, there exists a very effective approach
that will give almost as good results as the original: namely, logistic regression,
which is a special case of softmax regression (see :numref:<code>sec_softmax</code>)
for binary classification.
This is all that is needed to compute estimated probability ratios.
We learn a classifier to distinguish
between data drawn from $p(\mathbf{x})$
and data drawn from $q(\mathbf{x})$.
If it is impossible to distinguish
between the two distributions
then it means that the associated instances
are equally likely to come from
either one of those two distributions.
On the other hand, any instances
that can be well discriminated
should be significantly overweighted
or underweighted accordingly.</p>
<p>For simplicity's sake assume that we have
an equal number of instances from both distributions
$p(\mathbf{x})$
and $q(\mathbf{x})$, respectively.
Now denote by $z$ labels that are $1$
for data drawn from $p$ and $-1$ for data drawn from $q$.
Then the probability in a mixed dataset is given by</p>
<p>$$P(z=1 \mid \mathbf{x}) = \frac{p(\mathbf{x})}{p(\mathbf{x})+q(\mathbf{x})} \textrm{ and hence } \frac{P(z=1 \mid \mathbf{x})}{P(z=-1 \mid \mathbf{x})} = \frac{p(\mathbf{x})}{q(\mathbf{x})}.$$</p>
<p>Thus, if we use a logistic regression approach,
where $P(z=1 \mid \mathbf{x})=\frac{1}{1+\exp(-h(\mathbf{x}))}$ ($h$ is a parametrized function),
it follows that</p>
<p>$$
\beta_i = \frac{1/(1 + \exp(-h(\mathbf{x}_i)))}{\exp(-h(\mathbf{x}_i))/(1 + \exp(-h(\mathbf{x}_i)))} = \exp(h(\mathbf{x}_i)).
$$</p>
<p>As a result, we need to solve two problems:
the first, to distinguish between
data drawn from both distributions,
and then a weighted empirical risk minimization problem
in :eqref:<code>eq_weighted-empirical-risk-min</code>
where we weigh terms by $\beta_i$.</p>
<p>Now we are ready to describe a correction algorithm.
Suppose that we have a training set ${(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)}$ and an unlabeled test set ${\mathbf{u}_1, \ldots, \mathbf{u}_m}$.
For covariate shift,
we assume that $\mathbf{x}_i$ for all $1 \leq i \leq n$ are drawn from some source distribution
and $\mathbf{u}_i$ for all $1 \leq i \leq m$
are drawn from the target distribution.
Here is a prototypical algorithm
for correcting covariate shift:</p>
<ol>
<li>Create a binary-classification training set: ${(\mathbf{x}_1, -1), \ldots, (\mathbf{x}_n, -1), (\mathbf{u}_1, 1), \ldots, (\mathbf{u}_m, 1)}$.</li>
<li>Train a binary classifier using logistic regression to get the function $h$.</li>
<li>Weigh training data using $\beta_i = \exp(h(\mathbf{x}_i))$ or better $\beta_i = \min(\exp(h(\mathbf{x}_i)), c)$ for some constant $c$.</li>
<li>Use weights $\beta_i$ for training on ${(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)}$ in :eqref:<code>eq_weighted-empirical-risk-min</code>.</li>
</ol>
<p>Note that the above algorithm relies on a crucial assumption.
For this scheme to work, we need that each data example
in the target (e.g., test time) distribution
had nonzero probability of occurring at training time.
If we find a point where $p(\mathbf{x}) &gt; 0$ but $q(\mathbf{x}) = 0$,
then the corresponding importance weight should be infinity.</p>
<h3 id="label-shift-correction"><a class="header" href="#label-shift-correction">Label Shift Correction</a></h3>
<p>Assume that we are dealing with a
classification task with $k$ categories.
Using the same notation in :numref:<code>subsec_covariate-shift-correction</code>,
$q$ and $p$ are the source distribution (e.g., training time) and target distribution (e.g., test time), respectively.
Assume that the distribution of labels shifts over time:
$q(y) \neq p(y)$, but the class-conditional distribution
stays the same: $q(\mathbf{x} \mid y)=p(\mathbf{x} \mid y)$.
If the source distribution $q(y)$ is "wrong",
we can correct for that
according to
the following identity in the risk
as defined in
:eqref:<code>eq_true-risk</code>:</p>
<p>$$
\begin{aligned}
\int\int l(f(\mathbf{x}), y) p(\mathbf{x} \mid y)p(y) ;d\mathbf{x}dy =
\int\int l(f(\mathbf{x}), y) q(\mathbf{x} \mid y)q(y)\frac{p(y)}{q(y)} ;d\mathbf{x}dy.
\end{aligned}
$$</p>
<p>Here, our importance weights will correspond to the
label likelihood ratios:</p>
<p>$$\beta_i \stackrel{\textrm{def}}{=} \frac{p(y_i)}{q(y_i)}.$$</p>
<p>One nice thing about label shift is that
if we have a reasonably good model
on the source distribution,
then we can get consistent estimates of these weights
without ever having to deal with the ambient dimension.
In deep learning, the inputs tend
to be high-dimensional objects like images,
while the labels are often simpler objects like categories.</p>
<p>To estimate the target label distribution,
we first take our reasonably good off-the-shelf classifier
(typically trained on the training data)
and compute its "confusion" matrix using the validation set
(also from the training distribution).
The <em>confusion matrix</em>, $\mathbf{C}$, is simply a $k \times k$ matrix,
where each column corresponds to the label category (ground truth)
and each row corresponds to our model's predicted category.
Each cell's value $c_{ij}$ is the fraction of total predictions on the validation set
where the true label was $j$ and our model predicted $i$.</p>
<p>Now, we cannot calculate the confusion matrix
on the target data directly
because we do not get to see the labels for the examples
that we see in the wild,
unless we invest in a complex real-time annotation pipeline.
What we can do, however, is average all of our model's predictions
at test time together, yielding the mean model outputs $\mu(\hat{\mathbf{y}}) \in \mathbb{R}^k$,
where the $i^\textrm{th}$ element $\mu(\hat{y}_i)$
is the fraction of the total predictions on the test set
where our model predicted $i$.</p>
<p>It turns out that under some mild conditions---if
our classifier was reasonably accurate in the first place,
and if the target data contains only categories
that we have seen before,
and if the label shift assumption holds in the first place
(the strongest assumption here)---we can estimate the test set label distribution
by solving a simple linear system</p>
<p>$$\mathbf{C} p(\mathbf{y}) = \mu(\hat{\mathbf{y}}),$$</p>
<p>because as an estimate $\sum_{j=1}^k c_{ij} p(y_j) = \mu(\hat{y}_i)$ holds for all $1 \leq i \leq k$,
where $p(y_j)$ is the $j^\textrm{th}$ element of the $k$-dimensional label distribution vector $p(\mathbf{y})$.
If our classifier is sufficiently accurate to begin with,
then the confusion matrix $\mathbf{C}$ will be invertible,
and we get a solution $p(\mathbf{y}) = \mathbf{C}^{-1} \mu(\hat{\mathbf{y}})$.</p>
<p>Because we observe the labels on the source data,
it is easy to estimate the distribution $q(y)$.
Then, for any training example $i$ with label $y_i$,
we can take the ratio of our estimated $p(y_i)/q(y_i)$
to calculate the weight $\beta_i$,
and plug this into weighted empirical risk minimization
in :eqref:<code>eq_weighted-empirical-risk-min</code>.</p>
<h3 id="concept-shift-correction"><a class="header" href="#concept-shift-correction">Concept Shift Correction</a></h3>
<p>Concept shift is much harder to fix in a principled manner.
For instance, in a situation where suddenly the problem changes
from distinguishing cats from dogs to one of
distinguishing white from black animals,
it will be unreasonable to assume
that we can do much better than just collecting new labels
and training from scratch.
Fortunately, in practice, such extreme shifts are rare.
Instead, what usually happens is that the task keeps on changing slowly.
To make things more concrete, here are some examples:</p>
<ul>
<li>In computational advertising, new products are launched,
old products become less popular. This means that the distribution over ads and their popularity changes gradually and any click-through rate predictor needs to change gradually with it.</li>
<li>Traffic camera lenses degrade gradually due to environmental wear, affecting image quality progressively.</li>
<li>News content changes gradually (i.e., most of the news remains unchanged but new stories appear).</li>
</ul>
<p>In such cases, we can use the same approach that we used for training networks to make them adapt to the change in the data. In other words, we use the existing network weights and simply perform a few update steps with the new data rather than training from scratch.</p>
<h2 id="a-taxonomy-of-learning-problems"><a class="header" href="#a-taxonomy-of-learning-problems">A Taxonomy of Learning Problems</a></h2>
<p>Armed with knowledge about how to deal with changes in distributions, we can now consider some other aspects of machine learning problem formulation.</p>
<h3 id="batch-learning"><a class="header" href="#batch-learning">Batch Learning</a></h3>
<p>In <em>batch learning</em>, we have access to training features and labels ${(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)}$, which we use to train a model $f(\mathbf{x})$. Later on, we deploy this model to score new data $(\mathbf{x}, y)$ drawn from the same distribution. This is the default assumption for any of the problems that we discuss here. For instance, we might train a cat detector based on lots of pictures of cats and dogs. Once we have trained it, we ship it as part of a smart catdoor computer vision system that lets only cats in. This is then installed in a customer's home and is never updated again (barring extreme circumstances).</p>
<h3 id="online-learning"><a class="header" href="#online-learning">Online Learning</a></h3>
<p>Now imagine that the data $(\mathbf{x}_i, y_i)$ arrives one sample at a time. More specifically, assume that we first observe $\mathbf{x}_i$, then we need to come up with an estimate $f(\mathbf{x}_i)$. Only once we have done this do we observe $y_i$ and so receive a reward or incur a loss, given our decision.
Many real problems fall into this category. For example, we need to predict tomorrow's stock price, which allows us to trade based on that estimate and at the end of the day we find out whether our estimate made us a profit. In other words, in <em>online learning</em>, we have the following cycle where we are continuously improving our model given new observations:</p>
<p>$$\begin{aligned}&amp;\textrm{model } f_t \longrightarrow \textrm{data }  \mathbf{x}_t \longrightarrow \textrm{estimate } f_t(\mathbf{x}_t) \longrightarrow\ \textrm{obs}&amp;\textrm{ervation } y_t \longrightarrow \textrm{loss } l(y_t, f_t(\mathbf{x}<em>t)) \longrightarrow \textrm{model } f</em>{t+1}\end{aligned}$$</p>
<h3 id="bandits"><a class="header" href="#bandits">Bandits</a></h3>
<p><em>Bandits</em> are a special case of the problem above. While in most learning problems we have a continuously parametrized function $f$ where we want to learn its parameters (e.g., a deep network), in a <em>bandit</em> problem we only have a finite number of arms that we can pull, i.e., a finite number of actions that we can take. It is not very surprising that for this simpler problem stronger theoretical guarantees in terms of optimality can be obtained. We list it mainly since this problem is often (confusingly) treated as if it were a distinct learning setting.</p>
<h3 id="control"><a class="header" href="#control">Control</a></h3>
<p>In many cases the environment remembers what we did. Not necessarily in an adversarial manner but it will just remember and the response will depend on what happened before. For instance, a coffee boiler controller will observe different temperatures depending on whether it was heating the boiler previously. PID (proportional-integral-derivative) controller algorithms are a popular choice there.
Likewise, a user's behavior on a news site will depend on what we showed them previously (e.g., they will read most news only once). Many such algorithms form a model of the environment in which they act so as to make their decisions appear less random.
Recently,
control theory (e.g., PID variants) has also been used
to automatically tune hyperparameters
to achieve better disentangling and reconstruction quality,
and improve the diversity of generated text and the reconstruction quality of generated images :cite:<code>Shao.Yao.Sun.ea.2020</code>.</p>
<h3 id="reinforcement-learning-1"><a class="header" href="#reinforcement-learning-1">Reinforcement Learning</a></h3>
<p>In the more general case of an environment with memory, we may encounter situations where the environment is trying to cooperate with us (cooperative games, in particular for non-zero-sum games), or others where the environment will try to win. Chess, Go, Backgammon, or StarCraft are some of the cases in <em>reinforcement learning</em>. Likewise, we might want to build a good controller for autonomous cars. Other cars are likely to respond to the autonomous car's driving style in nontrivial ways, e.g., trying to avoid it, trying to cause an accident, or trying to cooperate with it.</p>
<h3 id="considering-the-environment"><a class="header" href="#considering-the-environment">Considering the Environment</a></h3>
<p>One key distinction between the different situations above is that a strategy that might have worked throughout in the case of a stationary environment, might not work throughout in an environment that can adapt. For instance, an arbitrage opportunity discovered by a trader is likely to disappear once it is exploited. The speed and manner at which the environment changes determines to a large extent the type of algorithms that we can bring to bear. For instance, if we know that things may only change slowly, we can force any estimate to change only slowly, too. If we know that the environment might change instantaneously, but only very infrequently, we can make allowances for that. These types of knowledge are crucial for the aspiring data scientist in dealing with concept shift, i.e., when the problem that is being solved can change over time.</p>
<h2 id="fairness-accountability-and-transparency-in-machine-learning"><a class="header" href="#fairness-accountability-and-transparency-in-machine-learning">Fairness, Accountability, and Transparency in Machine Learning</a></h2>
<p>Finally, it is important to remember
that when you deploy machine learning systems
you are not merely optimizing a predictive model---you
are typically providing a tool that will
be used to (partially or fully) automate decisions.
These technical systems can impact the lives
of individuals who are subject to the resulting decisions.
The leap from considering predictions to making decisions
raises not only new technical questions,
but also a slew of ethical questions
that must be carefully considered.
If we are deploying a medical diagnostic system,
we need to know for which populations
it may work and for which it may not.
Overlooking foreseeable risks to the welfare of
a subpopulation could cause us to administer inferior care.
Moreover, once we contemplate decision-making systems,
we must step back and reconsider how we evaluate our technology.
Among other consequences of this change of scope,
we will find that <em>accuracy</em> is seldom the right measure.
For instance, when translating predictions into actions,
we will often want to take into account
the potential cost sensitivity of erring in various ways.
If one way of misclassifying an image
could be perceived as a racial sleight of hand,
while misclassification to a different category
would be harmless, then we might want to adjust
our thresholds accordingly, accounting for societal values
in designing the decision-making protocol.
We also want to be careful about
how prediction systems can lead to feedback loops.
For example, consider predictive policing systems,
which allocate patrol officers
to areas with high forecasted crime.
It is easy to see how a worrying pattern can emerge:</p>
<ol>
<li>Neighborhoods with more crime get more patrols.</li>
<li>Consequently, more crimes are discovered in these neighborhoods, entering the training data available for future iterations.</li>
<li>Exposed to more positives, the model predicts yet more crime in these neighborhoods.</li>
<li>In the next iteration, the updated model targets the same neighborhood even more heavily leading to yet more crimes discovered, etc.</li>
</ol>
<p>Often, the various mechanisms by which
a model's predictions become coupled to its training data
are unaccounted for in the modeling process.
This can lead to what researchers call <em>runaway feedback loops</em>.
Additionally, we want to be careful about
whether we are addressing the right problem in the first place.
Predictive algorithms now play an outsize role
in mediating the dissemination of information.
Should the news that an individual encounters
be determined by the set of Facebook pages they have <em>Liked</em>?
These are just a few among the many pressing ethical dilemmas
that you might encounter in a career in machine learning.</p>
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<p>In many cases training and test sets do not come from the same distribution. This is called distribution shift.
The risk is the expectation of the loss over the entire population of data drawn from their true distribution. However, this entire population is usually unavailable. Empirical risk is an average loss over the training data to approximate the risk. In practice, we perform empirical risk minimization.</p>
<p>Under the corresponding assumptions, covariate and label shift can be detected and corrected for at test time. Failure to account for this bias can become problematic at test time.
In some cases, the environment may remember automated actions and respond in surprising ways. We must account for this possibility when building models and continue to monitor live systems, open to the possibility that our models and the environment will become entangled in unanticipated ways.</p>
<h2 id="exercises-21"><a class="header" href="#exercises-21">Exercises</a></h2>
<ol>
<li>What could happen when we change the behavior of a search engine? What might the users do? What about the advertisers?</li>
<li>Implement a covariate shift detector. Hint: build a classifier.</li>
<li>Implement a covariate shift corrector.</li>
<li>Besides distribution shift, what else could affect how the empirical risk approximates the risk?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/105">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multilayer-perceptrons"><a class="header" href="#multilayer-perceptrons">Multilayer Perceptrons</a></h1>
<p>:label:<code>chap_perceptrons</code></p>
<p>In this chapter, we will introduce your first truly <em>deep</em> network.
The simplest deep networks are called <em>multilayer perceptrons</em>,
and they consist of multiple layers of neurons
each fully connected to those in the layer below
(from which they receive input)
and those above (which they, in turn, influence).
Although automatic differentiation
significantly simplifies the implementation of deep learning algorithms,
we will dive deep into how these gradients
are calculated in deep networks.
Then we will
be ready to
discuss issues relating to numerical stability and parameter initialization
that are key to successfully training deep networks.
When we train such high-capacity models we run the risk of overfitting. Thus, we will
revisit regularization and generalization
for deep networks.
Throughout, we aim
to give you a firm grasp not just of the concepts but also of the practice of using deep networks.
At the end of this chapter, we apply what we have introduced so far to a real case: house price
prediction. We punt matters relating to the computational performance, scalability, and efficiency
of our models to subsequent chapters.</p>
<pre><code class="language-toc">:maxdepth: 2

mlp
mlp-implementation
backprop
numerical-stability-and-init
generalization-deep
dropout
kaggle-house-price
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="multilayer-perceptrons-1"><a class="header" href="#multilayer-perceptrons-1">Multilayer Perceptrons</a></h1>
<p>:label:<code>sec_mlp</code></p>
<p>In :numref:<code>sec_softmax</code>, we introduced
softmax regression,
implementing the algorithm from scratch
(:numref:<code>sec_softmax_scratch</code>) and using high-level APIs
(:numref:<code>sec_softmax_concise</code>). This allowed us to
train classifiers capable of recognizing
10 categories of clothing from low-resolution images.
Along the way, we learned how to wrangle data,
coerce our outputs into a valid probability distribution,
apply an appropriate loss function,
and minimize it with respect to our model's parameters.
Now that we have mastered these mechanics
in the context of simple linear models,
we can launch our exploration of deep neural networks,
the comparatively rich class of models
with which this book is primarily concerned.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
from jax import grad, vmap
</code></pre>
<h2 id="hidden-layers"><a class="header" href="#hidden-layers">Hidden Layers</a></h2>
<p>We described affine transformations in
:numref:<code>subsec_linear_model</code> as
linear transformations with added bias.
To begin, recall the model architecture
corresponding to our softmax regression example,
illustrated in  :numref:<code>fig_softmaxreg</code>.
This model maps inputs directly to outputs
via a single affine transformation,
followed by a softmax operation.
If our labels truly were related
to the input data by a simple affine transformation,
then this approach would be sufficient.
However, linearity (in affine transformations) is a <em>strong</em> assumption.</p>
<h3 id="limitations-of-linear-models"><a class="header" href="#limitations-of-linear-models">Limitations of Linear Models</a></h3>
<p>For example, linearity implies the <em>weaker</em>
assumption of <em>monotonicity</em>, i.e.,
that any increase in our feature must
either always cause an increase in our model's output
(if the corresponding weight is positive),
or always cause a decrease in our model's output
(if the corresponding weight is negative).
Sometimes that makes sense.
For example, if we were trying to predict
whether an individual will repay a loan,
we might reasonably assume that all other things being equal,
an applicant with a higher income
would always be more likely to repay
than one with a lower income.
While monotonic, this relationship likely
is not linearly associated with the probability of
repayment. An increase in income from $0 to $50,000
likely corresponds to a bigger increase
in likelihood of repayment
than an increase from $1 million to $1.05 million.
One way to handle this might be to postprocess our outcome
such that linearity becomes more plausible,
by using the logistic map (and thus the logarithm of the probability of outcome).</p>
<p>Note that we can easily come up with examples
that violate monotonicity.
Say for example that we want to predict health as a function
of body temperature.
For individuals with a normal body temperature
above 37°C (98.6°F),
higher temperatures indicate greater risk.
However, if the body temperatures drops
below 37°C, lower temperatures indicate greater risk!
Again, we might resolve the problem
with some clever preprocessing, such as using the distance from 37°C
as a feature.</p>
<p>But what about classifying images of cats and dogs?
Should increasing the intensity
of the pixel at location (13, 17)
always increase (or always decrease)
the likelihood that the image depicts a dog?
Reliance on a linear model corresponds to the implicit
assumption that the only requirement
for differentiating cats and dogs is to assess
the brightness of individual pixels.
This approach is doomed to fail in a world
where inverting an image preserves the category.</p>
<p>And yet despite the apparent absurdity of linearity here,
as compared with our previous examples,
it is less obvious that we could address the problem
with a simple preprocessing fix.
That is, because the significance of any pixel
depends in complex ways on its context
(the values of the surrounding pixels).
While there might exist a representation of our data
that would take into account
the relevant interactions among our features,
on top of which a linear model would be suitable,
we simply do not know how to calculate it by hand.
With deep neural networks, we used observational data
to jointly learn both a representation via hidden layers
and a linear predictor that acts upon that representation.</p>
<p>This problem of nonlinearity has been studied for at least a
century :cite:<code>Fisher.1928</code>. For instance, decision trees
in their most basic form use a sequence of binary decisions to
decide upon class membership :cite:<code>quinlan2014c4</code>. Likewise, kernel
methods have been used for many decades to model nonlinear dependencies
:cite:<code>Aronszajn.1950</code>. This has found its way into
nonparametric spline models :cite:<code>Wahba.1990</code> and kernel methods
:cite:<code>Scholkopf.Smola.2002</code>. It is also something that the brain solves
quite naturally. After all, neurons feed into other neurons which,
in turn, feed into other neurons again :cite:<code>Cajal.Azoulay.1894</code>.
Consequently we have a sequence of relatively simple transformations.</p>
<h3 id="incorporating-hidden-layers"><a class="header" href="#incorporating-hidden-layers">Incorporating Hidden Layers</a></h3>
<p>We can overcome the limitations of linear models
by incorporating one or more hidden layers.
The easiest way to do this is to stack
many fully connected layers on top of one another.
Each layer feeds into the layer above it,
until we generate outputs.
We can think of the first $L-1$ layers
as our representation and the final layer
as our linear predictor.
This architecture is commonly called
a <em>multilayer perceptron</em>,
often abbreviated as <em>MLP</em> (:numref:<code>fig_mlp</code>).</p>
<p><img src="chapter_multilayer-perceptrons/../img/mlp.svg" alt="An MLP with a hidden layer of five hidden units." />
:label:<code>fig_mlp</code></p>
<p>This MLP has four inputs, three outputs,
and its hidden layer contains five hidden units.
Since the input layer does not involve any calculations,
producing outputs with this network
requires implementing the computations
for both the hidden and output layers;
thus, the number of layers in this MLP is two.
Note that both layers are fully connected.
Every input influences every neuron in the hidden layer,
and each of these in turn influences
every neuron in the output layer. Alas, we are not quite
done yet.</p>
<h3 id="from-linear-to-nonlinear"><a class="header" href="#from-linear-to-nonlinear">From Linear to Nonlinear</a></h3>
<p>As before, we denote by the matrix $\mathbf{X} \in \mathbb{R}^{n \times d}$
a minibatch of $n$ examples where each example has $d$ inputs (features).
For a one-hidden-layer MLP whose hidden layer has $h$ hidden units,
we denote by $\mathbf{H} \in \mathbb{R}^{n \times h}$
the outputs of the hidden layer, which are
<em>hidden representations</em>.
Since the hidden and output layers are both fully connected,
we have hidden-layer weights $\mathbf{W}^{(1)} \in \mathbb{R}^{d \times h}$ and biases $\mathbf{b}^{(1)} \in \mathbb{R}^{1 \times h}$
and output-layer weights $\mathbf{W}^{(2)} \in \mathbb{R}^{h \times q}$ and biases $\mathbf{b}^{(2)} \in \mathbb{R}^{1 \times q}$.
This allows us to calculate the outputs $\mathbf{O} \in \mathbb{R}^{n \times q}$
of the one-hidden-layer MLP as follows:</p>
<p>$$
\begin{aligned}
\mathbf{H} &amp; = \mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}, \
\mathbf{O} &amp; = \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}.
\end{aligned}
$$</p>
<p>Note that after adding the hidden layer,
our model now requires us to track and update
additional sets of parameters.
So what have we gained in exchange?
You might be surprised to find out
that---in the model defined above---<em>we
gain nothing for our troubles</em>!
The reason is plain.
The hidden units above are given by
an affine function of the inputs,
and the outputs (pre-softmax) are just
an affine function of the hidden units.
An affine function of an affine function
is itself an affine function.
Moreover, our linear model was already
capable of representing any affine function.</p>
<p>To see this formally we can just collapse out the hidden layer in the above definition,
yielding an equivalent single-layer model with parameters
$\mathbf{W} = \mathbf{W}^{(1)}\mathbf{W}^{(2)}$ and $\mathbf{b} = \mathbf{b}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)}$:</p>
<p>$$
\mathbf{O} = (\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)})\mathbf{W}^{(2)} + \mathbf{b}^{(2)} = \mathbf{X} \mathbf{W}^{(1)}\mathbf{W}^{(2)} + \mathbf{b}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)} = \mathbf{X} \mathbf{W} + \mathbf{b}.
$$</p>
<p>In order to realize the potential of multilayer architectures,
we need one more key ingredient: a
nonlinear <em>activation function</em> $\sigma$
to be applied to each hidden unit
following the affine transformation. For instance, a popular
choice is the ReLU (rectified linear unit) activation function :cite:<code>Nair.Hinton.2010</code>
$\sigma(x) = \mathrm{max}(0, x)$ operating on its arguments elementwise.
The outputs of activation functions $\sigma(\cdot)$
are called <em>activations</em>.
In general, with activation functions in place,
it is no longer possible to collapse our MLP into a linear model:</p>
<p>$$
\begin{aligned}
\mathbf{H} &amp; = \sigma(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}), \
\mathbf{O} &amp; = \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}.\
\end{aligned}
$$</p>
<p>Since each row in $\mathbf{X}$ corresponds to an example in the minibatch,
with some abuse of notation, we define the nonlinearity
$\sigma$ to apply to its inputs in a rowwise fashion,
i.e., one example at a time.
Note that we used the same notation for softmax
when we denoted a rowwise operation in :numref:<code>subsec_softmax_vectorization</code>.
Quite frequently the activation functions we use apply not merely rowwise but
elementwise. That means that after computing the linear portion of the layer,
we can calculate each activation
without looking at the values taken by the other hidden units.</p>
<p>To build more general MLPs, we can continue stacking
such hidden layers,
e.g., $\mathbf{H}^{(1)} = \sigma_1(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)})$
and $\mathbf{H}^{(2)} = \sigma_2(\mathbf{H}^{(1)} \mathbf{W}^{(2)} + \mathbf{b}^{(2)})$,
one atop another, yielding ever more expressive models.</p>
<h3 id="universal-approximators"><a class="header" href="#universal-approximators">Universal Approximators</a></h3>
<p>We know that the brain is capable of very sophisticated statistical analysis. As such,
it is worth asking, just <em>how powerful</em> a deep network could be. This question
has been answered multiple times, e.g., in :citet:<code>Cybenko.1989</code> in the context
of MLPs, and in :citet:<code>micchelli1984interpolation</code> in the context of reproducing kernel
Hilbert spaces in a way that could be seen as radial basis function (RBF) networks with a single hidden layer.
These (and related results) suggest that even with a single-hidden-layer network,
given enough nodes (possibly absurdly many),
and the right set of weights,
we can model any function.
Actually learning that function is the hard part, though.
You might think of your neural network
as being a bit like the C programming language.
The language, like any other modern language,
is capable of expressing any computable program.
But actually coming up with a program
that meets your specifications is the hard part.</p>
<p>Moreover, just because a single-hidden-layer network
<em>can</em> learn any function
does not mean that you should try
to solve all of your problems
with one. In fact, in this case kernel methods
are way more effective, since they are capable of solving the problem
<em>exactly</em> even in infinite dimensional spaces :cite:<code>Kimeldorf.Wahba.1971,Scholkopf.Herbrich.Smola.2001</code>.
In fact, we can approximate many functions
much more compactly by using deeper (rather than wider) networks :cite:<code>Simonyan.Zisserman.2014</code>.
We will touch upon more rigorous arguments in subsequent chapters.</p>
<h2 id="activation-functions"><a class="header" href="#activation-functions">Activation Functions</a></h2>
<p>:label:<code>subsec_activation-functions</code></p>
<p>Activation functions decide whether a neuron should be activated or not by
calculating the weighted sum and further adding bias to it.
They are differentiable operators for transforming input signals to outputs,
while most of them add nonlinearity.
Because activation functions are fundamental to deep learning,
(<strong>let's briefly survey some common ones</strong>).</p>
<h3 id="relu-function"><a class="header" href="#relu-function">ReLU Function</a></h3>
<p>The most popular choice,
due to both simplicity of implementation and
its good performance on a variety of predictive tasks,
is the <em>rectified linear unit</em> (<em>ReLU</em>) :cite:<code>Nair.Hinton.2010</code>.
[<strong>ReLU provides a very simple nonlinear transformation</strong>].
Given an element $x$, the function is defined
as the maximum of that element and $0$:</p>
<p>$$\operatorname{ReLU}(x) = \max(x, 0).$$</p>
<p>Informally, the ReLU function retains only positive
elements and discards all negative elements
by setting the corresponding activations to 0.
To gain some intuition, we can plot the function.
As you can see, the activation function is piecewise linear.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(-8.0, 8.0, 0.1)
x.attach_grad()
with autograd.record():
    y = npx.relu(x)
d2l.plot(x, y, 'x', 'relu(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)
y = torch.relu(x)
d2l.plot(x.detach(), y.detach(), 'x', 'relu(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.Variable(tf.range(-8.0, 8.0, 0.1), dtype=tf.float32)
y = tf.nn.relu(x)
d2l.plot(x.numpy(), y.numpy(), 'x', 'relu(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(-8.0, 8.0, 0.1)
y = jax.nn.relu(x)
d2l.plot(x, y, 'x', 'relu(x)', figsize=(5, 2.5))
</code></pre>
<p>When the input is negative,
the derivative of the ReLU function is 0,
and when the input is positive,
the derivative of the ReLU function is 1.
Note that the ReLU function is not differentiable
when the input takes value precisely equal to 0.
In these cases, we default to the left-hand-side
derivative and say that the derivative is 0 when the input is 0.
We can get away with this because
the input may never actually be zero (mathematicians would
say that it is nondifferentiable on a set of measure zero).
There is an old adage that if subtle boundary conditions matter,
we are probably doing (<em>real</em>) mathematics, not engineering.
That conventional wisdom may apply here, or at least, the fact that
we are not performing constrained optimization :cite:<code>Mangasarian.1965,Rockafellar.1970</code>.
We plot the derivative of the ReLU function below.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y.backward()
d2l.plot(x, x.grad, 'x', 'grad of relu', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
y.backward(torch.ones_like(x), retain_graph=True)
d2l.plot(x.detach(), x.grad, 'x', 'grad of relu', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with tf.GradientTape() as t:
    y = tf.nn.relu(x)
d2l.plot(x.numpy(), t.gradient(y, x).numpy(), 'x', 'grad of relu',
         figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
grad_relu = vmap(grad(jax.nn.relu))
d2l.plot(x, grad_relu(x), 'x', 'grad of relu', figsize=(5, 2.5))
</code></pre>
<p>The reason for using ReLU is that
its derivatives are particularly well behaved:
either they vanish or they just let the argument through.
This makes optimization better behaved
and it mitigated the well-documented problem
of vanishing gradients that plagued
previous versions of neural networks (more on this later).</p>
<p>Note that there are many variants to the ReLU function,
including the <em>parametrized ReLU</em> (<em>pReLU</em>) function :cite:<code>He.Zhang.Ren.ea.2015</code>.
This variation adds a linear term to ReLU,
so some information still gets through,
even when the argument is negative:</p>
<p>$$\operatorname{pReLU}(x) = \max(0, x) + \alpha \min(0, x).$$</p>
<h3 id="sigmoid-function"><a class="header" href="#sigmoid-function">Sigmoid Function</a></h3>
<p>[<strong>The <em>sigmoid function</em> transforms those inputs</strong>]
whose values lie in the domain $\mathbb{R}$,
(<strong>to outputs that lie on the interval (0, 1).</strong>)
For that reason, the sigmoid is
often called a <em>squashing function</em>:
it squashes any input in the range (-inf, inf)
to some value in the range (0, 1):</p>
<p>$$\operatorname{sigmoid}(x) = \frac{1}{1 + \exp(-x)}.$$</p>
<p>In the earliest neural networks, scientists
were interested in modeling biological neurons
that either <em>fire</em> or <em>do not fire</em>.
Thus the pioneers of this field,
going all the way back to McCulloch and Pitts,
the inventors of the artificial neuron,
focused on thresholding units :cite:<code>McCulloch.Pitts.1943</code>.
A thresholding activation takes value 0
when its input is below some threshold
and value 1 when the input exceeds the threshold.</p>
<p>When attention shifted to gradient-based learning,
the sigmoid function was a natural choice
because it is a smooth, differentiable
approximation to a thresholding unit.
Sigmoids are still widely used as
activation functions on the output units
when we want to interpret the outputs as probabilities
for binary classification problems: you can think of the sigmoid as a special case of the softmax.
However, the sigmoid has largely been replaced
by the simpler and more easily trainable ReLU
for most use in hidden layers. Much of this has to do
with the fact that the sigmoid poses challenges for optimization
:cite:<code>LeCun.Bottou.Orr.ea.1998</code> since its gradient vanishes for large positive <em>and</em> negative arguments.
This can lead to plateaus that are difficult to escape from.
Nonetheless sigmoids are important. In later chapters (e.g., :numref:<code>sec_lstm</code>) on recurrent neural networks,
we will describe architectures that leverage sigmoid units
to control the flow of information across time.</p>
<p>Below, we plot the sigmoid function.
Note that when the input is close to 0,
the sigmoid function approaches
a linear transformation.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
with autograd.record():
    y = npx.sigmoid(x)
d2l.plot(x, y, 'x', 'sigmoid(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
y = torch.sigmoid(x)
d2l.plot(x.detach(), y.detach(), 'x', 'sigmoid(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
y = tf.nn.sigmoid(x)
d2l.plot(x.numpy(), y.numpy(), 'x', 'sigmoid(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = jax.nn.sigmoid(x)
d2l.plot(x, y, 'x', 'sigmoid(x)', figsize=(5, 2.5))
</code></pre>
<p>The derivative of the sigmoid function is given by the following equation:</p>
<p>$$\frac{d}{dx} \operatorname{sigmoid}(x) = \frac{\exp(-x)}{(1 + \exp(-x))^2} = \operatorname{sigmoid}(x)\left(1-\operatorname{sigmoid}(x)\right).$$</p>
<p>The derivative of the sigmoid function is plotted below.
Note that when the input is 0,
the derivative of the sigmoid function
reaches a maximum of 0.25.
As the input diverges from 0 in either direction,
the derivative approaches 0.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y.backward()
d2l.plot(x, x.grad, 'x', 'grad of sigmoid', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# Clear out previous gradients
x.grad.data.zero_()
y.backward(torch.ones_like(x),retain_graph=True)
d2l.plot(x.detach(), x.grad, 'x', 'grad of sigmoid', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with tf.GradientTape() as t:
    y = tf.nn.sigmoid(x)
d2l.plot(x.numpy(), t.gradient(y, x).numpy(), 'x', 'grad of sigmoid',
         figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
grad_sigmoid = vmap(grad(jax.nn.sigmoid))
d2l.plot(x, grad_sigmoid(x), 'x', 'grad of sigmoid', figsize=(5, 2.5))
</code></pre>
<h3 id="tanh-function"><a class="header" href="#tanh-function">Tanh Function</a></h3>
<p>:label:<code>subsec_tanh</code></p>
<p>Like the sigmoid function, [<strong>the tanh (hyperbolic tangent)
function also squashes its inputs</strong>],
transforming them into elements on the interval (<strong>between $-1$ and $1$</strong>):</p>
<p>$$\operatorname{tanh}(x) = \frac{1 - \exp(-2x)}{1 + \exp(-2x)}.$$</p>
<p>We plot the tanh function below. Note that as input nears 0, the tanh function approaches a linear transformation. Although the shape of the function is similar to that of the sigmoid function, the tanh function exhibits point symmetry about the origin of the coordinate system :cite:<code>Kalman.Kwasny.1992</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
with autograd.record():
    y = np.tanh(x)
d2l.plot(x, y, 'x', 'tanh(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
y = torch.tanh(x)
d2l.plot(x.detach(), y.detach(), 'x', 'tanh(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
y = tf.nn.tanh(x)
d2l.plot(x.numpy(), y.numpy(), 'x', 'tanh(x)', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = jax.nn.tanh(x)
d2l.plot(x, y, 'x', 'tanh(x)', figsize=(5, 2.5))
</code></pre>
<p>The derivative of the tanh function is:</p>
<p>$$\frac{d}{dx} \operatorname{tanh}(x) = 1 - \operatorname{tanh}^2(x).$$</p>
<p>It is plotted below.
As the input nears 0,
the derivative of the tanh function approaches a maximum of 1.
And as we saw with the sigmoid function,
as input moves away from 0 in either direction,
the derivative of the tanh function approaches 0.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y.backward()
d2l.plot(x, x.grad, 'x', 'grad of tanh', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# Clear out previous gradients
x.grad.data.zero_()
y.backward(torch.ones_like(x),retain_graph=True)
d2l.plot(x.detach(), x.grad, 'x', 'grad of tanh', figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with tf.GradientTape() as t:
    y = tf.nn.tanh(x)
d2l.plot(x.numpy(), t.gradient(y, x).numpy(), 'x', 'grad of tanh',
         figsize=(5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
grad_tanh = vmap(grad(jax.nn.tanh))
d2l.plot(x, grad_tanh(x), 'x', 'grad of tanh', figsize=(5, 2.5))
</code></pre>
<h2 id="summary-and-discussion-1"><a class="header" href="#summary-and-discussion-1">Summary and Discussion</a></h2>
<p>We now know how to incorporate nonlinearities
to build expressive multilayer neural network architectures.
As a side note, your knowledge already
puts you in command of a similar toolkit
to a practitioner circa 1990.
In some ways, you have an advantage
over anyone working back then,
because you can leverage powerful
open-source deep learning frameworks
to build models rapidly, using only a few lines of code.
Previously, training these networks
required researchers to code up layers and derivatives
explicitly in C, Fortran, or even Lisp (in the case of LeNet).</p>
<p>A secondary benefit is that ReLU is significantly more amenable to
optimization than the sigmoid or the tanh function. One could argue
that this was one of the key innovations that helped the resurgence
of deep learning over the past decade. Note, though, that research in
activation functions has not stopped.
For instance,
the GELU (Gaussian error linear unit)
activation function $x \Phi(x)$ by :citet:<code>Hendrycks.Gimpel.2016</code> ($\Phi(x)$
is the standard Gaussian cumulative distribution function)
and
the Swish activation
function $\sigma(x) = x \operatorname{sigmoid}(\beta x)$ as proposed in :citet:<code>Ramachandran.Zoph.Le.2017</code> can yield better accuracy
in many cases.</p>
<h2 id="exercises-22"><a class="header" href="#exercises-22">Exercises</a></h2>
<ol>
<li>Show that adding layers to a <em>linear</em> deep network, i.e., a network without
nonlinearity $\sigma$ can never increase the expressive power of the network.
Give an example where it actively reduces it.</li>
<li>Compute the derivative of the pReLU activation function.</li>
<li>Compute the derivative of the Swish activation function $x \operatorname{sigmoid}(\beta x)$.</li>
<li>Show that an MLP using only ReLU (or pReLU) constructs a
continuous piecewise linear function.</li>
<li>Sigmoid and tanh are very similar.
<ol>
<li>Show that $\operatorname{tanh}(x) + 1 = 2 \operatorname{sigmoid}(2x)$.</li>
<li>Prove that the function classes parametrized by both nonlinearities are identical. Hint: affine layers have bias terms, too.</li>
</ol>
</li>
<li>Assume that we have a nonlinearity that applies to one minibatch at a time, such as the batch normalization :cite:<code>Ioffe.Szegedy.2015</code>. What kinds of problems do you expect this to cause?</li>
<li>Provide an example where the gradients vanish for the sigmoid activation function.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/90">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/91">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/226">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17984">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="implementation-of-multilayer-perceptrons"><a class="header" href="#implementation-of-multilayer-perceptrons">Implementation of Multilayer Perceptrons</a></h1>
<p>:label:<code>sec_mlp-implementation</code></p>
<p>Multilayer perceptrons (MLPs) are not much more complex to implement than simple linear models. The key conceptual
difference is that we now concatenate multiple layers.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="implementation-from-scratch-1"><a class="header" href="#implementation-from-scratch-1">Implementation from Scratch</a></h2>
<p>Let's begin again by implementing such a network from scratch.</p>
<h3 id="initializing-model-parameters"><a class="header" href="#initializing-model-parameters">Initializing Model Parameters</a></h3>
<p>Recall that Fashion-MNIST contains 10 classes,
and that each image consists of a $28 \times 28 = 784$
grid of grayscale pixel values.
As before we will disregard the spatial structure
among the pixels for now,
so we can think of this as a classification dataset
with 784 input features and 10 classes.
To begin, we will [<strong>implement an MLP
with one hidden layer and 256 hidden units.</strong>]
Both the number of layers and their width are adjustable
(they are considered hyperparameters).
Typically, we choose the layer widths to be divisible by larger powers of 2.
This is computationally efficient due to the way
memory is allocated and addressed in hardware.</p>
<p>Again, we will represent our parameters with several tensors.
Note that <em>for every layer</em>, we must keep track of
one weight matrix and one bias vector.
As always, we allocate memory
for the gradients of the loss with respect to these parameters.</p>
<p>:begin_tab:<code>mxnet</code>
In the code below, we first define and initialize the parameters
and then enable gradient tracking.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In the code below we use <code>nn.Parameter</code>
to automatically register
a class attribute as a parameter to be tracked by <code>autograd</code> (:numref:<code>sec_autograd</code>).
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
In the code below we use <code>tf.Variable</code>
to define the model parameter.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
In the code below we use <code>flax.linen.Module.param</code>
to define the model parameter.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MLPScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W1 = np.random.randn(num_inputs, num_hiddens) * sigma
        self.b1 = np.zeros(num_hiddens)
        self.W2 = np.random.randn(num_hiddens, num_outputs) * sigma
        self.b2 = np.zeros(num_outputs)
        for param in self.get_scratch_params():
            param.attach_grad()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MLPScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens) * sigma)
        self.b1 = nn.Parameter(torch.zeros(num_hiddens))
        self.W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs) * sigma)
        self.b2 = nn.Parameter(torch.zeros(num_outputs))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MLPScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W1 = tf.Variable(
            tf.random.normal((num_inputs, num_hiddens)) * sigma)
        self.b1 = tf.Variable(tf.zeros(num_hiddens))
        self.W2 = tf.Variable(
            tf.random.normal((num_hiddens, num_outputs)) * sigma)
        self.b2 = tf.Variable(tf.zeros(num_outputs))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MLPScratch(d2l.Classifier):
    num_inputs: int
    num_outputs: int
    num_hiddens: int
    lr: float
    sigma: float = 0.01

    def setup(self):
        self.W1 = self.param('W1', nn.initializers.normal(self.sigma),
                             (self.num_inputs, self.num_hiddens))
        self.b1 = self.param('b1', nn.initializers.zeros, self.num_hiddens)
        self.W2 = self.param('W2', nn.initializers.normal(self.sigma),
                             (self.num_hiddens, self.num_outputs))
        self.b2 = self.param('b2', nn.initializers.zeros, self.num_outputs)
</code></pre>
<h3 id="model-1"><a class="header" href="#model-1">Model</a></h3>
<p>To make sure we know how everything works,
we will [<strong>implement the ReLU activation</strong>] ourselves
rather than invoking the built-in <code>relu</code> function directly.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def relu(X):
    return np.maximum(X, 0)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def relu(X):
    a = torch.zeros_like(X)
    return torch.max(X, a)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def relu(X):
    return tf.math.maximum(X, 0)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def relu(X):
    return jnp.maximum(X, 0)
</code></pre>
<p>Since we are disregarding spatial structure,
we <code>reshape</code> each two-dimensional image into
a flat vector of length  <code>num_inputs</code>.
Finally, we (<strong>implement our model</strong>)
with just a few lines of code. Since we use the framework built-in autograd this is all that it takes.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(MLPScratch)
def forward(self, X):
    X = d2l.reshape(X, (-1, self.num_inputs))
    H = relu(d2l.matmul(X, self.W1) + self.b1)
    return d2l.matmul(H, self.W2) + self.b2
</code></pre>
<h3 id="training-5"><a class="header" href="#training-5">Training</a></h3>
<p>Fortunately, [<strong>the training loop for MLPs
is exactly the same as for softmax regression.</strong>] We define the model, data, and trainer, then finally invoke the <code>fit</code> method on model and data.</p>
<pre><code class="language-{.python .input}">%%tab all
model = MLPScratch(num_inputs=784, num_outputs=10, num_hiddens=256, lr=0.1)
data = d2l.FashionMNIST(batch_size=256)
trainer = d2l.Trainer(max_epochs=10)
trainer.fit(model, data)
</code></pre>
<h2 id="concise-implementation-1"><a class="header" href="#concise-implementation-1">Concise Implementation</a></h2>
<p>As you might expect, by relying on the high-level APIs, we can implement MLPs even more concisely.</p>
<h3 id="model-2"><a class="header" href="#model-2">Model</a></h3>
<p>Compared with our concise implementation
of softmax regression implementation
(:numref:<code>sec_softmax_concise</code>),
the only difference is that we add
<em>two</em> fully connected layers where we previously added only <em>one</em>.
The first is [<strong>the hidden layer</strong>],
the second is the output layer.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential()
        self.net.add(nn.Dense(num_hiddens, activation='relu'),
                     nn.Dense(num_outputs))
        self.net.initialize()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential(nn.Flatten(), nn.LazyLinear(num_hiddens),
                                 nn.ReLU(), nn.LazyLinear(num_outputs))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = tf.keras.models.Sequential([
            tf.keras.layers.Flatten(),
            tf.keras.layers.Dense(num_hiddens, activation='relu'),
            tf.keras.layers.Dense(num_outputs)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MLP(d2l.Classifier):
    num_outputs: int
    num_hiddens: int
    lr: float

    @nn.compact
    def __call__(self, X):
        X = X.reshape((X.shape[0], -1))  # Flatten
        X = nn.Dense(self.num_hiddens)(X)
        X = nn.relu(X)
        X = nn.Dense(self.num_outputs)(X)
        return X
</code></pre>
<p>Previously, we defined <code>forward</code> methods for models to transform input using the model parameters.
These operations are essentially a pipeline:
you take an input and
apply a transformation (e.g.,
matrix multiplication with weights followed by bias addition),
then repetitively use the output of the current transformation as
input to the next transformation.
However, you may have noticed that
no <code>forward</code> method is defined here.
In fact, <code>MLP</code> inherits the <code>forward</code> method from the <code>Module</code> class (:numref:<code>subsec_oo-design-models</code>) to
simply invoke <code>self.net(X)</code> (<code>X</code> is input),
which is now defined as a sequence of transformations
via the <code>Sequential</code> class.
The <code>Sequential</code> class abstracts the forward process
enabling us to focus on the transformations.
We will further discuss how the <code>Sequential</code> class works in :numref:<code>subsec_model-construction-sequential</code>.</p>
<h3 id="training-6"><a class="header" href="#training-6">Training</a></h3>
<p>[<strong>The training loop</strong>] is exactly the same
as when we implemented softmax regression.
This modularity enables us to separate
matters concerning the model architecture
from orthogonal considerations.</p>
<pre><code class="language-{.python .input}">%%tab all
model = MLP(num_outputs=10, num_hiddens=256, lr=0.1)
trainer.fit(model, data)
</code></pre>
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<p>Now that we have more practice in designing deep networks, the step from a single to multiple layers of deep networks does not pose such a significant challenge any longer. In particular, we can reuse the training algorithm and data loader. Note, though, that implementing MLPs from scratch is nonetheless messy: naming and keeping track of the model parameters makes it difficult to extend models. For instance, imagine wanting to insert another layer between layers 42 and 43. This might now be layer 42b, unless we are willing to perform sequential renaming. Moreover, if we implement the network from scratch, it is much more difficult for the framework to perform meaningful performance optimizations.</p>
<p>Nonetheless, you have now reached the state of the art of the late 1980s when fully connected deep networks were the method of choice for neural network modeling. Our next conceptual step will be to consider images. Before we do so, we need to review a number of statistical basics and details on how to compute models efficiently.</p>
<h2 id="exercises-23"><a class="header" href="#exercises-23">Exercises</a></h2>
<ol>
<li>Change the number of hidden units <code>num_hiddens</code> and plot how its number affects the accuracy of the model. What is the best value of this hyperparameter?</li>
<li>Try adding a hidden layer to see how it affects the results.</li>
<li>Why is it a bad idea to insert a hidden layer with a single neuron? What could go wrong?</li>
<li>How does changing the learning rate alter your results? With all other parameters fixed, which learning rate gives you the best results? How does this relate to the number of epochs?</li>
<li>Let's optimize over all hyperparameters jointly, i.e., learning rate, number of epochs, number of hidden layers, and number of hidden units per layer.
<ol>
<li>What is the best result you can get by optimizing over all of them?</li>
<li>Why it is much more challenging to deal with multiple hyperparameters?</li>
<li>Describe an efficient strategy for optimizing over multiple parameters jointly.</li>
</ol>
</li>
<li>Compare the speed of the framework and the from-scratch implementation for a challenging problem. How does it change with the complexity of the network?</li>
<li>Measure the speed of tensor--matrix multiplications for well-aligned and misaligned matrices. For instance, test for matrices with dimension 1024, 1025, 1026, 1028, and 1032.
<ol>
<li>How does this change between GPUs and CPUs?</li>
<li>Determine the memory bus width of your CPU and GPU.</li>
</ol>
</li>
<li>Try out different activation functions. Which one works best?</li>
<li>Is there a difference between weight initializations of the network? Does it matter?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/92">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/93">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/227">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17985">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward-propagation-backward-propagation-and-computational-graphs"><a class="header" href="#forward-propagation-backward-propagation-and-computational-graphs">Forward Propagation, Backward Propagation, and Computational Graphs</a></h1>
<p>:label:<code>sec_backprop</code></p>
<p>So far, we have trained our models
with minibatch stochastic gradient descent.
However, when we implemented the algorithm,
we only worried about the calculations involved
in <em>forward propagation</em> through the model.
When it came time to calculate the gradients,
we just invoked the backpropagation function provided by the deep learning framework.</p>
<p>The automatic calculation of gradients
profoundly simplifies
the implementation of deep learning algorithms.
Before automatic differentiation,
even small changes to complicated models required
recalculating complicated derivatives by hand.
Surprisingly often, academic papers had to allocate
numerous pages to deriving update rules.
While we must continue to rely on automatic differentiation
so we can focus on the interesting parts,
you ought to know how these gradients
are calculated under the hood
if you want to go beyond a shallow
understanding of deep learning.</p>
<p>In this section, we take a deep dive
into the details of <em>backward propagation</em>
(more commonly called <em>backpropagation</em>).
To convey some insight for both the
techniques and their implementations,
we rely on some basic mathematics and computational graphs.
To start, we focus our exposition on
a one-hidden-layer MLP
with weight decay ($\ell_2$ regularization, to be described in subsequent chapters).</p>
<h2 id="forward-propagation"><a class="header" href="#forward-propagation">Forward Propagation</a></h2>
<p><em>Forward propagation</em> (or <em>forward pass</em>) refers to the calculation and storage
of intermediate variables (including outputs)
for a neural network in order
from the input layer to the output layer.
We now work step-by-step through the mechanics
of a neural network with one hidden layer.
This may seem tedious but in the eternal words
of funk virtuoso James Brown,
you must "pay the cost to be the boss".</p>
<p>For the sake of simplicity, let's assume
that the input example is $\mathbf{x}\in \mathbb{R}^d$
and that our hidden layer does not include a bias term.
Here the intermediate variable is:</p>
<p>$$\mathbf{z}= \mathbf{W}^{(1)} \mathbf{x},$$</p>
<p>where $\mathbf{W}^{(1)} \in \mathbb{R}^{h \times d}$
is the weight parameter of the hidden layer.
After running the intermediate variable
$\mathbf{z}\in \mathbb{R}^h$ through the
activation function $\phi$
we obtain our hidden activation vector of length $h$:</p>
<p>$$\mathbf{h}= \phi (\mathbf{z}).$$</p>
<p>The hidden layer output $\mathbf{h}$
is also an intermediate variable.
Assuming that the parameters of the output layer
possess only a weight of
$\mathbf{W}^{(2)} \in \mathbb{R}^{q \times h}$,
we can obtain an output layer variable
with a vector of length $q$:</p>
<p>$$\mathbf{o}= \mathbf{W}^{(2)} \mathbf{h}.$$</p>
<p>Assuming that the loss function is $l$
and the example label is $y$,
we can then calculate the loss term
for a single data example,</p>
<p>$$L = l(\mathbf{o}, y).$$</p>
<p>As we will see the definition of $\ell_2$ regularization
to be introduced later,
given the hyperparameter $\lambda$,
the regularization term is</p>
<p>$$s = \frac{\lambda}{2} \left(|\mathbf{W}^{(1)}|<em>\textrm{F}^2 + |\mathbf{W}^{(2)}|</em>\textrm{F}^2\right),$$
:eqlabel:<code>eq_forward-s</code></p>
<p>where the Frobenius norm of the matrix
is simply the $\ell_2$ norm applied
after flattening the matrix into a vector.
Finally, the model's regularized loss
on a given data example is:</p>
<p>$$J = L + s.$$</p>
<p>We refer to $J$ as the <em>objective function</em>
in the following discussion.</p>
<h2 id="computational-graph-of-forward-propagation"><a class="header" href="#computational-graph-of-forward-propagation">Computational Graph of Forward Propagation</a></h2>
<p>Plotting <em>computational graphs</em> helps us visualize
the dependencies of operators
and variables within the calculation.
:numref:<code>fig_forward</code> contains the graph associated
with the simple network described above,
where squares denote variables and circles denote operators.
The lower-left corner signifies the input
and the upper-right corner is the output.
Notice that the directions of the arrows
(which illustrate data flow)
are primarily rightward and upward.</p>
<p><img src="chapter_multilayer-perceptrons/../img/forward.svg" alt="Computational graph of forward propagation." />
:label:<code>fig_forward</code></p>
<h2 id="backpropagation"><a class="header" href="#backpropagation">Backpropagation</a></h2>
<p><em>Backpropagation</em> refers to the method of calculating
the gradient of neural network parameters.
In short, the method traverses the network in reverse order,
from the output to the input layer,
according to the <em>chain rule</em> from calculus.
The algorithm stores any intermediate variables
(partial derivatives)
required while calculating the gradient
with respect to some parameters.
Assume that we have functions
$\mathsf{Y}=f(\mathsf{X})$
and $\mathsf{Z}=g(\mathsf{Y})$,
in which the input and the output
$\mathsf{X}, \mathsf{Y}, \mathsf{Z}$
are tensors of arbitrary shapes.
By using the chain rule,
we can compute the derivative
of $\mathsf{Z}$ with respect to $\mathsf{X}$ via</p>
<p>$$\frac{\partial \mathsf{Z}}{\partial \mathsf{X}} = \textrm{prod}\left(\frac{\partial \mathsf{Z}}{\partial \mathsf{Y}}, \frac{\partial \mathsf{Y}}{\partial \mathsf{X}}\right).$$</p>
<p>Here we use the $\textrm{prod}$ operator
to multiply its arguments
after the necessary operations,
such as transposition and swapping input positions,
have been carried out.
For vectors, this is straightforward:
it is simply matrix--matrix multiplication.
For higher dimensional tensors,
we use the appropriate counterpart.
The operator $\textrm{prod}$ hides all the notational overhead.</p>
<p>Recall that
the parameters of the simple network with one hidden layer,
whose computational graph is in :numref:<code>fig_forward</code>,
are $\mathbf{W}^{(1)}$ and $\mathbf{W}^{(2)}$.
The objective of backpropagation is to
calculate the gradients $\partial J/\partial \mathbf{W}^{(1)}$
and $\partial J/\partial \mathbf{W}^{(2)}$.
To accomplish this, we apply the chain rule
and calculate, in turn, the gradient of
each intermediate variable and parameter.
The order of calculations are reversed
relative to those performed in forward propagation,
since we need to start with the outcome of the computational graph
and work our way towards the parameters.
The first step is to calculate the gradients
of the objective function $J=L+s$
with respect to the loss term $L$
and the regularization term $s$:</p>
<p>$$\frac{\partial J}{\partial L} = 1 ; \textrm{and} ; \frac{\partial J}{\partial s} = 1.$$</p>
<p>Next, we compute the gradient of the objective function
with respect to variable of the output layer $\mathbf{o}$
according to the chain rule:</p>
<p>$$
\frac{\partial J}{\partial \mathbf{o}}
= \textrm{prod}\left(\frac{\partial J}{\partial L}, \frac{\partial L}{\partial \mathbf{o}}\right)
= \frac{\partial L}{\partial \mathbf{o}}
\in \mathbb{R}^q.
$$</p>
<p>Next, we calculate the gradients
of the regularization term
with respect to both parameters:</p>
<p>$$\frac{\partial s}{\partial \mathbf{W}^{(1)}} = \lambda \mathbf{W}^{(1)}
; \textrm{and} ;
\frac{\partial s}{\partial \mathbf{W}^{(2)}} = \lambda \mathbf{W}^{(2)}.$$</p>
<p>Now we are able to calculate the gradient
$\partial J/\partial \mathbf{W}^{(2)} \in \mathbb{R}^{q \times h}$
of the model parameters closest to the output layer.
Using the chain rule yields:</p>
<p>$$\frac{\partial J}{\partial \mathbf{W}^{(2)}}= \textrm{prod}\left(\frac{\partial J}{\partial \mathbf{o}}, \frac{\partial \mathbf{o}}{\partial \mathbf{W}^{(2)}}\right) + \textrm{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial \mathbf{W}^{(2)}}\right)= \frac{\partial J}{\partial \mathbf{o}} \mathbf{h}^\top + \lambda \mathbf{W}^{(2)}.$$
:eqlabel:<code>eq_backprop-J-h</code></p>
<p>To obtain the gradient with respect to $\mathbf{W}^{(1)}$
we need to continue backpropagation
along the output layer to the hidden layer.
The gradient with respect to the hidden layer output
$\partial J/\partial \mathbf{h} \in \mathbb{R}^h$ is given by</p>
<p>$$
\frac{\partial J}{\partial \mathbf{h}}
= \textrm{prod}\left(\frac{\partial J}{\partial \mathbf{o}}, \frac{\partial \mathbf{o}}{\partial \mathbf{h}}\right)
= {\mathbf{W}^{(2)}}^\top \frac{\partial J}{\partial \mathbf{o}}.
$$</p>
<p>Since the activation function $\phi$ applies elementwise,
calculating the gradient $\partial J/\partial \mathbf{z} \in \mathbb{R}^h$
of the intermediate variable $\mathbf{z}$
requires that we use the elementwise multiplication operator,
which we denote by $\odot$:</p>
<p>$$
\frac{\partial J}{\partial \mathbf{z}}
= \textrm{prod}\left(\frac{\partial J}{\partial \mathbf{h}}, \frac{\partial \mathbf{h}}{\partial \mathbf{z}}\right)
= \frac{\partial J}{\partial \mathbf{h}} \odot \phi'\left(\mathbf{z}\right).
$$</p>
<p>Finally, we can obtain the gradient
$\partial J/\partial \mathbf{W}^{(1)} \in \mathbb{R}^{h \times d}$
of the model parameters closest to the input layer.
According to the chain rule, we get</p>
<p>$$
\frac{\partial J}{\partial \mathbf{W}^{(1)}}
= \textrm{prod}\left(\frac{\partial J}{\partial \mathbf{z}}, \frac{\partial \mathbf{z}}{\partial \mathbf{W}^{(1)}}\right) + \textrm{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial \mathbf{W}^{(1)}}\right)
= \frac{\partial J}{\partial \mathbf{z}} \mathbf{x}^\top + \lambda \mathbf{W}^{(1)}.
$$</p>
<h2 id="training-neural-networks"><a class="header" href="#training-neural-networks">Training Neural Networks</a></h2>
<p>When training neural networks,
forward and backward propagation depend on each other.
In particular, for forward propagation,
we traverse the computational graph in the direction of dependencies
and compute all the variables on its path.
These are then used for backpropagation
where the compute order on the graph is reversed.</p>
<p>Take the aforementioned simple network as an illustrative example.
On the one hand,
computing the regularization term :eqref:<code>eq_forward-s</code>
during forward propagation
depends on the current values of model parameters $\mathbf{W}^{(1)}$ and $\mathbf{W}^{(2)}$.
They are given by the optimization algorithm according to backpropagation in the most recent iteration.
On the other hand,
the gradient calculation for the parameter
:eqref:<code>eq_backprop-J-h</code> during backpropagation
depends on the current value of the hidden layer output $\mathbf{h}$,
which is given by forward propagation.</p>
<p>Therefore when training neural networks, once model parameters are initialized,
we alternate forward propagation with backpropagation,
updating model parameters using gradients given by backpropagation.
Note that backpropagation reuses the stored intermediate values from forward propagation to avoid duplicate calculations.
One of the consequences is that we need to retain
the intermediate values until backpropagation is complete.
This is also one of the reasons why training
requires significantly more memory than plain prediction.
Besides, the size of such intermediate values is roughly
proportional to the number of network layers and the batch size.
Thus,
training deeper networks using larger batch sizes
more easily leads to <em>out-of-memory</em> errors.</p>
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<p>Forward propagation sequentially calculates and stores intermediate variables within the computational graph defined by the neural network. It proceeds from the input to the output layer.
Backpropagation sequentially calculates and stores the gradients of intermediate variables and parameters within the neural network in the reversed order.
When training deep learning models, forward propagation and backpropagation are interdependent,
and training requires significantly more memory than prediction.</p>
<h2 id="exercises-24"><a class="header" href="#exercises-24">Exercises</a></h2>
<ol>
<li>Assume that the inputs $\mathbf{X}$ to some scalar function $f$ are $n \times m$ matrices. What is the dimensionality of the gradient of $f$ with respect to $\mathbf{X}$?</li>
<li>Add a bias to the hidden layer of the model described in this section (you do not need to include bias in the regularization term).
<ol>
<li>Draw the corresponding computational graph.</li>
<li>Derive the forward and backward propagation equations.</li>
</ol>
</li>
<li>Compute the memory footprint for training and prediction in the model described in this section.</li>
<li>Assume that you want to compute second derivatives. What happens to the computational graph? How long do you expect the calculation to take?</li>
<li>Assume that the computational graph is too large for your GPU.
<ol>
<li>Can you partition it over more than one GPU?</li>
<li>What are the advantages and disadvantages over training on a smaller minibatch?</li>
</ol>
</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/102">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="numerical-stability-and-initialization"><a class="header" href="#numerical-stability-and-initialization">Numerical Stability and Initialization</a></h1>
<p>:label:<code>sec_numerical_stability</code></p>
<p>Thus far, every model that we have implemented
required that we initialize its parameters
according to some pre-specified distribution.
Until now, we took the initialization scheme for granted,
glossing over the details of how these choices are made.
You might have even gotten the impression that these choices
are not especially important.
On the contrary, the choice of initialization scheme
plays a significant role in neural network learning,
and it can be crucial for maintaining numerical stability.
Moreover, these choices can be tied up in interesting ways
with the choice of the nonlinear activation function.
Which function we choose and how we initialize parameters
can determine how quickly our optimization algorithm converges.
Poor choices here can cause us to encounter
exploding or vanishing gradients while training.
In this section, we delve into these topics in greater detail
and discuss some useful heuristics
that you will find useful
throughout your career in deep learning.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
from jax import grad, vmap
</code></pre>
<h2 id="vanishing-and-exploding-gradients"><a class="header" href="#vanishing-and-exploding-gradients">Vanishing and Exploding Gradients</a></h2>
<p>Consider a deep network with $L$ layers,
input $\mathbf{x}$ and output $\mathbf{o}$.
With each layer $l$ defined by a transformation $f_l$
parametrized by weights $\mathbf{W}^{(l)}$,
whose hidden layer output is $\mathbf{h}^{(l)}$ (let $\mathbf{h}^{(0)} = \mathbf{x}$),
our network can be expressed as:</p>
<p>$$\mathbf{h}^{(l)} = f_l (\mathbf{h}^{(l-1)}) \textrm{ and thus } \mathbf{o} = f_L \circ \cdots \circ f_1(\mathbf{x}).$$</p>
<p>If all the hidden layer output and the input are vectors,
we can write the gradient of $\mathbf{o}$ with respect to
any set of parameters $\mathbf{W}^{(l)}$ as follows:</p>
<p>$$\partial_{\mathbf{W}^{(l)}} \mathbf{o} = \underbrace{\partial_{\mathbf{h}^{(L-1)}} \mathbf{h}^{(L)}}<em>{ \mathbf{M}^{(L)} \stackrel{\textrm{def}}{=}} \cdots \underbrace{\partial</em>{\mathbf{h}^{(l)}} \mathbf{h}^{(l+1)}}<em>{ \mathbf{M}^{(l+1)} \stackrel{\textrm{def}}{=}} \underbrace{\partial</em>{\mathbf{W}^{(l)}} \mathbf{h}^{(l)}}_{ \mathbf{v}^{(l)} \stackrel{\textrm{def}}{=}}.$$</p>
<p>In other words, this gradient is
the product of $L-l$ matrices
$\mathbf{M}^{(L)} \cdots \mathbf{M}^{(l+1)}$
and the gradient vector $\mathbf{v}^{(l)}$.
Thus we are susceptible to the same
problems of numerical underflow that often crop up
when multiplying together too many probabilities.
When dealing with probabilities, a common trick is to
switch into log-space, i.e., shifting
pressure from the mantissa to the exponent
of the numerical representation.
Unfortunately, our problem above is more serious:
initially the matrices $\mathbf{M}^{(l)}$ may have a wide variety of eigenvalues.
They might be small or large, and
their product might be <em>very large</em> or <em>very small</em>.</p>
<p>The risks posed by unstable gradients
go beyond numerical representation.
Gradients of unpredictable magnitude
also threaten the stability of our optimization algorithms.
We may be facing parameter updates that are either
(i) excessively large, destroying our model
(the <em>exploding gradient</em> problem);
or (ii) excessively small
(the <em>vanishing gradient</em> problem),
rendering learning impossible as parameters
hardly move on each update.</p>
<h3 id="vanishing-gradients"><a class="header" href="#vanishing-gradients">(<strong>Vanishing Gradients</strong>)</a></h3>
<p>One frequent culprit causing the vanishing gradient problem
is the choice of the activation function $\sigma$
that is appended following each layer's linear operations.
Historically, the sigmoid function
$1/(1 + \exp(-x))$ (introduced in :numref:<code>sec_mlp</code>)
was popular because it resembles a thresholding function.
Since early artificial neural networks were inspired
by biological neural networks,
the idea of neurons that fire either <em>fully</em> or <em>not at all</em>
(like biological neurons) seemed appealing.
Let's take a closer look at the sigmoid
to see why it can cause vanishing gradients.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(-8.0, 8.0, 0.1)
x.attach_grad()
with autograd.record():
    y = npx.sigmoid(x)
y.backward()

d2l.plot(x, [y, x.grad], legend=['sigmoid', 'gradient'], figsize=(4.5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)
y = torch.sigmoid(x)
y.backward(torch.ones_like(x))

d2l.plot(x.detach().numpy(), [y.detach().numpy(), x.grad.numpy()],
         legend=['sigmoid', 'gradient'], figsize=(4.5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.Variable(tf.range(-8.0, 8.0, 0.1))
with tf.GradientTape() as t:
    y = tf.nn.sigmoid(x)
d2l.plot(x.numpy(), [y.numpy(), t.gradient(y, x).numpy()],
         legend=['sigmoid', 'gradient'], figsize=(4.5, 2.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(-8.0, 8.0, 0.1)
y = jax.nn.sigmoid(x)
grad_sigmoid = vmap(grad(jax.nn.sigmoid))
d2l.plot(x, [y, grad_sigmoid(x)],
         legend=['sigmoid', 'gradient'], figsize=(4.5, 2.5))
</code></pre>
<p>As you can see, (<strong>the sigmoid's gradient vanishes
both when its inputs are large and when they are small</strong>).
Moreover, when backpropagating through many layers,
unless we are in the Goldilocks zone, where
the inputs to many of the sigmoids are close to zero,
the gradients of the overall product may vanish.
When our network boasts many layers,
unless we are careful, the gradient
will likely be cut off at some layer.
Indeed, this problem used to plague deep network training.
Consequently, ReLUs, which are more stable
(but less neurally plausible),
have emerged as the default choice for practitioners.</p>
<h3 id="exploding-gradients"><a class="header" href="#exploding-gradients">[<strong>Exploding Gradients</strong>]</a></h3>
<p>The opposite problem, when gradients explode,
can be similarly vexing.
To illustrate this a bit better,
we draw 100 Gaussian random matrices
and multiply them with some initial matrix.
For the scale that we picked
(the choice of the variance $\sigma^2=1$),
the matrix product explodes.
When this happens because of the initialization
of a deep network, we have no chance of getting
a gradient descent optimizer to converge.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
M = np.random.normal(size=(4, 4))
print('a single matrix', M)
for i in range(100):
    M = np.dot(M, np.random.normal(size=(4, 4)))
print('after multiplying 100 matrices', M)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
M = torch.normal(0, 1, size=(4, 4))
print('a single matrix \n',M)
for i in range(100):
    M = M @ torch.normal(0, 1, size=(4, 4))
print('after multiplying 100 matrices\n', M)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
M = tf.random.normal((4, 4))
print('a single matrix \n', M)
for i in range(100):
    M = tf.matmul(M, tf.random.normal((4, 4)))
print('after multiplying 100 matrices\n', M.numpy())
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
get_key = lambda: jax.random.PRNGKey(d2l.get_seed())  # Generate PRNG keys
M = jax.random.normal(get_key(), (4, 4))
print('a single matrix \n', M)
for i in range(100):
    M = jnp.matmul(M, jax.random.normal(get_key(), (4, 4)))
print('after multiplying 100 matrices\n', M)
</code></pre>
<h3 id="breaking-the-symmetry"><a class="header" href="#breaking-the-symmetry">Breaking the Symmetry</a></h3>
<p>Another problem in neural network design
is the symmetry inherent in their parametrization.
Assume that we have a simple MLP
with one hidden layer and two units.
In this case, we could permute the weights $\mathbf{W}^{(1)}$
of the first layer and likewise permute
the weights of the output layer
to obtain the same function.
There is nothing special differentiating
the first and second hidden units.
In other words, we have permutation symmetry
among the hidden units of each layer.</p>
<p>This is more than just a theoretical nuisance.
Consider the aforementioned one-hidden-layer MLP
with two hidden units.
For illustration,
suppose that the output layer transforms the two hidden units into only one output unit.
Imagine what would happen if we initialized
all the parameters of the hidden layer
as $\mathbf{W}^{(1)} = c$ for some constant $c$.
In this case, during forward propagation
either hidden unit takes the same inputs and parameters
producing the same activation
which is fed to the output unit.
During backpropagation,
differentiating the output unit with respect to parameters $\mathbf{W}^{(1)}$ gives a gradient all of whose elements take the same value.
Thus, after gradient-based iteration (e.g., minibatch stochastic gradient descent),
all the elements of $\mathbf{W}^{(1)}$ still take the same value.
Such iterations would
never <em>break the symmetry</em> on their own
and we might never be able to realize
the network's expressive power.
The hidden layer would behave
as if it had only a single unit.
Note that while minibatch stochastic gradient descent would not break this symmetry,
dropout regularization (to be introduced later) would!</p>
<h2 id="parameter-initialization"><a class="header" href="#parameter-initialization">Parameter Initialization</a></h2>
<p>One way of addressing---or at least mitigating---the
issues raised above is through careful initialization.
As we will see later,
additional care during optimization
and suitable regularization can further enhance stability.</p>
<h3 id="default-initialization"><a class="header" href="#default-initialization">Default Initialization</a></h3>
<p>In the previous sections, e.g., in :numref:<code>sec_linear_concise</code>,
we used a normal distribution
to initialize the values of our weights.
If we do not specify the initialization method, the framework will
use a default random initialization method, which often works well in practice
for moderate problem sizes.</p>
<h3 id="xavier-initialization"><a class="header" href="#xavier-initialization">Xavier Initialization</a></h3>
<p>:label:<code>subsec_xavier</code></p>
<p>Let's look at the scale distribution of
an output $o_{i}$ for some fully connected layer
<em>without nonlinearities</em>.
With $n_\textrm{in}$ inputs $x_j$
and their associated weights $w_{ij}$ for this layer,
an output is given by</p>
<p>$$o_{i} = \sum_{j=1}^{n_\textrm{in}} w_{ij} x_j.$$</p>
<p>The weights $w_{ij}$ are all drawn
independently from the same distribution.
Furthermore, let's assume that this distribution
has zero mean and variance $\sigma^2$.
Note that this does not mean that the distribution has to be Gaussian,
just that the mean and variance need to exist.
For now, let's assume that the inputs to the layer $x_j$
also have zero mean and variance $\gamma^2$
and that they are independent of $w_{ij}$ and independent of each other.
In this case, we can compute the mean of $o_i$:</p>
<p>$$
\begin{aligned}
E[o_i] &amp; = \sum_{j=1}^{n_\textrm{in}} E[w_{ij} x_j] \&amp;= \sum_{j=1}^{n_\textrm{in}} E[w_{ij}] E[x_j] \&amp;= 0, \end{aligned}$$</p>
<p>and the variance:</p>
<p>$$
\begin{aligned}
\textrm{Var}[o_i] &amp; = E[o_i^2] - (E[o_i])^2 \
&amp; = \sum_{j=1}^{n_\textrm{in}} E[w^2_{ij} x^2_j] - 0 \
&amp; = \sum_{j=1}^{n_\textrm{in}} E[w^2_{ij}] E[x^2_j] \
&amp; = n_\textrm{in} \sigma^2 \gamma^2.
\end{aligned}
$$</p>
<p>One way to keep the variance fixed
is to set $n_\textrm{in} \sigma^2 = 1$.
Now consider backpropagation.
There we face a similar problem,
albeit with gradients being propagated from the layers closer to the output.
Using the same reasoning as for forward propagation,
we see that the gradients' variance can blow up
unless $n_\textrm{out} \sigma^2 = 1$,
where $n_\textrm{out}$ is the number of outputs of this layer.
This leaves us in a dilemma:
we cannot possibly satisfy both conditions simultaneously.
Instead, we simply try to satisfy:</p>
<p>$$
\begin{aligned}
\frac{1}{2} (n_\textrm{in} + n_\textrm{out}) \sigma^2 = 1 \textrm{ or equivalently }
\sigma = \sqrt{\frac{2}{n_\textrm{in} + n_\textrm{out}}}.
\end{aligned}
$$</p>
<p>This is the reasoning underlying the now-standard
and practically beneficial <em>Xavier initialization</em>,
named after the first author of its creators :cite:<code>Glorot.Bengio.2010</code>.
Typically, the Xavier initialization
samples weights from a Gaussian distribution
with zero mean and variance
$\sigma^2 = \frac{2}{n_\textrm{in} + n_\textrm{out}}$.
We can also adapt this to
choose the variance when sampling weights
from a uniform distribution.
Note that the uniform distribution $U(-a, a)$ has variance $\frac{a^2}{3}$.
Plugging $\frac{a^2}{3}$ into our condition on $\sigma^2$
prompts us to initialize according to</p>
<p>$$U\left(-\sqrt{\frac{6}{n_\textrm{in} + n_\textrm{out}}}, \sqrt{\frac{6}{n_\textrm{in} + n_\textrm{out}}}\right).$$</p>
<p>Though the assumption for nonexistence of nonlinearities
in the above mathematical reasoning
can be easily violated in neural networks,
the Xavier initialization method
turns out to work well in practice.</p>
<h3 id="beyond"><a class="header" href="#beyond">Beyond</a></h3>
<p>The reasoning above barely scratches the surface
of modern approaches to parameter initialization.
A deep learning framework often implements over a dozen different heuristics.
Moreover, parameter initialization continues to be
a hot area of fundamental research in deep learning.
Among these are heuristics specialized for
tied (shared) parameters, super-resolution,
sequence models, and other situations.
For instance,
:citet:<code>Xiao.Bahri.Sohl-Dickstein.ea.2018</code> demonstrated the possibility of training
10,000-layer neural networks without architectural tricks
by using a carefully-designed initialization method.</p>
<p>If the topic interests you we suggest
a deep dive into this module's offerings,
reading the papers that proposed and analyzed each heuristic,
and then exploring the latest publications on the topic.
Perhaps you will stumble across or even invent
a clever idea and contribute an implementation to deep learning frameworks.</p>
<h2 id="summary-18"><a class="header" href="#summary-18">Summary</a></h2>
<p>Vanishing and exploding gradients are common issues in deep networks. Great care in parameter initialization is required to ensure that gradients and parameters remain well controlled.
Initialization heuristics are needed to ensure that the initial gradients are neither too large nor too small.
Random initialization is key to ensuring that symmetry is broken before optimization.
Xavier initialization suggests that, for each layer, variance of any output is not affected by the number of inputs, and variance of any gradient is not affected by the number of outputs.
ReLU activation functions mitigate the vanishing gradient problem. This can accelerate convergence.</p>
<h2 id="exercises-25"><a class="header" href="#exercises-25">Exercises</a></h2>
<ol>
<li>Can you design other cases where a neural network might exhibit symmetry that needs breaking, besides the permutation symmetry in an MLP's layers?</li>
<li>Can we initialize all weight parameters in linear regression or in softmax regression to the same value?</li>
<li>Look up analytic bounds on the eigenvalues of the product of two matrices. What does this tell you about ensuring that gradients are well conditioned?</li>
<li>If we know that some terms diverge, can we fix this after the fact? Look at the paper on layerwise adaptive rate scaling  for inspiration :cite:<code>You.Gitman.Ginsburg.2017</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/103">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/104">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/235">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17986">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalization-in-deep-learning"><a class="header" href="#generalization-in-deep-learning">Generalization in Deep Learning</a></h1>
<p>In :numref:<code>chap_regression</code> and :numref:<code>chap_classification</code>,
we tackled regression and classification problems
by fitting linear models to training data.
In both cases, we provided practical algorithms
for finding the parameters that maximized
the likelihood of the observed training labels.
And then, towards the end of each chapter,
we recalled that fitting the training data
was only an intermediate goal.
Our real quest all along was to discover <em>general patterns</em>
on the basis of which we can make accurate predictions
even on new examples drawn from the same underlying population.
Machine learning researchers are <em>consumers</em> of optimization algorithms.
Sometimes, we must even develop new optimization algorithms.
But at the end of the day, optimization is merely a means to an end.
At its core, machine learning is a statistical discipline
and we wish to optimize training loss only insofar
as some statistical principle (known or unknown)
leads the resulting models to generalize beyond the training set.</p>
<p>On the bright side, it turns out that deep neural networks
trained by stochastic gradient descent generalize remarkably well
across myriad prediction problems, spanning computer vision;
natural language processing; time series data; recommender systems;
electronic health records; protein folding;
value function approximation in video games
and board games; and numerous other domains.
On the downside, if you were looking
for a straightforward account
of either the optimization story
(why we can fit them to training data)
or the generalization story
(why the resulting models generalize to unseen examples),
then you might want to pour yourself a drink.
While our procedures for optimizing linear models
and the statistical properties of the solutions
are both described well by a comprehensive body of theory,
our understanding of deep learning
still resembles the wild west on both fronts.</p>
<p>Both the theory and practice of deep learning
are rapidly evolving,
with theorists adopting new strategies
to explain what's going on,
even as practitioners continue
to innovate at a blistering pace,
building arsenals of heuristics for training deep networks
and a body of intuitions and folk knowledge
that provide guidance for deciding
which techniques to apply in which situations.</p>
<p>The summary of the present moment is that the theory of deep learning
has produced promising lines of attack and scattered fascinating results,
but still appears far from a comprehensive account
of both (i) why we are able to optimize neural networks
and (ii) how models learned by gradient descent
manage to generalize so well, even on high-dimensional tasks.
However, in practice, (i) is seldom a problem
(we can always find parameters that will fit all of our training data)
and thus understanding generalization is far the bigger problem.
On the other hand, even absent the comfort of a coherent scientific theory,
practitioners have developed a large collection of techniques
that may help you to produce models that generalize well in practice.
While no pithy summary can possibly do justice
to the vast topic of generalization in deep learning,
and while the overall state of research is far from resolved,
we hope, in this section, to present a broad overview
of the state of research and practice.</p>
<h2 id="revisiting-overfitting-and-regularization"><a class="header" href="#revisiting-overfitting-and-regularization">Revisiting Overfitting and Regularization</a></h2>
<p>According to the "no free lunch" theorem of :citet:<code>wolpert1995no</code>,
any learning algorithm generalizes better on data with certain distributions, and worse with other distributions.
Thus, given a finite training set,
a model relies on certain assumptions:
to achieve human-level performance
it may be useful to identify <em>inductive biases</em>
that reflect how humans think about the world.
Such inductive biases show preferences
for solutions with certain properties.
For example,
a deep MLP has an inductive bias
towards building up a complicated function by the composition of simpler functions.</p>
<p>With machine learning models encoding inductive biases,
our approach to training them
typically consists of two phases: (i) fit the training data;
and (ii) estimate the <em>generalization error</em>
(the true error on the underlying population)
by evaluating the model on holdout data.
The difference between our fit on the training data
and our fit on the test data is called the <em>generalization gap</em> and when this is large,
we say that our models <em>overfit</em> to the training data.
In extreme cases of overfitting,
we might exactly fit the training data,
even when the test error remains significant.
And in the classical view,
the interpretation is that our models are too complex,
requiring that we either shrink the number of features,
the number of nonzero parameters learned,
or the size of the parameters as quantified.
Recall the plot of model complexity compared with loss
(:numref:<code>fig_capacity_vs_error</code>)
from :numref:<code>sec_generalization_basics</code>.</p>
<p>However deep learning complicates this picture in counterintuitive ways.
First, for classification problems,
our models are typically expressive enough
to perfectly fit every training example,
even in datasets consisting of millions
:cite:<code>zhang2021understanding</code>.
In the classical picture, we might think
that this setting lies on the far right extreme
of the model complexity axis,
and that any improvements in generalization error
must come by way of regularization,
either by reducing the complexity of the model class,
or by applying a penalty, severely constraining
the set of values that our parameters might take.
But that is where things start to get weird.</p>
<p>Strangely, for many deep learning tasks
(e.g., image recognition and text classification)
we are typically choosing among model architectures,
all of which can achieve arbitrarily low training loss
(and zero training error).
Because all models under consideration achieve zero training error,
<em>the only avenue for further gains is to reduce overfitting</em>.
Even stranger, it is often the case that
despite fitting the training data perfectly,
we can actually <em>reduce the generalization error</em>
further by making the model <em>even more expressive</em>,
e.g., adding layers, nodes, or training
for a larger number of epochs.
Stranger yet, the pattern relating the generalization gap
to the <em>complexity</em> of the model (as captured, for example, in the depth or width of the networks)
can be non-monotonic,
with greater complexity hurting at first
but subsequently helping in a so-called "double-descent" pattern
:cite:<code>nakkiran2021deep</code>.
Thus the deep learning practitioner possesses a bag of tricks,
some of which seemingly restrict the model in some fashion
and others that seemingly make it even more expressive,
and all of which, in some sense, are applied to mitigate overfitting.</p>
<p>Complicating things even further,
while the guarantees provided by classical learning theory
can be conservative even for classical models,
they appear powerless to explain why it is
that deep neural networks generalize in the first place.
Because deep neural networks are capable of fitting
arbitrary labels even for large datasets,
and despite the use of familiar methods such as $\ell_2$ regularization,
traditional complexity-based generalization bounds,
e.g., those based on the VC dimension
or Rademacher complexity of a hypothesis class
cannot explain why neural networks generalize.</p>
<h2 id="inspiration-from-nonparametrics"><a class="header" href="#inspiration-from-nonparametrics">Inspiration from Nonparametrics</a></h2>
<p>Approaching deep learning for the first time,
it is tempting to think of them as parametric models.
After all, the models <em>do</em> have millions of parameters.
When we update the models, we update their parameters.
When we save the models, we write their parameters to disk.
However, mathematics and computer science are riddled
with counterintuitive changes of perspective,
and surprising isomorphisms between seemingly different problems.
While neural networks clearly <em>have</em> parameters,
in some ways it can be more fruitful
to think of them as behaving like nonparametric models.
So what precisely makes a model nonparametric?
While the name covers a diverse set of approaches,
one common theme is that nonparametric methods
tend to have a level of complexity that grows
as the amount of available data grows.</p>
<p>Perhaps the simplest example of a nonparametric model
is the $k$-nearest neighbor algorithm (we will cover more nonparametric models later, for example in :numref:<code>sec_attention-pooling</code>).
Here, at training time,
the learner simply memorizes the dataset.
Then, at prediction time,
when confronted with a new point $\mathbf{x}$,
the learner looks up the $k$ nearest neighbors
(the $k$ points $\mathbf{x}_i'$ that minimize
some distance $d(\mathbf{x}, \mathbf{x}_i')$).
When $k=1$, this algorithm is called $1$-nearest neighbors,
and the algorithm will always achieve a training error of zero.
That however, does not mean that the algorithm will not generalize.
In fact, it turns out that under some mild conditions,
the 1-nearest neighbor algorithm is consistent
(eventually converging to the optimal predictor).</p>
<p>Note that $1$-nearest neighbor requires that we specify
some distance function $d$, or equivalently,
that we specify some vector-valued basis function $\phi(\mathbf{x})$
for featurizing our data.
For any choice of the distance metric,
we will achieve zero training error
and eventually reach an optimal predictor,
but different distance metrics $d$
encode different inductive biases
and with a finite amount of available data
will yield different predictors.
Different choices of the distance metric $d$
represent different assumptions about the underlying patterns
and the performance of the different predictors
will depend on how compatible the assumptions
are with the observed data.</p>
<p>In a sense, because neural networks are over-parametrized,
possessing many more parameters than are needed to fit the training data,
they tend to <em>interpolate</em> the training data (fitting it perfectly)
and thus behave, in some ways, more like nonparametric models.
More recent theoretical research has established
deep connection between large neural networks
and nonparametric methods, notably kernel methods.
In particular, :citet:<code>Jacot.Grabriel.Hongler.2018</code>
demonstrated that in the limit, as multilayer perceptrons
with randomly initialized weights grow infinitely wide,
they become equivalent to (nonparametric) kernel methods
for a specific choice of the kernel function
(essentially, a distance function),
which they call the neural tangent kernel.
While current neural tangent kernel models may not fully explain
the behavior of modern deep networks,
their success as an analytical tool
underscores the usefulness of nonparametric modeling
for understanding the behavior of over-parametrized deep networks.</p>
<h2 id="early-stopping"><a class="header" href="#early-stopping">Early Stopping</a></h2>
<p>While deep neural networks are capable of fitting arbitrary labels,
even when labels are assigned incorrectly or randomly
:cite:<code>zhang2021understanding</code>,
this capability only emerges over many iterations of training.
A new line of work :cite:<code>Rolnick.Veit.Belongie.Shavit.2017</code>
has revealed that in the setting of label noise,
neural networks tend to fit cleanly labeled data first
and only subsequently to interpolate the mislabeled data.
Moreover, it has been established that this phenomenon
translates directly into a guarantee on generalization:
whenever a model has fitted the cleanly labeled data
but not randomly labeled examples included in the training set,
it has in fact generalized :cite:<code>Garg.Balakrishnan.Kolter.Lipton.2021</code>.</p>
<p>Together these findings help to motivate <em>early stopping</em>,
a classic technique for regularizing deep neural networks.
Here, rather than directly constraining the values of the weights,
one constrains the number of epochs of training.
The most common way to determine the stopping criterion
is to monitor validation error throughout training
(typically by checking once after each epoch)
and to cut off training when the validation error
has not decreased by more than some small amount $\epsilon$
for some number of epochs.
This is sometimes called a <em>patience criterion</em>.
As well as the potential to lead to better generalization
in the setting of noisy labels,
another benefit of early stopping is the time saved.
Once the patience criterion is met, one can terminate training.
For large models that might require days of training
simultaneously across eight or more GPUs,
well-tuned early stopping can save researchers days of time
and can save their employers many thousands of dollars.</p>
<p>Notably, when there is no label noise and datasets are <em>realizable</em>
(the classes are truly separable, e.g., distinguishing cats from dogs),
early stopping tends not to lead to significant improvements in generalization.
On the other hand, when there is label noise,
or intrinsic variability in the label
(e.g., predicting mortality among patients),
early stopping is crucial.
Training models until they interpolate noisy data is typically a bad idea.</p>
<h2 id="classical-regularization-methods-for-deep-networks"><a class="header" href="#classical-regularization-methods-for-deep-networks">Classical Regularization Methods for Deep Networks</a></h2>
<p>In :numref:<code>chap_regression</code>, we described
several  classical regularization techniques
for constraining the complexity of our models.
In particular, :numref:<code>sec_weight_decay</code>
introduced a method called weight decay,
which consists of adding a regularization term to the loss function
in order to penalize large values of the weights.
Depending on which weight norm is penalized
this technique is known either as ridge regularization (for $\ell_2$ penalty)
or lasso regularization (for an $\ell_1$ penalty).
In the classical analysis of these regularizers,
they are considered as sufficiently restrictive on the values
that the weights can take to prevent the model from fitting arbitrary labels.</p>
<p>In deep learning implementations,
weight decay remains a popular tool.
However, researchers have noted
that typical strengths of $\ell_2$ regularization
are insufficient to prevent the networks
from interpolating the data :cite:<code>zhang2021understanding</code> and thus the benefits if interpreted
as regularization might only make sense
in combination with the early stopping criterion.
Absent early stopping, it is possible
that just like the number of layers
or number of nodes (in deep learning)
or the distance metric (in 1-nearest neighbor),
these methods may lead to better generalization
not because they meaningfully constrain
the power of the neural network
but rather because they somehow encode inductive biases
that are better compatible with the patterns
found in datasets of interests.
Thus, classical regularizers remain popular
in deep learning implementations,
even if the theoretical rationale
for their efficacy may be radically different.</p>
<p>Notably, deep learning researchers have also built
on techniques first popularized
in classical regularization contexts,
such as adding noise to model inputs.
In the next section we will introduce
the famous dropout technique
(invented by :citet:<code>Srivastava.Hinton.Krizhevsky.ea.2014</code>),
which has become a mainstay of deep learning,
even as the theoretical basis for its efficacy
remains similarly mysterious.</p>
<h2 id="summary-19"><a class="header" href="#summary-19">Summary</a></h2>
<p>Unlike classical linear models,
which tend to have fewer parameters than examples,
deep networks tend to be over-parametrized,
and for most tasks are capable
of perfectly fitting the training set.
This <em>interpolation regime</em> challenges
many hard fast-held intuitions.
Functionally, neural networks look like parametric models.
But thinking of them as nonparametric models
can sometimes be a more reliable source of intuition.
Because it is often the case that all deep networks under consideration
are capable of fitting all of the training labels,
nearly all gains must come by mitigating overfitting
(closing the <em>generalization gap</em>).
Paradoxically, the interventions
that reduce the generalization gap
sometimes appear to increase model complexity
and at other times appear to decrease complexity.
However, these methods seldom decrease complexity
sufficiently for classical theory
to explain the generalization of deep networks,
and <em>why certain choices lead to improved generalization</em>
remains for the most part a massive open question
despite the concerted efforts of many brilliant researchers.</p>
<h2 id="exercises-26"><a class="header" href="#exercises-26">Exercises</a></h2>
<ol>
<li>In what sense do traditional complexity-based measures fail to account for generalization of deep neural networks?</li>
<li>Why might <em>early stopping</em> be considered a regularization technique?</li>
<li>How do researchers typically determine the stopping criterion?</li>
<li>What important factor seems to differentiate cases when early stopping leads to big improvements in generalization?</li>
<li>Beyond generalization, describe another benefit of early stopping.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/7473">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="dropout"><a class="header" href="#dropout">Dropout</a></h1>
<p>:label:<code>sec_dropout</code></p>
<p>Let's think briefly about what we
expect from a good predictive model.
We want it to peform well on unseen data.
Classical generalization theory
suggests that to close the gap between
train and test performance,
we should aim for a simple model.
Simplicity can come in the form
of a small number of dimensions.
We explored this when discussing the
monomial basis functions of linear models
in :numref:<code>sec_generalization_basics</code>.
Additionally, as we saw when discussing weight decay
($\ell_2$ regularization) in :numref:<code>sec_weight_decay</code>,
the (inverse) norm of the parameters also
represents a useful measure of simplicity.
Another useful notion of simplicity is smoothness,
i.e., that the function should not be sensitive
to small changes to its inputs.
For instance, when we classify images,
we would expect that adding some random noise
to the pixels should be mostly harmless.</p>
<p>:citet:<code>Bishop.1995</code> formalized
this idea when he proved that training with input noise
is equivalent to Tikhonov regularization.
This work drew a clear mathematical connection
between the requirement that a function be smooth (and thus simple),
and the requirement that it be resilient
to perturbations in the input.</p>
<p>Then, :citet:<code>Srivastava.Hinton.Krizhevsky.ea.2014</code>
developed a clever idea for how to apply Bishop's idea
to the internal layers of a network, too.
Their idea, called <em>dropout</em>, involves
injecting noise while computing
each internal layer during forward propagation,
and it has become a standard technique
for training neural networks.
The method is called <em>dropout</em> because we literally
<em>drop out</em> some neurons during training.
Throughout training, on each iteration,
standard dropout consists of zeroing out
some fraction of the nodes in each layer
before calculating the subsequent layer.</p>
<p>To be clear, we are imposing
our own narrative with the link to Bishop.
The original paper on dropout
offers intuition through a surprising
analogy to sexual reproduction.
The authors argue that neural network overfitting
is characterized by a state in which
each layer relies on a specific
pattern of activations in the previous layer,
calling this condition <em>co-adaptation</em>.
Dropout, they claim, breaks up co-adaptation
just as sexual reproduction is argued to
break up co-adapted genes.
While such an justification of this theory is certainly up for debate,
the dropout technique itself has proved enduring,
and various forms of dropout are implemented
in most deep learning libraries.</p>
<p>The key challenge is how to inject this noise.
One idea is to inject it in an <em>unbiased</em> manner
so that the expected value of each layer---while fixing
the others---equals the value it would have taken absent noise.
In Bishop's work, he added Gaussian noise
to the inputs to a linear model.
At each training iteration, he added noise
sampled from a distribution with mean zero
$\epsilon \sim \mathcal{N}(0,\sigma^2)$ to the input $\mathbf{x}$,
yielding a perturbed point $\mathbf{x}' = \mathbf{x} + \epsilon$.
In expectation, $E[\mathbf{x}'] = \mathbf{x}$.</p>
<p>In standard dropout regularization,
one zeros out some fraction of the nodes in each layer
and then <em>debiases</em> each layer by normalizing
by the fraction of nodes that were retained (not dropped out).
In other words,
with <em>dropout probability</em> $p$,
each intermediate activation $h$ is replaced by
a random variable $h'$ as follows:</p>
<p>$$
\begin{aligned}
h' =
\begin{cases}
0 &amp; \textrm{ with probability } p \
\frac{h}{1-p} &amp; \textrm{ otherwise}
\end{cases}
\end{aligned}
$$</p>
<p>By design, the expectation remains unchanged, i.e., $E[h'] = h$.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from functools import partial
import jax
from jax import numpy as jnp
import optax
</code></pre>
<h2 id="dropout-in-practice"><a class="header" href="#dropout-in-practice">Dropout in Practice</a></h2>
<p>Recall the MLP with a hidden layer and five hidden units
from :numref:<code>fig_mlp</code>.
When we apply dropout to a hidden layer,
zeroing out each hidden unit with probability $p$,
the result can be viewed as a network
containing only a subset of the original neurons.
In :numref:<code>fig_dropout2</code>, $h_2$ and $h_5$ are removed.
Consequently, the calculation of the outputs
no longer depends on $h_2$ or $h_5$
and their respective gradient also vanishes
when performing backpropagation.
In this way, the calculation of the output layer
cannot be overly dependent on any
one element of $h_1, \ldots, h_5$.</p>
<p><img src="chapter_multilayer-perceptrons/../img/dropout2.svg" alt="MLP before and after dropout." />
:label:<code>fig_dropout2</code></p>
<p>Typically, we disable dropout at test time.
Given a trained model and a new example,
we do not drop out any nodes
and thus do not need to normalize.
However, there are some exceptions:
some researchers use dropout at test time as a heuristic
for estimating the <em>uncertainty</em> of neural network predictions:
if the predictions agree across many different dropout outputs,
then we might say that the network is more confident.</p>
<h2 id="implementation-from-scratch-2"><a class="header" href="#implementation-from-scratch-2">Implementation from Scratch</a></h2>
<p>To implement the dropout function for a single layer,
we must draw as many samples
from a Bernoulli (binary) random variable
as our layer has dimensions,
where the random variable takes value $1$ (keep)
with probability $1-p$ and $0$ (drop) with probability $p$.
One easy way to implement this is to first draw samples
from the uniform distribution $U[0, 1]$.
Then we can keep those nodes for which the corresponding
sample is greater than $p$, dropping the rest.</p>
<p>In the following code, we (<strong>implement a <code>dropout_layer</code> function
that drops out the elements in the tensor input <code>X</code>
with probability <code>dropout</code></strong>),
rescaling the remainder as described above:
dividing the survivors by <code>1.0-dropout</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def dropout_layer(X, dropout):
    assert 0 &lt;= dropout &lt;= 1
    if dropout == 1: return np.zeros_like(X)
    mask = np.random.uniform(0, 1, X.shape) &gt; dropout
    return mask.astype(np.float32) * X / (1.0 - dropout)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def dropout_layer(X, dropout):
    assert 0 &lt;= dropout &lt;= 1
    if dropout == 1: return torch.zeros_like(X)
    mask = (torch.rand(X.shape) &gt; dropout).float()
    return mask * X / (1.0 - dropout)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def dropout_layer(X, dropout):
    assert 0 &lt;= dropout &lt;= 1
    if dropout == 1: return tf.zeros_like(X)
    mask = tf.random.uniform(
        shape=tf.shape(X), minval=0, maxval=1) &lt; 1 - dropout
    return tf.cast(mask, dtype=tf.float32) * X / (1.0 - dropout)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def dropout_layer(X, dropout, key=d2l.get_key()):
    assert 0 &lt;= dropout &lt;= 1
    if dropout == 1: return jnp.zeros_like(X)
    mask = jax.random.uniform(key, X.shape) &gt; dropout
    return jnp.asarray(mask, dtype=jnp.float32) * X / (1.0 - dropout)
</code></pre>
<p>We can [<strong>test out the <code>dropout_layer</code> function on a few examples</strong>].
In the following lines of code,
we pass our input <code>X</code> through the dropout operation,
with probabilities 0, 0.5, and 1, respectively.</p>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('mxnet'):
    X = np.arange(16).reshape(2, 8)
if tab.selected('pytorch'):
    X = torch.arange(16, dtype = torch.float32).reshape((2, 8))
if tab.selected('tensorflow'):
    X = tf.reshape(tf.range(16, dtype=tf.float32), (2, 8))
if tab.selected('jax'):
    X = jnp.arange(16, dtype=jnp.float32).reshape(2, 8)
print('dropout_p = 0:', dropout_layer(X, 0))
print('dropout_p = 0.5:', dropout_layer(X, 0.5))
print('dropout_p = 1:', dropout_layer(X, 1))
</code></pre>
<h3 id="defining-the-model-4"><a class="header" href="#defining-the-model-4">Defining the Model</a></h3>
<p>The model below applies dropout to the output
of each hidden layer (following the activation function).
We can set dropout probabilities for each layer separately.
A common choice is to set
a lower dropout probability closer to the input layer.
We ensure that dropout is only active during training.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class DropoutMLPScratch(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.lin1 = nn.Dense(num_hiddens_1, activation='relu')
        self.lin2 = nn.Dense(num_hiddens_2, activation='relu')
        self.lin3 = nn.Dense(num_outputs)
        self.initialize()

    def forward(self, X):
        H1 = self.lin1(X)
        if autograd.is_training():
            H1 = dropout_layer(H1, self.dropout_1)
        H2 = self.lin2(H1)
        if autograd.is_training():
            H2 = dropout_layer(H2, self.dropout_2)
        return self.lin3(H2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class DropoutMLPScratch(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.lin1 = nn.LazyLinear(num_hiddens_1)
        self.lin2 = nn.LazyLinear(num_hiddens_2)
        self.lin3 = nn.LazyLinear(num_outputs)
        self.relu = nn.ReLU()

    def forward(self, X):
        H1 = self.relu(self.lin1(X.reshape((X.shape[0], -1))))
        if self.training:  
            H1 = dropout_layer(H1, self.dropout_1)
        H2 = self.relu(self.lin2(H1))
        if self.training:
            H2 = dropout_layer(H2, self.dropout_2)
        return self.lin3(H2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class DropoutMLPScratch(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.lin1 = tf.keras.layers.Dense(num_hiddens_1, activation='relu')
        self.lin2 = tf.keras.layers.Dense(num_hiddens_2, activation='relu')
        self.lin3 = tf.keras.layers.Dense(num_outputs)

    def forward(self, X):
        H1 = self.lin1(tf.reshape(X, (X.shape[0], -1)))
        if self.training:
            H1 = dropout_layer(H1, self.dropout_1)
        H2 = self.lin2(H1)
        if self.training:
            H2 = dropout_layer(H2, self.dropout_2)
        return self.lin3(H2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class DropoutMLPScratch(d2l.Classifier):
    num_hiddens_1: int
    num_hiddens_2: int
    num_outputs: int
    dropout_1: float
    dropout_2: float
    lr: float
    training: bool = True

    def setup(self):
        self.lin1 = nn.Dense(self.num_hiddens_1)
        self.lin2 = nn.Dense(self.num_hiddens_2)
        self.lin3 = nn.Dense(self.num_outputs)
        self.relu = nn.relu

    def forward(self, X):
        H1 = self.relu(self.lin1(X.reshape(X.shape[0], -1)))
        if self.training:
            H1 = dropout_layer(H1, self.dropout_1)
        H2 = self.relu(self.lin2(H1))
        if self.training:
            H2 = dropout_layer(H2, self.dropout_2)
        return self.lin3(H2)
</code></pre>
<h3 id="training-7"><a class="header" href="#training-7">[<strong>Training</strong>]</a></h3>
<p>The following is similar to the training of MLPs described previously.</p>
<pre><code class="language-{.python .input}">%%tab all
hparams = {'num_outputs':10, 'num_hiddens_1':256, 'num_hiddens_2':256,
           'dropout_1':0.5, 'dropout_2':0.5, 'lr':0.1}
model = DropoutMLPScratch(**hparams)
data = d2l.FashionMNIST(batch_size=256)
trainer = d2l.Trainer(max_epochs=10)
trainer.fit(model, data)
</code></pre>
<h2 id="concise-implementation-2"><a class="header" href="#concise-implementation-2">[<strong>Concise Implementation</strong>]</a></h2>
<p>With high-level APIs, all we need to do is add a <code>Dropout</code> layer
after each fully connected layer,
passing in the dropout probability
as the only argument to its constructor.
During training, the <code>Dropout</code> layer will randomly
drop out outputs of the previous layer
(or equivalently, the inputs to the subsequent layer)
according to the specified dropout probability.
When not in training mode,
the <code>Dropout</code> layer simply passes the data through during testing.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class DropoutMLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential()
        self.net.add(nn.Dense(num_hiddens_1, activation="relu"),
                     nn.Dropout(dropout_1),
                     nn.Dense(num_hiddens_2, activation="relu"),
                     nn.Dropout(dropout_2),
                     nn.Dense(num_outputs))
        self.net.initialize()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class DropoutMLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential(
            nn.Flatten(), nn.LazyLinear(num_hiddens_1), nn.ReLU(), 
            nn.Dropout(dropout_1), nn.LazyLinear(num_hiddens_2), nn.ReLU(), 
            nn.Dropout(dropout_2), nn.LazyLinear(num_outputs))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class DropoutMLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2,
                 dropout_1, dropout_2, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = tf.keras.models.Sequential([
            tf.keras.layers.Flatten(),
            tf.keras.layers.Dense(num_hiddens_1, activation=tf.nn.relu),
            tf.keras.layers.Dropout(dropout_1),
            tf.keras.layers.Dense(num_hiddens_2, activation=tf.nn.relu),
            tf.keras.layers.Dropout(dropout_2),
            tf.keras.layers.Dense(num_outputs)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class DropoutMLP(d2l.Classifier):
    num_hiddens_1: int
    num_hiddens_2: int
    num_outputs: int
    dropout_1: float
    dropout_2: float
    lr: float
    training: bool = True

    @nn.compact
    def __call__(self, X):
        x = nn.relu(nn.Dense(self.num_hiddens_1)(X.reshape((X.shape[0], -1))))
        x = nn.Dropout(self.dropout_1, deterministic=not self.training)(x)
        x = nn.relu(nn.Dense(self.num_hiddens_2)(x))
        x = nn.Dropout(self.dropout_2, deterministic=not self.training)(x)
        return nn.Dense(self.num_outputs)(x)
</code></pre>
<p>:begin_tab:<code>jax</code>
Note that we need to redefine the loss function since a network
with a dropout layer needs a PRNGKey when using <code>Module.apply()</code>,
and this RNG seed should be explicitly named <code>dropout</code>. This key is
used by the <code>dropout</code> layer in Flax to generate the random dropout
mask internally. It is important to use a unique <code>dropout_rng</code> key
with every epoch in the training loop, otherwise the generated dropout
mask will not be stochastic and different between the epoch runs.
This <code>dropout_rng</code> can be stored in the
<code>TrainState</code> object (in the <code>d2l.Trainer</code> class defined in
:numref:<code>oo-design-training</code>) as an attribute and with every epoch
it is replaced with a new <code>dropout_rng</code>. We already handled this with the
<code>fit_epoch</code> method defined in :numref:<code>sec_linear_scratch</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Classifier)  #@save
@partial(jax.jit, static_argnums=(0, 5))
def loss(self, params, X, Y, state, averaged=True):
    Y_hat = state.apply_fn({'params': params}, *X,
                           mutable=False,  # To be used later (e.g., batch norm)
                           rngs={'dropout': state.dropout_rng})
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    Y = d2l.reshape(Y, (-1,))
    fn = optax.softmax_cross_entropy_with_integer_labels
    # The returned empty dictionary is a placeholder for auxiliary data,
    # which will be used later (e.g., for batch norm)
    return (fn(Y_hat, Y).mean(), {}) if averaged else (fn(Y_hat, Y), {})
</code></pre>
<p>Next, we [<strong>train the model</strong>].</p>
<pre><code class="language-{.python .input}">%%tab all
model = DropoutMLP(**hparams)
trainer.fit(model, data)
</code></pre>
<h2 id="summary-20"><a class="header" href="#summary-20">Summary</a></h2>
<p>Beyond controlling the number of dimensions and the size of the weight vector, dropout is yet another tool for avoiding overfitting. Often tools are used jointly.
Note that dropout is
used only during training:
it replaces an activation $h$ with a random variable with expected value $h$.</p>
<h2 id="exercises-27"><a class="header" href="#exercises-27">Exercises</a></h2>
<ol>
<li>What happens if you change the dropout probabilities for the first and second layers? In particular, what happens if you switch the ones for both layers? Design an experiment to answer these questions, describe your results quantitatively, and summarize the qualitative takeaways.</li>
<li>Increase the number of epochs and compare the results obtained when using dropout with those when not using it.</li>
<li>What is the variance of the activations in each hidden layer when dropout is and is not applied? Draw a plot to show how this quantity evolves over time for both models.</li>
<li>Why is dropout not typically used at test time?</li>
<li>Using the model in this section as an example, compare the effects of using dropout and weight decay. What happens when dropout and weight decay are used at the same time? Are the results additive? Are there diminished returns (or worse)? Do they cancel each other out?</li>
<li>What happens if we apply dropout to the individual weights of the weight matrix rather than the activations?</li>
<li>Invent another technique for injecting random noise at each layer that is different from the standard dropout technique. Can you develop a method that outperforms dropout on the Fashion-MNIST dataset (for a fixed architecture)?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/100">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/101">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/261">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17987">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="predicting-house-prices-on-kaggle"><a class="header" href="#predicting-house-prices-on-kaggle">Predicting House Prices on Kaggle</a></h1>
<p>:label:<code>sec_kaggle_house</code></p>
<p>Now that we have introduced some basic tools
for building and training deep networks
and regularizing them with techniques including
weight decay and dropout,
we are ready to put all this knowledge into practice
by participating in a Kaggle competition.
The house price prediction competition
is a great place to start.
The data is fairly generic and do not exhibit exotic structure
that might require specialized models (as audio or video might).
This dataset, collected by :citet:<code>De-Cock.2011</code>,
covers house prices in Ames, Iowa from the period 2006--2010.
It is considerably larger than the famous <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.names">Boston housing dataset</a> of Harrison and Rubinfeld (1978),
boasting both more examples and more features.</p>
<p>In this section, we will walk you through details of
data preprocessing, model design, and hyperparameter selection.
We hope that through a hands-on approach,
you will gain some intuitions that will guide you
in your career as a data scientist.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, autograd, init, np, npx
from mxnet.gluon import nn
import pandas as pd

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
from torch import nn
import pandas as pd
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
import pandas as pd
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import numpy as np
import pandas as pd
</code></pre>
<h2 id="downloading-data"><a class="header" href="#downloading-data">Downloading Data</a></h2>
<p>Throughout the book, we will train and test models
on various downloaded datasets.
Here, we (<strong>implement two utility functions</strong>)
for downloading and extracting zip or tar files.
Again, we skip implementation details of
such utility functions.</p>
<pre><code class="language-{.python .input  n=2}">%%tab all
def download(url, folder, sha1_hash=None):
    """Download a file to folder and return the local filepath."""

def extract(filename, folder):
    """Extract a zip/tar file into folder."""
</code></pre>
<h2 id="kaggle"><a class="header" href="#kaggle">Kaggle</a></h2>
<p><a href="https://www.kaggle.com">Kaggle</a> is a popular platform
that hosts machine learning competitions.
Each competition centers on a dataset and many
are sponsored by stakeholders who offer prizes
to the winning solutions.
The platform helps users to interact
via forums and shared code,
fostering both collaboration and competition.
While leaderboard chasing often spirals out of control,
with researchers focusing myopically on preprocessing steps
rather than asking fundamental questions,
there is also tremendous value in the objectivity of a platform
that facilitates direct quantitative comparisons
among competing approaches as well as code sharing
so that everyone can learn what did and did not work.
If you want to participate in a Kaggle competition,
you will first need to register for an account
(see :numref:<code>fig_kaggle</code>).</p>
<p><img src="chapter_multilayer-perceptrons/../img/kaggle.png" alt="The Kaggle website." />
:width:<code>400px</code>
:label:<code>fig_kaggle</code></p>
<p>On the house price prediction competition page, as illustrated
in :numref:<code>fig_house_pricing</code>,
you can find the dataset (under the "Data" tab),
submit predictions, and see your ranking,
The URL is right here:</p>
<blockquote>
<p>https://www.kaggle.com/c/house-prices-advanced-regression-techniques</p>
</blockquote>
<p><img src="chapter_multilayer-perceptrons/../img/house-pricing.png" alt="The house price prediction competition page." />
:width:<code>400px</code>
:label:<code>fig_house_pricing</code></p>
<h2 id="accessing-and-reading-the-dataset"><a class="header" href="#accessing-and-reading-the-dataset">Accessing and Reading the Dataset</a></h2>
<p>Note that the competition data is separated
into training and test sets.
Each record includes the property value of the house
and attributes such as street type, year of construction,
roof type, basement condition, etc.
The features consist of various data types.
For example, the year of construction
is represented by an integer,
the roof type by discrete categorical assignments,
and other features by floating point numbers.
And here is where reality complicates things:
for some examples, some data is altogether missing
with the missing value marked simply as "na".
The price of each house is included
for the training set only
(it is a competition after all).
We will want to partition the training set
to create a validation set,
but we only get to evaluate our models on the official test set
after uploading predictions to Kaggle.
The "Data" tab on the competition tab
in :numref:<code>fig_house_pricing</code>
has links for downloading the data.</p>
<p>To get started, we will [<strong>read in and process the data
using <code>pandas</code></strong>], which we introduced in :numref:<code>sec_pandas</code>.
For convenience, we can download and cache
the Kaggle housing dataset.
If a file corresponding to this dataset already exists in the cache directory and its SHA-1 matches <code>sha1_hash</code>, our code will use the cached file to avoid clogging up your Internet with redundant downloads.</p>
<pre><code class="language-{.python .input  n=30}">%%tab all
class KaggleHouse(d2l.DataModule):
    def __init__(self, batch_size, train=None, val=None):
        super().__init__()
        self.save_hyperparameters()
        if self.train is None:
            self.raw_train = pd.read_csv(d2l.download(
                d2l.DATA_URL + 'kaggle_house_pred_train.csv', self.root,
                sha1_hash='585e9cc93e70b39160e7921475f9bcd7d31219ce'))
            self.raw_val = pd.read_csv(d2l.download(
                d2l.DATA_URL + 'kaggle_house_pred_test.csv', self.root,
                sha1_hash='fa19780a7b011d9b009e8bff8e99922a8ee2eb90'))
</code></pre>
<p>The training dataset includes 1460 examples,
80 features, and one label, while the validation data
contains 1459 examples and 80 features.</p>
<pre><code class="language-{.python .input  n=31}">%%tab all
data = KaggleHouse(batch_size=64)
print(data.raw_train.shape)
print(data.raw_val.shape)
</code></pre>
<h2 id="data-preprocessing-1"><a class="header" href="#data-preprocessing-1">Data Preprocessing</a></h2>
<p>Let's [<strong>take a look at the first four and final two features
as well as the label (SalePrice)</strong>] from the first four examples.</p>
<pre><code class="language-{.python .input  n=10}">%%tab all
print(data.raw_train.iloc[:4, [0, 1, 2, 3, -3, -2, -1]])
</code></pre>
<p>We can see that in each example, the first feature is the identifier.
This helps the model determine each training example.
While this is convenient, it does not carry
any information for prediction purposes.
Hence, we will remove it from the dataset
before feeding the data into the model.
Furthermore, given a wide variety of data types,
we will need to preprocess the data before we can start modeling.</p>
<p>Let's start with the numerical features.
First, we apply a heuristic,
[<strong>replacing all missing values
by the corresponding feature's mean.</strong>]
Then, to put all features on a common scale,
we (<strong><em>standardize</em> the data by
rescaling features to zero mean and unit variance</strong>):</p>
<p>$$x \leftarrow \frac{x - \mu}{\sigma},$$</p>
<p>where $\mu$ and $\sigma$ denote mean and standard deviation, respectively.
To verify that this indeed transforms
our feature (variable) such that it has zero mean and unit variance,
note that $E[\frac{x-\mu}{\sigma}] = \frac{\mu - \mu}{\sigma} = 0$
and that $E[(x-\mu)^2] = (\sigma^2 + \mu^2) - 2\mu^2+\mu^2 = \sigma^2$.
Intuitively, we standardize the data
for two reasons.
First, it proves convenient for optimization.
Second, because we do not know <em>a priori</em>
which features will be relevant,
we do not want to penalize coefficients
assigned to one feature more than any other.</p>
<p>[<strong>Next we deal with discrete values.</strong>]
These include features such as "MSZoning".
(<strong>We replace them by a one-hot encoding</strong>)
in the same way that we earlier transformed
multiclass labels into vectors (see :numref:<code>subsec_classification-problem</code>).
For instance, "MSZoning" assumes the values "RL" and "RM".
Dropping the "MSZoning" feature,
two new indicator features
"MSZoning_RL" and "MSZoning_RM" are created with values being either 0 or 1.
According to one-hot encoding,
if the original value of "MSZoning" is "RL",
then "MSZoning_RL" is 1 and "MSZoning_RM" is 0.
The <code>pandas</code> package does this automatically for us.</p>
<pre><code class="language-{.python .input  n=32}">%%tab all
@d2l.add_to_class(KaggleHouse)
def preprocess(self):
    # Remove the ID and label columns
    label = 'SalePrice'
    features = pd.concat(
        (self.raw_train.drop(columns=['Id', label]),
         self.raw_val.drop(columns=['Id'])))
    # Standardize numerical columns
    numeric_features = features.dtypes[features.dtypes!='object'].index
    features[numeric_features] = features[numeric_features].apply(
        lambda x: (x - x.mean()) / (x.std()))
    # Replace NAN numerical features by 0
    features[numeric_features] = features[numeric_features].fillna(0)
    # Replace discrete features by one-hot encoding
    features = pd.get_dummies(features, dummy_na=True)
    # Save preprocessed features
    self.train = features[:self.raw_train.shape[0]].copy()
    self.train[label] = self.raw_train[label]
    self.val = features[self.raw_train.shape[0]:].copy()
</code></pre>
<p>You can see that this conversion increases
the number of features from 79 to 331 (excluding ID and label columns).</p>
<pre><code class="language-{.python .input  n=33}">%%tab all
data.preprocess()
data.train.shape
</code></pre>
<h2 id="error-measure"><a class="header" href="#error-measure">Error Measure</a></h2>
<p>To get started we will train a linear model with squared loss. Not surprisingly, our linear model will not lead to a competition-winning submission but it does provide a sanity check to see whether there is meaningful information in the data. If we cannot do better than random guessing here, then there might be a good chance that we have a data processing bug. And if things work, the linear model will serve as a baseline giving us some intuition about how close the simple model gets to the best reported models, giving us a sense of how much gain we should expect from fancier models.</p>
<p>With house prices, as with stock prices,
we care about relative quantities
more than absolute quantities.
Thus [<strong>we tend to care more about
the relative error $\frac{y - \hat{y}}{y}$</strong>]
than about the absolute error $y - \hat{y}$.
For instance, if our prediction is off by $100,000
when estimating the price of a house in rural Ohio,
where the value of a typical house is $125,000,
then we are probably doing a horrible job.
On the other hand, if we err by this amount
in Los Altos Hills, California,
this might represent a stunningly accurate prediction
(there, the median house price exceeds $4 million).</p>
<p>(<strong>One way to address this problem is to
measure the discrepancy in the logarithm of the price estimates.</strong>)
In fact, this is also the official error measure
used by the competition to evaluate the quality of submissions.
After all, a small value $\delta$ for $|\log y - \log \hat{y}| \leq \delta$
translates into $e^{-\delta} \leq \frac{\hat{y}}{y} \leq e^\delta$.
This leads to the following root-mean-squared-error between the logarithm of the predicted price and the logarithm of the label price:</p>
<p>$$\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log y_i -\log \hat{y}_i\right)^2}.$$</p>
<pre><code class="language-{.python .input  n=60}">%%tab all
@d2l.add_to_class(KaggleHouse)
def get_dataloader(self, train):
    label = 'SalePrice'
    data = self.train if train else self.val
    if label not in data: return
    get_tensor = lambda x: d2l.tensor(x.values.astype(float),
                                      dtype=d2l.float32)
    # Logarithm of prices 
    tensors = (get_tensor(data.drop(columns=[label])),  # X
               d2l.reshape(d2l.log(get_tensor(data[label])), (-1, 1)))  # Y
    return self.get_tensorloader(tensors, train)
</code></pre>
<h2 id="k-fold-cross-validation"><a class="header" href="#k-fold-cross-validation">$K$-Fold Cross-Validation</a></h2>
<p>You might recall that we introduced [<strong>cross-validation</strong>]
in :numref:<code>subsec_generalization-model-selection</code>, where we discussed how to deal
with model selection.
We will put this to good use to select the model design
and to adjust the hyperparameters.
We first need a function that returns
the $i^\textrm{th}$ fold of the data
in a $K$-fold cross-validation procedure.
It proceeds by slicing out the $i^\textrm{th}$ segment
as validation data and returning the rest as training data.
Note that this is not the most efficient way of handling data
and we would definitely do something much smarter
if our dataset was considerably larger.
But this added complexity might obfuscate our code unnecessarily
so we can safely omit it here owing to the simplicity of our problem.</p>
<pre><code class="language-{.python .input}">%%tab all
def k_fold_data(data, k):
    rets = []
    fold_size = data.train.shape[0] // k
    for j in range(k):
        idx = range(j * fold_size, (j+1) * fold_size)
        rets.append(KaggleHouse(data.batch_size, data.train.drop(index=idx),  
                                data.train.loc[idx]))    
    return rets
</code></pre>
<p>[<strong>The average validation error is returned</strong>]
when we train $K$ times in the $K$-fold cross-validation.</p>
<pre><code class="language-{.python .input}">%%tab all
def k_fold(trainer, data, k, lr):
    val_loss, models = [], []
    for i, data_fold in enumerate(k_fold_data(data, k)):
        model = d2l.LinearRegression(lr)
        model.board.yscale='log'
        if i != 0: model.board.display = False
        trainer.fit(model, data_fold)
        val_loss.append(float(model.board.data['val_loss'][-1].y))
        models.append(model)
    print(f'average validation log mse = {sum(val_loss)/len(val_loss)}')
    return models
</code></pre>
<h2 id="model-selection-1"><a class="header" href="#model-selection-1">[<strong>Model Selection</strong>]</a></h2>
<p>In this example, we pick an untuned set of hyperparameters
and leave it up to the reader to improve the model.
Finding a good choice can take time,
depending on how many variables one optimizes over.
With a large enough dataset,
and the normal sorts of hyperparameters,
$K$-fold cross-validation tends to be
reasonably resilient against multiple testing.
However, if we try an unreasonably large number of options
we might find that our validation
performance is no longer representative of the true error.</p>
<pre><code class="language-{.python .input}">%%tab all
trainer = d2l.Trainer(max_epochs=10)
models = k_fold(trainer, data, k=5, lr=0.01)
</code></pre>
<p>Notice that sometimes the number of training errors
for a set of hyperparameters can be very low,
even as the number of errors on $K$-fold cross-validation
grows considerably higher.
This indicates that we are overfitting.
Throughout training you will want to monitor both numbers.
Less overfitting might indicate that our data can support a more powerful model.
Massive overfitting might suggest that we can gain
by incorporating regularization techniques.</p>
<h2 id="submitting-predictions-on-kaggle"><a class="header" href="#submitting-predictions-on-kaggle">[<strong>Submitting Predictions on Kaggle</strong>]</a></h2>
<p>Now that we know what a good choice of hyperparameters should be,
we might
calculate the average predictions
on the test set
by all the $K$ models.
Saving the predictions in a csv file
will simplify uploading the results to Kaggle.
The following code will generate a file called <code>submission.csv</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    preds = [model(d2l.tensor(data.val.values.astype(float), dtype=d2l.float32))
             for model in models]
if tab.selected('jax'):
    preds = [model.apply({'params': trainer.state.params},
             d2l.tensor(data.val.values.astype(float), dtype=d2l.float32))
             for model in models]
# Taking exponentiation of predictions in the logarithm scale
ensemble_preds = d2l.reduce_mean(d2l.exp(d2l.concat(preds, 1)), 1)
submission = pd.DataFrame({'Id':data.raw_val.Id,
                           'SalePrice':d2l.numpy(ensemble_preds)})
submission.to_csv('submission.csv', index=False)
</code></pre>
<p>Next, as demonstrated in :numref:<code>fig_kaggle_submit2</code>,
we can submit our predictions on Kaggle
and see how they compare with the actual house prices (labels)
on the test set.
The steps are quite simple:</p>
<ul>
<li>Log in to the Kaggle website and visit the house price prediction competition page.</li>
<li>Click the “Submit Predictions” or “Late Submission” button.</li>
<li>Click the “Upload Submission File” button in the dashed box at the bottom of the page and select the prediction file you wish to upload.</li>
<li>Click the “Make Submission” button at the bottom of the page to view your results.</li>
</ul>
<p><img src="chapter_multilayer-perceptrons/../img/kaggle-submit2.png" alt="Submitting data to Kaggle." />
:width:<code>400px</code>
:label:<code>fig_kaggle_submit2</code></p>
<h2 id="summary-and-discussion-2"><a class="header" href="#summary-and-discussion-2">Summary and Discussion</a></h2>
<p>Real data often contains a mix of different data types and needs to be preprocessed.
Rescaling real-valued data to zero mean and unit variance is a good default. So is replacing missing values with their mean.
Furthermore, transforming categorical features into indicator features allows us to treat them like one-hot vectors.
When we tend to care more about
the relative error than about the absolute error,
we can
measure the discrepancy in the logarithm of the prediction.
To select the model and adjust the hyperparameters,
we can use $K$-fold cross-validation .</p>
<h2 id="exercises-28"><a class="header" href="#exercises-28">Exercises</a></h2>
<ol>
<li>Submit your predictions for this section to Kaggle. How good are they?</li>
<li>Is it always a good idea to replace missing values by a mean? Hint: can you construct a situation where the values are not missing at random?</li>
<li>Improve the score by tuning the hyperparameters through $K$-fold cross-validation.</li>
<li>Improve the score by improving the model (e.g., layers, weight decay, and dropout).</li>
<li>What happens if we do not standardize the continuous numerical features as we have done in this section?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/106">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/107">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/237">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17988">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builders-guide"><a class="header" href="#builders-guide">Builders' Guide</a></h1>
<p>:label:<code>chap_computation</code></p>
<p>Alongside giant datasets and powerful hardware,
great software tools have played an indispensable role
in the rapid progress of deep learning.
Starting with the pathbreaking Theano library released in 2007,
flexible open-source tools have enabled researchers
to rapidly prototype models, avoiding repetitive work
when recycling standard components
while still maintaining the ability to make low-level modifications.
Over time, deep learning's libraries have evolved
to offer increasingly coarse abstractions.
Just as semiconductor designers went from specifying transistors
to logical circuits to writing code,
neural networks researchers have moved from thinking about
the behavior of individual artificial neurons
to conceiving of networks in terms of whole layers,
and now often design architectures with far coarser <em>blocks</em> in mind.</p>
<p>So far, we have introduced some basic machine learning concepts,
ramping up to fully-functional deep learning models.
In the last chapter,
we implemented each component of an MLP from scratch
and even showed how to leverage high-level APIs
to roll out the same models effortlessly.
To get you that far that fast, we <em>called upon</em> the libraries,
but skipped over more advanced details about <em>how they work</em>.
In this chapter, we will peel back the curtain,
digging deeper into the key components of deep learning computation,
namely model construction, parameter access and initialization,
designing custom layers and blocks, reading and writing models to disk,
and leveraging GPUs to achieve dramatic speedups.
These insights will move you from <em>end user</em> to <em>power user</em>,
giving you the tools needed to reap the benefits
of a mature deep learning library while retaining the flexibility
to implement more complex models, including those you invent yourself!
While this chapter does not introduce any new models or datasets,
the advanced modeling chapters that follow rely heavily on these techniques.</p>
<pre><code class="language-toc">:maxdepth: 2

model-construction
parameters
init-param
lazy-init
custom-layer
read-write
use-gpu
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="layers-and-modules"><a class="header" href="#layers-and-modules">Layers and Modules</a></h1>
<p>:label:<code>sec_model_construction</code></p>
<p>When we first introduced neural networks,
we focused on linear models with a single output.
Here, the entire model consists of just a single neuron.
Note that a single neuron
(i) takes some set of inputs;
(ii) generates a corresponding scalar output;
and (iii) has a set of associated parameters that can be updated
to optimize some objective function of interest.
Then, once we started thinking about networks with multiple outputs,
we leveraged vectorized arithmetic
to characterize an entire layer of neurons.
Just like individual neurons,
layers (i) take a set of inputs,
(ii) generate corresponding outputs,
and (iii) are described by a set of tunable parameters.
When we worked through softmax regression,
a single layer was itself the model.
However, even when we subsequently
introduced MLPs,
we could still think of the model as
retaining this same basic structure.</p>
<p>Interestingly, for MLPs,
both the entire model and its constituent layers
share this structure.
The entire model takes in raw inputs (the features),
generates outputs (the predictions),
and possesses parameters
(the combined parameters from all constituent layers).
Likewise, each individual layer ingests inputs
(supplied by the previous layer)
generates outputs (the inputs to the subsequent layer),
and possesses a set of tunable parameters that are updated
according to the signal that flows backwards
from the subsequent layer.</p>
<p>While you might think that neurons, layers, and models
give us enough abstractions to go about our business,
it turns out that we often find it convenient
to speak about components that are
larger than an individual layer
but smaller than the entire model.
For example, the ResNet-152 architecture,
which is wildly popular in computer vision,
possesses hundreds of layers.
These layers consist of repeating patterns of <em>groups of layers</em>. Implementing such a network one layer at a time can grow tedious.
This concern is not just hypothetical---such
design patterns are common in practice.
The ResNet architecture mentioned above
won the 2015 ImageNet and COCO computer vision competitions
for both recognition and detection :cite:<code>He.Zhang.Ren.ea.2016</code>
and remains a go-to architecture for many vision tasks.
Similar architectures in which layers are arranged
in various repeating patterns
are now ubiquitous in other domains,
including natural language processing and speech.</p>
<p>To implement these complex networks,
we introduce the concept of a neural network <em>module</em>.
A module could describe a single layer,
a component consisting of multiple layers,
or the entire model itself!
One benefit of working with the module abstraction
is that they can be combined into larger artifacts,
often recursively. This is illustrated in :numref:<code>fig_blocks</code>. By defining code to generate modules
of arbitrary complexity on demand,
we can write surprisingly compact code
and still implement complex neural networks.</p>
<p><img src="chapter_builders-guide/../img/blocks.svg" alt="Multiple layers are combined into modules, forming repeating patterns of larger models." />
:label:<code>fig_blocks</code></p>
<p>From a programming standpoint, a module is represented by a <em>class</em>.
Any subclass of it must define a forward propagation method
that transforms its input into output
and must store any necessary parameters.
Note that some modules do not require any parameters at all.
Finally a module must possess a backpropagation method,
for purposes of calculating gradients.
Fortunately, due to some behind-the-scenes magic
supplied by the auto differentiation
(introduced in :numref:<code>sec_autograd</code>)
when defining our own module,
we only need to worry about parameters
and the forward propagation method.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from typing import List
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<p>[<strong>To begin, we revisit the code
that we used to implement MLPs</strong>]
(:numref:<code>sec_mlp</code>).
The following code generates a network
with one fully connected hidden layer
with 256 units and ReLU activation,
followed by a fully connected output layer
with ten units (no activation function).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(256, activation='relu'))
net.add(nn.Dense(10))
net.initialize()

X = np.random.uniform(size=(2, 20))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))

X = torch.rand(2, 20)
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation=tf.nn.relu),
    tf.keras.layers.Dense(10),
])

X = tf.random.uniform((2, 20))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(256), nn.relu, nn.Dense(10)])

# get_key is a d2l saved function returning jax.random.PRNGKey(random_seed)
X = jax.random.uniform(d2l.get_key(), (2, 20))
params = net.init(d2l.get_key(), X)
net.apply(params, X).shape
</code></pre>
<p>:begin_tab:<code>mxnet</code>
In this example, we constructed
our model by instantiating an <code>nn.Sequential</code>,
assigning the returned object to the <code>net</code> variable.
Next, we repeatedly call its <code>add</code> method,
appending layers in the order
that they should be executed.
In short, <code>nn.Sequential</code> defines a special kind of <code>Block</code>,
the class that presents a <em>module</em> in Gluon.
It maintains an ordered list of constituent <code>Block</code>s.
The <code>add</code> method simply facilitates
the addition of each successive <code>Block</code> to the list.
Note that each layer is an instance of the <code>Dense</code> class
which is itself a subclass of <code>Block</code>.
The forward propagation (<code>forward</code>) method is also remarkably simple:
it chains each <code>Block</code> in the list together,
passing the output of each as input to the next.
Note that until now, we have been invoking our models
via the construction <code>net(X)</code> to obtain their outputs.
This is actually just shorthand for <code>net.forward(X)</code>,
a slick Python trick achieved via
the <code>Block</code> class's <code>__call__</code> method.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In this example, we constructed
our model by instantiating an <code>nn.Sequential</code>, with layers in the order
that they should be executed passed as arguments.
In short, (<strong><code>nn.Sequential</code> defines a special kind of <code>Module</code></strong>),
the class that presents a module in PyTorch.
It maintains an ordered list of constituent <code>Module</code>s.
Note that each of the two fully connected layers is an instance of the <code>Linear</code> class
which is itself a subclass of <code>Module</code>.
The forward propagation (<code>forward</code>) method is also remarkably simple:
it chains each module in the list together,
passing the output of each as input to the next.
Note that until now, we have been invoking our models
via the construction <code>net(X)</code> to obtain their outputs.
This is actually just shorthand for <code>net.__call__(X)</code>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
In this example, we constructed
our model by instantiating an <code>keras.models.Sequential</code>, with layers in the order
that they should be executed passed as arguments.
In short, <code>Sequential</code> defines a special kind of <code>keras.Model</code>,
the class that presents a module in Keras.
It maintains an ordered list of constituent <code>Model</code>s.
Note that each of the two fully connected layers is an instance of the <code>Dense</code> class
which is itself a subclass of <code>Model</code>.
The forward propagation (<code>call</code>) method is also remarkably simple:
it chains each module in the list together,
passing the output of each as input to the next.
Note that until now, we have been invoking our models
via the construction <code>net(X)</code> to obtain their outputs.
This is actually just shorthand for <code>net.call(X)</code>,
a slick Python trick achieved via
the module class's <code>__call__</code> method.
:end_tab:</p>
<h2 id="a-custom-module"><a class="header" href="#a-custom-module">[<strong>A Custom Module</strong>]</a></h2>
<p>Perhaps the easiest way to develop intuition
about how a module works
is to implement one ourselves.
Before we do that,
we briefly summarize the basic functionality
that each module must provide:</p>
<ol>
<li>Ingest input data as arguments to its forward propagation method.</li>
<li>Generate an output by having the forward propagation method return a value. Note that the output may have a different shape from the input. For example, the first fully connected layer in our model above ingests an input of arbitrary dimension but returns an output of dimension 256.</li>
<li>Calculate the gradient of its output with respect to its input, which can be accessed via its backpropagation method. Typically this happens automatically.</li>
<li>Store and provide access to those parameters necessary
for executing the forward propagation computation.</li>
<li>Initialize model parameters as needed.</li>
</ol>
<p>In the following snippet,
we code up a module from scratch
corresponding to an MLP
with one hidden layer with 256 hidden units,
and a 10-dimensional output layer.
Note that the <code>MLP</code> class below inherits the class that represents a module.
We will heavily rely on the parent class's methods,
supplying only our own constructor (the <code>__init__</code> method in Python) and the forward propagation method.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MLP(nn.Block):
    def __init__(self):
        # Call the constructor of the MLP parent class nn.Block to perform
        # the necessary initialization
        super().__init__()
        self.hidden = nn.Dense(256, activation='relu')
        self.out = nn.Dense(10)

    # Define the forward propagation of the model, that is, how to return the
    # required model output based on the input X
    def forward(self, X):
        return self.out(self.hidden(X))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MLP(nn.Module):
    def __init__(self):
        # Call the constructor of the parent class nn.Module to perform
        # the necessary initialization
        super().__init__()
        self.hidden = nn.LazyLinear(256)
        self.out = nn.LazyLinear(10)

    # Define the forward propagation of the model, that is, how to return the
    # required model output based on the input X
    def forward(self, X):
        return self.out(F.relu(self.hidden(X)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MLP(tf.keras.Model):
    def __init__(self):
        # Call the constructor of the parent class tf.keras.Model to perform
        # the necessary initialization
        super().__init__()
        self.hidden = tf.keras.layers.Dense(units=256, activation=tf.nn.relu)
        self.out = tf.keras.layers.Dense(units=10)

    # Define the forward propagation of the model, that is, how to return the
    # required model output based on the input X
    def call(self, X):
        return self.out(self.hidden((X)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MLP(nn.Module):
    def setup(self):
        # Define the layers
        self.hidden = nn.Dense(256)
        self.out = nn.Dense(10)

    # Define the forward propagation of the model, that is, how to return the
    # required model output based on the input X
    def __call__(self, X):
        return self.out(nn.relu(self.hidden(X)))
</code></pre>
<p>Let's first focus on the forward propagation method.
Note that it takes <code>X</code> as input,
calculates the hidden representation
with the activation function applied,
and outputs its logits.
In this <code>MLP</code> implementation,
both layers are instance variables.
To see why this is reasonable, imagine
instantiating two MLPs, <code>net1</code> and <code>net2</code>,
and training them on different data.
Naturally, we would expect them
to represent two different learned models.</p>
<p>We [<strong>instantiate the MLP's layers</strong>]
in the constructor
(<strong>and subsequently invoke these layers</strong>)
on each call to the forward propagation method.
Note a few key details.
First, our customized <code>__init__</code> method
invokes the parent class's <code>__init__</code> method
via <code>super().__init__()</code>
sparing us the pain of restating
boilerplate code applicable to most modules.
We then instantiate our two fully connected layers,
assigning them to <code>self.hidden</code> and <code>self.out</code>.
Note that unless we implement a new layer,
we need not worry about the backpropagation method
or parameter initialization.
The system will generate these methods automatically.
Let's try this out.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
net = MLP()
if tab.selected('mxnet'):
    net.initialize()
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = MLP()
params = net.init(d2l.get_key(), X)
net.apply(params, X).shape
</code></pre>
<p>A key virtue of the module abstraction is its versatility.
We can subclass a module to create layers
(such as the fully connected layer class),
entire models (such as the <code>MLP</code> class above),
or various components of intermediate complexity.
We exploit this versatility
throughout the coming chapters,
such as when addressing
convolutional neural networks.</p>
<h2 id="the-sequential-module"><a class="header" href="#the-sequential-module">[<strong>The Sequential Module</strong>]</a></h2>
<p>:label:<code>subsec_model-construction-sequential</code></p>
<p>We can now take a closer look
at how the <code>Sequential</code> class works.
Recall that <code>Sequential</code> was designed
to daisy-chain other modules together.
To build our own simplified <code>MySequential</code>,
we just need to define two key methods:</p>
<ol>
<li>A method for appending modules one by one to a list.</li>
<li>A forward propagation method for passing an input through the chain of modules, in the same order as they were appended.</li>
</ol>
<p>The following <code>MySequential</code> class delivers the same
functionality of the default <code>Sequential</code> class.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MySequential(nn.Block):
    def add(self, block):
        # Here, block is an instance of a Block subclass, and we assume that
        # it has a unique name. We save it in the member variable _children of
        # the Block class, and its type is OrderedDict. When the MySequential
        # instance calls the initialize method, the system automatically
        # initializes all members of _children
        self._children[block.name] = block

    def forward(self, X):
        # OrderedDict guarantees that members will be traversed in the order
        # they were added
        for block in self._children.values():
            X = block(X)
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MySequential(nn.Module):
    def __init__(self, *args):
        super().__init__()
        for idx, module in enumerate(args):
            self.add_module(str(idx), module)

    def forward(self, X):
        for module in self.children():            
            X = module(X)
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MySequential(tf.keras.Model):
    def __init__(self, *args):
        super().__init__()
        self.modules = args

    def call(self, X):
        for module in self.modules:
            X = module(X)
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MySequential(nn.Module):
    modules: List

    def __call__(self, X):
        for module in self.modules:
            X = module(X)
        return X
</code></pre>
<p>:begin_tab:<code>mxnet</code>
The <code>add</code> method adds a single block
to the ordered dictionary <code>_children</code>.
You might wonder why every Gluon <code>Block</code>
possesses a <code>_children</code> attribute
and why we used it rather than just
define a Python list ourselves.
In short the chief advantage of <code>_children</code>
is that during our block's parameter initialization,
Gluon knows to look inside the <code>_children</code>
dictionary to find sub-blocks whose
parameters also need to be initialized.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In the <code>__init__</code> method, we add every module
by calling the <code>add_modules</code> method. These modules can be accessed by the <code>children</code> method at a later date.
In this way the system knows the added modules,
and it will properly initialize each module's parameters.
:end_tab:</p>
<p>When our <code>MySequential</code>'s forward propagation method is invoked,
each added module is executed
in the order in which they were added.
We can now reimplement an MLP
using our <code>MySequential</code> class.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = MySequential()
net.add(nn.Dense(256, activation='relu'))
net.add(nn.Dense(10))
net.initialize()
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = MySequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = MySequential(
    tf.keras.layers.Dense(units=256, activation=tf.nn.relu),
    tf.keras.layers.Dense(10))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = MySequential([nn.Dense(256), nn.relu, nn.Dense(10)])
params = net.init(d2l.get_key(), X)
net.apply(params, X).shape
</code></pre>
<p>Note that this use of <code>MySequential</code>
is identical to the code we previously wrote
for the <code>Sequential</code> class
(as described in :numref:<code>sec_mlp</code>).</p>
<h2 id="executing-code-in-the-forward-propagation-method"><a class="header" href="#executing-code-in-the-forward-propagation-method">[<strong>Executing Code in the Forward Propagation Method</strong>]</a></h2>
<p>The <code>Sequential</code> class makes model construction easy,
allowing us to assemble new architectures
without having to define our own class.
However, not all architectures are simple daisy chains.
When greater flexibility is required,
we will want to define our own blocks.
For example, we might want to execute
Python's control flow within the forward propagation method.
Moreover, we might want to perform
arbitrary mathematical operations,
not simply relying on predefined neural network layers.</p>
<p>You may have noticed that until now,
all of the operations in our networks
have acted upon our network's activations
and its parameters.
Sometimes, however, we might want to
incorporate terms
that are neither the result of previous layers
nor updatable parameters.
We call these <em>constant parameters</em>.
Say for example that we want a layer
that calculates the function
$f(\mathbf{x},\mathbf{w}) = c \cdot \mathbf{w}^\top \mathbf{x}$,
where $\mathbf{x}$ is the input, $\mathbf{w}$ is our parameter,
and $c$ is some specified constant
that is not updated during optimization.
So we implement a <code>FixedHiddenMLP</code> class as follows.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class FixedHiddenMLP(nn.Block):
    def __init__(self):
        super().__init__()
        # Random weight parameters created with the get_constant method
        # are not updated during training (i.e., constant parameters)
        self.rand_weight = self.params.get_constant(
            'rand_weight', np.random.uniform(size=(20, 20)))
        self.dense = nn.Dense(20, activation='relu')

    def forward(self, X):
        X = self.dense(X)
        # Use the created constant parameters, as well as the relu and dot
        # functions
        X = npx.relu(np.dot(X, self.rand_weight.data()) + 1)
        # Reuse the fully connected layer. This is equivalent to sharing
        # parameters with two fully connected layers
        X = self.dense(X)
        # Control flow
        while np.abs(X).sum() &gt; 1:
            X /= 2
        return X.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class FixedHiddenMLP(nn.Module):
    def __init__(self):
        super().__init__()
        # Random weight parameters that will not compute gradients and
        # therefore keep constant during training
        self.rand_weight = torch.rand((20, 20))
        self.linear = nn.LazyLinear(20)

    def forward(self, X):
        X = self.linear(X)        
        X = F.relu(X @ self.rand_weight + 1)
        # Reuse the fully connected layer. This is equivalent to sharing
        # parameters with two fully connected layers
        X = self.linear(X)
        # Control flow
        while X.abs().sum() &gt; 1:
            X /= 2
        return X.sum()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class FixedHiddenMLP(tf.keras.Model):
    def __init__(self):
        super().__init__()
        self.flatten = tf.keras.layers.Flatten()
        # Random weight parameters created with tf.constant are not updated
        # during training (i.e., constant parameters)
        self.rand_weight = tf.constant(tf.random.uniform((20, 20)))
        self.dense = tf.keras.layers.Dense(20, activation=tf.nn.relu)

    def call(self, inputs):
        X = self.flatten(inputs)
        # Use the created constant parameters, as well as the relu and
        # matmul functions
        X = tf.nn.relu(tf.matmul(X, self.rand_weight) + 1)
        # Reuse the fully connected layer. This is equivalent to sharing
        # parameters with two fully connected layers
        X = self.dense(X)
        # Control flow
        while tf.reduce_sum(tf.math.abs(X)) &gt; 1:
            X /= 2
        return tf.reduce_sum(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class FixedHiddenMLP(nn.Module):
    # Random weight parameters that will not compute gradients and
    # therefore keep constant during training
    rand_weight: jnp.array = jax.random.uniform(d2l.get_key(), (20, 20))

    def setup(self):
        self.dense = nn.Dense(20)

    def __call__(self, X):
        X = self.dense(X)
        X = nn.relu(X @ self.rand_weight + 1)
        # Reuse the fully connected layer. This is equivalent to sharing
        # parameters with two fully connected layers
        X = self.dense(X)
        # Control flow
        while jnp.abs(X).sum() &gt; 1:
            X /= 2
        return X.sum()
</code></pre>
<p>In this model,
we implement a hidden layer whose weights
(<code>self.rand_weight</code>) are initialized randomly
at instantiation and are thereafter constant.
This weight is not a model parameter
and thus it is never updated by backpropagation.
The network then passes the output of this "fixed" layer
through a fully connected layer.</p>
<p>Note that before returning the output,
our model did something unusual.
We ran a while-loop, testing
on the condition its $\ell_1$ norm is larger than $1$,
and dividing our output vector by $2$
until it satisfied the condition.
Finally, we returned the sum of the entries in <code>X</code>.
To our knowledge, no standard neural network
performs this operation.
Note that this particular operation may not be useful
in any real-world task.
Our point is only to show you how to integrate
arbitrary code into the flow of your
neural network computations.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
net = FixedHiddenMLP()
if tab.selected('mxnet'):
    net.initialize()
net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = FixedHiddenMLP()
params = net.init(d2l.get_key(), X)
net.apply(params, X)
</code></pre>
<p>We can [<strong>mix and match various
ways of assembling modules together.</strong>]
In the following example, we nest modules
in some creative ways.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class NestMLP(nn.Block):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.net = nn.Sequential()
        self.net.add(nn.Dense(64, activation='relu'),
                     nn.Dense(32, activation='relu'))
        self.dense = nn.Dense(16, activation='relu')

    def forward(self, X):
        return self.dense(self.net(X))

chimera = nn.Sequential()
chimera.add(NestMLP(), nn.Dense(20), FixedHiddenMLP())
chimera.initialize()
chimera(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class NestMLP(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(nn.LazyLinear(64), nn.ReLU(),
                                 nn.LazyLinear(32), nn.ReLU())
        self.linear = nn.LazyLinear(16)

    def forward(self, X):
        return self.linear(self.net(X))

chimera = nn.Sequential(NestMLP(), nn.LazyLinear(20), FixedHiddenMLP())
chimera(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class NestMLP(tf.keras.Model):
    def __init__(self):
        super().__init__()
        self.net = tf.keras.Sequential()
        self.net.add(tf.keras.layers.Dense(64, activation=tf.nn.relu))
        self.net.add(tf.keras.layers.Dense(32, activation=tf.nn.relu))
        self.dense = tf.keras.layers.Dense(16, activation=tf.nn.relu)

    def call(self, inputs):
        return self.dense(self.net(inputs))

chimera = tf.keras.Sequential()
chimera.add(NestMLP())
chimera.add(tf.keras.layers.Dense(20))
chimera.add(FixedHiddenMLP())
chimera(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class NestMLP(nn.Module):
    def setup(self):
        self.net = nn.Sequential([nn.Dense(64), nn.relu,
                                  nn.Dense(32), nn.relu])
        self.dense = nn.Dense(16)

    def __call__(self, X):
        return self.dense(self.net(X))


chimera = nn.Sequential([NestMLP(), nn.Dense(20), FixedHiddenMLP()])
params = chimera.init(d2l.get_key(), X)
chimera.apply(params, X)
</code></pre>
<h2 id="summary-21"><a class="header" href="#summary-21">Summary</a></h2>
<p>Individual layers can be modules.
Many layers can comprise a module.
Many modules can comprise a module.</p>
<p>A module can contain code.
Modules take care of lots of housekeeping, including parameter initialization and backpropagation.
Sequential concatenations of layers and modules are handled by the <code>Sequential</code> module.</p>
<h2 id="exercises-29"><a class="header" href="#exercises-29">Exercises</a></h2>
<ol>
<li>What kinds of problems will occur if you change <code>MySequential</code> to store modules in a Python list?</li>
<li>Implement a module that takes two modules as an argument, say <code>net1</code> and <code>net2</code> and returns the concatenated output of both networks in the forward propagation. This is also called a <em>parallel module</em>.</li>
<li>Assume that you want to concatenate multiple instances of the same network. Implement a factory function that generates multiple instances of the same module and build a larger network from it.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/54">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/55">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/264">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17989">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="parameter-management"><a class="header" href="#parameter-management">Parameter Management</a></h1>
<p>Once we have chosen an architecture
and set our hyperparameters,
we proceed to the training loop,
where our goal is to find parameter values
that minimize our loss function.
After training, we will need these parameters
in order to make future predictions.
Additionally, we will sometimes wish
to extract the parameters
perhaps to reuse them in some other context,
to save our model to disk so that
it may be executed in other software,
or for examination in the hope of
gaining scientific understanding.</p>
<p>Most of the time, we will be able
to ignore the nitty-gritty details
of how parameters are declared
and manipulated, relying on deep learning frameworks
to do the heavy lifting.
However, when we move away from
stacked architectures with standard layers,
we will sometimes need to get into the weeds
of declaring and manipulating parameters.
In this section, we cover the following:</p>
<ul>
<li>Accessing parameters for debugging, diagnostics, and visualizations.</li>
<li>Sharing parameters across different model components.</li>
</ul>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<p>(<strong>We start by focusing on an MLP with one hidden layer.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(8, activation='relu'))
net.add(nn.Dense(1))
net.initialize()  # Use the default initialization method

X = np.random.uniform(size=(2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(8),
                    nn.ReLU(),
                    nn.LazyLinear(1))

X = torch.rand(size=(2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(4, activation=tf.nn.relu),
    tf.keras.layers.Dense(1),
])

X = tf.random.uniform((2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(8), nn.relu, nn.Dense(1)])

X = jax.random.uniform(d2l.get_key(), (2, 4))
params = net.init(d2l.get_key(), X)
net.apply(params, X).shape
</code></pre>
<h2 id="parameter-access"><a class="header" href="#parameter-access">[<strong>Parameter Access</strong>]</a></h2>
<p>:label:<code>subsec_param-access</code></p>
<p>Let's start with how to access parameters
from the models that you already know.</p>
<p>:begin_tab:<code>mxnet, pytorch, tensorflow</code>
When a model is defined via the <code>Sequential</code> class,
we can first access any layer by indexing
into the model as though it were a list.
Each layer's parameters are conveniently
located in its attribute.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Flax and JAX decouple the model and the parameters as you
might have observed in the models defined previously.
When a model is defined via the <code>Sequential</code> class,
we first need to initialize the network to generate
the parameters dictionary. We can access
any layer's parameters through the keys of this dictionary.
:end_tab:</p>
<p>We can inspect the parameters of the second fully connected layer as follows.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net[1].params
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net[2].state_dict()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net.layers[2].weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
params['params']['layers_2']
</code></pre>
<p>We can see that this fully connected layer
contains two parameters,
corresponding to that layer's
weights and biases, respectively.</p>
<h3 id="targeted-parameters"><a class="header" href="#targeted-parameters">[<strong>Targeted Parameters</strong>]</a></h3>
<p>Note that each parameter is represented
as an instance of the parameter class.
To do anything useful with the parameters,
we first need to access the underlying numerical values.
There are several ways to do this.
Some are simpler while others are more general.
The following code extracts the bias
from the second neural network layer, which returns a parameter class instance, and
further accesses that parameter's value.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
type(net[1].bias), net[1].bias.data()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
type(net[2].bias), net[2].bias.data
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
type(net.layers[2].weights[1]), tf.convert_to_tensor(net.layers[2].weights[1])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
bias = params['params']['layers_2']['bias']
type(bias), bias
</code></pre>
<p>:begin_tab:<code>mxnet,pytorch</code>
Parameters are complex objects,
containing values, gradients,
and additional information.
That is why we need to request the value explicitly.</p>
<p>In addition to the value, each parameter also allows us to access the gradient. Because we have not invoked backpropagation for this network yet, it is in its initial state.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Unlike the other frameworks, JAX does not keep a track of the gradients over the
neural network parameters, instead the parameters and the network are decoupled.
It allows the user to express their computation as a
Python function, and use the <code>grad</code> transformation for the same purpose.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net[1].weight.grad()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net[2].weight.grad == None
</code></pre>
<h3 id="all-parameters-at-once"><a class="header" href="#all-parameters-at-once">[<strong>All Parameters at Once</strong>]</a></h3>
<p>When we need to perform operations on all parameters,
accessing them one-by-one can grow tedious.
The situation can grow especially unwieldy
when we work with more complex, e.g., nested, modules,
since we would need to recurse
through the entire tree to extract
each sub-module's parameters. Below we demonstrate accessing the parameters of all layers.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net.collect_params()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
[(name, param.shape) for name, param in net.named_parameters()]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net.get_weights()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
jax.tree_util.tree_map(lambda x: x.shape, params)
</code></pre>
<h2 id="tied-parameters"><a class="header" href="#tied-parameters">[<strong>Tied Parameters</strong>]</a></h2>
<p>Often, we want to share parameters across multiple layers.
Let's see how to do this elegantly.
In the following we allocate a fully connected layer
and then use its parameters specifically
to set those of another layer.
Here we need to run the forward propagation
<code>net(X)</code> before accessing the parameters.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
# We need to give the shared layer a name so that we can refer to its
# parameters
shared = nn.Dense(8, activation='relu')
net.add(nn.Dense(8, activation='relu'),
        shared,
        nn.Dense(8, activation='relu', params=shared.params),
        nn.Dense(10))
net.initialize()

X = np.random.uniform(size=(2, 20))

net(X)
# Check whether the parameters are the same
print(net[1].weight.data()[0] == net[2].weight.data()[0])
net[1].weight.data()[0, 0] = 100
# Make sure that they are actually the same object rather than just having the
# same value
print(net[1].weight.data()[0] == net[2].weight.data()[0])
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# We need to give the shared layer a name so that we can refer to its
# parameters
shared = nn.LazyLinear(8)
net = nn.Sequential(nn.LazyLinear(8), nn.ReLU(),
                    shared, nn.ReLU(),
                    shared, nn.ReLU(),
                    nn.LazyLinear(1))

net(X)
# Check whether the parameters are the same
print(net[2].weight.data[0] == net[4].weight.data[0])
net[2].weight.data[0, 0] = 100
# Make sure that they are actually the same object rather than just having the
# same value
print(net[2].weight.data[0] == net[4].weight.data[0])
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# tf.keras behaves a bit differently. It removes the duplicate layer
# automatically
shared = tf.keras.layers.Dense(4, activation=tf.nn.relu)
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    shared,
    shared,
    tf.keras.layers.Dense(1),
])

net(X)
# Check whether the parameters are different
print(len(net.layers) == 3)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# We need to give the shared layer a name so that we can refer to its
# parameters
shared = nn.Dense(8)
net = nn.Sequential([nn.Dense(8), nn.relu,
                     shared, nn.relu,
                     shared, nn.relu,
                     nn.Dense(1)])

params = net.init(jax.random.PRNGKey(d2l.get_seed()), X)

# Check whether the parameters are different
print(len(params['params']) == 3)
</code></pre>
<p>This example shows that the parameters
of the second and third layer are tied.
They are not just equal, they are
represented by the same exact tensor.
Thus, if we change one of the parameters,
the other one changes, too.</p>
<p>:begin_tab:<code>mxnet, pytorch, tensorflow</code>
You might wonder,
when parameters are tied
what happens to the gradients?
Since the model parameters contain gradients,
the gradients of the second hidden layer
and the third hidden layer are added together
during backpropagation.
:end_tab:</p>
<h2 id="summary-22"><a class="header" href="#summary-22">Summary</a></h2>
<p>We have several ways of accessing and tying model parameters.</p>
<h2 id="exercises-30"><a class="header" href="#exercises-30">Exercises</a></h2>
<ol>
<li>Use the <code>NestMLP</code> model defined in :numref:<code>sec_model_construction</code> and access the parameters of the various layers.</li>
<li>Construct an MLP containing a shared parameter layer and train it. During the training process, observe the model parameters and gradients of each layer.</li>
<li>Why is sharing parameters a good idea?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/56">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/57">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/269">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17990">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="parameter-initialization-1"><a class="header" href="#parameter-initialization-1">Parameter Initialization</a></h1>
<p>Now that we know how to access the parameters,
let's look at how to initialize them properly.
We discussed the need for proper initialization in :numref:<code>sec_numerical_stability</code>.
The deep learning framework provides default random initializations to its layers.
However, we often want to initialize our weights
according to various other protocols. The framework provides most commonly
used protocols, and also allows to create a custom initializer.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<p>:begin_tab:<code>mxnet</code>
By default, MXNet initializes weight parameters by randomly drawing from a uniform distribution $U(-0.07, 0.07)$,
clearing bias parameters to zero.
MXNet's <code>init</code> module provides a variety
of preset initialization methods.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
By default, PyTorch initializes weight and bias matrices
uniformly by drawing from a range that is computed according to the input and output dimension.
PyTorch's <code>nn.init</code> module provides a variety
of preset initialization methods.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
By default, Keras initializes weight matrices uniformly by drawing from a range that is computed according to the input and output dimension, and the bias parameters are all set to zero.
TensorFlow provides a variety of initialization methods both in the root module and the <code>keras.initializers</code> module.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
By default, Flax initializes weights using <code>jax.nn.initializers.lecun_normal</code>,
i.e., by drawing samples from a truncated normal distribution centered on 0 with
the standard deviation set as the squared root of $1 / \textrm{fan}_{\textrm{in}}$
where <code>fan_in</code> is the number of input units in the weight tensor. The bias
parameters are all set to zero.
Jax's <code>nn.initializers</code> module provides a variety
of preset initialization methods.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(8, activation='relu'))
net.add(nn.Dense(1))
net.initialize()  # Use the default initialization method

X = np.random.uniform(size=(2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(8), nn.ReLU(), nn.LazyLinear(1))
X = torch.rand(size=(2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(4, activation=tf.nn.relu),
    tf.keras.layers.Dense(1),
])

X = tf.random.uniform((2, 4))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(8), nn.relu, nn.Dense(1)])
X = jax.random.uniform(d2l.get_key(), (2, 4))
params = net.init(d2l.get_key(), X)
net.apply(params, X).shape
</code></pre>
<h2 id="built-in-initialization"><a class="header" href="#built-in-initialization">[<strong>Built-in Initialization</strong>]</a></h2>
<p>Let's begin by calling on built-in initializers.
The code below initializes all weight parameters
as Gaussian random variables
with standard deviation 0.01, while bias parameters are cleared to zero.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
# Here force_reinit ensures that parameters are freshly initialized even if
# they were already initialized previously
net.initialize(init=init.Normal(sigma=0.01), force_reinit=True)
net[0].weight.data()[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def init_normal(module):
    if type(module) == nn.Linear:
        nn.init.normal_(module.weight, mean=0, std=0.01)
        nn.init.zeros_(module.bias)

net.apply(init_normal)
net[0].weight.data[0], net[0].bias.data[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(
        4, activation=tf.nn.relu,
        kernel_initializer=tf.random_normal_initializer(mean=0, stddev=0.01),
        bias_initializer=tf.zeros_initializer()),
    tf.keras.layers.Dense(1)])

net(X)
net.weights[0], net.weights[1]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
weight_init = nn.initializers.normal(0.01)
bias_init = nn.initializers.zeros

net = nn.Sequential([nn.Dense(8, kernel_init=weight_init, bias_init=bias_init),
                     nn.relu,
                     nn.Dense(1, kernel_init=weight_init, bias_init=bias_init)])

params = net.init(jax.random.PRNGKey(d2l.get_seed()), X)
layer_0 = params['params']['layers_0']
layer_0['kernel'][:, 0], layer_0['bias'][0]
</code></pre>
<p>We can also initialize all the parameters
to a given constant value (say, 1).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net.initialize(init=init.Constant(1), force_reinit=True)
net[0].weight.data()[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def init_constant(module):
    if type(module) == nn.Linear:
        nn.init.constant_(module.weight, 1)
        nn.init.zeros_(module.bias)

net.apply(init_constant)
net[0].weight.data[0], net[0].bias.data[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(
        4, activation=tf.nn.relu,
        kernel_initializer=tf.keras.initializers.Constant(1),
        bias_initializer=tf.zeros_initializer()),
    tf.keras.layers.Dense(1),
])

net(X)
net.weights[0], net.weights[1]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
weight_init = nn.initializers.constant(1)

net = nn.Sequential([nn.Dense(8, kernel_init=weight_init, bias_init=bias_init),
                     nn.relu,
                     nn.Dense(1, kernel_init=weight_init, bias_init=bias_init)])

params = net.init(jax.random.PRNGKey(d2l.get_seed()), X)
layer_0 = params['params']['layers_0']
layer_0['kernel'][:, 0], layer_0['bias'][0]
</code></pre>
<p>[<strong>We can also apply different initializers for certain blocks.</strong>]
For example, below we initialize the first layer
with the Xavier initializer
and initialize the second layer
to a constant value of 42.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net[0].weight.initialize(init=init.Xavier(), force_reinit=True)
net[1].initialize(init=init.Constant(42), force_reinit=True)
print(net[0].weight.data()[0])
print(net[1].weight.data())
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def init_xavier(module):
    if type(module) == nn.Linear:
        nn.init.xavier_uniform_(module.weight)

def init_42(module):
    if type(module) == nn.Linear:
        nn.init.constant_(module.weight, 42)

net[0].apply(init_xavier)
net[2].apply(init_42)
print(net[0].weight.data[0])
print(net[2].weight.data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(
        4,
        activation=tf.nn.relu,
        kernel_initializer=tf.keras.initializers.GlorotUniform()),
    tf.keras.layers.Dense(
        1, kernel_initializer=tf.keras.initializers.Constant(42)),
])

net(X)
print(net.layers[1].weights[0])
print(net.layers[2].weights[0])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(8, kernel_init=nn.initializers.xavier_uniform(),
                              bias_init=bias_init),
                     nn.relu,
                     nn.Dense(1, kernel_init=nn.initializers.constant(42),
                              bias_init=bias_init)])

params = net.init(jax.random.PRNGKey(d2l.get_seed()), X)
params['params']['layers_0']['kernel'][:, 0], params['params']['layers_2']['kernel']
</code></pre>
<h3 id="custom-initialization"><a class="header" href="#custom-initialization">[<strong>Custom Initialization</strong>]</a></h3>
<p>Sometimes, the initialization methods we need
are not provided by the deep learning framework.
In the example below, we define an initializer
for any weight parameter $w$ using the following strange distribution:</p>
<p>$$
\begin{aligned}
w \sim \begin{cases}
U(5, 10) &amp; \textrm{ with probability } \frac{1}{4} \
0    &amp; \textrm{ with probability } \frac{1}{2} \
U(-10, -5) &amp; \textrm{ with probability } \frac{1}{4}
\end{cases}
\end{aligned}
$$</p>
<p>:begin_tab:<code>mxnet</code>
Here we define a subclass of the <code>Initializer</code> class.
Usually, we only need to implement the <code>_init_weight</code> function
which takes a tensor argument (<code>data</code>)
and assigns to it the desired initialized values.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Again, we implement a <code>my_init</code> function to apply to <code>net</code>.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Here we define a subclass of <code>Initializer</code> and implement the <code>__call__</code>
function that return a desired tensor given the shape and data type.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Jax initialization functions take as arguments the <code>PRNGKey</code>, <code>shape</code> and
<code>dtype</code>. Here we implement the function <code>my_init</code> that returns a desired
tensor given the shape and data type.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MyInit(init.Initializer):
    def _init_weight(self, name, data):
        print('Init', name, data.shape)
        data[:] = np.random.uniform(-10, 10, data.shape)
        data *= np.abs(data) &gt;= 5

net.initialize(MyInit(), force_reinit=True)
net[0].weight.data()[:2]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def my_init(module):
    if type(module) == nn.Linear:
        print("Init", *[(name, param.shape)
                        for name, param in module.named_parameters()][0])
        nn.init.uniform_(module.weight, -10, 10)
        module.weight.data *= module.weight.data.abs() &gt;= 5

net.apply(my_init)
net[0].weight[:2]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MyInit(tf.keras.initializers.Initializer):
    def __call__(self, shape, dtype=None):
        data=tf.random.uniform(shape, -10, 10, dtype=dtype)
        factor=(tf.abs(data) &gt;= 5)
        factor=tf.cast(factor, tf.float32)
        return data * factor

net = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(
        4,
        activation=tf.nn.relu,
        kernel_initializer=MyInit()),
    tf.keras.layers.Dense(1),
])

net(X)
print(net.layers[1].weights[0])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def my_init(key, shape, dtype=jnp.float_):
    data = jax.random.uniform(key, shape, minval=-10, maxval=10)
    return data * (jnp.abs(data) &gt;= 5)

net = nn.Sequential([nn.Dense(8, kernel_init=my_init), nn.relu, nn.Dense(1)])
params = net.init(d2l.get_key(), X)
print(params['params']['layers_0']['kernel'][:, :2])
</code></pre>
<p>:begin_tab:<code>mxnet, pytorch, tensorflow</code>
Note that we always have the option
of setting parameters directly.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
When initializing parameters in JAX and Flax, the the dictionary of parameters
returned has a <code>flax.core.frozen_dict.FrozenDict</code> type. It is not advisable in
the Jax ecosystem to directly alter the values of an array, hence the datatypes
are generally immutable. One might use <code>params.unfreeze()</code> to make changes.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net[0].weight.data()[:] += 1
net[0].weight.data()[0, 0] = 42
net[0].weight.data()[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net[0].weight.data[:] += 1
net[0].weight.data[0, 0] = 42
net[0].weight.data[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net.layers[1].weights[0][:].assign(net.layers[1].weights[0] + 1)
net.layers[1].weights[0][0, 0].assign(42)
net.layers[1].weights[0]
</code></pre>
<h2 id="summary-23"><a class="header" href="#summary-23">Summary</a></h2>
<p>We can initialize parameters using built-in and custom initializers.</p>
<h2 id="exercises-31"><a class="header" href="#exercises-31">Exercises</a></h2>
<p>Look up the online documentation for more built-in initializers.</p>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/8089">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/8090">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/8091">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17991">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="lazy-initialization"><a class="header" href="#lazy-initialization">Lazy Initialization</a></h1>
<p>:label:<code>sec_lazy_init</code></p>
<p>So far, it might seem that we got away
with being sloppy in setting up our networks.
Specifically, we did the following unintuitive things,
which might not seem like they should work:</p>
<ul>
<li>We defined the network architectures
without specifying the input dimensionality.</li>
<li>We added layers without specifying
the output dimension of the previous layer.</li>
<li>We even "initialized" these parameters
before providing enough information to determine
how many parameters our models should contain.</li>
</ul>
<p>You might be surprised that our code runs at all.
After all, there is no way the deep learning framework
could tell what the input dimensionality of a network would be.
The trick here is that the framework <em>defers initialization</em>,
waiting until the first time we pass data through the model,
to infer the sizes of each layer on the fly.</p>
<p>Later on, when working with convolutional neural networks,
this technique will become even more convenient
since the input dimensionality
(e.g., the resolution of an image)
will affect the dimensionality
of each subsequent layer.
Hence the ability to set parameters
without the need to know,
at the time of writing the code,
the value of the dimension
can greatly simplify the task of specifying
and subsequently modifying our models.
Next, we go deeper into the mechanics of initialization.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<p>To begin, let's instantiate an MLP.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(256, activation='relu'))
net.add(nn.Dense(10))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation=tf.nn.relu),
    tf.keras.layers.Dense(10),
])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(256), nn.relu, nn.Dense(10)])
</code></pre>
<p>At this point, the network cannot possibly know
the dimensions of the input layer's weights
because the input dimension remains unknown.</p>
<p>:begin_tab:<code>mxnet, pytorch, tensorflow</code>
Consequently the framework has not yet initialized any parameters.
We confirm by attempting to access the parameters below.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
As mentioned in :numref:<code>subsec_param-access</code>, parameters and the network definition are decoupled
in Jax and Flax, and the user handles both manually. Flax models are stateless
hence there is no <code>parameters</code> attribute.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
print(net.collect_params)
print(net.collect_params())
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net[0].weight
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
[net.layers[i].get_weights() for i in range(len(net.layers))]
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Note that while the parameter objects exist,
the input dimension to each layer is listed as -1.
MXNet uses the special value -1 to indicate
that the parameter dimension remains unknown.
At this point, attempts to access <code>net[0].weight.data()</code>
would trigger a runtime error stating that the network
must be initialized before the parameters can be accessed.
Now let's see what happens when we attempt to initialize
parameters via the <code>initialize</code> method.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Note that each layer objects exist but the weights are empty.
Using <code>net.get_weights()</code> would throw an error since the weights
have not been initialized yet.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net.initialize()
net.collect_params()
</code></pre>
<p>:begin_tab:<code>mxnet</code>
As we can see, nothing has changed.
When input dimensions are unknown,
calls to initialize do not truly initialize the parameters.
Instead, this call registers to MXNet that we wish
(and optionally, according to which distribution)
to initialize the parameters.
:end_tab:</p>
<p>Next let's pass data through the network
to make the framework finally initialize parameters.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
X = np.random.uniform(size=(2, 20))
net(X)

net.collect_params()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
X = torch.rand(2, 20)
net(X)

net[0].weight.shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = tf.random.uniform((2, 20))
net(X)
[w.shape for w in net.get_weights()]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
params = net.init(d2l.get_key(), jnp.zeros((2, 20)))
jax.tree_util.tree_map(lambda x: x.shape, params).tree_flatten_with_keys()
</code></pre>
<p>As soon as we know the input dimensionality,
20,
the framework can identify the shape of the first layer's weight matrix by plugging in the value of 20.
Having recognized the first layer's shape, the framework proceeds
to the second layer,
and so on through the computational graph
until all shapes are known.
Note that in this case,
only the first layer requires lazy initialization,
but the framework initializes sequentially.
Once all parameter shapes are known,
the framework can finally initialize the parameters.</p>
<p>:begin_tab:<code>pytorch</code>
The following method
passes in dummy inputs
through the network
for a dry run
to infer all parameter shapes
and subsequently initializes the parameters.
It will be used later when default random initializations are not desired.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Parameter initialization in Flax is always done manually and handled by the
user. The following method takes a dummy input and a key dictionary as argument.
This key dictionary has the rngs for initializing the model parameters
and dropout rng for generating the dropout mask for the models with
dropout layers. More about dropout will be covered later in :numref:<code>sec_dropout</code>.
Ultimately the method initializes the model returning the parameters.
We have been using it under the hood in the previous sections as well.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(d2l.Module)  #@save
def apply_init(self, inputs, init=None):
    self.forward(*inputs)
    if init is not None:
        self.net.apply(init)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Module)  #@save
def apply_init(self, dummy_input, key):
    params = self.init(key, *dummy_input)  # dummy_input tuple unpacked
    return params
</code></pre>
<h2 id="summary-24"><a class="header" href="#summary-24">Summary</a></h2>
<p>Lazy initialization can be convenient, allowing the framework to infer parameter shapes automatically, making it easy to modify architectures and eliminating one common source of errors.
We can pass data through the model to make the framework finally initialize parameters.</p>
<h2 id="exercises-32"><a class="header" href="#exercises-32">Exercises</a></h2>
<ol>
<li>What happens if you specify the input dimensions to the first layer but not to subsequent layers? Do you get immediate initialization?</li>
<li>What happens if you specify mismatching dimensions?</li>
<li>What would you need to do if you have input of varying dimensionality? Hint: look at the parameter tying.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/280">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/8092">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/281">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17992">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="custom-layers"><a class="header" href="#custom-layers">Custom Layers</a></h1>
<p>One factor behind deep learning's success
is the availability of a wide range of layers
that can be composed in creative ways
to design architectures suitable
for a wide variety of tasks.
For instance, researchers have invented layers
specifically for handling images, text,
looping over sequential data,
and
performing dynamic programming.
Sooner or later, you will need
a layer that does not exist yet in the deep learning framework.
In these cases, you must build a custom layer.
In this section, we show you how.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="layers-without-parameters"><a class="header" href="#layers-without-parameters">(<strong>Layers without Parameters</strong>)</a></h2>
<p>To start, we construct a custom layer
that does not have any parameters of its own.
This should look familiar if you recall our
introduction to modules in :numref:<code>sec_model_construction</code>.
The following <code>CenteredLayer</code> class simply
subtracts the mean from its input.
To build it, we simply need to inherit
from the base layer class and implement the forward propagation function.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class CenteredLayer(nn.Block):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def forward(self, X):
        return X - X.mean()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class CenteredLayer(nn.Module):
    def __init__(self):
        super().__init__()

    def forward(self, X):
        return X - X.mean()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class CenteredLayer(tf.keras.Model):
    def __init__(self):
        super().__init__()

    def call(self, X):
        return X - tf.reduce_mean(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class CenteredLayer(nn.Module):
    def __call__(self, X):
        return X - X.mean()
</code></pre>
<p>Let's verify that our layer works as intended by feeding some data through it.</p>
<pre><code class="language-{.python .input}">%%tab all
layer = CenteredLayer()
layer(d2l.tensor([1.0, 2, 3, 4, 5]))
</code></pre>
<p>We can now [<strong>incorporate our layer as a component
in constructing more complex models.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(128), CenteredLayer())
net.initialize()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(128), CenteredLayer())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.Sequential([tf.keras.layers.Dense(128), CenteredLayer()])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(128), CenteredLayer()])
</code></pre>
<p>As an extra sanity check, we can send random data
through the network and check that the mean is in fact 0.
Because we are dealing with floating point numbers,
we may still see a very small nonzero number
due to quantization.</p>
<p>:begin_tab:<code>jax</code>
Here we utilize the <code>init_with_output</code> method which returns both the output of
the network as well as the parameters. In this case we only focus on the
output.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet
Y = net(d2l.rand(4, 8))
Y.mean()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
Y = net(tf.random.uniform((4, 8)))
tf.reduce_mean(Y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Y, _ = net.init_with_output(d2l.get_key(), jax.random.uniform(d2l.get_key(),
                                                              (4, 8)))
Y.mean()
</code></pre>
<h2 id="layers-with-parameters"><a class="header" href="#layers-with-parameters">[<strong>Layers with Parameters</strong>]</a></h2>
<p>Now that we know how to define simple layers,
let's move on to defining layers with parameters
that can be adjusted through training.
We can use built-in functions to create parameters, which
provide some basic housekeeping functionality.
In particular, they govern access, initialization,
sharing, saving, and loading model parameters.
This way, among other benefits, we will not need to write
custom serialization routines for every custom layer.</p>
<p>Now let's implement our own version of the  fully connected layer.
Recall that this layer requires two parameters,
one to represent the weight and the other for the bias.
In this implementation, we bake in the ReLU activation as a default.
This layer requires two input arguments: <code>in_units</code> and <code>units</code>, which
denote the number of inputs and outputs, respectively.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MyDense(nn.Block):
    def __init__(self, units, in_units, **kwargs):
        super().__init__(**kwargs)
        self.weight = self.params.get('weight', shape=(in_units, units))
        self.bias = self.params.get('bias', shape=(units,))

    def forward(self, x):
        linear = np.dot(x, self.weight.data(ctx=x.ctx)) + self.bias.data(
            ctx=x.ctx)
        return npx.relu(linear)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MyLinear(nn.Module):
    def __init__(self, in_units, units):
        super().__init__()
        self.weight = nn.Parameter(torch.randn(in_units, units))
        self.bias = nn.Parameter(torch.randn(units,))
        
    def forward(self, X):
        linear = torch.matmul(X, self.weight.data) + self.bias.data
        return F.relu(linear)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MyDense(tf.keras.Model):
    def __init__(self, units):
        super().__init__()
        self.units = units

    def build(self, X_shape):
        self.weight = self.add_weight(name='weight',
            shape=[X_shape[-1], self.units],
            initializer=tf.random_normal_initializer())
        self.bias = self.add_weight(
            name='bias', shape=[self.units],
            initializer=tf.zeros_initializer())

    def call(self, X):
        linear = tf.matmul(X, self.weight) + self.bias
        return tf.nn.relu(linear)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MyDense(nn.Module):
    in_units: int
    units: int

    def setup(self):
        self.weight = self.param('weight', nn.initializers.normal(stddev=1),
                                 (self.in_units, self.units))
        self.bias = self.param('bias', nn.initializers.zeros, self.units)

    def __call__(self, X):
        linear = jnp.matmul(X, self.weight) + self.bias
        return nn.relu(linear)
</code></pre>
<p>:begin_tab:<code>mxnet, tensorflow, jax</code>
Next, we instantiate the <code>MyDense</code> class
and access its model parameters.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Next, we instantiate the <code>MyLinear</code> class
and access its model parameters.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
dense = MyDense(units=3, in_units=5)
dense.params
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
linear = MyLinear(5, 3)
linear.weight
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
dense = MyDense(3)
dense(tf.random.uniform((2, 5)))
dense.get_weights()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
dense = MyDense(5, 3)
params = dense.init(d2l.get_key(), jnp.zeros((3, 5)))
params
</code></pre>
<p>We can [<strong>directly carry out forward propagation calculations using custom layers.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
dense.initialize()
dense(np.random.uniform(size=(2, 5)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
linear(torch.rand(2, 5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
dense(tf.random.uniform((2, 5)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
dense.apply(params, jax.random.uniform(d2l.get_key(),
                                       (2, 5)))
</code></pre>
<p>We can also (<strong>construct models using custom layers.</strong>)
Once we have that we can use it just like the built-in fully connected layer.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(MyDense(8, in_units=64),
        MyDense(1, in_units=8))
net.initialize()
net(np.random.uniform(size=(2, 64)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(MyLinear(64, 8), MyLinear(8, 1))
net(torch.rand(2, 64))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net = tf.keras.models.Sequential([MyDense(8), MyDense(1)])
net(tf.random.uniform((2, 64)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([MyDense(64, 8), MyDense(8, 1)])
Y, _ = net.init_with_output(d2l.get_key(), jax.random.uniform(d2l.get_key(),
                                                              (2, 64)))
Y
</code></pre>
<h2 id="summary-25"><a class="header" href="#summary-25">Summary</a></h2>
<p>We can design custom layers via the basic layer class. This allows us to define flexible new layers that behave differently from any existing layers in the library.
Once defined, custom layers can be invoked in arbitrary contexts and architectures.
Layers can have local parameters, which can be created through built-in functions.</p>
<h2 id="exercises-33"><a class="header" href="#exercises-33">Exercises</a></h2>
<ol>
<li>Design a layer that takes an input and computes a tensor reduction,
i.e., it returns $y_k = \sum_{i, j} W_{ijk} x_i x_j$.</li>
<li>Design a layer that returns the leading half of the Fourier coefficients of the data.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/58">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/59">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/279">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17993">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="file-io"><a class="header" href="#file-io">File I/O</a></h1>
<p>So far we have discussed how to process data and how
to build, train, and test deep learning models.
However, at some point we will hopefully be happy enough
with the learned models that we will want
to save the results for later use in various contexts
(perhaps even to make predictions in deployment).
Additionally, when running a long training process,
the best practice is to periodically save intermediate results (checkpointing)
to ensure that we do not lose several days' worth of computation
if we trip over the power cord of our server.
Thus it is time to learn how to load and store
both individual weight vectors and entire models.
This section addresses both issues.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
import numpy as np
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
import flax
from flax import linen as nn
from flax.training import checkpoints
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="loading-and-saving-tensors"><a class="header" href="#loading-and-saving-tensors">(<strong>Loading and Saving Tensors</strong>)</a></h2>
<p>For individual tensors, we can directly
invoke the <code>load</code> and <code>save</code> functions
to read and write them respectively.
Both functions require that we supply a name,
and <code>save</code> requires as input the variable to be saved.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.arange(4)
npx.save('x-file', x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.arange(4)
torch.save(x, 'x-file')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.range(4)
np.save('x-file.npy', x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.arange(4)
jnp.save('x-file.npy', x)
</code></pre>
<p>We can now read the data from the stored file back into memory.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x2 = npx.load('x-file')
x2
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x2 = torch.load('x-file')
x2
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x2 = np.load('x-file.npy', allow_pickle=True)
x2
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x2 = jnp.load('x-file.npy', allow_pickle=True)
x2
</code></pre>
<p>We can [<strong>store a list of tensors and read them back into memory.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
y = np.zeros(4)
npx.save('x-files', [x, y])
x2, y2 = npx.load('x-files')
(x2, y2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
y = torch.zeros(4)
torch.save([x, y],'x-files')
x2, y2 = torch.load('x-files')
(x2, y2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
y = tf.zeros(4)
np.save('xy-files.npy', [x, y])
x2, y2 = np.load('xy-files.npy', allow_pickle=True)
(x2, y2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
y = jnp.zeros(4)
jnp.save('xy-files.npy', [x, y])
x2, y2 = jnp.load('xy-files.npy', allow_pickle=True)
(x2, y2)
</code></pre>
<p>We can even [<strong>write and read a dictionary that maps
from strings to tensors.</strong>]
This is convenient when we want
to read or write all the weights in a model.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
mydict = {'x': x, 'y': y}
npx.save('mydict', mydict)
mydict2 = npx.load('mydict')
mydict2
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
mydict = {'x': x, 'y': y}
torch.save(mydict, 'mydict')
mydict2 = torch.load('mydict')
mydict2
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
mydict = {'x': x, 'y': y}
np.save('mydict.npy', mydict)
mydict2 = np.load('mydict.npy', allow_pickle=True)
mydict2
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
mydict = {'x': x, 'y': y}
jnp.save('mydict.npy', mydict)
mydict2 = jnp.load('mydict.npy', allow_pickle=True)
mydict2
</code></pre>
<h2 id="loading-and-saving-model-parameters"><a class="header" href="#loading-and-saving-model-parameters">[<strong>Loading and Saving Model Parameters</strong>]</a></h2>
<p>Saving individual weight vectors (or other tensors) is useful,
but it gets very tedious if we want to save
(and later load) an entire model.
After all, we might have hundreds of
parameter groups sprinkled throughout.
For this reason the deep learning framework provides built-in functionalities
to load and save entire networks.
An important detail to note is that this
saves model <em>parameters</em> and not the entire model.
For example, if we have a 3-layer MLP,
we need to specify the architecture separately.
The reason for this is that the models themselves can contain arbitrary code,
hence they cannot be serialized as naturally.
Thus, in order to reinstate a model, we need
to generate the architecture in code
and then load the parameters from disk.
(<strong>Let's start with our familiar MLP.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MLP(nn.Block):
    def __init__(self, **kwargs):
        super(MLP, self).__init__(**kwargs)
        self.hidden = nn.Dense(256, activation='relu')
        self.output = nn.Dense(10)

    def forward(self, x):
        return self.output(self.hidden(x))

net = MLP()
net.initialize()
X = np.random.uniform(size=(2, 20))
Y = net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MLP(nn.Module):
    def __init__(self):
        super().__init__()
        self.hidden = nn.LazyLinear(256)
        self.output = nn.LazyLinear(10)

    def forward(self, x):
        return self.output(F.relu(self.hidden(x)))

net = MLP()
X = torch.randn(size=(2, 20))
Y = net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MLP(tf.keras.Model):
    def __init__(self):
        super().__init__()
        self.flatten = tf.keras.layers.Flatten()
        self.hidden = tf.keras.layers.Dense(units=256, activation=tf.nn.relu)
        self.out = tf.keras.layers.Dense(units=10)

    def call(self, inputs):
        x = self.flatten(inputs)
        x = self.hidden(x)
        return self.out(x)

net = MLP()
X = tf.random.uniform((2, 20))
Y = net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MLP(nn.Module):
    def setup(self):
        self.hidden = nn.Dense(256)
        self.output = nn.Dense(10)

    def __call__(self, x):
        return self.output(nn.relu(self.hidden(x)))

net = MLP()
X = jax.random.normal(jax.random.PRNGKey(d2l.get_seed()), (2, 20))
Y, params = net.init_with_output(jax.random.PRNGKey(d2l.get_seed()), X)
</code></pre>
<p>Next, we [<strong>store the parameters of the model as a file</strong>] with the name "mlp.params".</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net.save_parameters('mlp.params')
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
torch.save(net.state_dict(), 'mlp.params')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net.save_weights('mlp.params')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
checkpoints.save_checkpoint('ckpt_dir', params, step=1, overwrite=True)
</code></pre>
<p>To recover the model, we instantiate a clone
of the original MLP model.
Instead of randomly initializing the model parameters,
we [<strong>read the parameters stored in the file directly</strong>].</p>
<pre><code class="language-{.python .input}">%%tab mxnet
clone = MLP()
clone.load_parameters('mlp.params')
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
clone = MLP()
clone.load_state_dict(torch.load('mlp.params'))
clone.eval()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
clone = MLP()
clone.load_weights('mlp.params')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
clone = MLP()
cloned_params = flax.core.freeze(checkpoints.restore_checkpoint('ckpt_dir',
                                                                target=None))
</code></pre>
<p>Since both instances have the same model parameters,
the computational result of the same input <code>X</code> should be the same.
Let's verify this.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
Y_clone = clone(X)
Y_clone == Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Y_clone = clone.apply(cloned_params, X)
Y_clone == Y
</code></pre>
<h2 id="summary-26"><a class="header" href="#summary-26">Summary</a></h2>
<p>The <code>save</code> and <code>load</code> functions can be used to perform file I/O for tensor objects.
We can save and load the entire sets of parameters for a network via a parameter dictionary.
Saving the architecture has to be done in code rather than in parameters.</p>
<h2 id="exercises-34"><a class="header" href="#exercises-34">Exercises</a></h2>
<ol>
<li>Even if there is no need to deploy trained models to a different device, what are the practical benefits of storing model parameters?</li>
<li>Assume that we want to reuse only parts of a network to be incorporated into a network having a different architecture. How would you go about using, say the first two layers from a previous network in a new network?</li>
<li>How would you go about saving the network architecture and parameters? What restrictions would you impose on the architecture?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/60">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/61">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/327">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17994">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="gpus"><a class="header" href="#gpus">GPUs</a></h1>
<p>:label:<code>sec_use_gpu</code></p>
<p>In :numref:<code>tab_intro_decade</code>, we illustrated the rapid growth
of computation over the past two decades.
In a nutshell, GPU performance has increased
by a factor of 1000 every decade since 2000.
This offers great opportunities but it also suggests
that there was significant demand for such performance.</p>
<p>In this section, we begin to discuss how to harness
this computational performance for your research.
First by using a single GPU and at a later point,
how to use multiple GPUs and multiple servers (with multiple GPUs).</p>
<p>Specifically, we will discuss how
to use a single NVIDIA GPU for calculations.
First, make sure you have at least one NVIDIA GPU installed.
Then, download the <a href="https://developer.nvidia.com/cuda-downloads">NVIDIA driver and CUDA</a>
and follow the prompts to set the appropriate path.
Once these preparations are complete,
the <code>nvidia-smi</code> command can be used
to (<strong>view the graphics card information</strong>).</p>
<p>:begin_tab:<code>mxnet</code>
You might have noticed that a MXNet tensor
looks almost identical to a NumPy <code>ndarray</code>.
But there are a few crucial differences.
One of the key features that distinguishes MXNet
from NumPy is its support for diverse hardware devices.</p>
<p>In MXNet, every array has a context.
So far, by default, all variables
and associated computation
have been assigned to the CPU.
Typically, other contexts might be various GPUs.
Things can get even hairier when
we deploy jobs across multiple servers.
By assigning arrays to contexts intelligently,
we can minimize the time spent
transferring data between devices.
For example, when training neural networks on a server with a GPU,
we typically prefer for the model's parameters to live on the GPU.</p>
<p>Next, we need to confirm that
the GPU version of MXNet is installed.
If a CPU version of MXNet is already installed,
we need to uninstall it first.
For example, use the <code>pip uninstall mxnet</code> command,
then install the corresponding MXNet version
according to your CUDA version.
Assuming you have CUDA 10.0 installed,
you can install the MXNet version
that supports CUDA 10.0 via <code>pip install mxnet-cu100</code>.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In PyTorch, every array has a device; we often refer it as a <em>context</em>.
So far, by default, all variables
and associated computation
have been assigned to the CPU.
Typically, other contexts might be various GPUs.
Things can get even hairier when
we deploy jobs across multiple servers.
By assigning arrays to contexts intelligently,
we can minimize the time spent
transferring data between devices.
For example, when training neural networks on a server with a GPU,
we typically prefer for the model's parameters to live on the GPU.
:end_tab:</p>
<p>To run the programs in this section,
you need at least two GPUs.
Note that this might be extravagant for most desktop computers
but it is easily available in the cloud, e.g.,
by using the AWS EC2 multi-GPU instances.
Almost all other sections do <em>not</em> require multiple GPUs, but here we simply wish to illustrate data flow between different devices.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="computing-devices"><a class="header" href="#computing-devices">[<strong>Computing Devices</strong>]</a></h2>
<p>We can specify devices, such as CPUs and GPUs,
for storage and calculation.
By default, tensors are created in the main memory
and then the CPU is used for calculations.</p>
<p>:begin_tab:<code>mxnet</code>
In MXNet, the CPU and GPU can be indicated by <code>cpu()</code> and <code>gpu()</code>.
It should be noted that <code>cpu()</code>
(or any integer in the parentheses)
means all physical CPUs and memory.
This means that MXNet's calculations
will try to use all CPU cores.
However, <code>gpu()</code> only represents one card
and the corresponding memory.
If there are multiple GPUs, we use <code>gpu(i)</code>
to represent the $i^\textrm{th}$ GPU ($i$ starts from 0).
Also, <code>gpu(0)</code> and <code>gpu()</code> are equivalent.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
In PyTorch, the CPU and GPU can be indicated by <code>torch.device('cpu')</code> and <code>torch.device('cuda')</code>.
It should be noted that the <code>cpu</code> device
means all physical CPUs and memory.
This means that PyTorch's calculations
will try to use all CPU cores.
However, a <code>gpu</code> device only represents one card
and the corresponding memory.
If there are multiple GPUs, we use <code>torch.device(f'cuda:{i}')</code>
to represent the $i^\textrm{th}$ GPU ($i$ starts at 0).
Also, <code>gpu:0</code> and <code>gpu</code> are equivalent.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch
def cpu():  #@save
    """Get the CPU device."""
    return torch.device('cpu')

def gpu(i=0):  #@save
    """Get a GPU device."""
    return torch.device(f'cuda:{i}')

cpu(), gpu(), gpu(1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow, jax
def cpu():  #@save
    """Get the CPU device."""
    if tab.selected('mxnet'):
        return npx.cpu()
    if tab.selected('tensorflow'):
        return tf.device('/CPU:0')
    if tab.selected('jax'):
        return jax.devices('cpu')[0]

def gpu(i=0):  #@save
    """Get a GPU device."""
    if tab.selected('mxnet'):
        return npx.gpu(i)
    if tab.selected('tensorflow'):
        return tf.device(f'/GPU:{i}')
    if tab.selected('jax'):
        return jax.devices('gpu')[i]

cpu(), gpu(), gpu(1)
</code></pre>
<p>We can (<strong>query the number of available GPUs.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab pytorch
def num_gpus():  #@save
    """Get the number of available GPUs."""
    return torch.cuda.device_count()

num_gpus()
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow, jax
def num_gpus():  #@save
    """Get the number of available GPUs."""
    if tab.selected('mxnet'):
        return npx.num_gpus()
    if tab.selected('tensorflow'):
        return len(tf.config.experimental.list_physical_devices('GPU'))
    if tab.selected('jax'):
        try:
            return jax.device_count('gpu')
        except:
            return 0  # No GPU backend found

num_gpus()
</code></pre>
<p>Now we [<strong>define two convenient functions that allow us
to run code even if the requested GPUs do not exist.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
def try_gpu(i=0):  #@save
    """Return gpu(i) if exists, otherwise return cpu()."""
    if num_gpus() &gt;= i + 1:
        return gpu(i)
    return cpu()

def try_all_gpus():  #@save
    """Return all available GPUs, or [cpu(),] if no GPU exists."""
    return [gpu(i) for i in range(num_gpus())]

try_gpu(), try_gpu(10), try_all_gpus()
</code></pre>
<h2 id="tensors-and-gpus"><a class="header" href="#tensors-and-gpus">Tensors and GPUs</a></h2>
<p>:begin_tab:<code>pytorch</code>
By default, tensors are created on the CPU.
We can [<strong>query the device where the tensor is located.</strong>]
:end_tab:</p>
<p>:begin_tab:<code>mxnet</code>
By default, tensors are created on the CPU.
We can [<strong>query the device where the tensor is located.</strong>]
:end_tab:</p>
<p>:begin_tab:<code>tensorflow, jax</code>
By default, tensors are created on the GPU/TPU if they are available,
else CPU is used if not available.
We can [<strong>query the device where the tensor is located.</strong>]
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
x = np.array([1, 2, 3])
x.ctx
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
x = torch.tensor([1, 2, 3])
x.device
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
x = tf.constant([1, 2, 3])
x.device
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
x = jnp.array([1, 2, 3])
x.device()
</code></pre>
<p>It is important to note that whenever we want
to operate on multiple terms,
they need to be on the same device.
For instance, if we sum two tensors,
we need to make sure that both arguments
live on the same device---otherwise the framework
would not know where to store the result
or even how to decide where to perform the computation.</p>
<h3 id="storage-on-the-gpu"><a class="header" href="#storage-on-the-gpu">Storage on the GPU</a></h3>
<p>There are several ways to [<strong>store a tensor on the GPU.</strong>]
For example, we can specify a storage device when creating a tensor.
Next, we create the tensor variable <code>X</code> on the first <code>gpu</code>.
The tensor created on a GPU only consumes the memory of this GPU.
We can use the <code>nvidia-smi</code> command to view GPU memory usage.
In general, we need to make sure that we do not create data that exceeds the GPU memory limit.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
X = np.ones((2, 3), ctx=try_gpu())
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
X = torch.ones(2, 3, device=try_gpu())
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with try_gpu():
    X = tf.ones((2, 3))
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# By default JAX puts arrays to GPUs or TPUs if available
X = jax.device_put(jnp.ones((2, 3)), try_gpu())
X
</code></pre>
<p>Assuming that you have at least two GPUs, the following code will (<strong>create a random tensor, <code>Y</code>, on the second GPU.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
Y = np.random.uniform(size=(2, 3), ctx=try_gpu(1))
Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Y = torch.rand(2, 3, device=try_gpu(1))
Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with try_gpu(1):
    Y = tf.random.uniform((2, 3))
Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Y = jax.device_put(jax.random.uniform(jax.random.PRNGKey(0), (2, 3)),
                   try_gpu(1))
Y
</code></pre>
<h3 id="copying"><a class="header" href="#copying">Copying</a></h3>
<p>[<strong>If we want to compute <code>X + Y</code>,
we need to decide where to perform this operation.</strong>]
For instance, as shown in :numref:<code>fig_copyto</code>,
we can transfer <code>X</code> to the second GPU
and perform the operation there.
<em>Do not</em> simply add <code>X</code> and <code>Y</code>,
since this will result in an exception.
The runtime engine would not know what to do:
it cannot find data on the same device and it fails.
Since <code>Y</code> lives on the second GPU,
we need to move <code>X</code> there before we can add the two.</p>
<p><img src="chapter_builders-guide/../img/copyto.svg" alt="Copy data to perform an operation on the same device." />
:label:<code>fig_copyto</code></p>
<pre><code class="language-{.python .input}">%%tab mxnet
Z = X.copyto(try_gpu(1))
print(X)
print(Z)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Z = X.cuda(1)
print(X)
print(Z)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with try_gpu(1):
    Z = X
print(X)
print(Z)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Z = jax.device_put(X, try_gpu(1))
print(X)
print(Z)
</code></pre>
<p>Now that [<strong>the data (both <code>Z</code> and <code>Y</code>) are on the same GPU), we can add them up.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
Y + Z
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Imagine that your variable <code>Z</code> already lives on your second GPU.
What happens if we still call  <code>Z.copyto(gpu(1))</code>?
It will make a copy and allocate new memory,
even though that variable already lives on the desired device.
There are times where, depending on the environment our code is running in,
two variables may already live on the same device.
So we want to make a copy only if the variables
currently live in different devices.
In these cases, we can call <code>as_in_ctx</code>.
If the variable already live in the specified device
then this is a no-op.
Unless you specifically want to make a copy,
<code>as_in_ctx</code> is the method of choice.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
But what if your variable <code>Z</code> already lived on your second GPU?
What happens if we still call <code>Z.cuda(1)</code>?
It will return <code>Z</code> instead of making a copy and allocating new memory.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Imagine that your variable <code>Z</code> already lives on your second GPU.
What happens if we still call <code>Z2 = Z</code> under the same device scope?
It will return <code>Z</code> instead of making a copy and allocating new memory.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Imagine that your variable <code>Z</code> already lives on your second GPU.
What happens if we still call <code>Z2 = Z</code> under the same device scope?
It will return <code>Z</code> instead of making a copy and allocating new memory.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
Z.as_in_ctx(try_gpu(1)) is Z
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Z.cuda(1) is Z
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
with try_gpu(1):
    Z2 = Z
Z2 is Z
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Z2 = jax.device_put(Z, try_gpu(1))
Z2 is Z
</code></pre>
<h3 id="side-notes"><a class="header" href="#side-notes">Side Notes</a></h3>
<p>People use GPUs to do machine learning
because they expect them to be fast.
But transferring variables between devices is slow: much slower than computation.
So we want you to be 100% certain
that you want to do something slow before we let you do it.
If the deep learning framework just did the copy automatically
without crashing then you might not realize
that you had written some slow code.</p>
<p>Transferring data is not only slow, it also makes parallelization a lot more difficult,
since we have to wait for data to be sent (or rather to be received)
before we can proceed with more operations.
This is why copy operations should be taken with great care.
As a rule of thumb, many small operations
are much worse than one big operation.
Moreover, several operations at a time
are much better than many single operations interspersed in the code
unless you know what you are doing.
This is the case since such operations can block if one device
has to wait for the other before it can do something else.
It is a bit like ordering your coffee in a queue
rather than pre-ordering it by phone
and finding out that it is ready when you are.</p>
<p>Last, when we print tensors or convert tensors to the NumPy format,
if the data is not in the main memory,
the framework will copy it to the main memory first,
resulting in additional transmission overhead.
Even worse, it is now subject to the dreaded global interpreter lock
that makes everything wait for Python to complete.</p>
<h2 id="neural-networks-and-gpus"><a class="header" href="#neural-networks-and-gpus">[<strong>Neural Networks and GPUs</strong>]</a></h2>
<p>Similarly, a neural network model can specify devices.
The following code puts the model parameters on the GPU.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net = nn.Sequential()
net.add(nn.Dense(1))
net.initialize(ctx=try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net = nn.Sequential(nn.LazyLinear(1))
net = net.to(device=try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
strategy = tf.distribute.MirroredStrategy()
with strategy.scope():
    net = tf.keras.models.Sequential([
        tf.keras.layers.Dense(1)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net = nn.Sequential([nn.Dense(1)])

key1, key2 = jax.random.split(jax.random.PRNGKey(0))
x = jax.random.normal(key1, (10,))  # Dummy input
params = net.init(key2, x)  # Initialization call
</code></pre>
<p>We will see many more examples of
how to run models on GPUs in the following chapters,
simply because the models will become somewhat more computationally intensive.</p>
<p>For example, when the input is a tensor on the GPU, the model will calculate the result on the same GPU.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, tensorflow
net(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
net.apply(params, x)
</code></pre>
<p>Let's (<strong>confirm that the model parameters are stored on the same GPU.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
net[0].weight.data().ctx
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
net[0].weight.data.device
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
net.layers[0].weights[0].device, net.layers[0].weights[1].device
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
print(jax.tree_util.tree_map(lambda x: x.device(), params))
</code></pre>
<p>Let the trainer support GPU.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(d2l.Module)  #@save
def set_scratch_params_device(self, device):
    for attr in dir(self):
        a = getattr(self, attr)
        if isinstance(a, np.ndarray):
            with autograd.record():
                setattr(self, attr, a.as_in_ctx(device))
            getattr(self, attr).attach_grad()
        if isinstance(a, d2l.Module):
            a.set_scratch_params_device(device)
        if isinstance(a, list):
            for elem in a:
                elem.set_scratch_params_device(device)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
@d2l.add_to_class(d2l.Trainer)  #@save
def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0):
    self.save_hyperparameters()
    self.gpus = [d2l.gpu(i) for i in range(min(num_gpus, d2l.num_gpus()))]

@d2l.add_to_class(d2l.Trainer)  #@save
def prepare_batch(self, batch):
    if self.gpus:
        batch = [d2l.to(a, self.gpus[0]) for a in batch]
    return batch

@d2l.add_to_class(d2l.Trainer)  #@save
def prepare_model(self, model):
    model.trainer = self
    model.board.xlim = [0, self.max_epochs]
    if self.gpus:
        if tab.selected('mxnet'):
            model.collect_params().reset_ctx(self.gpus[0])
            model.set_scratch_params_device(self.gpus[0])
        if tab.selected('pytorch'):
            model.to(self.gpus[0])
    self.model = model
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Trainer)  #@save
def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0):
    self.save_hyperparameters()
    self.gpus = [d2l.gpu(i) for i in range(min(num_gpus, d2l.num_gpus()))]

@d2l.add_to_class(d2l.Trainer)  #@save
def prepare_batch(self, batch):
    if self.gpus:
        batch = [d2l.to(a, self.gpus[0]) for a in batch]
    return batch
</code></pre>
<p>In short, as long as all data and parameters are on the same device, we can learn models efficiently. In the following chapters we will see several such examples.</p>
<h2 id="summary-27"><a class="header" href="#summary-27">Summary</a></h2>
<p>We can specify devices for storage and calculation, such as the CPU or GPU.
By default, data is created in the main memory
and then uses the CPU for calculations.
The deep learning framework requires all input data for calculation
to be on the same device,
be it CPU or the same GPU.
You can lose significant performance by moving data without care.
A typical mistake is as follows: computing the loss
for every minibatch on the GPU and reporting it back
to the user on the command line (or logging it in a NumPy <code>ndarray</code>)
will trigger a global interpreter lock which stalls all GPUs.
It is much better to allocate memory
for logging inside the GPU and only move larger logs.</p>
<h2 id="exercises-35"><a class="header" href="#exercises-35">Exercises</a></h2>
<ol>
<li>Try a larger computation task, such as the multiplication of large matrices,
and see the difference in speed between the CPU and GPU.
What about a task with a small number of calculations?</li>
<li>How should we read and write model parameters on the GPU?</li>
<li>Measure the time it takes to compute 1000
matrix--matrix multiplications of $100 \times 100$ matrices
and log the Frobenius norm of the output matrix one result at a time. Compare it with keeping a log on the GPU and transferring only the final result.</li>
<li>Measure how much time it takes to perform two matrix--matrix multiplications
on two GPUs at the same time. Compare it with computing in in sequence
on one GPU. Hint: you should see almost linear scaling.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/62">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/63">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/270">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17995">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolutional-neural-networks"><a class="header" href="#convolutional-neural-networks">Convolutional Neural Networks</a></h1>
<p>:label:<code>chap_cnn</code></p>
<p>Image data is represented as a two-dimensional grid of pixels, be the image
monochromatic or in color. Accordingly each pixel corresponds to one
or multiple numerical values respectively. So far we have ignored this rich
structure and treated images as vectors of numbers by <em>flattening</em> them, irrespective of the spatial relation between pixels. This
deeply unsatisfying approach was necessary in order to feed the
resulting one-dimensional vectors through a fully connected MLP.</p>
<p>Because these networks are invariant to the order of the features, we
could get similar results regardless of whether we preserve an order
corresponding to the spatial structure of the pixels or if we permute
the columns of our design matrix before fitting the MLP's parameters.
Ideally, we would leverage our prior knowledge that nearby pixels
are typically related to each other, to build efficient models for
learning from image data.</p>
<p>This chapter introduces <em>convolutional neural networks</em> (CNNs)
:cite:<code>LeCun.Jackel.Bottou.ea.1995</code>, a powerful family of neural networks that
are designed for precisely this purpose.
CNN-based architectures are
now ubiquitous in the field of computer vision.
For instance, on the Imagnet collection
:cite:<code>Deng.Dong.Socher.ea.2009</code> it was only the use of convolutional neural
networks, in short Convnets, that provided significant performance
improvements :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>.</p>
<p>Modern CNNs, as they are called colloquially, owe their design to
inspirations from biology, group theory, and a healthy dose of
experimental tinkering.  In addition to their sample efficiency in
achieving accurate models, CNNs tend to be computationally efficient,
both because they require fewer parameters than fully connected
architectures and because convolutions are easy to parallelize across
GPU cores :cite:<code>Chetlur.Woolley.Vandermersch.ea.2014</code>.  Consequently, practitioners often
apply CNNs whenever possible, and increasingly they have emerged as
credible competitors even on tasks with a one-dimensional sequence
structure, such as audio :cite:<code>Abdel-Hamid.Mohamed.Jiang.ea.2014</code>, text
:cite:<code>Kalchbrenner.Grefenstette.Blunsom.2014</code>, and time series analysis
:cite:<code>LeCun.Bengio.ea.1995</code>, where recurrent neural networks are
conventionally used.  Some clever adaptations of CNNs have also
brought them to bear on graph-structured data :cite:<code>Kipf.Welling.2016</code> and
in recommender systems.</p>
<p>First, we will dive more deeply into the motivation for convolutional
neural networks. This is followed by a walk through the basic operations
that comprise the backbone of all convolutional networks.
These include the convolutional layers themselves,
nitty-gritty details including padding and stride,
the pooling layers used to aggregate information
across adjacent spatial regions,
the use of multiple channels  at each layer,
and a careful discussion of the structure of modern architectures.
We will conclude the chapter with a full working example of LeNet,
the first convolutional network successfully deployed,
long before the rise of modern deep learning.
In the next chapter, we will dive into full implementations
of some popular and comparatively recent CNN architectures
whose designs represent most of the techniques
commonly used by modern practitioners.</p>
<pre><code class="language-toc">:maxdepth: 2

why-conv
conv-layer
padding-and-strides
channels
pooling
lenet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-fully-connected-layers-to-convolutions"><a class="header" href="#from-fully-connected-layers-to-convolutions">From Fully Connected Layers to Convolutions</a></h1>
<p>:label:<code>sec_why-conv</code></p>
<p>To this day,
the models that we have discussed so far
remain appropriate options
when we are dealing with tabular data.
By tabular, we mean that the data consist
of rows corresponding to examples
and columns corresponding to features.
With tabular data, we might anticipate
that the patterns we seek could involve
interactions among the features,
but we do not assume any structure <em>a priori</em>
concerning how the features interact.</p>
<p>Sometimes, we truly lack the knowledge to be able to guide the construction of fancier architectures.
In these cases, an MLP
may be the best that we can do.
However, for high-dimensional perceptual data,
such structureless networks can grow unwieldy.</p>
<p>For instance, let's return to our running example
of distinguishing cats from dogs.
Say that we do a thorough job in data collection,
collecting an annotated dataset of one-megapixel photographs.
This means that each input to the network has one million dimensions.
Even an aggressive reduction to one thousand hidden dimensions
would require a fully connected layer
characterized by $10^6 \times 10^3 = 10^9$ parameters.
Unless we have lots of GPUs, a talent
for distributed optimization,
and an extraordinary amount of patience,
learning the parameters of this network
may turn out to be infeasible.</p>
<p>A careful reader might object to this argument
on the basis that one megapixel resolution may not be necessary.
However, while we might be able
to get away with one hundred thousand pixels,
our hidden layer of size 1000 grossly underestimates
the number of hidden units that it takes
to learn good representations of images,
so a practical system will still require billions of parameters.
Moreover, learning a classifier by fitting so many parameters
might require collecting an enormous dataset.
And yet today both humans and computers are able
to distinguish cats from dogs quite well,
seemingly contradicting these intuitions.
That is because images exhibit rich structure
that can be exploited by humans
and machine learning models alike.
Convolutional neural networks (CNNs) are one creative way
that machine learning has embraced for exploiting
some of the known structure in natural images.</p>
<h2 id="invariance"><a class="header" href="#invariance">Invariance</a></h2>
<p>Imagine that we want to detect an object in an image.
It seems reasonable that whatever method
we use to recognize objects should not be overly concerned
with the precise location of the object in the image.
Ideally, our system should exploit this knowledge.
Pigs usually do not fly and planes usually do not swim.
Nonetheless, we should still recognize
a pig were one to appear at the top of the image.
We can draw some inspiration here
from the children's game "Where's Waldo"
(which itself has inspired many real-life imitations, such as that depicted in :numref:<code>img_waldo</code>).
The game consists of a number of chaotic scenes
bursting with activities.
Waldo shows up somewhere in each,
typically lurking in some unlikely location.
The reader's goal is to locate him.
Despite his characteristic outfit,
this can be surprisingly difficult,
due to the large number of distractions.
However, <em>what Waldo looks like</em>
does not depend upon <em>where Waldo is located</em>.
We could sweep the image with a Waldo detector
that could assign a score to each patch,
indicating the likelihood that the patch contains Waldo.
In fact, many object detection and segmentation algorithms
are based on this approach :cite:<code>Long.Shelhamer.Darrell.2015</code>.
CNNs systematize this idea of <em>spatial invariance</em>,
exploiting it to learn useful representations
with fewer parameters.</p>
<p><img src="chapter_convolutional-neural-networks/../img/waldo-football.jpg" alt="Can you find Waldo (image courtesy of William Murphy (Infomatique))?" />
:width:<code>400px</code>
:label:<code>img_waldo</code></p>
<p>We can now make these intuitions more concrete
by enumerating a few desiderata to guide our design
of a neural network architecture suitable for computer vision:</p>
<ol>
<li>In the earliest layers, our network
should respond similarly to the same patch,
regardless of where it appears in the image. This principle is called <em>translation invariance</em> (or <em>translation equivariance</em>).</li>
<li>The earliest layers of the network should focus on local regions,
without regard for the contents of the image in distant regions. This is the <em>locality</em> principle.
Eventually, these local representations can be aggregated
to make predictions at the whole image level.</li>
<li>As we proceed, deeper layers should be able to capture longer-range features of the
image, in a way similar to higher level vision in nature.</li>
</ol>
<p>Let's see how this translates into mathematics.</p>
<h2 id="constraining-the-mlp"><a class="header" href="#constraining-the-mlp">Constraining the MLP</a></h2>
<p>To start off, we can consider an MLP
with two-dimensional images $\mathbf{X}$ as inputs
and their immediate hidden representations
$\mathbf{H}$ similarly represented as matrices (they are two-dimensional tensors in code), where both $\mathbf{X}$ and $\mathbf{H}$ have the same shape.
Let that sink in.
We now imagine that not only the inputs but
also the hidden representations possess spatial structure.</p>
<p>Let $[\mathbf{X}]<em>{i, j}$ and $[\mathbf{H}]</em>{i, j}$ denote the pixel
at location $(i,j)$
in the input image and hidden representation, respectively.
Consequently, to have each of the hidden units
receive input from each of the input pixels,
we would switch from using weight matrices
(as we did previously in MLPs)
to representing our parameters
as fourth-order weight tensors $\mathsf{W}$.
Suppose that $\mathbf{U}$ contains biases,
we could formally express the fully connected layer as</p>
<p>$$\begin{aligned} \left[\mathbf{H}\right]<em>{i, j} &amp;= [\mathbf{U}]</em>{i, j} + \sum_k \sum_l[\mathsf{W}]<em>{i, j, k, l}  [\mathbf{X}]</em>{k, l}\ &amp;=  [\mathbf{U}]<em>{i, j} +
\sum_a \sum_b [\mathsf{V}]</em>{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}$$</p>
<p>The switch from $\mathsf{W}$ to $\mathsf{V}$ is entirely cosmetic for now
since there is a one-to-one correspondence
between coefficients in both fourth-order tensors.
We simply re-index the subscripts $(k, l)$
such that $k = i+a$ and $l = j+b$.
In other words, we set $[\mathsf{V}]<em>{i, j, a, b} = [\mathsf{W}]</em>{i, j, i+a, j+b}$.
The indices $a$ and $b$ run over both positive and negative offsets,
covering the entire image.
For any given location ($i$, $j$) in the hidden representation $[\mathbf{H}]<em>{i, j}$,
we compute its value by summing over pixels in $x$,
centered around $(i, j)$ and weighted by $[\mathsf{V}]</em>{i, j, a, b}$. Before we carry on, let's consider the total number of parameters required for a <em>single</em> layer in this parametrization: a $1000 \times 1000$ image (1 megapixel) is mapped to a $1000 \times 1000$ hidden representation. This requires $10^{12}$ parameters, far beyond what computers currently can handle.</p>
<h3 id="translation-invariance"><a class="header" href="#translation-invariance">Translation Invariance</a></h3>
<p>Now let's invoke the first principle
established above: translation invariance :cite:<code>Zhang.ea.1988</code>.
This implies that a shift in the input $\mathbf{X}$
should simply lead to a shift in the hidden representation $\mathbf{H}$.
This is only possible if $\mathsf{V}$ and $\mathbf{U}$ do not actually depend on $(i, j)$. As such,
we have $[\mathsf{V}]<em>{i, j, a, b} = [\mathbf{V}]</em>{a, b}$ and $\mathbf{U}$ is a constant, say $u$.
As a result, we can simplify the definition for $\mathbf{H}$:</p>
<p>$$[\mathbf{H}]<em>{i, j} = u + \sum_a\sum_b [\mathbf{V}]</em>{a, b}  [\mathbf{X}]_{i+a, j+b}.$$</p>
<p>This is a <em>convolution</em>!
We are effectively weighting pixels at $(i+a, j+b)$
in the vicinity of location $(i, j)$ with coefficients $[\mathbf{V}]<em>{a, b}$
to obtain the value $[\mathbf{H}]</em>{i, j}$.
Note that $[\mathbf{V}]<em>{a, b}$ needs many fewer coefficients than $[\mathsf{V}]</em>{i, j, a, b}$ since it
no longer depends on the location within the image. Consequently, the number of parameters required is no longer $10^{12}$ but a much more reasonable $4 \times 10^6$: we still have the dependency on $a, b \in (-1000, 1000)$. In short, we have made significant progress. Time-delay neural networks (TDNNs) are some of the first examples to exploit this idea :cite:<code>Waibel.Hanazawa.Hinton.ea.1989</code>.</p>
<h3 id="locality"><a class="header" href="#locality">Locality</a></h3>
<p>Now let's invoke the second principle: locality.
As motivated above, we believe that we should not have
to look very far away from location $(i, j)$
in order to glean relevant information
to assess what is going on at $[\mathbf{H}]<em>{i, j}$.
This means that outside some range $|a|&gt; \Delta$ or $|b| &gt; \Delta$,
we should set $[\mathbf{V}]</em>{a, b} = 0$.
Equivalently, we can rewrite $[\mathbf{H}]_{i, j}$ as</p>
<p>$$[\mathbf{H}]<em>{i, j} = u + \sum</em>{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]<em>{a, b}  [\mathbf{X}]</em>{i+a, j+b}.$$
:eqlabel:<code>eq_conv-layer</code></p>
<p>This reduces the number of parameters from $4 \times 10^6$ to $4 \Delta^2$, where $\Delta$ is typically smaller than $10$. As such, we reduced the number of parameters by another four orders of magnitude. Note that :eqref:<code>eq_conv-layer</code>, is what is called, in a nutshell, a <em>convolutional layer</em>.
<em>Convolutional neural networks</em> (CNNs)
are a special family of neural networks that contain convolutional layers.
In the deep learning research community,
$\mathbf{V}$ is referred to as a <em>convolution kernel</em>,
a <em>filter</em>, or simply the layer's <em>weights</em> that are learnable parameters.</p>
<p>While previously, we might have required billions of parameters
to represent just a single layer in an image-processing network,
we now typically need just a few hundred, without
altering the dimensionality of either
the inputs or the hidden representations.
The price paid for this drastic reduction in parameters
is that our features are now translation invariant
and that our layer can only incorporate local information,
when determining the value of each hidden activation.
All learning depends on imposing inductive bias.
When that bias agrees with reality,
we get sample-efficient models
that generalize well to unseen data.
But of course, if those biases do not agree with reality,
e.g., if images turned out not to be translation invariant,
our models might struggle even to fit our training data.</p>
<p>This dramatic reduction in parameters brings us to our last desideratum,
namely that deeper layers should represent larger and more complex aspects
of an image. This can be achieved by interleaving nonlinearities and convolutional
layers repeatedly.</p>
<h2 id="convolutions"><a class="header" href="#convolutions">Convolutions</a></h2>
<p>Let's briefly review why :eqref:<code>eq_conv-layer</code> is called a convolution.
In mathematics, the <em>convolution</em> between two functions :cite:<code>Rudin.1973</code>,
say $f, g: \mathbb{R}^d \to \mathbb{R}$ is defined as</p>
<p>$$(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}.$$</p>
<p>That is, we measure the overlap between $f$ and $g$
when one function is "flipped" and shifted by $\mathbf{x}$.
Whenever we have discrete objects, the integral turns into a sum.
For instance, for vectors from
the set of square-summable infinite-dimensional vectors
with index running over $\mathbb{Z}$ we obtain the following definition:</p>
<p>$$(f * g)(i) = \sum_a f(a) g(i-a).$$</p>
<p>For two-dimensional tensors, we have a corresponding sum
with indices $(a, b)$ for $f$ and $(i-a, j-b)$ for $g$, respectively:</p>
<p>$$(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b).$$
:eqlabel:<code>eq_2d-conv-discrete</code></p>
<p>This looks similar to :eqref:<code>eq_conv-layer</code>, with one major difference.
Rather than using $(i+a, j+b)$, we are using the difference instead.
Note, though, that this distinction is mostly cosmetic
since we can always match the notation between
:eqref:<code>eq_conv-layer</code> and :eqref:<code>eq_2d-conv-discrete</code>.
Our original definition in :eqref:<code>eq_conv-layer</code> more properly
describes a <em>cross-correlation</em>.
We will come back to this in the following section.</p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>:label:<code>subsec_why-conv-channels</code></p>
<p>Returning to our Waldo detector, let's see what this looks like.
The convolutional layer picks windows of a given size
and weighs intensities according to the filter $\mathsf{V}$, as demonstrated in :numref:<code>fig_waldo_mask</code>.
We might aim to learn a model so that
wherever the "waldoness" is highest,
we should find a peak in the hidden layer representations.</p>
<p><img src="chapter_convolutional-neural-networks/../img/waldo-mask.jpg" alt="Detect Waldo (image courtesy of William Murphy (Infomatique))." />
:width:<code>400px</code>
:label:<code>fig_waldo_mask</code></p>
<p>There is just one problem with this approach.
So far, we blissfully ignored that images consist
of three channels: red, green, and blue.
In sum, images are not two-dimensional objects
but rather third-order tensors,
characterized by a height, width, and channel,
e.g., with shape $1024 \times 1024 \times 3$ pixels.
While the first two of these axes concern spatial relationships,
the third can be regarded as assigning
a multidimensional representation to each pixel location.
We thus index $\mathsf{X}$ as $[\mathsf{X}]<em>{i, j, k}$.
The convolutional filter has to adapt accordingly.
Instead of $[\mathbf{V}]</em>{a,b}$, we now have $[\mathsf{V}]_{a,b,c}$.</p>
<p>Moreover, just as our input consists of a third-order tensor,
it turns out to be a good idea to similarly formulate
our hidden representations as third-order tensors $\mathsf{H}$.
In other words, rather than just having a single hidden representation
corresponding to each spatial location,
we want an entire vector of hidden representations
corresponding to each spatial location.
We could think of the hidden representations as comprising
a number of two-dimensional grids stacked on top of each other.
As in the inputs, these are sometimes called <em>channels</em>.
They are also sometimes called <em>feature maps</em>,
as each provides a spatialized set
of learned features for the subsequent layer.
Intuitively, you might imagine that at lower layers that are closer to inputs,
some channels could become specialized to recognize edges while
others could recognize textures.</p>
<p>To support multiple channels in both inputs ($\mathsf{X}$) and hidden representations ($\mathsf{H}$),
we can add a fourth coordinate to $\mathsf{V}$: $[\mathsf{V}]_{a, b, c, d}$.
Putting everything together we have:</p>
<p>$$[\mathsf{H}]<em>{i,j,d} = \sum</em>{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]<em>{a, b, c, d} [\mathsf{X}]</em>{i+a, j+b, c},$$
:eqlabel:<code>eq_conv-layer-channels</code></p>
<p>where $d$ indexes the output channels in the hidden representations $\mathsf{H}$. The subsequent convolutional layer will go on to take a third-order tensor, $\mathsf{H}$, as input.
We take
:eqref:<code>eq_conv-layer-channels</code>,
because of its generality, as
the definition of a convolutional layer for multiple channels, where $\mathsf{V}$ is a kernel or filter of the layer.</p>
<p>There are still many operations that we need to address.
For instance, we need to figure out how to combine all the hidden representations
to a single output, e.g., whether there is a Waldo <em>anywhere</em> in the image.
We also need to decide how to compute things efficiently,
how to combine multiple layers,
appropriate activation functions,
and how to make reasonable design choices
to yield networks that are effective in practice.
We turn to these issues in the remainder of the chapter.</p>
<h2 id="summary-and-discussion-3"><a class="header" href="#summary-and-discussion-3">Summary and Discussion</a></h2>
<p>In this section we derived the structure of convolutional neural networks from first principles. While it is unclear whether this was the route taken to the invention of CNNs, it is satisfying to know that they are the <em>right</em> choice when applying reasonable principles to how image processing and computer vision algorithms should operate, at least at lower levels. In particular, translation invariance in images implies that all patches of an image will be treated in the same manner. Locality means that only a small neighborhood of pixels will be used to compute the corresponding hidden representations. Some of the earliest references to CNNs are in the form of the Neocognitron :cite:<code>Fukushima.1982</code>.</p>
<p>A second principle that we encountered in our reasoning is how to reduce the number of parameters in a function class without limiting its expressive power, at least, whenever certain assumptions on the model hold. We saw a dramatic reduction of complexity as a result of this restriction, turning computationally and statistically infeasible problems into tractable models.</p>
<p>Adding channels allowed us to bring back some of the complexity that was lost due to the restrictions imposed on the convolutional kernel by locality and translation invariance. Note that it is quite natural to add channels other than just red, green, and blue. Many satellite
images, in particular for agriculture and meteorology, have tens to hundreds of channels,
generating hyperspectral images instead. They report data on many different wavelengths. In the following we will see how to use convolutions effectively to manipulate the dimensionality of the images they operate on, how to move from location-based to channel-based representations, and how to deal with large numbers of categories efficiently.</p>
<h2 id="exercises-36"><a class="header" href="#exercises-36">Exercises</a></h2>
<ol>
<li>Assume that the size of the convolution kernel is $\Delta = 0$.
Show that in this case the convolution kernel
implements an MLP independently for each set of channels. This leads to the Network in Network
architectures :cite:<code>Lin.Chen.Yan.2013</code>.</li>
<li>Audio data is often represented as a one-dimensional sequence.
<ol>
<li>When might you want to impose locality and translation invariance for audio?</li>
<li>Derive the convolution operations for audio.</li>
<li>Can you treat audio using the same tools as computer vision? Hint: use the spectrogram.</li>
</ol>
</li>
<li>Why might translation invariance not be a good idea after all? Give an example.</li>
<li>Do you think that convolutional layers might also be applicable for text data?
Which problems might you encounter with language?</li>
<li>What happens with convolutions when an object is at the boundary of an image?</li>
<li>Prove that the convolution is symmetric, i.e., $f * g = g * f$.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/64">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="convolutions-for-images"><a class="header" href="#convolutions-for-images">Convolutions for Images</a></h1>
<p>:label:<code>sec_conv_layer</code></p>
<p>Now that we understand how convolutional layers work in theory,
we are ready to see how they work in practice.
Building on our motivation of convolutional neural networks
as efficient architectures for exploring structure in image data,
we stick with images as our running example.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<h2 id="the-cross-correlation-operation"><a class="header" href="#the-cross-correlation-operation">The Cross-Correlation Operation</a></h2>
<p>Recall that strictly speaking, convolutional layers
are a  misnomer, since the operations they express
are more accurately described as cross-correlations.
Based on our descriptions of convolutional layers in :numref:<code>sec_why-conv</code>,
in such a layer, an input tensor
and a kernel tensor are combined
to produce an output tensor through a (<strong>cross-correlation operation.</strong>)</p>
<p>Let's ignore channels for now and see how this works
with two-dimensional data and hidden representations.
In :numref:<code>fig_correlation</code>,
the input is a two-dimensional tensor
with a height of 3 and width of 3.
We mark the shape of the tensor as $3 \times 3$ or ($3$, $3$).
The height and width of the kernel are both 2.
The shape of the <em>kernel window</em> (or <em>convolution window</em>)
is given by the height and width of the kernel
(here it is $2 \times 2$).</p>
<p><img src="chapter_convolutional-neural-networks/../img/correlation.svg" alt="Two-dimensional cross-correlation operation. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: $0\times0+1\times1+3\times2+4\times3=19$." />
:label:<code>fig_correlation</code></p>
<p>In the two-dimensional cross-correlation operation,
we begin with the convolution window positioned
at the upper-left corner of the input tensor
and slide it across the input tensor,
both from left to right and top to bottom.
When the convolution window slides to a certain position,
the input subtensor contained in that window
and the kernel tensor are multiplied elementwise
and the resulting tensor is summed up
yielding a single scalar value.
This result gives the value of the output tensor
at the corresponding location.
Here, the output tensor has a height of 2 and width of 2
and the four elements are derived from
the two-dimensional cross-correlation operation:</p>
<p>$$
0\times0+1\times1+3\times2+4\times3=19,\
1\times0+2\times1+4\times2+5\times3=25,\
3\times0+4\times1+6\times2+7\times3=37,\
4\times0+5\times1+7\times2+8\times3=43.
$$</p>
<p>Note that along each axis, the output size
is slightly smaller than the input size.
Because the kernel has width and height greater than $1$,
we can only properly compute the cross-correlation
for locations where the kernel fits wholly within the image,
the output size is given by the input size $n_\textrm{h} \times n_\textrm{w}$
minus the size of the convolution kernel $k_\textrm{h} \times k_\textrm{w}$
via</p>
<p>$$(n_\textrm{h}-k_\textrm{h}+1) \times (n_\textrm{w}-k_\textrm{w}+1).$$</p>
<p>This is the case since we need enough space
to "shift" the convolution kernel across the image.
Later we will see how to keep the size unchanged
by padding the image with zeros around its boundary
so that there is enough space to shift the kernel.
Next, we implement this process in the <code>corr2d</code> function,
which accepts an input tensor <code>X</code> and a kernel tensor <code>K</code>
and returns an output tensor <code>Y</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def corr2d(X, K):  #@save
    """Compute 2D cross-correlation."""
    h, w = K.shape
    Y = d2l.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = d2l.reduce_sum((X[i: i + h, j: j + w] * K))
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def corr2d(X, K):  #@save
    """Compute 2D cross-correlation."""
    h, w = K.shape
    Y = d2l.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = d2l.reduce_sum((X[i: i + h, j: j + w] * K))
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def corr2d(X, K):  #@save
    """Compute 2D cross-correlation."""
    h, w = K.shape
    Y = jnp.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y = Y.at[i, j].set((X[i:i + h, j:j + w] * K).sum())
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def corr2d(X, K):  #@save
    """Compute 2D cross-correlation."""
    h, w = K.shape
    Y = tf.Variable(tf.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j].assign(tf.reduce_sum(
                X[i: i + h, j: j + w] * K))
    return Y
</code></pre>
<p>We can construct the input tensor <code>X</code> and the kernel tensor <code>K</code>
from :numref:<code>fig_correlation</code>
to [<strong>validate the output of the above implementation</strong>]
of the two-dimensional cross-correlation operation.</p>
<pre><code class="language-{.python .input}">%%tab all
X = d2l.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])
K = d2l.tensor([[0.0, 1.0], [2.0, 3.0]])
corr2d(X, K)
</code></pre>
<h2 id="convolutional-layers"><a class="header" href="#convolutional-layers">Convolutional Layers</a></h2>
<p>A convolutional layer cross-correlates the input and kernel
and adds a scalar bias to produce an output.
The two parameters of a convolutional layer
are the kernel and the scalar bias.
When training models based on convolutional layers,
we typically initialize the kernels randomly,
just as we would with a fully connected layer.</p>
<p>We are now ready to [<strong>implement a two-dimensional convolutional layer</strong>]
based on the <code>corr2d</code> function defined above.
In the <code>__init__</code> constructor method,
we declare <code>weight</code> and <code>bias</code> as the two model parameters.
The forward propagation method
calls the <code>corr2d</code> function and adds the bias.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Conv2D(nn.Block):
    def __init__(self, kernel_size, **kwargs):
        super().__init__(**kwargs)
        self.weight = self.params.get('weight', shape=kernel_size)
        self.bias = self.params.get('bias', shape=(1,))

    def forward(self, x):
        return corr2d(x, self.weight.data()) + self.bias.data()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Conv2D(nn.Module):
    def __init__(self, kernel_size):
        super().__init__()
        self.weight = nn.Parameter(torch.rand(kernel_size))
        self.bias = nn.Parameter(torch.zeros(1))

    def forward(self, x):
        return corr2d(x, self.weight) + self.bias
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Conv2D(tf.keras.layers.Layer):
    def __init__(self):
        super().__init__()

    def build(self, kernel_size):
        initializer = tf.random_normal_initializer()
        self.weight = self.add_weight(name='w', shape=kernel_size,
                                      initializer=initializer)
        self.bias = self.add_weight(name='b', shape=(1, ),
                                    initializer=initializer)

    def call(self, inputs):
        return corr2d(inputs, self.weight) + self.bias
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Conv2D(nn.Module):
    kernel_size: int

    def setup(self):
        self.weight = nn.param('w', nn.initializers.uniform, self.kernel_size)
        self.bias = nn.param('b', nn.initializers.zeros, 1)

    def forward(self, x):
        return corr2d(x, self.weight) + self.bias
</code></pre>
<p>In
$h \times w$ convolution
or an $h \times w$ convolution kernel,
the height and width of the convolution kernel are $h$ and $w$, respectively.
We also refer to
a convolutional layer with an $h \times w$
convolution kernel simply as an $h \times w$ convolutional layer.</p>
<h2 id="object-edge-detection-in-images"><a class="header" href="#object-edge-detection-in-images">Object Edge Detection in Images</a></h2>
<p>Let's take a moment to parse [<strong>a simple application of a convolutional layer:
detecting the edge of an object in an image</strong>]
by finding the location of the pixel change.
First, we construct an "image" of $6\times 8$ pixels.
The middle four columns are black ($0$) and the rest are white ($1$).</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X = d2l.ones((6, 8))
X[:, 2:6] = 0
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = tf.Variable(tf.ones((6, 8)))
X[:, 2:6].assign(tf.zeros(X[:, 2:6].shape))
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = jnp.ones((6, 8))
X = X.at[:, 2:6].set(0)
X
</code></pre>
<p>Next, we construct a kernel <code>K</code> with a height of 1 and a width of 2.
When we perform the cross-correlation operation with the input,
if the horizontally adjacent elements are the same,
the output is 0. Otherwise, the output is nonzero.
Note that this kernel is a special case of a finite difference operator. At location $(i,j)$ it computes $x_{i,j} - x_{(i+1),j}$, i.e., it computes the difference between the values of horizontally adjacent pixels. This is a discrete approximation of the first derivative in the horizontal direction. After all, for a function $f(i,j)$ its derivative $-\partial_i f(i,j) = \lim_{\epsilon \to 0} \frac{f(i,j) - f(i+\epsilon,j)}{\epsilon}$. Let's see how this works in practice.</p>
<pre><code class="language-{.python .input}">%%tab all
K = d2l.tensor([[1.0, -1.0]])
</code></pre>
<p>We are ready to perform the cross-correlation operation
with arguments <code>X</code> (our input) and <code>K</code> (our kernel).
As you can see, [<strong>we detect $1$ for the edge from white to black
and $-1$ for the edge from black to white.</strong>]
All other outputs take value $0$.</p>
<pre><code class="language-{.python .input}">%%tab all
Y = corr2d(X, K)
Y
</code></pre>
<p>We can now apply the kernel to the transposed image.
As expected, it vanishes. [<strong>The kernel <code>K</code> only detects vertical edges.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
corr2d(d2l.transpose(X), K)
</code></pre>
<h2 id="learning-a-kernel"><a class="header" href="#learning-a-kernel">Learning a Kernel</a></h2>
<p>Designing an edge detector by finite differences <code>[1, -1]</code> is neat
if we know this is precisely what we are looking for.
However, as we look at larger kernels,
and consider successive layers of convolutions,
it might be impossible to specify
precisely what each filter should be doing manually.</p>
<p>Now let's see whether we can [<strong>learn the kernel that generated <code>Y</code> from <code>X</code></strong>]
by looking at the input--output pairs only.
We first construct a convolutional layer
and initialize its kernel as a random tensor.
Next, in each iteration, we will use the squared error
to compare <code>Y</code> with the output of the convolutional layer.
We can then calculate the gradient to update the kernel.
For the sake of simplicity,
in the following
we use the built-in class
for two-dimensional convolutional layers
and ignore the bias.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
# Construct a two-dimensional convolutional layer with 1 output channel and a
# kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here
conv2d = nn.Conv2D(1, kernel_size=(1, 2), use_bias=False)
conv2d.initialize()

# The two-dimensional convolutional layer uses four-dimensional input and
# output in the format of (example, channel, height, width), where the batch
# size (number of examples in the batch) and the number of channels are both 1
X = X.reshape(1, 1, 6, 8)
Y = Y.reshape(1, 1, 6, 7)
lr = 3e-2  # Learning rate

for i in range(10):
    with autograd.record():
        Y_hat = conv2d(X)
        l = (Y_hat - Y) ** 2
    l.backward()
    # Update the kernel
    conv2d.weight.data()[:] -= lr * conv2d.weight.grad()
    if (i + 1) % 2 == 0:
        print(f'epoch {i + 1}, loss {float(l.sum()):.3f}')
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# Construct a two-dimensional convolutional layer with 1 output channel and a
# kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here
conv2d = nn.LazyConv2d(1, kernel_size=(1, 2), bias=False)

# The two-dimensional convolutional layer uses four-dimensional input and
# output in the format of (example, channel, height, width), where the batch
# size (number of examples in the batch) and the number of channels are both 1
X = X.reshape((1, 1, 6, 8))
Y = Y.reshape((1, 1, 6, 7))
lr = 3e-2  # Learning rate

for i in range(10):
    Y_hat = conv2d(X)
    l = (Y_hat - Y) ** 2
    conv2d.zero_grad()
    l.sum().backward()
    # Update the kernel
    conv2d.weight.data[:] -= lr * conv2d.weight.grad
    if (i + 1) % 2 == 0:
        print(f'epoch {i + 1}, loss {l.sum():.3f}')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# Construct a two-dimensional convolutional layer with 1 output channel and a
# kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here
conv2d = tf.keras.layers.Conv2D(1, (1, 2), use_bias=False)

# The two-dimensional convolutional layer uses four-dimensional input and
# output in the format of (example, height, width, channel), where the batch
# size (number of examples in the batch) and the number of channels are both 1
X = tf.reshape(X, (1, 6, 8, 1))
Y = tf.reshape(Y, (1, 6, 7, 1))
lr = 3e-2  # Learning rate

Y_hat = conv2d(X)
for i in range(10):
    with tf.GradientTape(watch_accessed_variables=False) as g:
        g.watch(conv2d.weights[0])
        Y_hat = conv2d(X)
        l = (abs(Y_hat - Y)) ** 2
        # Update the kernel
        update = tf.multiply(lr, g.gradient(l, conv2d.weights[0]))
        weights = conv2d.get_weights()
        weights[0] = conv2d.weights[0] - update
        conv2d.set_weights(weights)
        if (i + 1) % 2 == 0:
            print(f'epoch {i + 1}, loss {tf.reduce_sum(l):.3f}')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# Construct a two-dimensional convolutional layer with 1 output channel and a
# kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here
conv2d = nn.Conv(1, kernel_size=(1, 2), use_bias=False, padding='VALID')

# The two-dimensional convolutional layer uses four-dimensional input and
# output in the format of (example, height, width, channel), where the batch
# size (number of examples in the batch) and the number of channels are both 1
X = X.reshape((1, 6, 8, 1))
Y = Y.reshape((1, 6, 7, 1))
lr = 3e-2  # Learning rate

params = conv2d.init(jax.random.PRNGKey(d2l.get_seed()), X)

def loss(params, X, Y):
    Y_hat = conv2d.apply(params, X)
    return ((Y_hat - Y) ** 2).sum()

for i in range(10):
    l, grads = jax.value_and_grad(loss)(params, X, Y)
    # Update the kernel
    params = jax.tree_map(lambda p, g: p - lr * g, params, grads)
    if (i + 1) % 2 == 0:
        print(f'epoch {i + 1}, loss {l:.3f}')
</code></pre>
<p>Note that the error has dropped to a small value after 10 iterations. Now we will [<strong>take a look at the kernel tensor we learned.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
d2l.reshape(conv2d.weight.data(), (1, 2))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
d2l.reshape(conv2d.weight.data, (1, 2))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
d2l.reshape(conv2d.get_weights()[0], (1, 2))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
params['params']['kernel'].reshape((1, 2))
</code></pre>
<p>Indeed, the learned kernel tensor is remarkably close
to the kernel tensor <code>K</code> we defined earlier.</p>
<h2 id="cross-correlation-and-convolution"><a class="header" href="#cross-correlation-and-convolution">Cross-Correlation and Convolution</a></h2>
<p>Recall our observation from :numref:<code>sec_why-conv</code> of the correspondence
between the cross-correlation and convolution operations.
Here let's continue to consider two-dimensional convolutional layers.
What if such layers
perform strict convolution operations
as defined in :eqref:<code>eq_2d-conv-discrete</code>
instead of cross-correlations?
In order to obtain the output of the strict <em>convolution</em> operation, we only need to flip the two-dimensional kernel tensor both horizontally and vertically, and then perform the <em>cross-correlation</em> operation with the input tensor.</p>
<p>It is noteworthy that since kernels are learned from data in deep learning,
the outputs of convolutional layers remain unaffected
no matter such layers
perform
either the strict convolution operations
or the cross-correlation operations.</p>
<p>To illustrate this, suppose that a convolutional layer performs <em>cross-correlation</em> and learns the kernel in :numref:<code>fig_correlation</code>, which is here denoted as the matrix $\mathbf{K}$.
Assuming that other conditions remain unchanged,
when this layer instead performs strict <em>convolution</em>,
the learned kernel $\mathbf{K}'$ will be the same as $\mathbf{K}$
after $\mathbf{K}'$ is
flipped both horizontally and vertically.
That is to say,
when the convolutional layer
performs strict <em>convolution</em>
for the input in :numref:<code>fig_correlation</code>
and $\mathbf{K}'$,
the same output in :numref:<code>fig_correlation</code>
(cross-correlation of the input and $\mathbf{K}$)
will be obtained.</p>
<p>In keeping with standard terminology in deep learning literature,
we will continue to refer to the cross-correlation operation
as a convolution even though, strictly-speaking, it is slightly different.
Furthermore,
we use the term <em>element</em> to refer to
an entry (or component) of any tensor representing a layer representation or a convolution kernel.</p>
<h2 id="feature-map-and-receptive-field"><a class="header" href="#feature-map-and-receptive-field">Feature Map and Receptive Field</a></h2>
<p>As described in :numref:<code>subsec_why-conv-channels</code>,
the convolutional layer output in
:numref:<code>fig_correlation</code>
is sometimes called a <em>feature map</em>,
as it can be regarded as
the learned representations (features)
in the spatial dimensions (e.g., width and height)
to the subsequent layer.
In CNNs,
for any element $x$ of some layer,
its <em>receptive field</em> refers to
all the elements (from all the previous layers)
that may affect the calculation of $x$
during the forward propagation.
Note that the receptive field
may be larger than the actual size of the input.</p>
<p>Let's continue to use :numref:<code>fig_correlation</code> to explain the receptive field.
Given the $2 \times 2$ convolution kernel,
the receptive field of the shaded output element (of value $19$)
is
the four elements in the shaded portion of the input.
Now let's denote the $2 \times 2$
output as $\mathbf{Y}$
and consider a deeper CNN
with an additional $2 \times 2$ convolutional layer that takes $\mathbf{Y}$
as its input, outputting
a single element $z$.
In this case,
the receptive field of $z$
on $\mathbf{Y}$ includes all the four elements of $\mathbf{Y}$,
while
the receptive field
on the input includes all the nine input elements.
Thus,
when any element in a feature map
needs a larger receptive field
to detect input features over a broader area,
we can build a deeper network.</p>
<p>Receptive fields derive their name from neurophysiology.
A series of experiments on a range of animals using different stimuli
:cite:<code>Hubel.Wiesel.1959,Hubel.Wiesel.1962,Hubel.Wiesel.1968</code> explored the response of what is called the visual
cortex on said stimuli. By and large they found that lower levels respond to edges and related
shapes. Later on, :citet:<code>Field.1987</code> illustrated this effect on natural
images with, what can only be called, convolutional kernels.
We reprint a key figure in :numref:<code>field_visual</code> to illustrate the striking similarities.</p>
<p><img src="chapter_convolutional-neural-networks/../img/field-visual.png" alt="Figure and caption taken from :citet:Field.1987: An example of coding with six different channels. (Left) Examples of the six types of sensor associated with each channel. (Right) Convolution of the image in (Middle) with the six sensors shown in (Left). The response of the individual sensors is determined by sampling these filtered images at a distance proportional to the size of the sensor (shown with dots). This diagram shows the response of only the even symmetric sensors." />
:label:<code>field_visual</code></p>
<p>As it turns out, this relation even holds for the features computed by deeper layers of networks trained on image classification tasks, as demonstrated in, for example, :citet:<code>Kuzovkin.Vicente.Petton.ea.2018</code>. Suffice it to say, convolutions have proven to be an incredibly powerful tool for computer vision, both in biology and in code. As such, it is not surprising (in hindsight) that they heralded the recent success in deep learning.</p>
<h2 id="summary-28"><a class="header" href="#summary-28">Summary</a></h2>
<p>The core computation required for a convolutional layer is a cross-correlation operation. We saw that a simple nested for-loop is all that is required to compute its value. If we have multiple input and multiple output channels, we are  performing a matrix--matrix operation between channels. As can be seen, the computation is straightforward and, most importantly, highly <em>local</em>. This affords significant hardware optimization and many recent results in computer vision are only possible because of that. After all, it means that chip designers can invest in fast computation rather than memory when it comes to optimizing for convolutions. While this may not lead to optimal designs for other applications, it does open the door to ubiquitous and affordable computer vision.</p>
<p>In terms of convolutions themselves, they can be used for many purposes, for example detecting edges and lines, blurring images, or sharpening them. Most importantly, it is not necessary that the statistician (or engineer) invents suitable filters. Instead, we can simply <em>learn</em> them from data. This replaces feature engineering heuristics by evidence-based statistics. Lastly, and quite delightfully, these filters are not just advantageous for building deep networks but they also correspond to receptive fields and feature maps in the brain. This gives us confidence that we are on the right track.</p>
<h2 id="exercises-37"><a class="header" href="#exercises-37">Exercises</a></h2>
<ol>
<li>Construct an image <code>X</code> with diagonal edges.
<ol>
<li>What happens if you apply the kernel <code>K</code> in this section to it?</li>
<li>What happens if you transpose <code>X</code>?</li>
<li>What happens if you transpose <code>K</code>?</li>
</ol>
</li>
<li>Design some kernels manually.
<ol>
<li>Given a directional vector $\mathbf{v} = (v_1, v_2)$, derive an edge-detection kernel that detects
edges orthogonal to $\mathbf{v}$, i.e., edges in the direction $(v_2, -v_1)$.</li>
<li>Derive a finite difference operator for the second derivative. What is the minimum
size of the convolutional kernel associated with it? Which structures in images respond most strongly to it?</li>
<li>How would you design a blur kernel? Why might you want to use such a kernel?</li>
<li>What is the minimum size of a kernel to obtain a derivative of order $d$?</li>
</ol>
</li>
<li>When you try to automatically find the gradient for the <code>Conv2D</code> class we created, what kind of error message do you see?</li>
<li>How do you represent a cross-correlation operation as a matrix multiplication by changing the input and kernel tensors?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/65">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/66">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/271">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17996">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="padding-and-stride"><a class="header" href="#padding-and-stride">Padding and Stride</a></h1>
<p>:label:<code>sec_padding</code></p>
<p>Recall the example of a convolution in :numref:<code>fig_correlation</code>.
The input had both a height and width of 3
and the convolution kernel had both a height and width of 2,
yielding an output representation with dimension $2\times2$.
Assuming that the input shape is $n_\textrm{h}\times n_\textrm{w}$
and the convolution kernel shape is $k_\textrm{h}\times k_\textrm{w}$,
the output shape will be $(n_\textrm{h}-k_\textrm{h}+1) \times (n_\textrm{w}-k_\textrm{w}+1)$:
we can only shift the convolution kernel so far until it runs out
of pixels to apply the convolution to.</p>
<p>In the following we will explore a number of techniques,
including padding and strided convolutions,
that offer more control over the size of the output.
As motivation, note that since kernels generally
have width and height greater than $1$,
after applying many successive convolutions,
we tend to wind up with outputs that are
considerably smaller than our input.
If we start with a $240 \times 240$ pixel image,
ten layers of $5 \times 5$ convolutions
reduce the image to $200 \times 200$ pixels,
slicing off $30 %$ of the image and with it
obliterating any interesting information
on the boundaries of the original image.
<em>Padding</em> is the most popular tool for handling this issue.
In other cases, we may want to reduce the dimensionality drastically,
e.g., if we find the original input resolution to be unwieldy.
<em>Strided convolutions</em> are a popular technique that can help in these instances.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>As described above, one tricky issue when applying convolutional layers
is that we tend to lose pixels on the perimeter of our image. Consider :numref:<code>img_conv_reuse</code> that depicts the pixel utilization as a function of the convolution kernel size and the position within the image. The pixels in the corners are hardly used at all.</p>
<p><img src="chapter_convolutional-neural-networks/../img/conv-reuse.svg" alt="Pixel utilization for convolutions of size $1 \times 1$, $2 \times 2$, and $3 \times 3$ respectively." />
:label:<code>img_conv_reuse</code></p>
<p>Since we typically use small kernels,
for any given convolution
we might only lose a few pixels
but this can add up as we apply
many successive convolutional layers.
One straightforward solution to this problem
is to add extra pixels of filler around the boundary of our input image,
thus increasing the effective size of the image.
Typically, we set the values of the extra pixels to zero.
In :numref:<code>img_conv_pad</code>, we pad a $3 \times 3$ input,
increasing its size to $5 \times 5$.
The corresponding output then increases to a $4 \times 4$ matrix.
The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: $0\times0+0\times1+0\times2+0\times3=0$.</p>
<p><img src="chapter_convolutional-neural-networks/../img/conv-pad.svg" alt="Two-dimensional cross-correlation with padding." />
:label:<code>img_conv_pad</code></p>
<p>In general, if we add a total of $p_\textrm{h}$ rows of padding
(roughly half on top and half on bottom)
and a total of $p_\textrm{w}$ columns of padding
(roughly half on the left and half on the right),
the output shape will be</p>
<p>$$(n_\textrm{h}-k_\textrm{h}+p_\textrm{h}+1)\times(n_\textrm{w}-k_\textrm{w}+p_\textrm{w}+1).$$</p>
<p>This means that the height and width of the output
will increase by $p_\textrm{h}$ and $p_\textrm{w}$, respectively.</p>
<p>In many cases, we will want to set $p_\textrm{h}=k_\textrm{h}-1$ and $p_\textrm{w}=k_\textrm{w}-1$
to give the input and output the same height and width.
This will make it easier to predict the output shape of each layer
when constructing the network.
Assuming that $k_\textrm{h}$ is odd here,
we will pad $p_\textrm{h}/2$ rows on both sides of the height.
If $k_\textrm{h}$ is even, one possibility is to
pad $\lceil p_\textrm{h}/2\rceil$ rows on the top of the input
and $\lfloor p_\textrm{h}/2\rfloor$ rows on the bottom.
We will pad both sides of the width in the same way.</p>
<p>CNNs commonly use convolution kernels
with odd height and width values, such as 1, 3, 5, or 7.
Choosing odd kernel sizes has the benefit
that we can preserve the dimensionality
while padding with the same number of rows on top and bottom,
and the same number of columns on left and right.</p>
<p>Moreover, this practice of using odd kernels
and padding to precisely preserve dimensionality
offers a clerical benefit.
For any two-dimensional tensor <code>X</code>,
when the kernel's size is odd
and the number of padding rows and columns
on all sides are the same,
thereby producing an output with the same height and width as the input,
we know that the output <code>Y[i, j]</code> is calculated
by cross-correlation of the input and convolution kernel
with the window centered on <code>X[i, j]</code>.</p>
<p>In the following example, we create a two-dimensional convolutional layer
with a height and width of 3
and (<strong>apply 1 pixel of padding on all sides.</strong>)
Given an input with a height and width of 8,
we find that the height and width of the output is also 8.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
# We define a helper function to calculate convolutions. It initializes 
# the convolutional layer weights and performs corresponding dimensionality 
# elevations and reductions on the input and output
def comp_conv2d(conv2d, X):
    conv2d.initialize()
    # (1, 1) indicates that batch size and the number of channels are both 1
    X = X.reshape((1, 1) + X.shape)
    Y = conv2d(X)
    # Strip the first two dimensions: examples and channels
    return Y.reshape(Y.shape[2:])

# 1 row and column is padded on either side, so a total of 2 rows or columns are added
conv2d = nn.Conv2D(1, kernel_size=3, padding=1)
X = np.random.uniform(size=(8, 8))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# We define a helper function to calculate convolutions. It initializes the
# convolutional layer weights and performs corresponding dimensionality
# elevations and reductions on the input and output
def comp_conv2d(conv2d, X):
    # (1, 1) indicates that batch size and the number of channels are both 1
    X = X.reshape((1, 1) + X.shape)
    Y = conv2d(X)
    # Strip the first two dimensions: examples and channels
    return Y.reshape(Y.shape[2:])

# 1 row and column is padded on either side, so a total of 2 rows or columns
# are added
conv2d = nn.LazyConv2d(1, kernel_size=3, padding=1)
X = torch.rand(size=(8, 8))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# We define a helper function to calculate convolutions. It initializes
# the convolutional layer weights and performs corresponding dimensionality
# elevations and reductions on the input and output
def comp_conv2d(conv2d, X):
    # (1, 1) indicates that batch size and the number of channels are both 1
    X = tf.reshape(X, (1, ) + X.shape + (1, ))
    Y = conv2d(X)
    # Strip the first two dimensions: examples and channels
    return tf.reshape(Y, Y.shape[1:3])
# 1 row and column is padded on either side, so a total of 2 rows or columns
# are added
conv2d = tf.keras.layers.Conv2D(1, kernel_size=3, padding='same')
X = tf.random.uniform(shape=(8, 8))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# We define a helper function to calculate convolutions. It initializes
# the convolutional layer weights and performs corresponding dimensionality
# elevations and reductions on the input and output
def comp_conv2d(conv2d, X):
    # (1, X.shape, 1) indicates that batch size and the number of channels are both 1
    key = jax.random.PRNGKey(d2l.get_seed())
    X = X.reshape((1,) + X.shape + (1,))
    Y, _ = conv2d.init_with_output(key, X)
    # Strip the dimensions: examples and channels
    return Y.reshape(Y.shape[1:3])
# 1 row and column is padded on either side, so a total of 2 rows or columns are added
conv2d = nn.Conv(1, kernel_size=(3, 3), padding='SAME')
X = jax.random.uniform(jax.random.PRNGKey(d2l.get_seed()), shape=(8, 8))
comp_conv2d(conv2d, X).shape
</code></pre>
<p>When the height and width of the convolution kernel are different,
we can make the output and input have the same height and width
by [<strong>setting different padding numbers for height and width.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
# We use a convolution kernel with height 5 and width 3. The padding on
# either side of the height and width are 2 and 1, respectively
conv2d = nn.Conv2D(1, kernel_size=(5, 3), padding=(2, 1))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# We use a convolution kernel with height 5 and width 3. The padding on either
# side of the height and width are 2 and 1, respectively
conv2d = nn.LazyConv2d(1, kernel_size=(5, 3), padding=(2, 1))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# We use a convolution kernel with height 5 and width 3. The padding on
# either side of the height and width are 2 and 1, respectively
conv2d = tf.keras.layers.Conv2D(1, kernel_size=(5, 3), padding='same')
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# We use a convolution kernel with height 5 and width 3. The padding on
# either side of the height and width are 2 and 1, respectively
conv2d = nn.Conv(1, kernel_size=(5, 3), padding=(2, 1))
comp_conv2d(conv2d, X).shape
</code></pre>
<h2 id="stride"><a class="header" href="#stride">Stride</a></h2>
<p>When computing the cross-correlation,
we start with the convolution window
at the upper-left corner of the input tensor,
and then slide it over all locations both down and to the right.
In the previous examples, we defaulted to sliding one element at a time.
However, sometimes, either for computational efficiency
or because we wish to downsample,
we move our window more than one element at a time,
skipping the intermediate locations. This is particularly useful if the convolution
kernel is large since it captures a large area of the underlying image.</p>
<p>We refer to the number of rows and columns traversed per slide as <em>stride</em>.
So far, we have used strides of 1, both for height and width.
Sometimes, we may want to use a larger stride.
:numref:<code>img_conv_stride</code> shows a two-dimensional cross-correlation operation
with a stride of 3 vertically and 2 horizontally.
The shaded portions are the output elements as well as the input and kernel tensor elements used for the output computation: $0\times0+0\times1+1\times2+2\times3=8$, $0\times0+6\times1+0\times2+0\times3=6$.
We can see that when the second element of the first column is generated,
the convolution window slides down three rows.
The convolution window slides two columns to the right
when the second element of the first row is generated.
When the convolution window continues to slide two columns to the right on the input,
there is no output because the input element cannot fill the window
(unless we add another column of padding).</p>
<p><img src="chapter_convolutional-neural-networks/../img/conv-stride.svg" alt="Cross-correlation with strides of 3 and 2 for height and width, respectively." />
:label:<code>img_conv_stride</code></p>
<p>In general, when the stride for the height is $s_\textrm{h}$
and the stride for the width is $s_\textrm{w}$, the output shape is</p>
<p>$$\lfloor(n_\textrm{h}-k_\textrm{h}+p_\textrm{h}+s_\textrm{h})/s_\textrm{h}\rfloor \times \lfloor(n_\textrm{w}-k_\textrm{w}+p_\textrm{w}+s_\textrm{w})/s_\textrm{w}\rfloor.$$</p>
<p>If we set $p_\textrm{h}=k_\textrm{h}-1$ and $p_\textrm{w}=k_\textrm{w}-1$,
then the output shape can be simplified to
$\lfloor(n_\textrm{h}+s_\textrm{h}-1)/s_\textrm{h}\rfloor \times \lfloor(n_\textrm{w}+s_\textrm{w}-1)/s_\textrm{w}\rfloor$.
Going a step further, if the input height and width
are divisible by the strides on the height and width,
then the output shape will be $(n_\textrm{h}/s_\textrm{h}) \times (n_\textrm{w}/s_\textrm{w})$.</p>
<p>Below, we [<strong>set the strides on both the height and width to 2</strong>],
thus halving the input height and width.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
conv2d = nn.Conv2D(1, kernel_size=3, padding=1, strides=2)
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
conv2d = nn.LazyConv2d(1, kernel_size=3, padding=1, stride=2)
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
conv2d = tf.keras.layers.Conv2D(1, kernel_size=3, padding='same', strides=2)
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
conv2d = nn.Conv(1, kernel_size=(3, 3), padding=1, strides=2)
comp_conv2d(conv2d, X).shape
</code></pre>
<p>Let's look at (<strong>a slightly more complicated example</strong>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
conv2d = nn.Conv2D(1, kernel_size=(3, 5), padding=(0, 1), strides=(3, 4))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
conv2d = nn.LazyConv2d(1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
conv2d = tf.keras.layers.Conv2D(1, kernel_size=(3,5), padding='valid',
                                strides=(3, 4))
comp_conv2d(conv2d, X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
conv2d = nn.Conv(1, kernel_size=(3, 5), padding=(0, 1), strides=(3, 4))
comp_conv2d(conv2d, X).shape
</code></pre>
<h2 id="summary-and-discussion-4"><a class="header" href="#summary-and-discussion-4">Summary and Discussion</a></h2>
<p>Padding can increase the height and width of the output. This is often used to give the output the same height and width as the input to avoid undesirable shrinkage of the output. Moreover, it ensures that all pixels are used equally frequently. Typically we pick symmetric padding on both sides of the input height and width. In this case we refer to $(p_\textrm{h}, p_\textrm{w})$ padding. Most commonly we set $p_\textrm{h} = p_\textrm{w}$, in which case we simply state that we choose padding $p$.</p>
<p>A similar convention applies to strides. When horizontal stride $s_\textrm{h}$ and vertical stride $s_\textrm{w}$ match, we simply talk about stride $s$. The stride can reduce the resolution of the output, for example reducing the height and width of the output to only $1/n$ of the height and width of the input for $n &gt; 1$. By default, the padding is 0 and the stride is 1.</p>
<p>So far all padding that we discussed simply extended images with zeros. This has significant computational benefit since it is trivial to accomplish. Moreover, operators can be engineered to take advantage of this padding implicitly without the need to allocate additional memory. At the same time, it allows CNNs to encode implicit position information within an image, simply by learning where the "whitespace" is. There are many alternatives to zero-padding. :citet:<code>Alsallakh.Kokhlikyan.Miglani.ea.2020</code> provided an extensive overview of those (albeit without a clear case for when to use nonzero paddings unless artifacts occur).</p>
<h2 id="exercises-38"><a class="header" href="#exercises-38">Exercises</a></h2>
<ol>
<li>Given the final code example in this section with kernel size $(3, 5)$, padding $(0, 1)$, and stride $(3, 4)$,
calculate the output shape to check if it is consistent with the experimental result.</li>
<li>For audio signals, what does a stride of 2 correspond to?</li>
<li>Implement mirror padding, i.e., padding where the border values are simply mirrored to extend tensors.</li>
<li>What are the computational benefits of a stride larger than 1?</li>
<li>What might be statistical benefits of a stride larger than 1?</li>
<li>How would you implement a stride of $\frac{1}{2}$? What does it correspond to? When would this be useful?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/67">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/68">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/272">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17997">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="multiple-input-and-multiple-output-channels"><a class="header" href="#multiple-input-and-multiple-output-channels">Multiple Input and Multiple Output Channels</a></h1>
<p>:label:<code>sec_channels</code></p>
<p>While we described the multiple channels
that comprise each image (e.g., color images have the standard RGB channels
to indicate the amount of red, green and blue) and convolutional layers for multiple channels in :numref:<code>subsec_why-conv-channels</code>,
until now, we simplified all of our numerical examples
by working with just a single input and a single output channel.
This allowed us to think of our inputs, convolution kernels,
and outputs each as two-dimensional tensors.</p>
<p>When we add channels into the mix,
our inputs and hidden representations
both become three-dimensional tensors.
For example, each RGB input image has shape $3\times h\times w$.
We refer to this axis, with a size of 3, as the <em>channel</em> dimension. The notion of
channels is as old as CNNs themselves: for instance LeNet-5 :cite:<code>LeCun.Jackel.Bottou.ea.1995</code> uses them.
In this section, we will take a deeper look
at convolution kernels with multiple input and multiple output channels.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
import jax
from jax import numpy as jnp
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<h2 id="multiple-input-channels"><a class="header" href="#multiple-input-channels">Multiple Input Channels</a></h2>
<p>When the input data contains multiple channels,
we need to construct a convolution kernel
with the same number of input channels as the input data,
so that it can perform cross-correlation with the input data.
Assuming that the number of channels for the input data is $c_\textrm{i}$,
the number of input channels of the convolution kernel also needs to be $c_\textrm{i}$. If our convolution kernel's window shape is $k_\textrm{h}\times k_\textrm{w}$,
then, when $c_\textrm{i}=1$, we can think of our convolution kernel
as just a two-dimensional tensor of shape $k_\textrm{h}\times k_\textrm{w}$.</p>
<p>However, when $c_\textrm{i}&gt;1$, we need a kernel
that contains a tensor of shape $k_\textrm{h}\times k_\textrm{w}$ for <em>every</em> input channel. Concatenating these $c_\textrm{i}$ tensors together
yields a convolution kernel of shape $c_\textrm{i}\times k_\textrm{h}\times k_\textrm{w}$.
Since the input and convolution kernel each have $c_\textrm{i}$ channels,
we can perform a cross-correlation operation
on the two-dimensional tensor of the input
and the two-dimensional tensor of the convolution kernel
for each channel, adding the $c_\textrm{i}$ results together
(summing over the channels)
to yield a two-dimensional tensor.
This is the result of a two-dimensional cross-correlation
between a multi-channel input and
a multi-input-channel convolution kernel.</p>
<p>:numref:<code>fig_conv_multi_in</code> provides an example
of a two-dimensional cross-correlation with two input channels.
The shaded portions are the first output element
as well as the input and kernel tensor elements used for the output computation:
$(1\times1+2\times2+4\times3+5\times4)+(0\times0+1\times1+3\times2+4\times3)=56$.</p>
<p><img src="chapter_convolutional-neural-networks/../img/conv-multi-in.svg" alt="Cross-correlation computation with two input channels." />
:label:<code>fig_conv_multi_in</code></p>
<p>To make sure we really understand what is going on here,
we can (<strong>implement cross-correlation operations with multiple input channels</strong>) ourselves.
Notice that all we are doing is performing a cross-correlation operation
per channel and then adding up the results.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
def corr2d_multi_in(X, K):
    # Iterate through the 0th dimension (channel) of K first, then add them up
    return sum(d2l.corr2d(x, k) for x, k in zip(X, K))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def corr2d_multi_in(X, K):
    # Iterate through the 0th dimension (channel) of K first, then add them up
    return tf.reduce_sum([d2l.corr2d(x, k) for x, k in zip(X, K)], axis=0)
</code></pre>
<p>We can construct the input tensor <code>X</code> and the kernel tensor <code>K</code>
corresponding to the values in :numref:<code>fig_conv_multi_in</code>
to (<strong>validate the output</strong>) of the cross-correlation operation.</p>
<pre><code class="language-{.python .input}">%%tab all
X = d2l.tensor([[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]],
               [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])
K = d2l.tensor([[[0.0, 1.0], [2.0, 3.0]], [[1.0, 2.0], [3.0, 4.0]]])

corr2d_multi_in(X, K)
</code></pre>
<h2 id="multiple-output-channels"><a class="header" href="#multiple-output-channels">Multiple Output Channels</a></h2>
<p>:label:<code>subsec_multi-output-channels</code></p>
<p>Regardless of the number of input channels,
so far we always ended up with one output channel.
However, as we discussed in :numref:<code>subsec_why-conv-channels</code>,
it turns out to be essential to have multiple channels at each layer.
In the most popular neural network architectures,
we actually increase the channel dimension
as we go deeper in the neural network,
typically downsampling to trade off spatial resolution
for greater <em>channel depth</em>.
Intuitively, you could think of each channel
as responding to a different set of features.
The reality is a bit more complicated than this. A naive interpretation would suggest
that representations are learned independently per pixel or per channel.
Instead, channels are optimized to be jointly useful.
This means that rather than mapping a single channel to an edge detector, it may simply mean
that some direction in channel space corresponds to detecting edges.</p>
<p>Denote by $c_\textrm{i}$ and $c_\textrm{o}$ the number
of input and output channels, respectively,
and by $k_\textrm{h}$ and $k_\textrm{w}$ the height and width of the kernel.
To get an output with multiple channels,
we can create a kernel tensor
of shape $c_\textrm{i}\times k_\textrm{h}\times k_\textrm{w}$
for <em>every</em> output channel.
We concatenate them on the output channel dimension,
so that the shape of the convolution kernel
is $c_\textrm{o}\times c_\textrm{i}\times k_\textrm{h}\times k_\textrm{w}$.
In cross-correlation operations,
the result on each output channel is calculated
from the convolution kernel corresponding to that output channel
and takes input from all channels in the input tensor.</p>
<p>We implement a cross-correlation function
to [<strong>calculate the output of multiple channels</strong>] as shown below.</p>
<pre><code class="language-{.python .input}">%%tab all
def corr2d_multi_in_out(X, K):
    # Iterate through the 0th dimension of K, and each time, perform
    # cross-correlation operations with input X. All of the results are
    # stacked together
    return d2l.stack([corr2d_multi_in(X, k) for k in K], 0)
</code></pre>
<p>We construct a trivial convolution kernel with three output channels
by concatenating the kernel tensor for <code>K</code> with <code>K+1</code> and <code>K+2</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
K = d2l.stack((K, K + 1, K + 2), 0)
K.shape
</code></pre>
<p>Below, we perform cross-correlation operations
on the input tensor <code>X</code> with the kernel tensor <code>K</code>.
Now the output contains three channels.
The result of the first channel is consistent
with the result of the previous input tensor <code>X</code>
and the multi-input channel,
single-output channel kernel.</p>
<pre><code class="language-{.python .input}">%%tab all
corr2d_multi_in_out(X, K)
</code></pre>
<h2 id="1times-1-convolutional-layer"><a class="header" href="#1times-1-convolutional-layer">$1\times 1$ Convolutional Layer</a></h2>
<p>:label:<code>subsec_1x1</code></p>
<p>At first, a [<strong>$1 \times 1$ convolution</strong>], i.e., $k_\textrm{h} = k_\textrm{w} = 1$,
does not seem to make much sense.
After all, a convolution correlates adjacent pixels.
A $1 \times 1$ convolution obviously does not.
Nonetheless, they are popular operations that are sometimes included
in the designs of complex deep networks :cite:<code>Lin.Chen.Yan.2013,Szegedy.Ioffe.Vanhoucke.ea.2017</code>.
Let's see in some detail what it actually does.</p>
<p>Because the minimum window is used,
the $1\times 1$ convolution loses the ability
of larger convolutional layers
to recognize patterns consisting of interactions
among adjacent elements in the height and width dimensions.
The only computation of the $1\times 1$ convolution occurs
on the channel dimension.</p>
<p>:numref:<code>fig_conv_1x1</code> shows the cross-correlation computation
using the $1\times 1$ convolution kernel
with 3 input channels and 2 output channels.
Note that the inputs and outputs have the same height and width.
Each element in the output is derived
from a linear combination of elements <em>at the same position</em>
in the input image.
You could think of the $1\times 1$ convolutional layer
as constituting a fully connected layer applied at every single pixel location
to transform the $c_\textrm{i}$ corresponding input values into $c_\textrm{o}$ output values.
Because this is still a convolutional layer,
the weights are tied across pixel location.
Thus the $1\times 1$ convolutional layer requires $c_\textrm{o}\times c_\textrm{i}$ weights
(plus the bias). Also note that convolutional layers are typically followed
by nonlinearities. This ensures that $1 \times 1$ convolutions cannot simply be
folded into other convolutions.</p>
<p><img src="chapter_convolutional-neural-networks/../img/conv-1x1.svg" alt="The cross-correlation computation uses the $1\times 1$ convolution kernel with three input channels and two output channels. The input and output have the same height and width." />
:label:<code>fig_conv_1x1</code></p>
<p>Let's check whether this works in practice:
we implement a $1 \times 1$ convolution
using a fully connected layer.
The only thing is that we need to make some adjustments
to the data shape before and after the matrix multiplication.</p>
<pre><code class="language-{.python .input}">%%tab all
def corr2d_multi_in_out_1x1(X, K):
    c_i, h, w = X.shape
    c_o = K.shape[0]
    X = d2l.reshape(X, (c_i, h * w))
    K = d2l.reshape(K, (c_o, c_i))
    # Matrix multiplication in the fully connected layer
    Y = d2l.matmul(K, X)
    return d2l.reshape(Y, (c_o, h, w))
</code></pre>
<p>When performing $1\times 1$ convolutions,
the above function is equivalent to the previously implemented cross-correlation function <code>corr2d_multi_in_out</code>.
Let's check this with some sample data.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X = d2l.normal(0, 1, (3, 3, 3))
K = d2l.normal(0, 1, (2, 3, 1, 1))
Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
assert float(d2l.reduce_sum(d2l.abs(Y1 - Y2))) &lt; 1e-6
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = d2l.normal((3, 3, 3), 0, 1)
K = d2l.normal((2, 3, 1, 1), 0, 1)
Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
assert float(d2l.reduce_sum(d2l.abs(Y1 - Y2))) &lt; 1e-6
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = jax.random.normal(jax.random.PRNGKey(d2l.get_seed()), (3, 3, 3)) + 0 * 1
K = jax.random.normal(jax.random.PRNGKey(d2l.get_seed()), (2, 3, 1, 1)) + 0 * 1
Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
assert float(d2l.reduce_sum(d2l.abs(Y1 - Y2))) &lt; 1e-6
</code></pre>
<h2 id="discussion-5"><a class="header" href="#discussion-5">Discussion</a></h2>
<p>Channels allow us to combine the best of both worlds: MLPs that allow for significant nonlinearities and convolutions that allow for <em>localized</em> analysis of features. In particular, channels allow the CNN to reason with multiple features, such as edge and shape detectors at the same time. They also offer a practical trade-off between the drastic parameter reduction arising from translation invariance and locality, and the need for expressive and diverse models in computer vision.</p>
<p>Note, though, that this flexibility comes at a price. Given an image of size $(h \times w)$, the cost for computing a $k \times k$ convolution is $\mathcal{O}(h \cdot w \cdot k^2)$. For $c_\textrm{i}$ and $c_\textrm{o}$ input and output channels respectively this increases to $\mathcal{O}(h \cdot w \cdot k^2 \cdot c_\textrm{i} \cdot c_\textrm{o})$. For a $256 \times 256$ pixel image with a $5 \times 5$ kernel and $128$ input and output channels respectively this amounts to over 53 billion operations (we count multiplications and additions separately). Later on we will encounter effective strategies to cut down on the cost, e.g., by requiring the channel-wise operations to be block-diagonal, leading to architectures such as ResNeXt :cite:<code>Xie.Girshick.Dollar.ea.2017</code>.</p>
<h2 id="exercises-39"><a class="header" href="#exercises-39">Exercises</a></h2>
<ol>
<li>Assume that we have two convolution kernels of size $k_1$ and $k_2$, respectively
(with no nonlinearity in between).
<ol>
<li>Prove that the result of the operation can be expressed by a single convolution.</li>
<li>What is the dimensionality of the equivalent single convolution?</li>
<li>Is the converse true, i.e., can you always decompose a convolution into two smaller ones?</li>
</ol>
</li>
<li>Assume an input of shape $c_\textrm{i}\times h\times w$ and a convolution kernel of shape
$c_\textrm{o}\times c_\textrm{i}\times k_\textrm{h}\times k_\textrm{w}$, padding of $(p_\textrm{h}, p_\textrm{w})$, and stride of $(s_\textrm{h}, s_\textrm{w})$.
<ol>
<li>What is the computational cost (multiplications and additions) for the forward propagation?</li>
<li>What is the memory footprint?</li>
<li>What is the memory footprint for the backward computation?</li>
<li>What is the computational cost for the backpropagation?</li>
</ol>
</li>
<li>By what factor does the number of calculations increase if we double both the number of input channels
$c_\textrm{i}$ and the number of output channels $c_\textrm{o}$? What happens if we double the padding?</li>
<li>Are the variables <code>Y1</code> and <code>Y2</code> in the final example of this section exactly the same? Why?</li>
<li>Express convolutions as a matrix multiplication, even when the convolution window is not $1 \times 1$.</li>
<li>Your task is to implement fast convolutions with a $k \times k$ kernel. One of the algorithm candidates
is to scan horizontally across the source, reading a $k$-wide strip and computing the $1$-wide output strip
one value at a time. The alternative is to read a $k + \Delta$ wide strip and compute a $\Delta$-wide
output strip. Why is the latter preferable? Is there a limit to how large you should choose $\Delta$?</li>
<li>Assume that we have a $c \times c$ matrix.
<ol>
<li>How much faster is it to multiply with a block-diagonal matrix if the matrix is broken up into $b$ blocks?</li>
<li>What is the downside of having $b$ blocks? How could you fix it, at least partly?</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/69">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/70">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/273">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17998">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="pooling"><a class="header" href="#pooling">Pooling</a></h1>
<p>:label:<code>sec_pooling</code></p>
<p>In many cases our ultimate task asks some global question about the image,
e.g., <em>does it contain a cat?</em> Consequently, the units of our final layer
should be sensitive to the entire input.
By gradually aggregating information, yielding coarser and coarser maps,
we accomplish this goal of ultimately learning a global representation,
while keeping all of the advantages of convolutional layers at the intermediate layers of processing.
The deeper we go in the network,
the larger the receptive field (relative to the input)
to which each hidden node is sensitive. Reducing spatial resolution
accelerates this process,
since the convolution kernels cover a larger effective area.</p>
<p>Moreover, when detecting lower-level features, such as edges
(as discussed in :numref:<code>sec_conv_layer</code>),
we often want our representations to be somewhat invariant to translation.
For instance, if we take the image <code>X</code>
with a sharp delineation between black and white
and shift the whole image by one pixel to the right,
i.e., <code>Z[i, j] = X[i, j + 1]</code>,
then the output for the new image <code>Z</code> might be vastly different.
The edge will have shifted by one pixel.
In reality, objects hardly ever occur exactly at the same place.
In fact, even with a tripod and a stationary object,
vibration of the camera due to the movement of the shutter
might shift everything by a pixel or so
(high-end cameras are loaded with special features to address this problem).</p>
<p>This section introduces <em>pooling layers</em>,
which serve the dual purposes of
mitigating the sensitivity of convolutional layers to location
and of spatially downsampling representations.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="maximum-pooling-and-average-pooling"><a class="header" href="#maximum-pooling-and-average-pooling">Maximum Pooling and Average Pooling</a></h2>
<p>Like convolutional layers, <em>pooling</em> operators
consist of a fixed-shape window that is slid over
all regions in the input according to its stride,
computing a single output for each location traversed
by the fixed-shape window (sometimes known as the <em>pooling window</em>).
However, unlike the cross-correlation computation
of the inputs and kernels in the convolutional layer,
the pooling layer contains no parameters (there is no <em>kernel</em>).
Instead, pooling operators are deterministic,
typically calculating either the maximum or the average value
of the elements in the pooling window.
These operations are called <em>maximum pooling</em> (<em>max-pooling</em> for short)
and <em>average pooling</em>, respectively.</p>
<p><em>Average pooling</em> is essentially as old as CNNs. The idea is akin to
downsampling an image. Rather than just taking the value of every second (or third)
pixel for the lower resolution image, we can average over adjacent pixels to obtain
an image with better signal-to-noise ratio since we are combining the information
from multiple adjacent pixels. <em>Max-pooling</em> was introduced in
:citet:<code>Riesenhuber.Poggio.1999</code> in the context of cognitive neuroscience to describe
how information aggregation might be aggregated hierarchically for the purpose
of object recognition; there already was an earlier version in speech recognition :cite:<code>Yamaguchi.Sakamoto.Akabane.ea.1990</code>. In almost all cases, max-pooling, as it is also referred to,
is preferable to average pooling.</p>
<p>In both cases, as with the cross-correlation operator,
we can think of the pooling window
as starting from the upper-left of the input tensor
and sliding across it from left to right and top to bottom.
At each location that the pooling window hits,
it computes the maximum or average
value of the input subtensor in the window,
depending on whether max or average pooling is employed.</p>
<p><img src="chapter_convolutional-neural-networks/../img/pooling.svg" alt="Max-pooling with a pooling window shape of $2\times 2$. The shaded portions are the first output element as well as the input tensor elements used for the output computation: $\max(0, 1, 3, 4)=4$." />
:label:<code>fig_pooling</code></p>
<p>The output tensor in :numref:<code>fig_pooling</code>  has a height of 2 and a width of 2.
The four elements are derived from the maximum value in each pooling window:</p>
<p>$$
\max(0, 1, 3, 4)=4,\
\max(1, 2, 4, 5)=5,\
\max(3, 4, 6, 7)=7,\
\max(4, 5, 7, 8)=8.\
$$</p>
<p>More generally, we can define a $p \times q$ pooling layer by aggregating over
a region of said size. Returning to the problem of edge detection,
we use the output of the convolutional layer
as input for $2\times 2$ max-pooling.
Denote by <code>X</code> the input of the convolutional layer input and <code>Y</code> the pooling layer output.
Regardless of whether or not the values of <code>X[i, j]</code>, <code>X[i, j + 1]</code>,
<code>X[i+1, j]</code> and <code>X[i+1, j + 1]</code> are different,
the pooling layer always outputs <code>Y[i, j] = 1</code>.
That is to say, using the $2\times 2$ max-pooling layer,
we can still detect if the pattern recognized by the convolutional layer
moves no more than one element in height or width.</p>
<p>In the code below, we (<strong>implement the forward propagation
of the pooling layer</strong>) in the <code>pool2d</code> function.
This function is similar to the <code>corr2d</code> function
in :numref:<code>sec_conv_layer</code>.
However, no kernel is needed, computing the output
as either the maximum or the average of each region in the input.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
def pool2d(X, pool_size, mode='max'):
    p_h, p_w = pool_size
    Y = d2l.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            if mode == 'max':
                Y[i, j] = X[i: i + p_h, j: j + p_w].max()
            elif mode == 'avg':
                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def pool2d(X, pool_size, mode='max'):
    p_h, p_w = pool_size
    Y = jnp.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            if mode == 'max':
                Y = Y.at[i, j].set(X[i: i + p_h, j: j + p_w].max())
            elif mode == 'avg':
                Y = Y.at[i, j].set(X[i: i + p_h, j: j + p_w].mean())
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf

def pool2d(X, pool_size, mode='max'):
    p_h, p_w = pool_size
    Y = tf.Variable(tf.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w +1)))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            if mode == 'max':
                Y[i, j].assign(tf.reduce_max(X[i: i + p_h, j: j + p_w]))
            elif mode =='avg':
                Y[i, j].assign(tf.reduce_mean(X[i: i + p_h, j: j + p_w]))
    return Y
</code></pre>
<p>We can construct the input tensor <code>X</code> in :numref:<code>fig_pooling</code> to [<strong>validate the output of the two-dimensional max-pooling layer</strong>].</p>
<pre><code class="language-{.python .input}">%%tab all
X = d2l.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])
pool2d(X, (2, 2))
</code></pre>
<p>Also, we can experiment with (<strong>the average pooling layer</strong>).</p>
<pre><code class="language-{.python .input}">%%tab all
pool2d(X, (2, 2), 'avg')
</code></pre>
<h2 id="padding-and-stride-1"><a class="header" href="#padding-and-stride-1">[<strong>Padding and Stride</strong>]</a></h2>
<p>As with convolutional layers, pooling layers
change the output shape.
And as before, we can adjust the operation to achieve a desired output shape
by padding the input and adjusting the stride.
We can demonstrate the use of padding and strides
in pooling layers via the built-in two-dimensional max-pooling layer from the deep learning framework.
We first construct an input tensor <code>X</code> whose shape has four dimensions,
where the number of examples (batch size) and number of channels are both 1.</p>
<p>:begin_tab:<code>tensorflow</code>
Note that unlike other frameworks, TensorFlow
prefers and is optimized for <em>channels-last</em> input.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X = d2l.reshape(d2l.arange(16, dtype=d2l.float32), (1, 1, 4, 4))
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
X = d2l.reshape(d2l.arange(16, dtype=d2l.float32), (1, 4, 4, 1))
X
</code></pre>
<p>Since pooling aggregates information from an area, (<strong>deep learning frameworks default to matching pooling window sizes and stride.</strong>) For instance, if we use a pooling window of shape <code>(3, 3)</code>
we get a stride shape of <code>(3, 3)</code> by default.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
pool2d = nn.MaxPool2D(3)
# Pooling has no model parameters, hence it needs no initialization
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
pool2d = nn.MaxPool2d(3)
# Pooling has no model parameters, hence it needs no initialization
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
pool2d = tf.keras.layers.MaxPool2D(pool_size=[3, 3])
# Pooling has no model parameters, hence it needs no initialization
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# Pooling has no model parameters, hence it needs no initialization
nn.max_pool(X, window_shape=(3, 3), strides=(3, 3))
</code></pre>
<p>Needless to say, [<strong>the stride and padding can be manually specified</strong>] to override framework defaults if required.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
pool2d = nn.MaxPool2D(3, padding=1, strides=2)
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
pool2d = nn.MaxPool2d(3, padding=1, stride=2)
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
paddings = tf.constant([[0, 0], [1,0], [1,0], [0,0]])
X_padded = tf.pad(X, paddings, "CONSTANT")
pool2d = tf.keras.layers.MaxPool2D(pool_size=[3, 3], padding='valid',
                                   strides=2)
pool2d(X_padded)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X_padded = jnp.pad(X, ((0, 0), (1, 0), (1, 0), (0, 0)), mode='constant')
nn.max_pool(X_padded, window_shape=(3, 3), padding='VALID', strides=(2, 2))
</code></pre>
<p>Of course, we can specify an arbitrary rectangular pooling window with arbitrary height and width respectively, as the example below shows.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
pool2d = nn.MaxPool2D((2, 3), padding=(0, 1), strides=(2, 3))
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
pool2d = nn.MaxPool2d((2, 3), stride=(2, 3), padding=(0, 1))
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
paddings = tf.constant([[0, 0], [0, 0], [1, 1], [0, 0]])
X_padded = tf.pad(X, paddings, "CONSTANT")

pool2d = tf.keras.layers.MaxPool2D(pool_size=[2, 3], padding='valid',
                                   strides=(2, 3))
pool2d(X_padded)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax

X_padded = jnp.pad(X, ((0, 0), (0, 0), (1, 1), (0, 0)), mode='constant')
nn.max_pool(X_padded, window_shape=(2, 3), strides=(2, 3), padding='VALID')
</code></pre>
<h2 id="multiple-channels"><a class="header" href="#multiple-channels">Multiple Channels</a></h2>
<p>When processing multi-channel input data,
[<strong>the pooling layer pools each input channel separately</strong>],
rather than summing the inputs up over channels
as in a convolutional layer.
This means that the number of output channels for the pooling layer
is the same as the number of input channels.
Below, we will concatenate tensors <code>X</code> and <code>X + 1</code>
on the channel dimension to construct an input with two channels.</p>
<p>:begin_tab:<code>tensorflow</code>
Note that this will require a
concatenation along the last dimension for TensorFlow due to the channels-last syntax.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X = d2l.concat((X, X + 1), 1)
X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
# Concatenate along `dim=3` due to channels-last syntax
X = d2l.concat([X, X + 1], 3)
X
</code></pre>
<p>As we can see, the number of output channels is still two after pooling.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
pool2d = nn.MaxPool2D(3, padding=1, strides=2)
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
pool2d = nn.MaxPool2d(3, padding=1, stride=2)
pool2d(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
paddings = tf.constant([[0, 0], [1,0], [1,0], [0,0]])
X_padded = tf.pad(X, paddings, "CONSTANT")
pool2d = tf.keras.layers.MaxPool2D(pool_size=[3, 3], padding='valid',
                                   strides=2)
pool2d(X_padded)

</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X_padded = jnp.pad(X, ((0, 0), (1, 0), (1, 0), (0, 0)), mode='constant')
nn.max_pool(X_padded, window_shape=(3, 3), padding='VALID', strides=(2, 2))
</code></pre>
<p>:begin_tab:<code>tensorflow</code>
Note that the output for the TensorFlow pooling appears at first glance to be different, however
numerically the same results are presented as MXNet and PyTorch.
The difference lies in the dimensionality, and reading the
output vertically yields the same output as the other implementations.
:end_tab:</p>
<h2 id="summary-29"><a class="header" href="#summary-29">Summary</a></h2>
<p>Pooling is an exceedingly simple operation. It does exactly what its name indicates, aggregate results over a window of values. All convolution semantics, such as strides and padding apply in the same way as they did previously. Note that pooling is indifferent to channels, i.e., it leaves the number of channels unchanged and it applies to each channel separately. Lastly, of the two popular pooling choices, max-pooling is preferable to average pooling, as it confers some degree of invariance to output. A popular choice is to pick a pooling window size of $2 \times 2$ to quarter the spatial resolution of output.</p>
<p>Note that there are many more ways of reducing resolution beyond pooling. For instance, in stochastic pooling :cite:<code>Zeiler.Fergus.2013</code> and fractional max-pooling :cite:<code>Graham.2014</code> aggregation is combined with randomization. This can slightly improve the accuracy in some cases. Lastly, as we will see later with the attention mechanism, there are more refined ways of aggregating over outputs, e.g., by using the alignment between a query and representation vectors.</p>
<h2 id="exercises-40"><a class="header" href="#exercises-40">Exercises</a></h2>
<ol>
<li>Implement average pooling through a convolution.</li>
<li>Prove that max-pooling cannot be implemented through a convolution alone.</li>
<li>Max-pooling can be accomplished using ReLU operations, i.e., $\textrm{ReLU}(x) = \max(0, x)$.
<ol>
<li>Express $\max (a, b)$ by using only ReLU operations.</li>
<li>Use this to implement max-pooling by means of convolutions and ReLU layers.</li>
<li>How many channels and layers do you need for a $2 \times 2$ convolution? How many for a $3 \times 3$ convolution?</li>
</ol>
</li>
<li>What is the computational cost of the pooling layer? Assume that the input to the pooling layer is of size $c\times h\times w$, the pooling window has a shape of $p_\textrm{h}\times p_\textrm{w}$ with a padding of $(p_\textrm{h}, p_\textrm{w})$ and a stride of $(s_\textrm{h}, s_\textrm{w})$.</li>
<li>Why do you expect max-pooling and average pooling to work differently?</li>
<li>Do we need a separate minimum pooling layer? Can you replace it with another operation?</li>
<li>We could use the softmax operation for pooling. Why might it not be so popular?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/71">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/72">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/274">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/17999">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="convolutional-neural-networks-lenet"><a class="header" href="#convolutional-neural-networks-lenet">Convolutional Neural Networks (LeNet)</a></h1>
<p>:label:<code>sec_lenet</code></p>
<p>We now have all the ingredients required to assemble
a fully-functional CNN.
In our earlier encounter with image data, we applied
a linear model with softmax regression (:numref:<code>sec_softmax_scratch</code>)
and an MLP (:numref:<code>sec_mlp-implementation</code>)
to pictures of clothing in the Fashion-MNIST dataset.
To make such data amenable we first flattened each image from a $28\times28$ matrix
into a fixed-length $784$-dimensional vector,
and thereafter processed them in fully connected layers.
Now that we have a handle on convolutional layers,
we can retain the spatial structure in our images.
As an additional benefit of replacing fully connected layers with convolutional layers,
we will enjoy more parsimonious models that require far fewer parameters.</p>
<p>In this section, we will introduce <em>LeNet</em>,
among the first published CNNs
to capture wide attention for its performance on computer vision tasks.
The model was introduced by (and named for) Yann LeCun,
then a researcher at AT&amp;T Bell Labs,
for the purpose of recognizing handwritten digits in images :cite:<code>LeCun.Bottou.Bengio.ea.1998</code>.
This work represented the culmination
of a decade of research developing the technology;
LeCun's team published the first study to successfully
train CNNs via backpropagation :cite:<code>LeCun.Boser.Denker.ea.1989</code>.</p>
<p>At the time LeNet achieved outstanding results
matching the performance of support vector machines,
then a dominant approach in supervised learning, achieving an error rate of less than 1% per digit.
LeNet was eventually adapted to recognize digits
for processing deposits in ATM machines.
To this day, some ATMs still run the code
that Yann LeCun and his colleague Leon Bottou wrote in the 1990s!</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
from types import FunctionType
</code></pre>
<h2 id="lenet"><a class="header" href="#lenet">LeNet</a></h2>
<p>At a high level, (<strong>LeNet (LeNet-5) consists of two parts:
(i) a convolutional encoder consisting of two convolutional layers; and
(ii) a dense block consisting of three fully connected layers</strong>).
The architecture is summarized in :numref:<code>img_lenet</code>.</p>
<p><img src="chapter_convolutional-neural-networks/../img/lenet.svg" alt="Data flow in LeNet. The input is a handwritten digit, the output is a probability over 10 possible outcomes." />
:label:<code>img_lenet</code></p>
<p>The basic units in each convolutional block
are a convolutional layer, a sigmoid activation function,
and a subsequent average pooling operation.
Note that while ReLUs and max-pooling work better,
they had not yet been discovered.
Each convolutional layer uses a $5\times 5$ kernel
and a sigmoid activation function.
These layers map spatially arranged inputs
to a number of two-dimensional feature maps, typically
increasing the number of channels.
The first convolutional layer has 6 output channels,
while the second has 16.
Each $2\times2$ pooling operation (stride 2)
reduces dimensionality by a factor of $4$ via spatial downsampling.
The convolutional block emits an output with shape given by
(batch size, number of channel, height, width).</p>
<p>In order to pass output from the convolutional block
to the dense block,
we must flatten each example in the minibatch.
In other words, we take this four-dimensional input and transform it
into the two-dimensional input expected by fully connected layers:
as a reminder, the two-dimensional representation that we desire uses the first dimension to index examples in the minibatch
and the second to give the flat vector representation of each example.
LeNet's dense block has three fully connected layers,
with 120, 84, and 10 outputs, respectively.
Because we are still performing classification,
the 10-dimensional output layer corresponds
to the number of possible output classes.</p>
<p>While getting to the point where you truly understand
what is going on inside LeNet may have taken a bit of work,
we hope that the following code snippet will convince you
that implementing such models with modern deep learning frameworks
is remarkably simple.
We need only to instantiate a <code>Sequential</code> block
and chain together the appropriate layers,
using Xavier initialization as
introduced in :numref:<code>subsec_xavier</code>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
def init_cnn(module):  #@save
    """Initialize weights for CNNs."""
    if type(module) == nn.Linear or type(module) == nn.Conv2d:
        nn.init.xavier_uniform_(module.weight)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class LeNet(d2l.Classifier):  #@save
    """The LeNet-5 model."""
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            self.net.add(
                nn.Conv2D(channels=6, kernel_size=5, padding=2,
                          activation='sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2),
                nn.Conv2D(channels=16, kernel_size=5, activation='sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2),
                nn.Dense(120, activation='sigmoid'),
                nn.Dense(84, activation='sigmoid'),
                nn.Dense(num_classes))
            self.net.initialize(init.Xavier())
        if tab.selected('pytorch'):
            self.net = nn.Sequential(
                nn.LazyConv2d(6, kernel_size=5, padding=2), nn.Sigmoid(),
                nn.AvgPool2d(kernel_size=2, stride=2),
                nn.LazyConv2d(16, kernel_size=5), nn.Sigmoid(),
                nn.AvgPool2d(kernel_size=2, stride=2),
                nn.Flatten(),
                nn.LazyLinear(120), nn.Sigmoid(),
                nn.LazyLinear(84), nn.Sigmoid(),
                nn.LazyLinear(num_classes))
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(filters=6, kernel_size=5,
                                       activation='sigmoid', padding='same'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Conv2D(filters=16, kernel_size=5,
                                       activation='sigmoid'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Flatten(),
                tf.keras.layers.Dense(120, activation='sigmoid'),
                tf.keras.layers.Dense(84, activation='sigmoid'),
                tf.keras.layers.Dense(num_classes)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class LeNet(d2l.Classifier):  #@save
    """The LeNet-5 model."""
    lr: float = 0.1
    num_classes: int = 10
    kernel_init: FunctionType = nn.initializers.xavier_uniform

    def setup(self):
        self.net = nn.Sequential([
            nn.Conv(features=6, kernel_size=(5, 5), padding='SAME',
                    kernel_init=self.kernel_init()),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            nn.Conv(features=16, kernel_size=(5, 5), padding='VALID',
                    kernel_init=self.kernel_init()),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            lambda x: x.reshape((x.shape[0], -1)),  # flatten
            nn.Dense(features=120, kernel_init=self.kernel_init()),
            nn.sigmoid,
            nn.Dense(features=84, kernel_init=self.kernel_init()),
            nn.sigmoid,
            nn.Dense(features=self.num_classes, kernel_init=self.kernel_init())
        ])
</code></pre>
<p>We have taken some liberty in the reproduction of LeNet insofar as we have replaced the Gaussian activation layer by
a softmax layer. This greatly simplifies the implementation, not least due to the
fact that the Gaussian decoder is rarely used nowadays. Other than that, this network matches
the original LeNet-5 architecture.</p>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
Let's see what happens inside the network. By passing a
single-channel (black and white)
$28 \times 28$ image through the network
and printing the output shape at each layer,
we can [<strong>inspect the model</strong>] to ensure
that its operations line up with
what we expect from :numref:<code>img_lenet_vert</code>.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Let's see what happens inside the network. By passing a
single-channel (black and white)
$28 \times 28$ image through the network
and printing the output shape at each layer,
we can [<strong>inspect the model</strong>] to ensure
that its operations line up with
what we expect from :numref:<code>img_lenet_vert</code>.
Flax provides <code>nn.tabulate</code>, a nifty method to summarise the layers and
parameters in our network. Here we use the <code>bind</code> method to create a bounded model.
The variables are now bound to the <code>d2l.Module</code> class, i.e., this bounded model
becomes a stateful object which can then be used to access the <code>Sequential</code>
object attribute <code>net</code> and the <code>layers</code> within. Note that the <code>bind</code> method should
only be used for interactive experimentation, and is not a direct
replacement for the <code>apply</code> method.
:end_tab:</p>
<p><img src="chapter_convolutional-neural-networks/../img/lenet-vert.svg" alt="Compressed notation for LeNet-5." />
:label:<code>img_lenet_vert</code></p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
@d2l.add_to_class(d2l.Classifier)  #@save
def layer_summary(self, X_shape):
    X = d2l.randn(*X_shape)
    for layer in self.net:
        X = layer(X)
        print(layer.__class__.__name__, 'output shape:\t', X.shape)
        
model = LeNet()
model.layer_summary((1, 1, 28, 28))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(d2l.Classifier)  #@save
def layer_summary(self, X_shape):
    X = d2l.normal(X_shape)
    for layer in self.net.layers:
        X = layer(X)
        print(layer.__class__.__name__, 'output shape:\t', X.shape)

model = LeNet()
model.layer_summary((1, 28, 28, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Classifier)  #@save
def layer_summary(self, X_shape, key=d2l.get_key()):
    X = jnp.zeros(X_shape)
    params = self.init(key, X)
    bound_model = self.clone().bind(params, mutable=['batch_stats'])
    _ = bound_model(X)
    for layer in bound_model.net.layers:
        X = layer(X)
        print(layer.__class__.__name__, 'output shape:\t', X.shape)

model = LeNet()
model.layer_summary((1, 28, 28, 1))
</code></pre>
<p>Note that the height and width of the representation
at each layer throughout the convolutional block
is reduced (compared with the previous layer).
The first convolutional layer uses two pixels of padding
to compensate for the reduction in height and width
that would otherwise result from using a $5 \times 5$ kernel.
As an aside, the image size of $28 \times 28$ pixels in the original
MNIST OCR dataset is a result of <em>trimming</em> two pixel rows (and columns) from the
original scans that measured $32 \times 32$ pixels. This was done primarily to
save space (a 30% reduction) at a time when megabytes mattered.</p>
<p>In contrast, the second convolutional layer forgoes padding,
and thus the height and width are both reduced by four pixels.
As we go up the stack of layers,
the number of channels increases layer-over-layer
from 1 in the input to 6 after the first convolutional layer
and 16 after the second convolutional layer.
However, each pooling layer halves the height and width.
Finally, each fully connected layer reduces dimensionality,
finally emitting an output whose dimension
matches the number of classes.</p>
<h2 id="training-8"><a class="header" href="#training-8">Training</a></h2>
<p>Now that we have implemented the model,
let's [<strong>run an experiment to see how the LeNet-5 model fares on Fashion-MNIST</strong>].</p>
<p>While CNNs have fewer parameters,
they can still be more expensive to compute
than similarly deep MLPs
because each parameter participates in many more
multiplications.
If you have access to a GPU, this might be a good time
to put it into action to speed up training.
Note that
the <code>d2l.Trainer</code> class takes care of all details.
By default, it initializes the model parameters on the
available devices.
Just as with MLPs, our loss function is cross-entropy,
and we minimize it via minibatch stochastic gradient descent.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, jax
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128)
model = LeNet(lr=0.1)
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128)
with d2l.try_gpu():
    model = LeNet(lr=0.1)
    trainer.fit(model, data)
</code></pre>
<h2 id="summary-30"><a class="header" href="#summary-30">Summary</a></h2>
<p>We have made significant progress in this chapter. We moved from the MLPs of the 1980s to the CNNs of the 1990s and early 2000s. The architectures proposed, e.g., in the form of LeNet-5 remain meaningful, even to this day. It is worth comparing the error rates on Fashion-MNIST achievable with LeNet-5 both to the very best possible with MLPs (:numref:<code>sec_mlp-implementation</code>) and those with significantly more advanced architectures such as ResNet (:numref:<code>sec_resnet</code>). LeNet is much more similar to the latter than to the former. One of the primary differences, as we shall see, is that greater amounts of computation enabled significantly more complex architectures.</p>
<p>A second difference is the relative ease with which we were able to implement LeNet. What used to be an engineering challenge worth months of C++ and assembly code, engineering to improve SN, an early Lisp-based deep learning tool :cite:<code>Bottou.Le-Cun.1988</code>, and finally experimentation with models can now be accomplished in minutes. It is this incredible productivity boost that has democratized deep learning model development tremendously. In the next chapter, we will journey down this rabbit hole to see where it takes us.</p>
<h2 id="exercises-41"><a class="header" href="#exercises-41">Exercises</a></h2>
<ol>
<li>Let's modernize LeNet. Implement and test the following changes:
<ol>
<li>Replace average pooling with max-pooling.</li>
<li>Replace the softmax layer with ReLU.</li>
</ol>
</li>
<li>Try to change the size of the LeNet style network to improve its accuracy in addition to max-pooling and ReLU.
<ol>
<li>Adjust the convolution window size.</li>
<li>Adjust the number of output channels.</li>
<li>Adjust the number of convolution layers.</li>
<li>Adjust the number of fully connected layers.</li>
<li>Adjust the learning rates and other training details (e.g., initialization and number of epochs).</li>
</ol>
</li>
<li>Try out the improved network on the original MNIST dataset.</li>
<li>Display the activations of the first and second layer of LeNet for different inputs (e.g., sweaters and coats).</li>
<li>What happens to the activations when you feed significantly different images into the network (e.g., cats, cars, or even random noise)?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/73">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/74">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/275">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18000">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-convolutional-neural-networks"><a class="header" href="#modern-convolutional-neural-networks">Modern Convolutional Neural Networks</a></h1>
<p>:label:<code>chap_modern_cnn</code></p>
<p>Now that we understand the basics of wiring together CNNs, let's take
a tour of modern CNN architectures. This tour is, by
necessity, incomplete, thanks to the plethora of exciting new designs
being added. Their importance derives from the fact that not only can
they be used directly for vision tasks, but they also serve as basic
feature generators for more advanced tasks such as tracking
:cite:<code>Zhang.Sun.Jiang.ea.2021</code>, segmentation :cite:<code>Long.Shelhamer.Darrell.2015</code>, object
detection :cite:<code>Redmon.Farhadi.2018</code>, or style transformation
:cite:<code>Gatys.Ecker.Bethge.2016</code>.  In this chapter, most sections
correspond to a significant CNN architecture that was at some point
(or currently) the base model upon which many research projects and
deployed systems were built.  Each of these networks was briefly a
dominant architecture and many were winners or runners-up in the
<a href="https://www.image-net.org/challenges/LSVRC/">ImageNet competition</a>
which has served as a barometer of progress on supervised learning in
computer vision since 2010. It is only recently that Transformers have begun
to displace CNNs, starting with :citet:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021</code> and
followed by the Swin Transformer :cite:<code>liu2021swin</code>. We will cover this development later
in :numref:<code>chap_attention-and-transformers</code>.</p>
<p>While the idea of <em>deep</em> neural networks is quite simple (stack
together a bunch of layers), performance can vary wildly across
architectures and hyperparameter choices.  The neural networks
described in this chapter are the product of intuition, a few
mathematical insights, and a lot of trial and error.  We present these
models in chronological order, partly to convey a sense of the history
so that you can form your own intuitions about where the field is
heading and perhaps develop your own architectures.  For instance,
batch normalization and residual connections described in this chapter
have offered two popular ideas for training and designing deep models,
both of which have since also been applied to architectures beyond computer
vision.</p>
<p>We begin our tour of modern CNNs with AlexNet :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>,
the first large-scale network deployed to beat conventional computer
vision methods on a large-scale vision challenge; the VGG network
:cite:<code>Simonyan.Zisserman.2014</code>, which makes use of a number of
repeating blocks of elements; the network in network (NiN) that
convolves whole neural networks patch-wise over inputs
:cite:<code>Lin.Chen.Yan.2013</code>; GoogLeNet that uses networks with
multi-branch convolutions :cite:<code>Szegedy.Liu.Jia.ea.2015</code>; the residual
network (ResNet) :cite:<code>He.Zhang.Ren.ea.2016</code>, which remains one of
the most popular off-the-shelf architectures in computer vision;
ResNeXt blocks :cite:<code>Xie.Girshick.Dollar.ea.2017</code>
for sparser connections;
and DenseNet
:cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code> for a generalization of the
residual architecture. Over time many special optimizations for efficient
networks have been developed, such as coordinate shifts (ShiftNet) :cite:<code>wu2018shift</code>. This
culminated in the automatic search for efficient architectures such as
MobileNet v3 :cite:<code>Howard.Sandler.Chu.ea.2019</code>. It also includes the
semi-automatic design exploration of :citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code>
that led to the RegNetX/Y which we will discuss later in this chapter.
The work is instructive insofar as it offers a path for marrying brute force computation with
the ingenuity of an experimenter in the search for efficient design spaces. Of note is
also the work of :citet:<code>liu2022convnet</code> as it shows that training techniques (e.g., optimizers, data augmentation, and regularization)
play a pivotal role in improving accuracy. It also shows that long-held assumptions, such as
the size of a convolution window, may need to be revisited, given the increase in
computation and data. We will cover this and many more questions in due course throughout this chapter.</p>
<pre><code class="language-toc">:maxdepth: 2

alexnet
vgg
nin
googlenet
batch-norm
resnet
densenet
cnn-design
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="deep-convolutional-neural-networks-alexnet"><a class="header" href="#deep-convolutional-neural-networks-alexnet">Deep Convolutional Neural Networks (AlexNet)</a></h1>
<p>:label:<code>sec_alexnet</code></p>
<p>Although CNNs were well known
in the computer vision and machine learning communities
following the introduction of LeNet :cite:<code>LeCun.Jackel.Bottou.ea.1995</code>,
they did not immediately dominate the field.
Although LeNet achieved good results on early small datasets,
the performance and feasibility of training CNNs
on larger, more realistic datasets had yet to be established.
In fact, for much of the intervening time between the early 1990s
and the watershed results of 2012 :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>,
neural networks were often surpassed by other machine learning methods,
such as kernel methods :cite:<code>Scholkopf.Smola.2002</code>, ensemble methods :cite:<code>Freund.Schapire.ea.1996</code>,
and structured estimation :cite:<code>Taskar.Guestrin.Koller.2004</code>.</p>
<p>For computer vision, this comparison is perhaps not entirely accurate.
That is, although the inputs to convolutional networks
consist of raw or lightly-processed (e.g., by centering) pixel values, practitioners would never feed raw pixels into traditional models.
Instead, typical computer vision pipelines
consisted of manually engineering feature extraction pipelines, such as SIFT :cite:<code>Lowe.2004</code>, SURF :cite:<code>Bay.Tuytelaars.Van-Gool.2006</code>, and bags of visual words :cite:<code>Sivic.Zisserman.2003</code>.
Rather than <em>learning</em> the features, the features were <em>crafted</em>.
Most of the progress came from having more clever ideas for feature extraction on the one hand and deep insight into geometry :cite:<code>Hartley.Zisserman.2000</code> on the other. The learning algorithm was often considered an afterthought.</p>
<p>Although some neural network accelerators were available in the 1990s,
they were not yet sufficiently powerful to make
deep multichannel, multilayer CNNs
with a large number of parameters. For instance, NVIDIA's GeForce 256 from 1999
was able to process at most 480 million floating-point operations, such as additions and multiplications, per second (MFLOPS), without any meaningful
programming framework for operations beyond games. Today's accelerators are able to perform in excess of 1000 TFLOPs per device.
Moreover, datasets were still relatively small: OCR on 60,000 low-resolution $28 \times 28$ pixel images was considered a highly challenging task.
Added to these obstacles, key tricks for training neural networks
including parameter initialization heuristics :cite:<code>Glorot.Bengio.2010</code>,
clever variants of stochastic gradient descent :cite:<code>Kingma.Ba.2014</code>,
non-squashing activation functions :cite:<code>Nair.Hinton.2010</code>,
and effective regularization techniques :cite:<code>Srivastava.Hinton.Krizhevsky.ea.2014</code> were still missing.</p>
<p>Thus, rather than training <em>end-to-end</em> (pixel to classification) systems,
classical pipelines looked more like this:</p>
<ol>
<li>Obtain an interesting dataset. In the early days, these datasets required expensive sensors. For instance, the <a href="https://en.wikipedia.org/wiki/Apple_QuickTake">Apple QuickTake 100</a> of 1994 sported a whopping 0.3 megapixel (VGA) resolution, capable of storing up to 8 images, all for the price of $1000.</li>
<li>Preprocess the dataset with hand-crafted features based on some knowledge of optics, geometry, other analytic tools, and occasionally on the serendipitous discoveries by lucky graduate students.</li>
<li>Feed the data through a standard set of feature extractors such as the SIFT (scale-invariant feature transform) :cite:<code>Lowe.2004</code>, the SURF (speeded up robust features) :cite:<code>Bay.Tuytelaars.Van-Gool.2006</code>, or any number of other hand-tuned pipelines. OpenCV still provides SIFT extractors to this day!</li>
<li>Dump the resulting representations into your favorite classifier, likely a linear model or kernel method, to train a classifier.</li>
</ol>
<p>If you spoke to machine learning researchers,
they would reply that machine learning was both important and beautiful.
Elegant theories proved the properties of various classifiers :cite:<code>boucheron2005theory</code> and convex
optimization :cite:<code>Boyd.Vandenberghe.2004</code> had become the mainstay for obtaining them.
The field of machine learning was thriving, rigorous, and eminently useful. However,
if you spoke to a computer vision researcher,
you would hear a very different story.
The dirty truth of image recognition, they would tell you,
is that features, geometry :cite:<code>Hartley.Zisserman.2000,hartley2009global</code>, and engineering,
rather than novel learning algorithms, drove progress.
Computer vision researchers justifiably believed
that a slightly bigger or cleaner dataset
or a slightly improved feature-extraction pipeline
mattered far more to the final accuracy than any learning algorithm.</p>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, init, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="representation-learning"><a class="header" href="#representation-learning">Representation Learning</a></h2>
<p>Another way to cast the state of affairs is that
the most important part of the pipeline was the representation.
And up until 2012 the representation was calculated mostly mechanically.
In fact, engineering a new set of feature functions, improving results, and writing up the method
all featured prominently in papers.
SIFT :cite:<code>Lowe.2004</code>,
SURF :cite:<code>Bay.Tuytelaars.Van-Gool.2006</code>,
HOG (histograms of oriented gradient) :cite:<code>Dalal.Triggs.2005</code>,
bags of visual words :cite:<code>Sivic.Zisserman.2003</code>,
and similar feature extractors ruled the roost.</p>
<p>Another group of researchers,
including Yann LeCun, Geoff Hinton, Yoshua Bengio,
Andrew Ng, Shun-ichi Amari, and Juergen Schmidhuber,
had different plans.
They believed that features themselves ought to be learned.
Moreover, they believed that to be reasonably complex,
the features ought to be hierarchically composed
with multiple jointly learned layers, each with learnable parameters.
In the case of an image, the lowest layers might come
to detect edges, colors, and textures, by analogy with how the visual system in animals
processes its input. In particular, the automatic design of visual features such as those obtained
by sparse coding :cite:<code>olshausen1996emergence</code> remained an open challenge until the advent of modern CNNs.
It was not until :citet:<code>Dean.Corrado.Monga.ea.2012,le2013building</code> that the idea of generating features
from image data automatically gained significant traction.</p>
<p>The first modern CNN :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>, named
<em>AlexNet</em> after one of its inventors, Alex Krizhevsky, is largely an evolutionary improvement
over LeNet. It achieved excellent performance in the 2012 ImageNet challenge.</p>
<p><img src="chapter_convolutional-modern/../img/filters.png" alt="Image filters learned by the first layer of AlexNet. Reproduction courtesy of :citet:Krizhevsky.Sutskever.Hinton.2012." />
:width:<code>400px</code>
:label:<code>fig_filters</code></p>
<p>Interestingly, in the lowest layers of the network,
the model learned feature extractors that resembled some traditional filters.
:numref:<code>fig_filters</code>
shows lower-level image descriptors.
Higher layers in the network might build upon these representations
to represent larger structures, like eyes, noses, blades of grass, and so on.
Even higher layers might represent whole objects
like people, airplanes, dogs, or frisbees.
Ultimately, the final hidden state learns a compact representation
of the image that summarizes its contents
such that data belonging to different categories can be easily separated.</p>
<p>AlexNet (2012) and its precursor LeNet (1995) share many architectural elements. This begs the question: why did it take so long?
A key difference was that, over the previous two decades, the amount of data and the computing power available had increased significantly. As such AlexNet was much larger: it was trained on much more data, and on much faster GPUs compared to the CPUs available in 1995.</p>
<h3 id="missing-ingredient-data"><a class="header" href="#missing-ingredient-data">Missing Ingredient: Data</a></h3>
<p>Deep models with many layers require large amounts of data
in order to enter the regime
where they significantly outperform traditional methods
based on convex optimizations (e.g., linear and kernel methods).
However, given the limited storage capacity of computers,
the relative expense of (imaging) sensors,
and the comparatively tighter research budgets in the 1990s,
most research relied on tiny datasets.
Numerous papers relied on the UCI collection of datasets,
many of which contained only hundreds or (a few) thousands of images
captured in low resolution and often with an artificially clean background.</p>
<p>In 2009, the ImageNet dataset was released :cite:<code>Deng.Dong.Socher.ea.2009</code>,
challenging researchers to learn models from 1 million examples,
1000 each from 1000 distinct categories of objects. The categories themselves
were based on the most popular noun nodes in WordNet :cite:<code>Miller.1995</code>.
The ImageNet team used Google Image Search to prefilter large candidate sets
for each category and employed
the Amazon Mechanical Turk crowdsourcing pipeline
to confirm for each image whether it belonged to the associated category.
This scale was unprecedented, exceeding others by over an order of magnitude
(e.g., CIFAR-100 has 60,000 images). Another aspect was that the images were at
relatively high resolution of $224 \times 224$ pixels, unlike the 80 million-sized
TinyImages dataset :cite:<code>Torralba.Fergus.Freeman.2008</code>, consisting of $32 \times 32$ pixel thumbnails.
This allowed for the formation of higher-level features.
The associated competition, dubbed the ImageNet Large Scale Visual Recognition
Challenge :cite:<code>russakovsky2015imagenet</code>,
pushed computer vision and machine learning research forward,
challenging researchers to identify which models performed best
at a greater scale than academics had previously considered. The largest vision datasets, such as LAION-5B
:cite:<code>schuhmann2022laion</code> contain billions of images with additional metadata.</p>
<h3 id="missing-ingredient-hardware"><a class="header" href="#missing-ingredient-hardware">Missing Ingredient: Hardware</a></h3>
<p>Deep learning models are voracious consumers of compute cycles.
Training can take hundreds of epochs, and each iteration
requires passing data through many layers of computationally expensive
linear algebra operations.
This is one of the main reasons why in the 1990s and early 2000s,
simple algorithms based on the more-efficiently optimized
convex objectives were preferred.</p>
<p><em>Graphical processing units</em> (GPUs) proved to be a game changer
in making deep learning feasible.
These chips had earlier been developed for accelerating
graphics processing to benefit computer games.
In particular, they were optimized for high throughput $4 \times 4$
matrix--vector products, which are needed for many computer graphics tasks.
Fortunately, the math is strikingly similar
to that required for calculating convolutional layers.
Around that time, NVIDIA and ATI had begun optimizing GPUs
for general computing operations :cite:<code>Fernando.2004</code>,
going as far as to market them as <em>general-purpose GPUs</em> (GPGPUs).</p>
<p>To provide some intuition, consider the cores of a modern microprocessor
(CPU).
Each of the cores is fairly powerful running at a high clock frequency
and sporting large caches (up to several megabytes of L3).
Each core is well-suited to executing a wide range of instructions,
with branch predictors, a deep pipeline, specialized execution units,
speculative execution,
and many other bells and whistles
that enable it to run a large variety of programs with sophisticated control flow.
This apparent strength, however, is also its Achilles heel:
general-purpose cores are very expensive to build. They excel at general-purpose
code with lots of control flow.
This requires lots of chip area, not just for the
actual ALU (arithmetic logical unit) where computation happens, but also for
all the aforementioned bells and whistles, plus
memory interfaces, caching logic between cores,
high-speed interconnects, and so on. CPUs are
comparatively bad at any single task when compared with dedicated hardware.
Modern laptops have 4--8 cores,
and even high-end servers rarely exceed 64 cores per socket,
simply because it is not cost-effective.</p>
<p>By comparison, GPUs can consist of thousands of small processing elements (NIVIDA's latest Ampere chips have up to 6912 CUDA cores), often grouped into larger groups (NVIDIA calls them warps).
The details differ somewhat between NVIDIA, AMD, ARM and other chip vendors. While each core is relatively weak,
running at about 1GHz clock frequency,
it is the total number of such cores that makes GPUs orders of magnitude faster than CPUs.
For instance, NVIDIA's recent Ampere A100 GPU offers over 300 TFLOPs per chip for specialized 16-bit precision (BFLOAT16) matrix-matrix multiplications, and up to 20 TFLOPs for more general-purpose floating point operations (FP32).
At the same time, floating point performance of CPUs rarely exceeds 1 TFLOPs. For instance, Amazon's Graviton 3  reaches 2 TFLOPs peak performance for 16-bit precision operations, a number similar to the GPU performance of Apple's M1 processor.</p>
<p>There are many reasons why GPUs are much faster than CPUs in terms of FLOPs.
First, power consumption tends to grow <em>quadratically</em> with clock frequency.
Hence, for the power budget of a CPU core that runs four times faster (a typical number),
you can use 16 GPU cores at $\frac{1}{4}$ the speed,
which yields $16 \times \frac{1}{4} = 4$ times the performance.
Second, GPU cores are much simpler
(in fact, for a long time they were not even <em>able</em>
to execute general-purpose code),
which makes them more energy efficient. For instance, (i) they tend not to support speculative evaluation, (ii) it typically is not possible to program each processing element individually, and (iii) the caches per core tend to be much smaller.
Last, many operations in deep learning require high memory bandwidth.
Again, GPUs shine here with buses that are at least 10 times as wide as many CPUs.</p>
<p>Back to 2012. A major breakthrough came
when Alex Krizhevsky and Ilya Sutskever
implemented a deep CNN
that could run on GPUs.
They realized that the computational bottlenecks in CNNs,
convolutions and matrix multiplications,
are all operations that could be parallelized in hardware.
Using two NVIDIA GTX 580s with 3GB of memory, either of which was capable of 1.5 TFLOPs (still a challenge for most CPUs a decade later),
they implemented fast convolutions.
The <a href="https://code.google.com/archive/p/cuda-convnet/">cuda-convnet</a> code
was good enough that for several years
it was the industry standard and powered
the first couple of years of the deep learning boom.</p>
<h2 id="alexnet"><a class="header" href="#alexnet">AlexNet</a></h2>
<p>AlexNet, which employed an 8-layer CNN,
won the ImageNet Large Scale Visual Recognition Challenge 2012
by a large margin :cite:<code>Russakovsky.Deng.Huang.ea.2013</code>.
This network showed, for the first time,
that the features obtained by learning can transcend manually-designed features, breaking the previous paradigm in computer vision.</p>
<p>The architectures of AlexNet and LeNet are strikingly similar,
as :numref:<code>fig_alexnet</code> illustrates.
Note that we provide a slightly streamlined version of AlexNet
removing some of the design quirks that were needed in 2012
to make the model fit on two small GPUs.</p>
<p><img src="chapter_convolutional-modern/../img/alexnet.svg" alt="From LeNet (left) to AlexNet (right)." />
:label:<code>fig_alexnet</code></p>
<p>There are also significant differences between AlexNet and LeNet.
First, AlexNet is much deeper than the comparatively small LeNet-5.
AlexNet consists of eight layers: five convolutional layers,
two fully connected hidden layers, and one fully connected output layer.
Second, AlexNet used the ReLU instead of the sigmoid
as its activation function. Let's delve into the details below.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>In AlexNet's first layer, the convolution window shape is $11\times11$.
Since the images in ImageNet are eight times taller and wider
than the MNIST images,
objects in ImageNet data tend to occupy more pixels with more visual detail.
Consequently, a larger convolution window is needed to capture the object.
The convolution window shape in the second layer
is reduced to $5\times5$, followed by $3\times3$.
In addition, after the first, second, and fifth convolutional layers,
the network adds max-pooling layers
with a window shape of $3\times3$ and a stride of 2.
Moreover, AlexNet has ten times more convolution channels than LeNet.</p>
<p>After the final convolutional layer, there are two huge fully connected layers
with 4096 outputs.
These layers require nearly 1GB model parameters.
Because of the limited memory in early GPUs,
the original AlexNet used a dual data stream design,
so that each of their two GPUs could be responsible
for storing and computing only its half of the model.
Fortunately, GPU memory is comparatively abundant now,
so we rarely need to break up models across GPUs these days
(our version of the AlexNet model deviates
from the original paper in this aspect).</p>
<h3 id="activation-functions-1"><a class="header" href="#activation-functions-1">Activation Functions</a></h3>
<p>Furthermore, AlexNet changed the sigmoid activation function to a simpler ReLU activation function. On the one hand, the computation of the ReLU activation function is simpler. For example, it does not have the exponentiation operation found in the sigmoid activation function.
On the other hand, the ReLU activation function makes model training easier when using different parameter initialization methods. This is because, when the output of the sigmoid activation function is very close to 0 or 1, the gradient of these regions is almost 0, so that backpropagation cannot continue to update some of the model parameters. By contrast, the gradient of the ReLU activation function in the positive interval is always 1 (:numref:<code>subsec_activation-functions</code>). Therefore, if the model parameters are not properly initialized, the sigmoid function may obtain a gradient of almost 0 in the positive interval, meaning that the model cannot be effectively trained.</p>
<h3 id="capacity-control-and-preprocessing"><a class="header" href="#capacity-control-and-preprocessing">Capacity Control and Preprocessing</a></h3>
<p>AlexNet controls the model complexity of the fully connected layer
by dropout (:numref:<code>sec_dropout</code>),
while LeNet only uses weight decay.
To augment the data even further, the training loop of AlexNet
added a great deal of image augmentation,
such as flipping, clipping, and color changes.
This makes the model more robust and the larger sample size effectively reduces overfitting.
See :citet:<code>Buslaev.Iglovikov.Khvedchenya.ea.2020</code> for an in-depth review of such preprocessing steps.</p>
<pre><code class="language-{.python .input  n=5}">%%tab pytorch, mxnet, tensorflow
class AlexNet(d2l.Classifier):
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            self.net.add(
                nn.Conv2D(96, kernel_size=11, strides=4, activation='relu'),
                nn.MaxPool2D(pool_size=3, strides=2),
                nn.Conv2D(256, kernel_size=5, padding=2, activation='relu'),
                nn.MaxPool2D(pool_size=3, strides=2),
                nn.Conv2D(384, kernel_size=3, padding=1, activation='relu'),
                nn.Conv2D(384, kernel_size=3, padding=1, activation='relu'),
                nn.Conv2D(256, kernel_size=3, padding=1, activation='relu'),
                nn.MaxPool2D(pool_size=3, strides=2),
                nn.Dense(4096, activation='relu'), nn.Dropout(0.5),
                nn.Dense(4096, activation='relu'), nn.Dropout(0.5),
                nn.Dense(num_classes))
            self.net.initialize(init.Xavier())
        if tab.selected('pytorch'):
            self.net = nn.Sequential(
                nn.LazyConv2d(96, kernel_size=11, stride=4, padding=1),
                nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2),
                nn.LazyConv2d(256, kernel_size=5, padding=2), nn.ReLU(),
                nn.MaxPool2d(kernel_size=3, stride=2),
                nn.LazyConv2d(384, kernel_size=3, padding=1), nn.ReLU(),
                nn.LazyConv2d(384, kernel_size=3, padding=1), nn.ReLU(),
                nn.LazyConv2d(256, kernel_size=3, padding=1), nn.ReLU(),
                nn.MaxPool2d(kernel_size=3, stride=2), nn.Flatten(),
                nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(p=0.5),
                nn.LazyLinear(4096), nn.ReLU(),nn.Dropout(p=0.5),
                nn.LazyLinear(num_classes))
            self.net.apply(d2l.init_cnn)
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(filters=96, kernel_size=11, strides=4,
                                       activation='relu'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                tf.keras.layers.Conv2D(filters=256, kernel_size=5, padding='same',
                                       activation='relu'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                tf.keras.layers.Conv2D(filters=384, kernel_size=3, padding='same',
                                       activation='relu'),
                tf.keras.layers.Conv2D(filters=384, kernel_size=3, padding='same',
                                       activation='relu'),
                tf.keras.layers.Conv2D(filters=256, kernel_size=3, padding='same',
                                       activation='relu'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                tf.keras.layers.Flatten(),
                tf.keras.layers.Dense(4096, activation='relu'),
                tf.keras.layers.Dropout(0.5),
                tf.keras.layers.Dense(4096, activation='relu'),
                tf.keras.layers.Dropout(0.5),
                tf.keras.layers.Dense(num_classes)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class AlexNet(d2l.Classifier):
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = nn.Sequential([
            nn.Conv(features=96, kernel_size=(11, 11), strides=4, padding=1),
            nn.relu,
            lambda x: nn.max_pool(x, window_shape=(3, 3), strides=(2, 2)),
            nn.Conv(features=256, kernel_size=(5, 5)),
            nn.relu,
            lambda x: nn.max_pool(x, window_shape=(3, 3), strides=(2, 2)),
            nn.Conv(features=384, kernel_size=(3, 3)), nn.relu,
            nn.Conv(features=384, kernel_size=(3, 3)), nn.relu,
            nn.Conv(features=256, kernel_size=(3, 3)), nn.relu,
            lambda x: nn.max_pool(x, window_shape=(3, 3), strides=(2, 2)),
            lambda x: x.reshape((x.shape[0], -1)),  # flatten
            nn.Dense(features=4096),
            nn.relu,
            nn.Dropout(0.5, deterministic=not self.training),
            nn.Dense(features=4096),
            nn.relu,
            nn.Dropout(0.5, deterministic=not self.training),
            nn.Dense(features=self.num_classes)
        ])
</code></pre>
<p>We [<strong>construct a single-channel data example</strong>] with both height and width of 224 (<strong>to observe the output shape of each layer</strong>). It matches the AlexNet architecture in :numref:<code>fig_alexnet</code>.</p>
<pre><code class="language-{.python .input  n=6}">%%tab pytorch, mxnet
AlexNet().layer_summary((1, 1, 224, 224))
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab tensorflow
AlexNet().layer_summary((1, 224, 224, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
AlexNet(training=False).layer_summary((1, 224, 224, 1))
</code></pre>
<h2 id="training-9"><a class="header" href="#training-9">Training</a></h2>
<p>Although AlexNet was trained on ImageNet in :citet:<code>Krizhevsky.Sutskever.Hinton.2012</code>,
we use Fashion-MNIST here
since training an ImageNet model to convergence could take hours or days
even on a modern GPU.
One of the problems with applying AlexNet directly on [<strong>Fashion-MNIST</strong>]
is that its (<strong>images have lower resolution</strong>) ($28 \times 28$ pixels)
(<strong>than ImageNet images.</strong>)
To make things work, (<strong>we upsample them to $224 \times 224$</strong>).
This is generally not a smart practice, as it simply increases the computational
complexity without adding information. Nonetheless, we do it here to be faithful to the AlexNet architecture.
We perform this resizing with the <code>resize</code> argument in the <code>d2l.FashionMNIST</code> constructor.</p>
<p>Now, we can [<strong>start training AlexNet.</strong>]
Compared to LeNet in :numref:<code>sec_lenet</code>,
the main change here is the use of a smaller learning rate
and much slower training due to the deeper and wider network,
the higher image resolution, and the more costly convolutions.</p>
<pre><code class="language-{.python .input  n=8}">%%tab pytorch, mxnet, jax
model = AlexNet(lr=0.01)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
with d2l.try_gpu():
    model = AlexNet(lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="discussion-6"><a class="header" href="#discussion-6">Discussion</a></h2>
<p>AlexNet's structure bears a striking resemblance to LeNet, with a number of critical improvements, both for accuracy (dropout) and for ease of training (ReLU). What is equally striking is the amount of progress that has been made in terms of deep learning tooling. What was several months of work in 2012 can now be accomplished in a dozen lines of code using any modern framework.</p>
<p>Reviewing the architecture, we see that AlexNet has an Achilles heel when it comes to efficiency: the last two hidden layers require matrices of size $6400 \times 4096$ and $4096 \times 4096$, respectively. This corresponds to 164 MB of memory and 81 MFLOPs of computation, both of which are a nontrivial outlay, especially on smaller devices, such as mobile phones. This is one of the reasons why AlexNet has been surpassed by much more effective architectures that we will cover in the following sections. Nonetheless, it is a key step from shallow to deep networks that are used nowadays. Note that even though the number of parameters exceeds by far the amount of training data in our experiments (the last two layers have more than 40 million parameters, trained on a datasets of 60 thousand images), there is hardly any overfitting: training and validation loss are virtually identical throughout training. This is due to the improved regularization, such as dropout, inherent in modern deep network designs.</p>
<p>Although it seems that there are only a few more lines in AlexNet's implementation than in LeNet's, it took the academic community many years to embrace this conceptual change and take advantage of its excellent experimental results. This was also due to the lack of efficient computational tools. At the time neither DistBelief :cite:<code>Dean.Corrado.Monga.ea.2012</code> nor Caffe :cite:<code>Jia.Shelhamer.Donahue.ea.2014</code> existed, and Theano :cite:<code>Bergstra.Breuleux.Bastien.ea.2010</code> still lacked many distinguishing features. It was the availability of TensorFlow :cite:<code>Abadi.Barham.Chen.ea.2016</code> that dramatically changed the situation.</p>
<h2 id="exercises-42"><a class="header" href="#exercises-42">Exercises</a></h2>
<ol>
<li>Following up on the discussion above, analyze the computational properties of AlexNet.
<ol>
<li>Compute the memory footprint for convolutions and fully connected layers, respectively. Which one dominates?</li>
<li>Calculate the computational cost for the convolutions and the fully connected layers.</li>
<li>How does the memory (read and write bandwidth, latency, size) affect computation? Is there any difference in its effects for training and inference?</li>
</ol>
</li>
<li>You are a chip designer and need to trade off computation and memory bandwidth. For example, a faster chip requires more power and possibly a larger chip area. More memory bandwidth requires more pins and control logic, thus also more area. How do you optimize?</li>
<li>Why do engineers no longer report performance benchmarks on AlexNet?</li>
<li>Try increasing the number of epochs when training AlexNet. Compared with LeNet, how do the results differ? Why?</li>
<li>AlexNet may be too complex for the Fashion-MNIST dataset, in particular due to the low resolution of the initial images.
<ol>
<li>Try simplifying the model to make the training faster, while ensuring that the accuracy does not drop significantly.</li>
<li>Design a better model that works directly on $28 \times 28$ images.</li>
</ol>
</li>
<li>Modify the batch size, and observe the changes in throughput (images/s), accuracy, and GPU memory.</li>
<li>Apply dropout and ReLU to LeNet-5. Does it improve? Can you improve things further by preprocessing to take advantage of the invariances inherent in the images?</li>
<li>Can you make AlexNet overfit? Which feature do you need to remove or change to break training?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/75">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/76">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/276">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18001">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="networks-using-blocks-vgg"><a class="header" href="#networks-using-blocks-vgg">Networks Using Blocks (VGG)</a></h1>
<p>:label:<code>sec_vgg</code></p>
<p>While AlexNet offered empirical evidence that deep CNNs
can achieve good results, it did not provide a general template
to guide subsequent researchers in designing new networks.
In the following sections, we will introduce several heuristic concepts
commonly used to design deep networks.</p>
<p>Progress in this field mirrors that of VLSI (very large scale integration)
in chip design
where engineers moved from placing transistors
to logical elements to logic blocks :cite:<code>Mead.1980</code>.
Similarly, the design of neural network architectures
has grown progressively more abstract,
with researchers moving from thinking in terms of
individual neurons to whole layers,
and now to blocks, repeating patterns of layers. A decade later, this has now
progressed to researchers using entire trained models to repurpose them for different,
albeit related, tasks. Such large pretrained models are typically called
<em>foundation models</em> :cite:<code>bommasani2021opportunities</code>.</p>
<p>Back to network design. The idea of using blocks first emerged from the
Visual Geometry Group (VGG) at Oxford University,
in their eponymously-named <em>VGG</em> network :cite:<code>Simonyan.Zisserman.2014</code>.
It is easy to implement these repeated structures in code
with any modern deep learning framework by using loops and subroutines.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
</code></pre>
<h2 id="vgg-blocks"><a class="header" href="#vgg-blocks">(<strong>VGG Blocks</strong>)</a></h2>
<p>:label:<code>subsec_vgg-blocks</code></p>
<p>The basic building block of CNNs
is a sequence of the following:
(i) a convolutional layer
with padding to maintain the resolution,
(ii) a nonlinearity such as a ReLU,
(iii) a pooling layer such
as max-pooling to reduce the resolution. One of the problems with
this approach is that the spatial resolution decreases quite rapidly. In particular,
this imposes a hard limit of $\log_2 d$ convolutional layers on the network before all
dimensions ($d$) are used up. For instance, in the case of ImageNet, it would be impossible to have
more than 8 convolutional layers in this way.</p>
<p>The key idea of :citet:<code>Simonyan.Zisserman.2014</code> was to use <em>multiple</em> convolutions in between downsampling
via max-pooling in the form of a block. They were primarily interested in whether deep or
wide networks perform better. For instance, the successive application of two $3 \times 3$ convolutions
touches the same pixels as a single $5 \times 5$ convolution does. At the same time, the latter uses approximately
as many parameters ($25 \cdot c^2$) as three $3 \times 3$ convolutions do ($3 \cdot 9 \cdot c^2$).
In a rather detailed analysis they showed that deep and narrow networks significantly outperform their shallow counterparts. This set deep learning on a quest for ever deeper networks with over 100 layers for typical applications.
Stacking $3 \times 3$ convolutions
has become a gold standard in later deep networks (a design decision only to be revisited recently by
:citet:<code>liu2022convnet</code>). Consequently, fast implementations for small convolutions have become a staple on GPUs :cite:<code>lavin2016fast</code>.</p>
<p>Back to VGG: a VGG block consists of a <em>sequence</em> of convolutions with $3\times3$ kernels with padding of 1
(keeping height and width) followed by a $2 \times 2$ max-pooling layer with stride of 2
(halving height and width after each block).
In the code below, we define a function called <code>vgg_block</code>
to implement one VGG block.</p>
<p>The function below takes two arguments,
corresponding to the number of convolutional layers <code>num_convs</code>
and the number of output channels <code>num_channels</code>.</p>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
def vgg_block(num_convs, num_channels):
    blk = nn.Sequential()
    for _ in range(num_convs):
        blk.add(nn.Conv2D(num_channels, kernel_size=3,
                          padding=1, activation='relu'))
    blk.add(nn.MaxPool2D(pool_size=2, strides=2))
    return blk
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
def vgg_block(num_convs, out_channels):
    layers = []
    for _ in range(num_convs):
        layers.append(nn.LazyConv2d(out_channels, kernel_size=3, padding=1))
        layers.append(nn.ReLU())
    layers.append(nn.MaxPool2d(kernel_size=2,stride=2))
    return nn.Sequential(*layers)
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
def vgg_block(num_convs, num_channels):
    blk = tf.keras.models.Sequential()
    for _ in range(num_convs):
        blk.add(
            tf.keras.layers.Conv2D(num_channels, kernel_size=3,
                                   padding='same', activation='relu'))
    blk.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def vgg_block(num_convs, out_channels):
    layers = []
    for _ in range(num_convs):
        layers.append(nn.Conv(out_channels, kernel_size=(3, 3), padding=(1, 1)))
        layers.append(nn.relu)
    layers.append(lambda x: nn.max_pool(x, window_shape=(2, 2), strides=(2, 2)))
    return nn.Sequential(layers)
</code></pre>
<h2 id="vgg-network"><a class="header" href="#vgg-network">[<strong>VGG Network</strong>]</a></h2>
<p>:label:<code>subsec_vgg-network</code></p>
<p>Like AlexNet and LeNet,
the VGG Network can be partitioned into two parts:
the first consisting mostly of convolutional and pooling layers
and the second consisting of fully connected layers that are identical to those in AlexNet.
The key difference is
that the convolutional layers are grouped in nonlinear transformations that
leave the dimensonality unchanged, followed by a resolution-reduction step, as
depicted in :numref:<code>fig_vgg</code>.</p>
<p><img src="chapter_convolutional-modern/../img/vgg.svg" alt="From AlexNet to VGG. The key difference is that VGG consists of blocks of layers, whereas AlexNet&#39;s layers are all designed individually." />
:width:<code>400px</code>
:label:<code>fig_vgg</code></p>
<p>The convolutional part of the network connects several VGG blocks from :numref:<code>fig_vgg</code> (also defined in the <code>vgg_block</code> function)
in succession. This grouping of convolutions is a pattern that has
remained almost unchanged over the past decade, although the specific choice of
operations has undergone considerable modifications.
The variable <code>arch</code> consists of a list of tuples (one per block),
where each contains two values: the number of convolutional layers
and the number of output channels,
which are precisely the arguments required to call
the <code>vgg_block</code> function. As such, VGG defines a <em>family</em> of networks rather than just
a specific manifestation. To build a specific network we simply iterate over <code>arch</code> to compose the blocks.</p>
<pre><code class="language-{.python .input  n=5}">%%tab pytorch, mxnet, tensorflow
class VGG(d2l.Classifier):
    def __init__(self, arch, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            for (num_convs, num_channels) in arch:
                self.net.add(vgg_block(num_convs, num_channels))
            self.net.add(nn.Dense(4096, activation='relu'), nn.Dropout(0.5),
                         nn.Dense(4096, activation='relu'), nn.Dropout(0.5),
                         nn.Dense(num_classes))
            self.net.initialize(init.Xavier())
        if tab.selected('pytorch'):
            conv_blks = []
            for (num_convs, out_channels) in arch:
                conv_blks.append(vgg_block(num_convs, out_channels))
            self.net = nn.Sequential(
                *conv_blks, nn.Flatten(),
                nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(0.5),
                nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(0.5),
                nn.LazyLinear(num_classes))
            self.net.apply(d2l.init_cnn)
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential()
            for (num_convs, num_channels) in arch:
                self.net.add(vgg_block(num_convs, num_channels))
            self.net.add(
                tf.keras.models.Sequential([
                tf.keras.layers.Flatten(),
                tf.keras.layers.Dense(4096, activation='relu'),
                tf.keras.layers.Dropout(0.5),
                tf.keras.layers.Dense(4096, activation='relu'),
                tf.keras.layers.Dropout(0.5),
                tf.keras.layers.Dense(num_classes)]))
</code></pre>
<pre><code class="language-{.python .input  n=5}">%%tab jax
class VGG(d2l.Classifier):
    arch: list
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        conv_blks = []
        for (num_convs, out_channels) in self.arch:
            conv_blks.append(vgg_block(num_convs, out_channels))

        self.net = nn.Sequential([
            *conv_blks,
            lambda x: x.reshape((x.shape[0], -1)),  # flatten
            nn.Dense(4096), nn.relu,
            nn.Dropout(0.5, deterministic=not self.training),
            nn.Dense(4096), nn.relu,
            nn.Dropout(0.5, deterministic=not self.training),
            nn.Dense(self.num_classes)])
</code></pre>
<p>The original VGG network had five convolutional blocks,
among which the first two have one convolutional layer each
and the latter three contain two convolutional layers each.
The first block has 64 output channels
and each subsequent block doubles the number of output channels,
until that number reaches 512.
Since this network uses eight convolutional layers
and three fully connected layers, it is often called VGG-11.</p>
<pre><code class="language-{.python .input  n=6}">%%tab pytorch, mxnet
VGG(arch=((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))).layer_summary(
    (1, 1, 224, 224))
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab tensorflow
VGG(arch=((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))).layer_summary(
    (1, 224, 224, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
VGG(arch=((1, 64), (1, 128), (2, 256), (2, 512), (2, 512)),
    training=False).layer_summary((1, 224, 224, 1))
</code></pre>
<p>As you can see, we halve height and width at each block,
finally reaching a height and width of 7
before flattening the representations
for processing by the fully connected part of the network.
:citet:<code>Simonyan.Zisserman.2014</code> described several other variants of VGG.
In fact, it has become the norm to propose <em>families</em> of networks with
different speed--accuracy trade-off when introducing a new architecture.</p>
<h2 id="training-10"><a class="header" href="#training-10">Training</a></h2>
<p>[<strong>Since VGG-11 is computationally more demanding than AlexNet
we construct a network with a smaller number of channels.</strong>]
This is more than sufficient for training on Fashion-MNIST.
The [<strong>model training</strong>] process is similar to that of AlexNet in :numref:<code>sec_alexnet</code>.
Again observe the close match between validation and training loss,
suggesting only a small amount of overfitting.</p>
<pre><code class="language-{.python .input  n=8}">%%tab mxnet, pytorch, jax
model = VGG(arch=((1, 16), (1, 32), (2, 64), (2, 128), (2, 128)), lr=0.01)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
with d2l.try_gpu():
    model = VGG(arch=((1, 16), (1, 32), (2, 64), (2, 128), (2, 128)), lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="summary-31"><a class="header" href="#summary-31">Summary</a></h2>
<p>One might argue that VGG is the first truly modern convolutional neural network. While AlexNet introduced many of the components of what make deep learning effective at scale, it is VGG that arguably introduced key properties such as blocks of multiple convolutions and a preference for deep and narrow networks. It is also the first network that is actually an entire family of similarly parametrized models, giving the practitioner ample trade-off between complexity and speed. This is also the place where modern deep learning frameworks shine. It is no longer necessary to generate XML configuration files to specify a network but rather, to assemble said networks through simple Python code.</p>
<p>More recently ParNet :cite:<code>Goyal.Bochkovskiy.Deng.ea.2021</code> demonstrated that it is possible to achieve competitive performance using a much more shallow architecture through a large number of parallel computations. This is an exciting development and there is hope that it will influence architecture designs in the future. For the remainder of the chapter, though, we will follow the path of scientific progress over the past decade.</p>
<h2 id="exercises-43"><a class="header" href="#exercises-43">Exercises</a></h2>
<ol>
<li>Compared with AlexNet, VGG is much slower in terms of computation, and it also needs more GPU memory.
<ol>
<li>Compare the number of parameters needed for AlexNet and VGG.</li>
<li>Compare the number of floating point operations used in the convolutional layers and in the fully connected layers.</li>
<li>How could you reduce the computational cost created by the fully connected layers?</li>
</ol>
</li>
<li>When displaying the dimensions associated with the various layers of the network, we only see the information associated with eight blocks (plus some auxiliary transforms), even though the network has 11 layers. Where did the remaining three layers go?</li>
<li>Use Table 1 in the VGG paper :cite:<code>Simonyan.Zisserman.2014</code> to construct other common models, such as VGG-16 or VGG-19.</li>
<li>Upsampling the resolution in Fashion-MNIST eight-fold from $28 \times 28$ to $224 \times 224$ dimensions is very wasteful. Try modifying the network architecture and resolution conversion, e.g., to 56 or to 84 dimensions for its input instead. Can you do so without reducing the accuracy of the network? Consult the VGG paper :cite:<code>Simonyan.Zisserman.2014</code> for ideas on adding more nonlinearities prior to downsampling.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/77">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/78">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/277">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18002">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="network-in-network-nin"><a class="header" href="#network-in-network-nin">Network in Network (NiN)</a></h1>
<p>:label:<code>sec_nin</code></p>
<p>LeNet, AlexNet, and VGG all share a common design pattern:
extract features exploiting <em>spatial</em> structure
via a sequence of convolutions and pooling layers
and post-process the representations via fully connected layers.
The improvements upon LeNet by AlexNet and VGG mainly lie
in how these later networks widen and deepen these two modules.</p>
<p>This design poses two major challenges.
First, the fully connected layers at the end
of the architecture consume tremendous numbers of parameters. For instance, even a simple
model such as VGG-11 requires a monstrous matrix, occupying almost
400MB of RAM in single precision (FP32). This is a significant impediment to computation, in particular on
mobile and embedded devices. After all, even high-end mobile phones sport no more than 8GB of RAM. At the time VGG was invented, this was an order of magnitude less (the iPhone 4S had 512MB). As such, it would have been difficult to justify spending the majority of memory on an image classifier.</p>
<p>Second, it is equally impossible to add fully connected layers
earlier in the network to increase the degree of nonlinearity: doing so would destroy the
spatial structure and require potentially even more memory.</p>
<p>The <em>network in network</em> (<em>NiN</em>) blocks :cite:<code>Lin.Chen.Yan.2013</code> offer an alternative,
capable of solving both problems in one simple strategy.
They were proposed based on a very simple insight: (i) use $1 \times 1$ convolutions to add
local nonlinearities across the channel activations and (ii) use global average pooling to integrate
across all locations in the last representation layer. Note that global average pooling would not
be effective, were it not for the added nonlinearities. Let's dive into this in detail.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="nin-blocks"><a class="header" href="#nin-blocks">(<strong>NiN Blocks</strong>)</a></h2>
<p>Recall :numref:<code>subsec_1x1</code>. In it we said that the inputs and outputs of convolutional layers
consist of four-dimensional tensors with axes
corresponding to the example, channel, height, and width.
Also recall that the inputs and outputs of fully connected layers
are typically two-dimensional tensors corresponding to the example and feature.
The idea behind NiN is to apply a fully connected layer
at each pixel location (for each height and width).
The resulting $1 \times 1$ convolution can be thought of as
a fully connected layer acting independently on each pixel location.</p>
<p>:numref:<code>fig_nin</code> illustrates the main structural
differences between VGG and NiN, and their blocks.
Note both the difference in the NiN blocks (the initial convolution is followed by $1 \times 1$ convolutions, whereas VGG retains $3 \times 3$ convolutions) and at the end where we no longer require a giant fully connected layer.</p>
<p><img src="chapter_convolutional-modern/../img/nin.svg" alt="Comparing the architectures of VGG and NiN, and of their blocks." />
:width:<code>600px</code>
:label:<code>fig_nin</code></p>
<pre><code class="language-{.python .input}">%%tab mxnet
def nin_block(num_channels, kernel_size, strides, padding):
    blk = nn.Sequential()
    blk.add(nn.Conv2D(num_channels, kernel_size, strides, padding,
                      activation='relu'),
            nn.Conv2D(num_channels, kernel_size=1, activation='relu'),
            nn.Conv2D(num_channels, kernel_size=1, activation='relu'))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def nin_block(out_channels, kernel_size, strides, padding):
    return nn.Sequential(
        nn.LazyConv2d(out_channels, kernel_size, strides, padding), nn.ReLU(),
        nn.LazyConv2d(out_channels, kernel_size=1), nn.ReLU(),
        nn.LazyConv2d(out_channels, kernel_size=1), nn.ReLU())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def nin_block(out_channels, kernel_size, strides, padding):
    return tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(out_channels, kernel_size, strides=strides,
                           padding=padding),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.Conv2D(out_channels, 1),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.Conv2D(out_channels, 1),
    tf.keras.layers.Activation('relu')])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def nin_block(out_channels, kernel_size, strides, padding):
    return nn.Sequential([
        nn.Conv(out_channels, kernel_size, strides, padding),
        nn.relu,
        nn.Conv(out_channels, kernel_size=(1, 1)), nn.relu,
        nn.Conv(out_channels, kernel_size=(1, 1)), nn.relu])
</code></pre>
<h2 id="nin-model"><a class="header" href="#nin-model">[<strong>NiN Model</strong>]</a></h2>
<p>NiN uses the same initial convolution sizes as AlexNet (it was proposed shortly thereafter).
The kernel sizes are $11\times 11$, $5\times 5$, and $3\times 3$, respectively,
and the numbers of output channels match those of AlexNet. Each NiN block is followed by a max-pooling layer
with a stride of 2 and a window shape of $3\times 3$.</p>
<p>The second significant difference between NiN and both AlexNet and VGG
is that NiN avoids fully connected layers altogether.
Instead, NiN uses a NiN block with a number of output channels equal to the number of label classes, followed by a <em>global</em> average pooling layer,
yielding a vector of logits.
This design significantly reduces the number of required model parameters, albeit at the expense of a potential increase in training time.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class NiN(d2l.Classifier):
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            self.net.add(
                nin_block(96, kernel_size=11, strides=4, padding=0),
                nn.MaxPool2D(pool_size=3, strides=2),
                nin_block(256, kernel_size=5, strides=1, padding=2),
                nn.MaxPool2D(pool_size=3, strides=2),
                nin_block(384, kernel_size=3, strides=1, padding=1),
                nn.MaxPool2D(pool_size=3, strides=2),
                nn.Dropout(0.5),
                nin_block(num_classes, kernel_size=3, strides=1, padding=1),
                nn.GlobalAvgPool2D(),
                nn.Flatten())
            self.net.initialize(init.Xavier())
        if tab.selected('pytorch'):
            self.net = nn.Sequential(
                nin_block(96, kernel_size=11, strides=4, padding=0),
                nn.MaxPool2d(3, stride=2),
                nin_block(256, kernel_size=5, strides=1, padding=2),
                nn.MaxPool2d(3, stride=2),
                nin_block(384, kernel_size=3, strides=1, padding=1),
                nn.MaxPool2d(3, stride=2),
                nn.Dropout(0.5),
                nin_block(num_classes, kernel_size=3, strides=1, padding=1),
                nn.AdaptiveAvgPool2d((1, 1)),
                nn.Flatten())
            self.net.apply(d2l.init_cnn)
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential([
                nin_block(96, kernel_size=11, strides=4, padding='valid'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                nin_block(256, kernel_size=5, strides=1, padding='same'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                nin_block(384, kernel_size=3, strides=1, padding='same'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2),
                tf.keras.layers.Dropout(0.5),
                nin_block(num_classes, kernel_size=3, strides=1, padding='same'),
                tf.keras.layers.GlobalAvgPool2D(),
                tf.keras.layers.Flatten()])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class NiN(d2l.Classifier):
    lr: float = 0.1
    num_classes = 10
    training: bool = True

    def setup(self):
        self.net = nn.Sequential([
            nin_block(96, kernel_size=(11, 11), strides=(4, 4), padding=(0, 0)),
            lambda x: nn.max_pool(x, (3, 3), strides=(2, 2)),
            nin_block(256, kernel_size=(5, 5), strides=(1, 1), padding=(2, 2)),
            lambda x: nn.max_pool(x, (3, 3), strides=(2, 2)),
            nin_block(384, kernel_size=(3, 3), strides=(1, 1), padding=(1, 1)),
            lambda x: nn.max_pool(x, (3, 3), strides=(2, 2)),
            nn.Dropout(0.5, deterministic=not self.training),
            nin_block(self.num_classes, kernel_size=(3, 3), strides=1, padding=(1, 1)),
            lambda x: nn.avg_pool(x, (5, 5)),  # global avg pooling
            lambda x: x.reshape((x.shape[0], -1))  # flatten
        ])
</code></pre>
<p>We create a data example to see [<strong>the output shape of each block</strong>].</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
NiN().layer_summary((1, 1, 224, 224))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
NiN().layer_summary((1, 224, 224, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
NiN(training=False).layer_summary((1, 224, 224, 1))
</code></pre>
<h2 id="training-11"><a class="header" href="#training-11">[<strong>Training</strong>]</a></h2>
<p>As before we use Fashion-MNIST to train the model using the same
optimizer that we used for AlexNet and VGG.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
model = NiN(lr=0.05)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(224, 224))
with d2l.try_gpu():
    model = NiN(lr=0.05)
    trainer.fit(model, data)
</code></pre>
<h2 id="summary-32"><a class="header" href="#summary-32">Summary</a></h2>
<p>NiN has dramatically fewer parameters than AlexNet and VGG. This stems primarily from the fact that it needs no giant fully connected layers. Instead, it uses global average pooling to aggregate across all image locations after the last stage of the network body. This obviates the need for expensive (learned) reduction operations and replaces them by a simple average. What surprised researchers at the time was the fact that this averaging operation did not harm accuracy. Note that averaging across a low-resolution representation (with many channels) also adds to the amount of translation invariance that the network can handle.</p>
<p>Choosing fewer convolutions with wide kernels and replacing them by $1 \times 1$ convolutions aids the quest for fewer parameters further. It can cater for a significant amount of nonlinearity across channels within any given location. Both $1 \times 1$ convolutions and global average pooling significantly influenced subsequent CNN designs.</p>
<h2 id="exercises-44"><a class="header" href="#exercises-44">Exercises</a></h2>
<ol>
<li>Why are there two $1\times 1$ convolutional layers per NiN block? Increase their number to three. Reduce their number to one. What changes?</li>
<li>What changes if you replace the $1 \times 1$ convolutions by $3 \times 3$ convolutions?</li>
<li>What happens if you replace the global average pooling by a fully connected layer (speed, accuracy, number of parameters)?</li>
<li>Calculate the resource usage for NiN.
<ol>
<li>What is the number of parameters?</li>
<li>What is the amount of computation?</li>
<li>What is the amount of memory needed during training?</li>
<li>What is the amount of memory needed during prediction?</li>
</ol>
</li>
<li>What are possible problems with reducing the $384 \times 5 \times 5$ representation to a $10 \times 5 \times 5$ representation in one step?</li>
<li>Use the structural design decisions in VGG that led to VGG-11, VGG-16, and VGG-19 to design a family of NiN-like networks.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/79">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/80">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18003">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="multi-branch-networks--googlenet"><a class="header" href="#multi-branch-networks--googlenet">Multi-Branch Networks  (GoogLeNet)</a></h1>
<p>:label:<code>sec_googlenet</code></p>
<p>In 2014, <em>GoogLeNet</em>
won the ImageNet Challenge :cite:<code>Szegedy.Liu.Jia.ea.2015</code>, using a structure
that combined the strengths of NiN :cite:<code>Lin.Chen.Yan.2013</code>, repeated blocks :cite:<code>Simonyan.Zisserman.2014</code>,
and a cocktail of convolution kernels. It was arguably also the first network that exhibited a clear distinction among the stem (data ingest), body (data processing), and head (prediction) in a CNN. This design pattern has persisted ever since in the design of deep networks: the <em>stem</em> is given by the first two or three convolutions that operate on the image. They extract low-level features from the underlying images. This is followed by a <em>body</em> of convolutional blocks. Finally, the <em>head</em> maps the features obtained so far to the required classification, segmentation, detection, or tracking problem at hand.</p>
<p>The key contribution in GoogLeNet was the design of the network body. It solved the problem of selecting
convolution kernels in an ingenious way. While other works tried to identify which convolution, ranging from $1 \times 1$ to $11 \times 11$ would be best, it simply <em>concatenated</em> multi-branch convolutions.
In what follows we introduce a slightly simplified version of GoogLeNet: the original design included a number of tricks for stabilizing training through intermediate loss functions, applied to multiple layers of the network.
They are no longer necessary due to the availability of improved training algorithms.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="inception-blocks"><a class="header" href="#inception-blocks">(<strong>Inception Blocks</strong>)</a></h2>
<p>The basic convolutional block in GoogLeNet is called an <em>Inception block</em>,
stemming from the meme "we need to go deeper" from the movie <em>Inception</em>.</p>
<p><img src="chapter_convolutional-modern/../img/inception.svg" alt="Structure of the Inception block." />
:label:<code>fig_inception</code></p>
<p>As depicted in :numref:<code>fig_inception</code>,
the inception block consists of four parallel branches.
The first three branches use convolutional layers
with window sizes of $1\times 1$, $3\times 3$, and $5\times 5$
to extract information from different spatial sizes.
The middle two branches also add a $1\times 1$ convolution of the input
to reduce the number of channels, reducing the model's complexity.
The fourth branch uses a $3\times 3$ max-pooling layer,
followed by a $1\times 1$ convolutional layer
to change the number of channels.
The four branches all use appropriate padding to give the input and output the same height and width.
Finally, the outputs along each branch are concatenated
along the channel dimension and comprise the block's output.
The commonly-tuned hyperparameters of the Inception block
are the number of output channels per layer, i.e., how to allocate capacity among convolutions of different size.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Inception(nn.Block):
    # c1--c4 are the number of output channels for each branch
    def __init__(self, c1, c2, c3, c4, **kwargs):
        super(Inception, self).__init__(**kwargs)
        # Branch 1
        self.b1_1 = nn.Conv2D(c1, kernel_size=1, activation='relu')
        # Branch 2
        self.b2_1 = nn.Conv2D(c2[0], kernel_size=1, activation='relu')
        self.b2_2 = nn.Conv2D(c2[1], kernel_size=3, padding=1,
                              activation='relu')
        # Branch 3
        self.b3_1 = nn.Conv2D(c3[0], kernel_size=1, activation='relu')
        self.b3_2 = nn.Conv2D(c3[1], kernel_size=5, padding=2,
                              activation='relu')
        # Branch 4
        self.b4_1 = nn.MaxPool2D(pool_size=3, strides=1, padding=1)
        self.b4_2 = nn.Conv2D(c4, kernel_size=1, activation='relu')

    def forward(self, x):
        b1 = self.b1_1(x)
        b2 = self.b2_2(self.b2_1(x))
        b3 = self.b3_2(self.b3_1(x))
        b4 = self.b4_2(self.b4_1(x))
        return np.concatenate((b1, b2, b3, b4), axis=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Inception(nn.Module):
    # c1--c4 are the number of output channels for each branch
    def __init__(self, c1, c2, c3, c4, **kwargs):
        super(Inception, self).__init__(**kwargs)
        # Branch 1
        self.b1_1 = nn.LazyConv2d(c1, kernel_size=1)
        # Branch 2
        self.b2_1 = nn.LazyConv2d(c2[0], kernel_size=1)
        self.b2_2 = nn.LazyConv2d(c2[1], kernel_size=3, padding=1)
        # Branch 3
        self.b3_1 = nn.LazyConv2d(c3[0], kernel_size=1)
        self.b3_2 = nn.LazyConv2d(c3[1], kernel_size=5, padding=2)
        # Branch 4
        self.b4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1)
        self.b4_2 = nn.LazyConv2d(c4, kernel_size=1)

    def forward(self, x):
        b1 = F.relu(self.b1_1(x))
        b2 = F.relu(self.b2_2(F.relu(self.b2_1(x))))
        b3 = F.relu(self.b3_2(F.relu(self.b3_1(x))))
        b4 = F.relu(self.b4_2(self.b4_1(x)))
        return torch.cat((b1, b2, b3, b4), dim=1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Inception(tf.keras.Model):
    # c1--c4 are the number of output channels for each branch
    def __init__(self, c1, c2, c3, c4):
        super().__init__()
        self.b1_1 = tf.keras.layers.Conv2D(c1, 1, activation='relu')
        self.b2_1 = tf.keras.layers.Conv2D(c2[0], 1, activation='relu')
        self.b2_2 = tf.keras.layers.Conv2D(c2[1], 3, padding='same',
                                           activation='relu')
        self.b3_1 = tf.keras.layers.Conv2D(c3[0], 1, activation='relu')
        self.b3_2 = tf.keras.layers.Conv2D(c3[1], 5, padding='same',
                                           activation='relu')
        self.b4_1 = tf.keras.layers.MaxPool2D(3, 1, padding='same')
        self.b4_2 = tf.keras.layers.Conv2D(c4, 1, activation='relu')

    def call(self, x):
        b1 = self.b1_1(x)
        b2 = self.b2_2(self.b2_1(x))
        b3 = self.b3_2(self.b3_1(x))
        b4 = self.b4_2(self.b4_1(x))
        return tf.keras.layers.Concatenate()([b1, b2, b3, b4])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Inception(nn.Module):
    # `c1`--`c4` are the number of output channels for each branch
    c1: int
    c2: tuple
    c3: tuple
    c4: int

    def setup(self):
        # Branch 1
        self.b1_1 = nn.Conv(self.c1, kernel_size=(1, 1))
        # Branch 2
        self.b2_1 = nn.Conv(self.c2[0], kernel_size=(1, 1))
        self.b2_2 = nn.Conv(self.c2[1], kernel_size=(3, 3), padding='same')
        # Branch 3
        self.b3_1 = nn.Conv(self.c3[0], kernel_size=(1, 1))
        self.b3_2 = nn.Conv(self.c3[1], kernel_size=(5, 5), padding='same')
        # Branch 4
        self.b4_1 = lambda x: nn.max_pool(x, window_shape=(3, 3),
                                          strides=(1, 1), padding='same')
        self.b4_2 = nn.Conv(self.c4, kernel_size=(1, 1))

    def __call__(self, x):
        b1 = nn.relu(self.b1_1(x))
        b2 = nn.relu(self.b2_2(nn.relu(self.b2_1(x))))
        b3 = nn.relu(self.b3_2(nn.relu(self.b3_1(x))))
        b4 = nn.relu(self.b4_2(self.b4_1(x)))
        return jnp.concatenate((b1, b2, b3, b4), axis=-1)
</code></pre>
<p>To gain some intuition for why this network works so well,
consider the combination of the filters.
They explore the image in a variety of filter sizes.
This means that details at different extents
can be recognized efficiently by filters of different sizes.
At the same time, we can allocate different amounts of parameters
for different filters.</p>
<h2 id="googlenet-model"><a class="header" href="#googlenet-model">[<strong>GoogLeNet Model</strong>]</a></h2>
<p>As shown in :numref:<code>fig_inception_full</code>, GoogLeNet uses a stack of a total of 9 inception blocks, arranged into three groups with max-pooling in between,
and global average pooling in its head to generate its estimates.
Max-pooling between inception blocks reduces the dimensionality.
At its stem, the first module is similar to AlexNet and LeNet.</p>
<p><img src="chapter_convolutional-modern/../img/inception-full-90.svg" alt="The GoogLeNet architecture." />
:label:<code>fig_inception_full</code></p>
<p>We can now implement GoogLeNet piece by piece. Let's begin with the stem.
The first module uses a 64-channel $7\times 7$ convolutional layer.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class GoogleNet(d2l.Classifier):
    def b1(self):
        if tab.selected('mxnet'):
            net = nn.Sequential()
            net.add(nn.Conv2D(64, kernel_size=7, strides=2, padding=3,
                              activation='relu'),
                    nn.MaxPool2D(pool_size=3, strides=2, padding=1))
            return net
        if tab.selected('pytorch'):
            return nn.Sequential(
                nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3),
                nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
        if tab.selected('tensorflow'):
            return tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(64, 7, strides=2, padding='same',
                                       activation='relu'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2,
                                          padding='same')])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class GoogleNet(d2l.Classifier):
    lr: float = 0.1
    num_classes: int = 10

    def setup(self):
        self.net = nn.Sequential([self.b1(), self.b2(), self.b3(), self.b4(),
                                  self.b5(), nn.Dense(self.num_classes)])

    def b1(self):
        return nn.Sequential([
                nn.Conv(64, kernel_size=(7, 7), strides=(2, 2), padding='same'),
                nn.relu,
                lambda x: nn.max_pool(x, window_shape=(3, 3), strides=(2, 2),
                                      padding='same')])
</code></pre>
<p>The second module uses two convolutional layers:
first, a 64-channel $1\times 1$ convolutional layer,
followed by a $3\times 3$ convolutional layer that triples the number of channels. This corresponds to the second branch in the Inception block and concludes the design of the body. At this point we have 192 channels.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(GoogleNet)
def b2(self):
    if tab.selected('mxnet'):
        net = nn.Sequential()
        net.add(nn.Conv2D(64, kernel_size=1, activation='relu'),
               nn.Conv2D(192, kernel_size=3, padding=1, activation='relu'),
               nn.MaxPool2D(pool_size=3, strides=2, padding=1))
        return net
    if tab.selected('pytorch'):
        return nn.Sequential(
            nn.LazyConv2d(64, kernel_size=1), nn.ReLU(),
            nn.LazyConv2d(192, kernel_size=3, padding=1), nn.ReLU(),
            nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
    if tab.selected('tensorflow'):
        return tf.keras.Sequential([
            tf.keras.layers.Conv2D(64, 1, activation='relu'),
            tf.keras.layers.Conv2D(192, 3, padding='same', activation='relu'),
            tf.keras.layers.MaxPool2D(pool_size=3, strides=2, padding='same')])
    if tab.selected('jax'):
        return nn.Sequential([nn.Conv(64, kernel_size=(1, 1)),
                              nn.relu,
                              nn.Conv(192, kernel_size=(3, 3), padding='same'),
                              nn.relu,
                              lambda x: nn.max_pool(x, window_shape=(3, 3),
                                                    strides=(2, 2),
                                                    padding='same')])
</code></pre>
<p>The third module connects two complete Inception blocks in series.
The number of output channels of the first Inception block is
$64+128+32+32=256$. This amounts to
a ratio of the number of output channels
among the four branches of $2:4:1:1$. To achieve this, we first reduce the input
dimensions by $\frac{1}{2}$ and by $\frac{1}{12}$ in the second and third branch respectively
to arrive at $96 = 192/2$ and $16 = 192/12$ channels respectively.</p>
<p>The number of output channels of the second Inception block
is increased to $128+192+96+64=480$, yielding a ratio of $128:192:96:64 = 4:6:3:2$. As before,
we need to reduce the number of intermediate dimensions in the second and third channel. A
scale of $\frac{1}{2}$ and $\frac{1}{8}$ respectively suffices, yielding $128$ and $32$ channels
respectively. This is captured by the arguments of the following <code>Inception</code> block constructors.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(GoogleNet)
def b3(self):
    if tab.selected('mxnet'):
        net = nn.Sequential()
        net.add(Inception(64, (96, 128), (16, 32), 32),
               Inception(128, (128, 192), (32, 96), 64),
               nn.MaxPool2D(pool_size=3, strides=2, padding=1))
        return net
    if tab.selected('pytorch'):
        return nn.Sequential(Inception(64, (96, 128), (16, 32), 32),
                             Inception(128, (128, 192), (32, 96), 64),
                             nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
    if tab.selected('tensorflow'):
        return tf.keras.models.Sequential([
            Inception(64, (96, 128), (16, 32), 32),
            Inception(128, (128, 192), (32, 96), 64),
            tf.keras.layers.MaxPool2D(pool_size=3, strides=2, padding='same')])
    if tab.selected('jax'):
        return nn.Sequential([Inception(64, (96, 128), (16, 32), 32),
                              Inception(128, (128, 192), (32, 96), 64),
                              lambda x: nn.max_pool(x, window_shape=(3, 3),
                                                    strides=(2, 2),
                                                    padding='same')])
</code></pre>
<p>The fourth module is more complicated.
It connects five Inception blocks in series,
and they have $192+208+48+64=512$, $160+224+64+64=512$,
$128+256+64+64=512$, $112+288+64+64=528$,
and $256+320+128+128=832$ output channels, respectively.
The number of channels assigned to these branches is similar
to that in the third module:
the second branch with the $3\times 3$ convolutional layer
outputs the largest number of channels,
followed by the first branch with only the $1\times 1$ convolutional layer,
the third branch with the $5\times 5$ convolutional layer,
and the fourth branch with the $3\times 3$ max-pooling layer.
The second and third branches will first reduce
the number of channels according to the ratio.
These ratios are slightly different in different Inception blocks.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(GoogleNet)
def b4(self):
    if tab.selected('mxnet'):
        net = nn.Sequential()
        net.add(Inception(192, (96, 208), (16, 48), 64),
                Inception(160, (112, 224), (24, 64), 64),
                Inception(128, (128, 256), (24, 64), 64),
                Inception(112, (144, 288), (32, 64), 64),
                Inception(256, (160, 320), (32, 128), 128),
                nn.MaxPool2D(pool_size=3, strides=2, padding=1))
        return net
    if tab.selected('pytorch'):
        return nn.Sequential(Inception(192, (96, 208), (16, 48), 64),
                             Inception(160, (112, 224), (24, 64), 64),
                             Inception(128, (128, 256), (24, 64), 64),
                             Inception(112, (144, 288), (32, 64), 64),
                             Inception(256, (160, 320), (32, 128), 128),
                             nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
    if tab.selected('tensorflow'):
        return tf.keras.Sequential([
            Inception(192, (96, 208), (16, 48), 64),
            Inception(160, (112, 224), (24, 64), 64),
            Inception(128, (128, 256), (24, 64), 64),
            Inception(112, (144, 288), (32, 64), 64),
            Inception(256, (160, 320), (32, 128), 128),
            tf.keras.layers.MaxPool2D(pool_size=3, strides=2, padding='same')])
    if tab.selected('jax'):
        return nn.Sequential([Inception(192, (96, 208), (16, 48), 64),
                              Inception(160, (112, 224), (24, 64), 64),
                              Inception(128, (128, 256), (24, 64), 64),
                              Inception(112, (144, 288), (32, 64), 64),
                              Inception(256, (160, 320), (32, 128), 128),
                              lambda x: nn.max_pool(x, window_shape=(3, 3),
                                                    strides=(2, 2),
                                                    padding='same')])
</code></pre>
<p>The fifth module has two Inception blocks with $256+320+128+128=832$
and $384+384+128+128=1024$ output channels.
The number of channels assigned to each branch
is the same as that in the third and fourth modules,
but differs in specific values.
It should be noted that the fifth block is followed by the output layer.
This block uses the global average pooling layer
to change the height and width of each channel to 1, just as in NiN.
Finally, we turn the output into a two-dimensional array
followed by a fully connected layer
whose number of outputs is the number of label classes.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(GoogleNet)
def b5(self):
    if tab.selected('mxnet'):
        net = nn.Sequential()
        net.add(Inception(256, (160, 320), (32, 128), 128),
                Inception(384, (192, 384), (48, 128), 128),
                nn.GlobalAvgPool2D())
        return net
    if tab.selected('pytorch'):
        return nn.Sequential(Inception(256, (160, 320), (32, 128), 128),
                             Inception(384, (192, 384), (48, 128), 128),
                             nn.AdaptiveAvgPool2d((1,1)), nn.Flatten())
    if tab.selected('tensorflow'):
        return tf.keras.Sequential([
            Inception(256, (160, 320), (32, 128), 128),
            Inception(384, (192, 384), (48, 128), 128),
            tf.keras.layers.GlobalAvgPool2D(),
            tf.keras.layers.Flatten()])
    if tab.selected('jax'):
        return nn.Sequential([Inception(256, (160, 320), (32, 128), 128),
                              Inception(384, (192, 384), (48, 128), 128),
                              # Flax does not provide a GlobalAvgPool2D layer
                              lambda x: nn.avg_pool(x,
                                                    window_shape=x.shape[1:3],
                                                    strides=x.shape[1:3],
                                                    padding='valid'),
                              lambda x: x.reshape((x.shape[0], -1))])
</code></pre>
<p>Now that we defined all blocks <code>b1</code> through <code>b5</code>, it is just a matter of assembling them all into a full network.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(GoogleNet)
def __init__(self, lr=0.1, num_classes=10):
    super(GoogleNet, self).__init__()
    self.save_hyperparameters()
    if tab.selected('mxnet'):
        self.net = nn.Sequential()
        self.net.add(self.b1(), self.b2(), self.b3(), self.b4(), self.b5(),
                     nn.Dense(num_classes))
        self.net.initialize(init.Xavier())
    if tab.selected('pytorch'):
        self.net = nn.Sequential(self.b1(), self.b2(), self.b3(), self.b4(),
                                 self.b5(), nn.LazyLinear(num_classes))
        self.net.apply(d2l.init_cnn)
    if tab.selected('tensorflow'):
        self.net = tf.keras.Sequential([
            self.b1(), self.b2(), self.b3(), self.b4(), self.b5(),
            tf.keras.layers.Dense(num_classes)])
</code></pre>
<p>The GoogLeNet model is computationally complex. Note the large number of
relatively arbitrary hyperparameters in terms of the number of channels chosen, the number of blocks prior to dimensionality reduction, the relative partitioning of capacity across channels, etc. Much of it is due to the
fact that at the time when GoogLeNet was introduced, automatic tools for network definition or design exploration
were not yet available. For instance, by now we take it for granted that a competent deep learning framework is capable of inferring dimensionalities of input tensors automatically. At the time, many such configurations had to be specified explicitly by the experimenter, thus often slowing down active experimentation. Moreover, the tools needed for automatic exploration were still in flux and initial experiments largely amounted to costly brute-force exploration, genetic algorithms, and similar strategies.</p>
<p>For now the only modification we will carry out is to
[<strong>reduce the input height and width from 224 to 96
to have a reasonable training time on Fashion-MNIST.</strong>]
This simplifies the computation. Let's have a look at the
changes in the shape of the output between the various modules.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
model = GoogleNet().layer_summary((1, 1, 96, 96))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow, jax
model = GoogleNet().layer_summary((1, 96, 96, 1))
</code></pre>
<h2 id="training-12"><a class="header" href="#training-12">[<strong>Training</strong>]</a></h2>
<p>As before, we train our model using the Fashion-MNIST dataset.
We transform it to $96 \times 96$ pixel resolution
before invoking the training procedure.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
model = GoogleNet(lr=0.01)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
with d2l.try_gpu():
    model = GoogleNet(lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="discussion-7"><a class="header" href="#discussion-7">Discussion</a></h2>
<p>A key feature of GoogLeNet is that it is actually <em>cheaper</em> to compute than its predecessors
while simultaneously providing improved accuracy. This marks the beginning of a much more deliberate
network design that trades off the cost of evaluating a network with a reduction in errors. It also marks the beginning of experimentation at a block level with network design hyperparameters, even though it was entirely manual at the time. We will revisit this topic in :numref:<code>sec_cnn-design</code> when discussing strategies for network structure exploration.</p>
<p>Over the following sections we will encounter a number of design choices (e.g., batch normalization, residual connections, and channel grouping) that allow us to improve networks significantly. For now, you can be proud to have implemented what is arguably the first truly modern CNN.</p>
<h2 id="exercises-45"><a class="header" href="#exercises-45">Exercises</a></h2>
<ol>
<li>GoogLeNet was so successful that it went through a number of iterations, progressively improving speed and accuracy. Try to implement and run some of them. They include the following:
<ol>
<li>Add a batch normalization layer :cite:<code>Ioffe.Szegedy.2015</code>, as described later in :numref:<code>sec_batch_norm</code>.</li>
<li>Make adjustments to the Inception block (width, choice and order of convolutions), as described in :citet:<code>Szegedy.Vanhoucke.Ioffe.ea.2016</code>.</li>
<li>Use label smoothing for model regularization, as described in :citet:<code>Szegedy.Vanhoucke.Ioffe.ea.2016</code>.</li>
<li>Make further adjustments to the Inception block by adding residual connection :cite:<code>Szegedy.Ioffe.Vanhoucke.ea.2017</code>, as described later in :numref:<code>sec_resnet</code>.</li>
</ol>
</li>
<li>What is the minimum image size needed for GoogLeNet to work?</li>
<li>Can you design a variant of GoogLeNet that works on Fashion-MNIST's native resolution of $28 \times 28$ pixels? How would you need to change the stem, the body, and the head of the network, if anything at all?</li>
<li>Compare the model parameter sizes of AlexNet, VGG, NiN, and GoogLeNet. How do the latter two network
architectures significantly reduce the model parameter size?</li>
<li>Compare the amount of computation needed in GoogLeNet and AlexNet. How does this affect the design of an accelerator chip, e.g., in terms of memory size, memory bandwidth, cache size, the amount of computation, and the benefit of specialized operations?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/81">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/82">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/316">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18004">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="batch-normalization"><a class="header" href="#batch-normalization">Batch Normalization</a></h1>
<p>:label:<code>sec_batch_norm</code></p>
<p>Training deep neural networks is difficult.
Getting them to converge in a reasonable amount of time can be tricky.
In this section, we describe <em>batch normalization</em>, a popular and effective technique
that consistently accelerates the convergence of deep networks :cite:<code>Ioffe.Szegedy.2015</code>.
Together with residual blocks---covered later in :numref:<code>sec_resnet</code>---batch normalization
has made it possible for practitioners to routinely train networks with over 100 layers.
A secondary (serendipitous) benefit of batch normalization lies in its inherent regularization.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, np, npx, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from functools import partial
from jax import numpy as jnp
import jax
import optax
</code></pre>
<h2 id="training-deep-networks"><a class="header" href="#training-deep-networks">Training Deep Networks</a></h2>
<p>When working with data, we often preprocess before training.
Choices regarding data preprocessing often make an enormous difference in the final results.
Recall our application of MLPs to predicting house prices (:numref:<code>sec_kaggle_house</code>).
Our first step when working with real data
was to standardize our input features to have
zero mean $\boldsymbol{\mu} = 0$ and unit variance $\boldsymbol{\Sigma} = \boldsymbol{1}$ across multiple observations :cite:<code>friedman1987exploratory</code>, frequently rescaling the latter so  that the diagonal is unity, i.e., $\Sigma_{ii} = 1$.
Yet another strategy is to rescale vectors to unit length, possibly zero mean <em>per observation</em>.
This can work well, e.g., for spatial sensor data. These preprocessing techniques and many others, are
beneficial for keeping the estimation problem well controlled.
For a review of feature selection and extraction see the article of :citet:<code>guyon2008feature</code>, for example.
Standardizing vectors also has the nice side-effect of constraining the function complexity of functions that act upon it. For instance, the celebrated radius-margin bound :cite:<code>Vapnik95</code> in support vector machines and the Perceptron Convergence Theorem :cite:<code>Novikoff62</code> rely on inputs of bounded norm.</p>
<p>Intuitively, this standardization plays nicely with our optimizers
since it puts the parameters <em>a priori</em> on a similar scale.
As such, it is only natural to ask whether a corresponding normalization step <em>inside</em> a deep network
might not be beneficial. While this is not quite the reasoning that led to the invention of batch normalization :cite:<code>Ioffe.Szegedy.2015</code>, it is a useful way of understanding it and its cousin, layer normalization :cite:<code>Ba.Kiros.Hinton.2016</code>, within a unified framework.</p>
<p>Second, for a typical MLP or CNN, as we train,
the variables
in intermediate layers (e.g., affine transformation outputs in MLP)
may take values with widely varying magnitudes:
whether along the layers from input to output, across units in the same layer,
and over time due to our updates to the model parameters.
The inventors of batch normalization postulated informally
that this drift in the distribution of such variables could hamper the convergence of the network.
Intuitively, we might conjecture that if one
layer has variable activations that are 100 times that of another layer,
this might necessitate compensatory adjustments in the learning rates. Adaptive solvers
such as AdaGrad :cite:<code>Duchi.Hazan.Singer.2011</code>, Adam :cite:<code>Kingma.Ba.2014</code>, Yogi :cite:<code>Zaheer.Reddi.Sachan.ea.2018</code>, or Distributed Shampoo :cite:<code>anil2020scalable</code> aim to address this from the viewpoint of optimization, e.g., by adding aspects of second-order methods.
The alternative is to prevent the problem from occurring, simply by adaptive normalization.</p>
<p>Third, deeper networks are complex and tend to be more liable to overfitting.
This means that regularization becomes more critical. A common technique for regularization is noise
injection. This has been known for a long time, e.g., with regard to noise injection for the
inputs :cite:<code>Bishop.1995</code>. It also forms the basis of dropout in :numref:<code>sec_dropout</code>. As it turns out, quite serendipitously, batch normalization conveys all three benefits: preprocessing, numerical stability, and regularization.</p>
<p>Batch normalization is applied to individual layers, or optionally, to all of them:
In each training iteration,
we first normalize the inputs (of batch normalization)
by subtracting their mean and
dividing by their standard deviation,
where both are estimated based on the statistics of the current minibatch.
Next, we apply a scale coefficient and an offset to recover the lost degrees
of freedom. It is precisely due to this <em>normalization</em> based on <em>batch</em> statistics
that <em>batch normalization</em> derives its name.</p>
<p>Note that if we tried to apply batch normalization with minibatches of size 1,
we would not be able to learn anything.
That is because after subtracting the means,
each hidden unit would take value 0.
As you might guess, since we are devoting a whole section to batch normalization,
with large enough minibatches the approach proves effective and stable.
One takeaway here is that when applying batch normalization,
the choice of batch size is
even more significant than without batch normalization, or at least,
suitable calibration is needed as we might adjust batch size.</p>
<p>Denote by $\mathcal{B}$ a minibatch and let $\mathbf{x} \in \mathcal{B}$ be an input to
batch normalization ($\textrm{BN}$). In this case the batch normalization is defined as follows:</p>
<p>$$\textrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}<em>\mathcal{B}}{\hat{\boldsymbol{\sigma}}</em>\mathcal{B}} + \boldsymbol{\beta}.$$
:eqlabel:<code>eq_batchnorm</code></p>
<p>In :eqref:<code>eq_batchnorm</code>,
$\hat{\boldsymbol{\mu}}<em>\mathcal{B}$ is the  sample mean
and $\hat{\boldsymbol{\sigma}}</em>\mathcal{B}$ is the sample standard deviation of the minibatch $\mathcal{B}$.
After applying standardization,
the resulting minibatch
has zero mean and unit variance.
The choice of unit variance
(rather than some other magic number) is arbitrary. We recover this degree of freedom
by including an elementwise
<em>scale parameter</em> $\boldsymbol{\gamma}$ and <em>shift parameter</em> $\boldsymbol{\beta}$
that have the same shape as $\mathbf{x}$. Both are parameters that
need to be learned as part of model training.</p>
<p>The variable magnitudes
for intermediate layers cannot diverge during training
since batch normalization actively centers and rescales them back
to a given mean and size (via $\hat{\boldsymbol{\mu}}<em>\mathcal{B}$ and ${\hat{\boldsymbol{\sigma}}</em>\mathcal{B}}$).
Practical experience confirms that, as alluded to when discussing feature rescaling, batch normalization seems to allow for more aggressive learning rates.
We calculate $\hat{\boldsymbol{\mu}}<em>\mathcal{B}$ and ${\hat{\boldsymbol{\sigma}}</em>\mathcal{B}}$ in :eqref:<code>eq_batchnorm</code> as follows:</p>
<p>$$\hat{\boldsymbol{\mu}}<em>\mathcal{B} = \frac{1}{|\mathcal{B}|} \sum</em>{\mathbf{x} \in \mathcal{B}} \mathbf{x}
\textrm{ and }
\hat{\boldsymbol{\sigma}}<em>\mathcal{B}^2 = \frac{1}{|\mathcal{B}|} \sum</em>{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon.$$</p>
<p>Note that we add a small constant $\epsilon &gt; 0$
to the variance estimate
to ensure that we never attempt division by zero,
even in cases where the empirical variance estimate might be very small or vanish.
The estimates $\hat{\boldsymbol{\mu}}<em>\mathcal{B}$ and ${\hat{\boldsymbol{\sigma}}</em>\mathcal{B}}$ counteract the scaling issue
by using noisy estimates of mean and variance.
You might think that this noisiness should be a problem.
On the contrary, it is actually beneficial.</p>
<p>This turns out to be a recurring theme in deep learning.
For reasons that are not yet well-characterized theoretically,
various sources of noise in optimization
often lead to faster training and less overfitting:
this variation appears to act as a form of regularization.
:citet:<code>Teye.Azizpour.Smith.2018</code> and :citet:<code>Luo.Wang.Shao.ea.2018</code>
related the properties of batch normalization to Bayesian priors and penalties, respectively.
In particular, this sheds some light on the puzzle
of why batch normalization works best for moderate minibatch sizes in the 50--100 range.
This particular size of minibatch seems to inject just the "right amount" of noise per layer, both in terms of scale via $\hat{\boldsymbol{\sigma}}$, and in terms of offset via $\hat{\boldsymbol{\mu}}$: a
larger minibatch regularizes less due to the more stable estimates, whereas tiny minibatches
destroy useful signal due to high variance. Exploring this direction further, considering alternative types
of preprocessing and filtering may yet lead to other effective types of regularization.</p>
<p>Fixing a trained model, you might think
that we would prefer using the entire dataset
to estimate the mean and variance.
Once training is complete, why would we want
the same image to be classified differently,
depending on the batch in which it happens to reside?
During training, such exact calculation is infeasible
because the intermediate variables
for all data examples
change every time we update our model.
However, once the model is trained,
we can calculate the means and variances
of each layer's variables based on the entire dataset.
Indeed this is standard practice for
models employing batch normalization;
thus batch normalization layers function differently
in <em>training mode</em> (normalizing by minibatch statistics)
than in <em>prediction mode</em> (normalizing by dataset statistics).
In this form they closely resemble the behavior of dropout regularization of :numref:<code>sec_dropout</code>,
where noise is only injected during training.</p>
<h2 id="batch-normalization-layers"><a class="header" href="#batch-normalization-layers">Batch Normalization Layers</a></h2>
<p>Batch normalization implementations for fully connected layers
and convolutional layers are slightly different.
One key difference between batch normalization and other layers
is that because the former operates on a full minibatch at a time,
we cannot just ignore the batch dimension
as we did before when introducing other layers.</p>
<h3 id="fully-connected-layers"><a class="header" href="#fully-connected-layers">Fully Connected Layers</a></h3>
<p>When applying batch normalization to fully connected layers,
:citet:<code>Ioffe.Szegedy.2015</code>, in their original paper inserted batch normalization after the affine transformation
and <em>before</em> the nonlinear activation function. Later applications experimented with
inserting batch normalization right <em>after</em> activation functions.
Denoting the input to the fully connected layer by $\mathbf{x}$,
the affine transformation
by $\mathbf{W}\mathbf{x} + \mathbf{b}$ (with the weight parameter $\mathbf{W}$ and the bias parameter $\mathbf{b}$),
and the activation function by $\phi$,
we can express the computation of a batch-normalization-enabled,
fully connected layer output $\mathbf{h}$ as follows:</p>
<p>$$\mathbf{h} = \phi(\textrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}) ).$$</p>
<p>Recall that mean and variance are computed
on the <em>same</em> minibatch
on which the transformation is applied.</p>
<h3 id="convolutional-layers-1"><a class="header" href="#convolutional-layers-1">Convolutional Layers</a></h3>
<p>Similarly, with convolutional layers,
we can apply batch normalization after the convolution
but before the nonlinear activation function. The key difference from batch normalization
in fully connected layers is that we apply the operation on a per-channel basis
<em>across all locations</em>. This is compatible with our assumption of translation
invariance that led to convolutions: we assumed that the specific location of a pattern
within an image was not critical for the purpose of understanding.</p>
<p>Assume that our minibatches contain $m$ examples
and that for each channel,
the output of the convolution has height $p$ and width $q$.
For convolutional layers, we carry out each batch normalization
over the $m \cdot p \cdot q$ elements per output channel simultaneously.
Thus, we collect the values over all spatial locations
when computing the mean and variance
and consequently
apply the same mean and variance
within a given channel
to normalize the value at each spatial location.
Each channel has its own scale and shift parameters,
both of which are scalars.</p>
<h3 id="layer-normalization"><a class="header" href="#layer-normalization">Layer Normalization</a></h3>
<p>:label:<code>subsec_layer-normalization-in-bn</code></p>
<p>Note that in the context of convolutions the batch normalization is well defined even for
minibatches of size 1: after all, we have all the locations across an image to average. Consequently,
mean and variance are well defined, even if it is just within a single observation. This consideration
led :citet:<code>Ba.Kiros.Hinton.2016</code> to introduce the notion of <em>layer normalization</em>. It works just like
a batch norm, only that it is applied to one observation at a time. Consequently both the offset and the scaling factor are scalars. For an $n$-dimensional vector $\mathbf{x}$, layer norms are given by</p>
<p>$$\mathbf{x} \rightarrow \textrm{LN}(\mathbf{x}) =  \frac{\mathbf{x} - \hat{\mu}}{\hat\sigma},$$</p>
<p>where scaling and offset are applied coefficient-wise
and given by</p>
<p>$$\hat{\mu} \stackrel{\textrm{def}}{=} \frac{1}{n} \sum_{i=1}^n x_i \textrm{ and }
\hat{\sigma}^2 \stackrel{\textrm{def}}{=} \frac{1}{n} \sum_{i=1}^n (x_i - \hat{\mu})^2 + \epsilon.$$</p>
<p>As before we add a small offset $\epsilon &gt; 0$ to prevent division by zero. One of the major benefits of using layer normalization is that it prevents divergence. After all, ignoring $\epsilon$, the output of the layer normalization is scale independent. That is, we have $\textrm{LN}(\mathbf{x}) \approx \textrm{LN}(\alpha \mathbf{x})$ for any choice of $\alpha \neq 0$. This becomes an equality for $|\alpha| \to \infty$ (the approximate equality is due to the offset $\epsilon$ for the variance).</p>
<p>Another advantage of the layer normalization is that it does not depend on the minibatch size. It is also independent of whether we are in training or test regime. In other words, it is simply a deterministic transformation that standardizes the activations to a given scale. This can be very beneficial in preventing divergence in optimization. We skip further details and recommend that interested readers consult the original paper.</p>
<h3 id="batch-normalization-during-prediction"><a class="header" href="#batch-normalization-during-prediction">Batch Normalization During Prediction</a></h3>
<p>As we mentioned earlier, batch normalization typically behaves differently
in training mode than in prediction mode.
First, the noise in the sample mean and the sample variance
arising from estimating each on minibatches
is no longer desirable once we have trained the model.
Second, we might not have the luxury
of computing per-batch normalization statistics.
For example,
we might need to apply our model to make one prediction at a time.</p>
<p>Typically, after training, we use the entire dataset
to compute stable estimates of the variable statistics
and then fix them at prediction time.
Hence, batch normalization behaves differently during training than at test time.
Recall that dropout also exhibits this characteristic.</p>
<h2 id="implementation-from-scratch-3"><a class="header" href="#implementation-from-scratch-3">(<strong>Implementation from Scratch</strong>)</a></h2>
<p>To see how batch normalization works in practice, we implement one from scratch below.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum):
    # Use autograd to determine whether we are in training mode
    if not autograd.is_training():
        # In prediction mode, use mean and variance obtained by moving average
        X_hat = (X - moving_mean) / np.sqrt(moving_var + eps)
    else:
        assert len(X.shape) in (2, 4)
        if len(X.shape) == 2:
            # When using a fully connected layer, calculate the mean and
            # variance on the feature dimension
            mean = X.mean(axis=0)
            var = ((X - mean) ** 2).mean(axis=0)
        else:
            # When using a two-dimensional convolutional layer, calculate the
            # mean and variance on the channel dimension (axis=1). Here we
            # need to maintain the shape of X, so that the broadcasting
            # operation can be carried out later
            mean = X.mean(axis=(0, 2, 3), keepdims=True)
            var = ((X - mean) ** 2).mean(axis=(0, 2, 3), keepdims=True)
        # In training mode, the current mean and variance are used 
        X_hat = (X - mean) / np.sqrt(var + eps)
        # Update the mean and variance using moving average
        moving_mean = (1.0 - momentum) * moving_mean + momentum * mean
        moving_var = (1.0 - momentum) * moving_var + momentum * var
    Y = gamma * X_hat + beta  # Scale and shift
    return Y, moving_mean, moving_var
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum):
    # Use is_grad_enabled to determine whether we are in training mode
    if not torch.is_grad_enabled():
        # In prediction mode, use mean and variance obtained by moving average
        X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps)
    else:
        assert len(X.shape) in (2, 4)
        if len(X.shape) == 2:
            # When using a fully connected layer, calculate the mean and
            # variance on the feature dimension
            mean = X.mean(dim=0)
            var = ((X - mean) ** 2).mean(dim=0)
        else:
            # When using a two-dimensional convolutional layer, calculate the
            # mean and variance on the channel dimension (axis=1). Here we
            # need to maintain the shape of X, so that the broadcasting
            # operation can be carried out later
            mean = X.mean(dim=(0, 2, 3), keepdim=True)
            var = ((X - mean) ** 2).mean(dim=(0, 2, 3), keepdim=True)
        # In training mode, the current mean and variance are used 
        X_hat = (X - mean) / torch.sqrt(var + eps)
        # Update the mean and variance using moving average
        moving_mean = (1.0 - momentum) * moving_mean + momentum * mean
        moving_var = (1.0 - momentum) * moving_var + momentum * var
    Y = gamma * X_hat + beta  # Scale and shift
    return Y, moving_mean.data, moving_var.data
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def batch_norm(X, gamma, beta, moving_mean, moving_var, eps):
    # Compute reciprocal of square root of the moving variance elementwise
    inv = tf.cast(tf.math.rsqrt(moving_var + eps), X.dtype)
    # Scale and shift
    inv *= gamma
    Y = X * inv + (beta - moving_mean * inv)
    return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def batch_norm(X, deterministic, gamma, beta, moving_mean, moving_var, eps,
               momentum):
    # Use `deterministic` to determine whether the current mode is training
    # mode or prediction mode
    if deterministic:
        # In prediction mode, use mean and variance obtained by moving average
        # `linen.Module.variables` have a `value` attribute containing the array
        X_hat = (X - moving_mean.value) / jnp.sqrt(moving_var.value + eps)
    else:
        assert len(X.shape) in (2, 4)
        if len(X.shape) == 2:
            # When using a fully connected layer, calculate the mean and
            # variance on the feature dimension
            mean = X.mean(axis=0)
            var = ((X - mean) ** 2).mean(axis=0)
        else:
            # When using a two-dimensional convolutional layer, calculate the
            # mean and variance on the channel dimension (axis=1). Here we
            # need to maintain the shape of `X`, so that the broadcasting
            # operation can be carried out later
            mean = X.mean(axis=(0, 2, 3), keepdims=True)
            var = ((X - mean) ** 2).mean(axis=(0, 2, 3), keepdims=True)
        # In training mode, the current mean and variance are used
        X_hat = (X - mean) / jnp.sqrt(var + eps)
        # Update the mean and variance using moving average
        moving_mean.value = momentum * moving_mean.value + (1.0 - momentum) * mean
        moving_var.value = momentum * moving_var.value + (1.0 - momentum) * var
    Y = gamma * X_hat + beta  # Scale and shift
    return Y
</code></pre>
<p>We can now [<strong>create a proper <code>BatchNorm</code> layer.</strong>]
Our layer will maintain proper parameters
for scale <code>gamma</code> and shift <code>beta</code>,
both of which will be updated in the course of training.
Additionally, our layer will maintain
moving averages of the means and variances
for subsequent use during model prediction.</p>
<p>Putting aside the algorithmic details,
note the design pattern underlying our implementation of the layer.
Typically, we define the mathematics in a separate function, say <code>batch_norm</code>.
We then integrate this functionality into a custom layer,
whose code mostly addresses bookkeeping matters,
such as moving data to the right device context,
allocating and initializing any required variables,
keeping track of moving averages (here for mean and variance), and so on.
This pattern enables a clean separation of mathematics from boilerplate code.
Also note that for the sake of convenience
we did not worry about automatically inferring the input shape here;
thus we need to specify the number of features throughout.
By now all modern deep learning frameworks offer automatic detection of size and shape in the
high-level batch normalization APIs (in practice we will use this instead).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class BatchNorm(nn.Block):
    # `num_features`: the number of outputs for a fully connected layer
    # or the number of output channels for a convolutional layer. `num_dims`:
    # 2 for a fully connected layer and 4 for a convolutional layer
    def __init__(self, num_features, num_dims, **kwargs):
        super().__init__(**kwargs)
        if num_dims == 2:
            shape = (1, num_features)
        else:
            shape = (1, num_features, 1, 1)
        # The scale parameter and the shift parameter (model parameters) are
        # initialized to 1 and 0, respectively
        self.gamma = self.params.get('gamma', shape=shape, init=init.One())
        self.beta = self.params.get('beta', shape=shape, init=init.Zero())
        # The variables that are not model parameters are initialized to 0 and
        # 1
        self.moving_mean = np.zeros(shape)
        self.moving_var = np.ones(shape)

    def forward(self, X):
        # If `X` is not on the main memory, copy `moving_mean` and
        # `moving_var` to the device where `X` is located
        if self.moving_mean.ctx != X.ctx:
            self.moving_mean = self.moving_mean.copyto(X.ctx)
            self.moving_var = self.moving_var.copyto(X.ctx)
        # Save the updated `moving_mean` and `moving_var`
        Y, self.moving_mean, self.moving_var = batch_norm(
            X, self.gamma.data(), self.beta.data(), self.moving_mean,
            self.moving_var, eps=1e-12, momentum=0.1)
        return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class BatchNorm(nn.Module):
    # num_features: the number of outputs for a fully connected layer or the
    # number of output channels for a convolutional layer. num_dims: 2 for a
    # fully connected layer and 4 for a convolutional layer
    def __init__(self, num_features, num_dims):
        super().__init__()
        if num_dims == 2:
            shape = (1, num_features)
        else:
            shape = (1, num_features, 1, 1)
        # The scale parameter and the shift parameter (model parameters) are
        # initialized to 1 and 0, respectively
        self.gamma = nn.Parameter(torch.ones(shape))
        self.beta = nn.Parameter(torch.zeros(shape))
        # The variables that are not model parameters are initialized to 0 and
        # 1
        self.moving_mean = torch.zeros(shape)
        self.moving_var = torch.ones(shape)

    def forward(self, X):
        # If X is not on the main memory, copy moving_mean and moving_var to
        # the device where X is located
        if self.moving_mean.device != X.device:
            self.moving_mean = self.moving_mean.to(X.device)
            self.moving_var = self.moving_var.to(X.device)
        # Save the updated moving_mean and moving_var
        Y, self.moving_mean, self.moving_var = batch_norm(
            X, self.gamma, self.beta, self.moving_mean,
            self.moving_var, eps=1e-5, momentum=0.1)
        return Y
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class BatchNorm(tf.keras.layers.Layer):
    def __init__(self, **kwargs):
        super(BatchNorm, self).__init__(**kwargs)

    def build(self, input_shape):
        weight_shape = [input_shape[-1], ]
        # The scale parameter and the shift parameter (model parameters) are
        # initialized to 1 and 0, respectively
        self.gamma = self.add_weight(name='gamma', shape=weight_shape,
            initializer=tf.initializers.ones, trainable=True)
        self.beta = self.add_weight(name='beta', shape=weight_shape,
            initializer=tf.initializers.zeros, trainable=True)
        # The variables that are not model parameters are initialized to 0
        self.moving_mean = self.add_weight(name='moving_mean',
            shape=weight_shape, initializer=tf.initializers.zeros,
            trainable=False)
        self.moving_variance = self.add_weight(name='moving_variance',
            shape=weight_shape, initializer=tf.initializers.ones,
            trainable=False)
        super(BatchNorm, self).build(input_shape)

    def assign_moving_average(self, variable, value):
        momentum = 0.1
        delta = (1.0 - momentum) * variable + momentum * value
        return variable.assign(delta)

    @tf.function
    def call(self, inputs, training):
        if training:
            axes = list(range(len(inputs.shape) - 1))
            batch_mean = tf.reduce_mean(inputs, axes, keepdims=True)
            batch_variance = tf.reduce_mean(tf.math.squared_difference(
                inputs, tf.stop_gradient(batch_mean)), axes, keepdims=True)
            batch_mean = tf.squeeze(batch_mean, axes)
            batch_variance = tf.squeeze(batch_variance, axes)
            mean_update = self.assign_moving_average(
                self.moving_mean, batch_mean)
            variance_update = self.assign_moving_average(
                self.moving_variance, batch_variance)
            self.add_update(mean_update)
            self.add_update(variance_update)
            mean, variance = batch_mean, batch_variance
        else:
            mean, variance = self.moving_mean, self.moving_variance
        output = batch_norm(inputs, moving_mean=mean, moving_var=variance,
            beta=self.beta, gamma=self.gamma, eps=1e-5)
        return output
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class BatchNorm(nn.Module):
    # `num_features`: the number of outputs for a fully connected layer
    # or the number of output channels for a convolutional layer.
    # `num_dims`: 2 for a fully connected layer and 4 for a convolutional layer
    # Use `deterministic` to determine whether the current mode is training
    # mode or prediction mode
    num_features: int
    num_dims: int
    deterministic: bool = False

    @nn.compact
    def __call__(self, X):
        if self.num_dims == 2:
            shape = (1, self.num_features)
        else:
            shape = (1, 1, 1, self.num_features)

        # The scale parameter and the shift parameter (model parameters) are
        # initialized to 1 and 0, respectively
        gamma = self.param('gamma', jax.nn.initializers.ones, shape)
        beta = self.param('beta', jax.nn.initializers.zeros, shape)

        # The variables that are not model parameters are initialized to 0 and
        # 1. Save them to the 'batch_stats' collection
        moving_mean = self.variable('batch_stats', 'moving_mean', jnp.zeros, shape)
        moving_var = self.variable('batch_stats', 'moving_var', jnp.ones, shape)
        Y = batch_norm(X, self.deterministic, gamma, beta,
                       moving_mean, moving_var, eps=1e-5, momentum=0.9)

        return Y
</code></pre>
<p>We used <code>momentum</code> to govern the aggregation over past mean and variance estimates. This is somewhat of a misnomer as it has nothing whatsoever to do with the <em>momentum</em> term of optimization. Nonetheless, it is the commonly adopted name for this term and in deference to API naming convention we use the same variable name in our code.</p>
<h2 id="lenet-with-batch-normalization"><a class="header" href="#lenet-with-batch-normalization">[<strong>LeNet with Batch Normalization</strong>]</a></h2>
<p>To see how to apply <code>BatchNorm</code> in context,
below we apply it to a traditional LeNet model (:numref:<code>sec_lenet</code>).
Recall that batch normalization is applied
after the convolutional layers or fully connected layers
but before the corresponding activation functions.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class BNLeNetScratch(d2l.Classifier):
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            self.net.add(
                nn.Conv2D(6, kernel_size=5), BatchNorm(6, num_dims=4),
                nn.Activation('sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2),
                nn.Conv2D(16, kernel_size=5), BatchNorm(16, num_dims=4),
                nn.Activation('sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2), nn.Dense(120),
                BatchNorm(120, num_dims=2), nn.Activation('sigmoid'),
                nn.Dense(84), BatchNorm(84, num_dims=2),
                nn.Activation('sigmoid'), nn.Dense(num_classes))
            self.initialize()
        if tab.selected('pytorch'):
            self.net = nn.Sequential(
                nn.LazyConv2d(6, kernel_size=5), BatchNorm(6, num_dims=4),
                nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2),
                nn.LazyConv2d(16, kernel_size=5), BatchNorm(16, num_dims=4),
                nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2),
                nn.Flatten(), nn.LazyLinear(120),
                BatchNorm(120, num_dims=2), nn.Sigmoid(), nn.LazyLinear(84),
                BatchNorm(84, num_dims=2), nn.Sigmoid(),
                nn.LazyLinear(num_classes))
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(filters=6, kernel_size=5,
                                       input_shape=(28, 28, 1)),
                BatchNorm(), tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Conv2D(filters=16, kernel_size=5),
                BatchNorm(), tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Flatten(), tf.keras.layers.Dense(120),
                BatchNorm(), tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.Dense(84), BatchNorm(),
                tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.Dense(num_classes)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class BNLeNetScratch(d2l.Classifier):
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = nn.Sequential([
            nn.Conv(6, kernel_size=(5, 5)),
            BatchNorm(6, num_dims=4, deterministic=not self.training),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            nn.Conv(16, kernel_size=(5, 5)),
            BatchNorm(16, num_dims=4, deterministic=not self.training),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            lambda x: x.reshape((x.shape[0], -1)),
            nn.Dense(120),
            BatchNorm(120, num_dims=2, deterministic=not self.training),
            nn.sigmoid,
            nn.Dense(84),
            BatchNorm(84, num_dims=2, deterministic=not self.training),
            nn.sigmoid,
            nn.Dense(self.num_classes)])
</code></pre>
<p>:begin_tab:<code>jax</code>
Since <code>BatchNorm</code> layers need to calculate the batch statistics
(mean and variance), Flax keeps track of the <code>batch_stats</code> dictionary, updating
them with every minibatch. Collections like <code>batch_stats</code> can be stored in the
<code>TrainState</code> object (in the <code>d2l.Trainer</code> class defined in
:numref:<code>oo-design-training</code>) as an attribute and during the model's forward pass,
these should be passed to the <code>mutable</code> argument, so that Flax returns the mutated
variables.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.Classifier)  #@save
@partial(jax.jit, static_argnums=(0, 5))
def loss(self, params, X, Y, state, averaged=True):
    Y_hat, updates = state.apply_fn({'params': params,
                                     'batch_stats': state.batch_stats},
                                    *X, mutable=['batch_stats'],
                                    rngs={'dropout': state.dropout_rng})
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    Y = d2l.reshape(Y, (-1,))
    fn = optax.softmax_cross_entropy_with_integer_labels
    return (fn(Y_hat, Y).mean(), updates) if averaged else (fn(Y_hat, Y), updates)
</code></pre>
<p>As before, we will [<strong>train our network on the Fashion-MNIST dataset</strong>].
This code is virtually identical to that when we first trained LeNet.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128)
model = BNLeNetScratch(lr=0.1)
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128)
with d2l.try_gpu():
    model = BNLeNetScratch(lr=0.5)
    trainer.fit(model, data)
</code></pre>
<p>Let's [<strong>have a look at the scale parameter <code>gamma</code>
and the shift parameter <code>beta</code></strong>] learned
from the first batch normalization layer.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
model.net[1].gamma.data().reshape(-1,), model.net[1].beta.data().reshape(-1,)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
model.net[1].gamma.reshape((-1,)), model.net[1].beta.reshape((-1,))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.reshape(model.net.layers[1].gamma, (-1,)), tf.reshape(
    model.net.layers[1].beta, (-1,))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
trainer.state.params['net']['layers_1']['gamma'].reshape((-1,)), \
trainer.state.params['net']['layers_1']['beta'].reshape((-1,))
</code></pre>
<h2 id="concise-implementation-3"><a class="header" href="#concise-implementation-3">[<strong>Concise Implementation</strong>]</a></h2>
<p>Compared with the <code>BatchNorm</code> class,
which we just defined ourselves,
we can use the <code>BatchNorm</code> class defined in high-level APIs from the deep learning framework directly.
The code looks virtually identical
to our implementation above, except that we no longer need to provide additional arguments for it to get the dimensions right.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, tensorflow, mxnet
class BNLeNet(d2l.Classifier):
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.net = nn.Sequential()
            self.net.add(
                nn.Conv2D(6, kernel_size=5), nn.BatchNorm(),
                nn.Activation('sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2),
                nn.Conv2D(16, kernel_size=5), nn.BatchNorm(),
                nn.Activation('sigmoid'),
                nn.AvgPool2D(pool_size=2, strides=2),
                nn.Dense(120), nn.BatchNorm(), nn.Activation('sigmoid'),
                nn.Dense(84), nn.BatchNorm(), nn.Activation('sigmoid'),
                nn.Dense(num_classes))
            self.initialize()
        if tab.selected('pytorch'):
            self.net = nn.Sequential(
                nn.LazyConv2d(6, kernel_size=5), nn.LazyBatchNorm2d(),
                nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2),
                nn.LazyConv2d(16, kernel_size=5), nn.LazyBatchNorm2d(),
                nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2),
                nn.Flatten(), nn.LazyLinear(120), nn.LazyBatchNorm1d(),
                nn.Sigmoid(), nn.LazyLinear(84), nn.LazyBatchNorm1d(),
                nn.Sigmoid(), nn.LazyLinear(num_classes))
        if tab.selected('tensorflow'):
            self.net = tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(filters=6, kernel_size=5,
                                       input_shape=(28, 28, 1)),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Conv2D(filters=16, kernel_size=5),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
                tf.keras.layers.Flatten(), tf.keras.layers.Dense(120),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.Dense(84),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Activation('sigmoid'),
                tf.keras.layers.Dense(num_classes)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class BNLeNet(d2l.Classifier):
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = nn.Sequential([
            nn.Conv(6, kernel_size=(5, 5)),
            nn.BatchNorm(not self.training),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            nn.Conv(16, kernel_size=(5, 5)),
            nn.BatchNorm(not self.training),
            nn.sigmoid,
            lambda x: nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2)),
            lambda x: x.reshape((x.shape[0], -1)),
            nn.Dense(120),
            nn.BatchNorm(not self.training),
            nn.sigmoid,
            nn.Dense(84),
            nn.BatchNorm(not self.training),
            nn.sigmoid,
            nn.Dense(self.num_classes)])
</code></pre>
<p>Below, we [<strong>use the same hyperparameters to train our model.</strong>]
Note that as usual, the high-level API variant runs much faster
because its code has been compiled to C++ or CUDA
while our custom implementation must be interpreted by Python.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128)
model = BNLeNet(lr=0.1)
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128)
with d2l.try_gpu():
    model = BNLeNet(lr=0.5)
    trainer.fit(model, data)
</code></pre>
<h2 id="discussion-8"><a class="header" href="#discussion-8">Discussion</a></h2>
<p>Intuitively, batch normalization is thought
to make the optimization landscape smoother.
However, we must be careful to distinguish between
speculative intuitions and true explanations
for the phenomena that we observe when training deep models.
Recall that we do not even know why simpler
deep neural networks (MLPs and conventional CNNs)
generalize well in the first place.
Even with dropout and weight decay,
they remain so flexible that their ability to generalize to unseen data
likely needs significantly more refined learning-theoretic generalization guarantees.</p>
<p>The original paper proposing batch normalization :cite:<code>Ioffe.Szegedy.2015</code>, in addition to introducing a powerful and useful tool,
offered an explanation for why it works:
by reducing <em>internal covariate shift</em>.
Presumably by <em>internal covariate shift</em> they
meant something like the intuition expressed above---the
notion that the distribution of variable values changes
over the course of training.
However, there were two problems with this explanation:
i) This drift is very different from <em>covariate shift</em>,
rendering the name a misnomer. If anything, it is closer to concept drift.
ii) The explanation offers an under-specified intuition
but leaves the question of <em>why precisely this technique works</em>
an open question wanting for a rigorous explanation.
Throughout this book, we aim to convey the intuitions that practitioners
use to guide their development of deep neural networks.
However, we believe that it is important
to separate these guiding intuitions
from established scientific fact.
Eventually, when you master this material
and start writing your own research papers
you will want to be clear to delineate
between technical claims and hunches.</p>
<p>Following the success of batch normalization,
its explanation in terms of <em>internal covariate shift</em>
has repeatedly surfaced in debates in the technical literature
and broader discourse about how to present machine learning research.
In a memorable speech given while accepting a Test of Time Award
at the 2017 NeurIPS conference,
Ali Rahimi used <em>internal covariate shift</em>
as a focal point in an argument likening
the modern practice of deep learning to alchemy.
Subsequently, the example was revisited in detail
in a position paper outlining
troubling trends in machine learning :cite:<code>Lipton.Steinhardt.2018</code>.
Other authors
have proposed alternative explanations for the success of batch normalization,
some :cite:<code>Santurkar.Tsipras.Ilyas.ea.2018</code>
claiming that batch normalization's success comes despite exhibiting behavior
that is in some ways opposite to those claimed in the original paper.</p>
<p>We note that the <em>internal covariate shift</em>
is no more worthy of criticism than any of
thousands of similarly vague claims
made every year in the technical machine learning literature.
Likely, its resonance as a focal point of these debates
owes to its broad recognizability for the target audience.
Batch normalization has proven an indispensable method,
applied in nearly all deployed image classifiers,
earning the paper that introduced the technique
tens of thousands of citations. We conjecture, though, that the guiding principles
of regularization through noise injection, acceleration through rescaling and lastly preprocessing
may well lead to further inventions of layers and techniques in the future.</p>
<p>On a more practical note, there are a number of aspects worth remembering about batch normalization:</p>
<ul>
<li>During model training, batch normalization continuously adjusts the intermediate output of
the network by utilizing the mean and standard deviation of the minibatch, so that the
values of the intermediate output in each layer throughout the neural network are more stable.</li>
<li>Batch normalization is slightly different for fully connected layers than for convolutional layers. In fact,
for convolutional layers, layer normalization can sometimes be used as an alternative.</li>
<li>Like a dropout layer, batch normalization layers have different behaviors
in training mode than in prediction mode.</li>
<li>Batch normalization is useful for regularization and improving convergence in optimization. By contrast,
the original motivation of reducing internal covariate shift seems not to be a valid explanation.</li>
<li>For more robust models that are less sensitive to input perturbations, consider removing batch normalization :cite:<code>wang2022removing</code>.</li>
</ul>
<h2 id="exercises-46"><a class="header" href="#exercises-46">Exercises</a></h2>
<ol>
<li>Should we remove the bias parameter from the fully connected layer or the convolutional layer before the batch normalization? Why?</li>
<li>Compare the learning rates for LeNet with and without batch normalization.
<ol>
<li>Plot the increase in validation accuracy.</li>
<li>How large can you make the learning rate before the optimization fails in both cases?</li>
</ol>
</li>
<li>Do we need batch normalization in every layer? Experiment with it.</li>
<li>Implement a "lite" version of batch normalization that only removes the mean, or alternatively one that
only removes the variance. How does it behave?</li>
<li>Fix the parameters <code>beta</code> and <code>gamma</code>. Observe and analyze the results.</li>
<li>Can you replace dropout by batch normalization? How does the behavior change?</li>
<li>Research ideas: think of other normalization transforms that you can apply:
<ol>
<li>Can you apply the probability integral transform?</li>
<li>Can you use a full-rank covariance estimate? Why should you probably not do that?</li>
<li>Can you use other compact matrix variants (block-diagonal, low-displacement rank, Monarch, etc.)?</li>
<li>Does a sparsification compression act as a regularizer?</li>
<li>Are there other projections (e.g., convex cone, symmetry group-specific transforms) that you can use?</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/83">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/84">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/330">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18005">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="residual-networks-resnet-and-resnext"><a class="header" href="#residual-networks-resnet-and-resnext">Residual Networks (ResNet) and ResNeXt</a></h1>
<p>:label:<code>sec_resnet</code></p>
<p>As we design ever deeper networks it becomes imperative to understand how adding layers can increase the complexity and expressiveness of the network.
Even more important is the ability to design networks where adding layers makes networks strictly more expressive rather than just different.
To make some progress we need a bit of mathematics.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="function-classes"><a class="header" href="#function-classes">Function Classes</a></h2>
<p>Consider $\mathcal{F}$, the class of functions that a specific network architecture (together with learning rates and other hyperparameter settings) can reach.
That is, for all $f \in \mathcal{F}$ there exists some set of parameters (e.g., weights and biases) that can be obtained through training on a suitable dataset.
Let's assume that $f^<em>$ is the "truth" function that we really would like to find.
If it is in $\mathcal{F}$, we are in good shape but typically we will not be quite so lucky.
Instead, we will try to find some $f^</em>_\mathcal{F}$ which is our best bet within $\mathcal{F}$.
For instance,
given a dataset with features $\mathbf{X}$
and labels $\mathbf{y}$,
we might try finding it by solving the following optimization problem:</p>
<p>$$f^*_\mathcal{F} \stackrel{\textrm{def}}{=} \mathop{\mathrm{argmin}}_f L(\mathbf{X}, \mathbf{y}, f) \textrm{ subject to } f \in \mathcal{F}.$$</p>
<p>We know that regularization :cite:<code>tikhonov1977solutions,morozov2012methods</code> may control complexity of $\mathcal{F}$
and achieve consistency, so a larger size of training data
generally leads to better $f^<em>_\mathcal{F}$.
It is only reasonable to assume that if we design a different and more powerful architecture $\mathcal{F}'$ we should arrive at a better outcome. In other words, we would expect that $f^</em><em>{\mathcal{F}'}$ is "better" than $f^*</em>{\mathcal{F}}$. However, if $\mathcal{F} \not\subseteq \mathcal{F}'$ there is no guarantee that this should even happen. In fact, $f^<em>_{\mathcal{F}'}$ might well be worse.
As illustrated by :numref:<code>fig_functionclasses</code>,
for non-nested function classes, a larger function class does not always move closer to the "truth" function $f^</em>$. For instance,
on the left of :numref:<code>fig_functionclasses</code>,
though $\mathcal{F}_3$ is closer to $f^<em>$ than $\mathcal{F}_1$, $\mathcal{F}_6$ moves away and there is no guarantee that further increasing the complexity can reduce the distance from $f^</em>$.
With nested function classes
where $\mathcal{F}_1 \subseteq \cdots \subseteq \mathcal{F}_6$
on the right of :numref:<code>fig_functionclasses</code>,
we can avoid the aforementioned issue from the non-nested function classes.</p>
<p><img src="chapter_convolutional-modern/../img/functionclasses.svg" alt="For non-nested function classes, a larger (indicated by area) function class does not guarantee we will get closer to the &quot;truth&quot; function ($\mathit{f}^*$). This does not happen in nested function classes." />
:label:<code>fig_functionclasses</code></p>
<p>Thus,
only if larger function classes contain the smaller ones are we guaranteed that increasing them strictly increases the expressive power of the network.
For deep neural networks,
if we can
train the newly-added layer into an identity function $f(\mathbf{x}) = \mathbf{x}$, the new model will be as effective as the original model. As the new model may get a better solution to fit the training dataset, the added layer might make it easier to reduce training errors.</p>
<p>This is the question that :citet:<code>He.Zhang.Ren.ea.2016</code> considered when working on very deep computer vision models.
At the heart of their proposed <em>residual network</em> (<em>ResNet</em>) is the idea that every additional layer should
more easily
contain the identity function as one of its elements.
These considerations are rather profound but they led to a surprisingly simple
solution, a <em>residual block</em>.
With it, ResNet won the ImageNet Large Scale Visual Recognition Challenge in 2015. The design had a profound influence on how to
build deep neural networks. For instance, residual blocks have been added to recurrent networks :cite:<code>prakash2016neural,kim2017residual</code>. Likewise, Transformers :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code> use them to stack many layers of networks efficiently. It is also used in graph neural networks :cite:<code>Kipf.Welling.2016</code> and, as a basic concept, it has been used extensively in computer vision :cite:<code>Redmon.Farhadi.2018,Ren.He.Girshick.ea.2015</code>.
Note that residual networks are predated by highway networks :cite:<code>srivastava2015highway</code> that share some of the motivation, albeit without the elegant parametrization around the identity function.</p>
<h2 id="residual-blocks"><a class="header" href="#residual-blocks">(<strong>Residual Blocks</strong>)</a></h2>
<p>:label:<code>subsec_residual-blks</code></p>
<p>Let's focus on a local part of a neural network, as depicted in :numref:<code>fig_residual_block</code>. Denote the input by $\mathbf{x}$.
We assume that $f(\mathbf{x})$, the desired underlying mapping we want to obtain by learning, is to be used as input to the activation function on the top.
On the left,
the portion within the dotted-line box
must directly learn $f(\mathbf{x})$.
On the right,
the portion within the dotted-line box
needs to
learn the <em>residual mapping</em> $g(\mathbf{x}) = f(\mathbf{x}) - \mathbf{x}$,
which is how the residual block derives its name.
If the identity mapping $f(\mathbf{x}) = \mathbf{x}$ is the desired underlying mapping,
the residual mapping amounts to $g(\mathbf{x}) = 0$ and it is thus easier to learn:
we only need to push the weights and biases
of the
upper weight layer (e.g., fully connected layer and convolutional layer)
within the dotted-line box
to zero.
The right figure illustrates the <em>residual block</em> of ResNet,
where the solid line carrying the layer input
$\mathbf{x}$ to the addition operator
is called a <em>residual connection</em> (or <em>shortcut connection</em>).
With residual blocks, inputs can
forward propagate faster through the residual connections across layers.
In fact,
the residual block
can be thought of as
a special case of the multi-branch Inception block:
it has two branches
one of which is the identity mapping.</p>
<p><img src="chapter_convolutional-modern/../img/residual-block.svg" alt="In a regular block (left), the portion within the dotted-line box must directly learn the mapping $\mathit{f}(\mathbf{x})$. In a residual block (right), the portion within the dotted-line box needs to learn the residual mapping $\mathit{g}(\mathbf{x}) = \mathit{f}(\mathbf{x}) - \mathbf{x}$, making the identity mapping $\mathit{f}(\mathbf{x}) = \mathbf{x}$ easier to learn." />
:label:<code>fig_residual_block</code></p>
<p>ResNet has VGG's full $3\times 3$ convolutional layer design. The residual block has two $3\times 3$ convolutional layers with the same number of output channels. Each convolutional layer is followed by a batch normalization layer and a ReLU activation function. Then, we skip these two convolution operations and add the input directly before the final ReLU activation function.
This kind of design requires that the output of the two convolutional layers has to be of the same shape as the input, so that they can be added together. If we want to change the number of channels, we need to introduce an additional $1\times 1$ convolutional layer to transform the input into the desired shape for the addition operation. Let's have a look at the code below.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Residual(nn.Block):  #@save
    """The Residual block of ResNet models."""
    def __init__(self, num_channels, use_1x1conv=False, strides=1, **kwargs):
        super().__init__(**kwargs)
        self.conv1 = nn.Conv2D(num_channels, kernel_size=3, padding=1,
                               strides=strides)
        self.conv2 = nn.Conv2D(num_channels, kernel_size=3, padding=1)
        if use_1x1conv:
            self.conv3 = nn.Conv2D(num_channels, kernel_size=1,
                                   strides=strides)
        else:
            self.conv3 = None
        self.bn1 = nn.BatchNorm()
        self.bn2 = nn.BatchNorm()

    def forward(self, X):
        Y = npx.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3:
            X = self.conv3(X)
        return npx.relu(Y + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Residual(nn.Module):  #@save
    """The Residual block of ResNet models."""
    def __init__(self, num_channels, use_1x1conv=False, strides=1):
        super().__init__()
        self.conv1 = nn.LazyConv2d(num_channels, kernel_size=3, padding=1,
                                   stride=strides)
        self.conv2 = nn.LazyConv2d(num_channels, kernel_size=3, padding=1)
        if use_1x1conv:
            self.conv3 = nn.LazyConv2d(num_channels, kernel_size=1,
                                       stride=strides)
        else:
            self.conv3 = None
        self.bn1 = nn.LazyBatchNorm2d()
        self.bn2 = nn.LazyBatchNorm2d()

    def forward(self, X):
        Y = F.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3:
            X = self.conv3(X)
        Y += X
        return F.relu(Y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Residual(tf.keras.Model):  #@save
    """The Residual block of ResNet models."""
    def __init__(self, num_channels, use_1x1conv=False, strides=1):
        super().__init__()
        self.conv1 = tf.keras.layers.Conv2D(num_channels, padding='same',
                                            kernel_size=3, strides=strides)
        self.conv2 = tf.keras.layers.Conv2D(num_channels, kernel_size=3,
                                            padding='same')
        self.conv3 = None
        if use_1x1conv:
            self.conv3 = tf.keras.layers.Conv2D(num_channels, kernel_size=1,
                                                strides=strides)
        self.bn1 = tf.keras.layers.BatchNormalization()
        self.bn2 = tf.keras.layers.BatchNormalization()

    def call(self, X):
        Y = tf.keras.activations.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3 is not None:
            X = self.conv3(X)
        Y += X
        return tf.keras.activations.relu(Y)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Residual(nn.Module):  #@save
    """The Residual block of ResNet models."""
    num_channels: int
    use_1x1conv: bool = False
    strides: tuple = (1, 1)
    training: bool = True

    def setup(self):
        self.conv1 = nn.Conv(self.num_channels, kernel_size=(3, 3),
                             padding='same', strides=self.strides)
        self.conv2 = nn.Conv(self.num_channels, kernel_size=(3, 3),
                             padding='same')
        if self.use_1x1conv:
            self.conv3 = nn.Conv(self.num_channels, kernel_size=(1, 1),
                                 strides=self.strides)
        else:
            self.conv3 = None
        self.bn1 = nn.BatchNorm(not self.training)
        self.bn2 = nn.BatchNorm(not self.training)

    def __call__(self, X):
        Y = nn.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3:
            X = self.conv3(X)
        Y += X
        return nn.relu(Y)
</code></pre>
<p>This code generates two types of networks: one where we add the input to the output before applying the ReLU nonlinearity whenever <code>use_1x1conv=False</code>; and one where we adjust channels and resolution by means of a $1 \times 1$ convolution before adding. :numref:<code>fig_resnet_block</code> illustrates this.</p>
<p><img src="chapter_convolutional-modern/../img/resnet-block.svg" alt="ResNet block with and without $1 \times 1$ convolution, which transforms the input into the desired shape for the addition operation." />
:label:<code>fig_resnet_block</code></p>
<p>Now let's look at [<strong>a situation where the input and output are of the same shape</strong>], where $1 \times 1$ convolution is not needed.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
if tab.selected('mxnet'):
    blk = Residual(3)
    blk.initialize()
if tab.selected('pytorch'):
    blk = Residual(3)
X = d2l.randn(4, 3, 6, 6)
blk(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
blk = Residual(3)
X = d2l.normal((4, 6, 6, 3))
Y = blk(X)
Y.shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
blk = Residual(3)
X = jax.random.normal(d2l.get_key(), (4, 6, 6, 3))
blk.init_with_output(d2l.get_key(), X)[0].shape
</code></pre>
<p>We also have the option to [<strong>halve the output height and width while increasing the number of output channels</strong>].
In this case we use $1 \times 1$ convolutions via <code>use_1x1conv=True</code>. This comes in handy at the beginning of each ResNet block to reduce the spatial dimensionality via <code>strides=2</code>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
blk = Residual(6, use_1x1conv=True, strides=2)
if tab.selected('mxnet'):
    blk.initialize()
blk(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
blk = Residual(6, use_1x1conv=True, strides=(2, 2))
blk.init_with_output(d2l.get_key(), X)[0].shape
</code></pre>
<h2 id="resnet-model"><a class="header" href="#resnet-model">[<strong>ResNet Model</strong>]</a></h2>
<p>The first two layers of ResNet are the same as those of the GoogLeNet we described before: the $7\times 7$ convolutional layer with 64 output channels and a stride of 2 is followed by the $3\times 3$ max-pooling layer with a stride of 2. The difference is the batch normalization layer added after each convolutional layer in ResNet.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class ResNet(d2l.Classifier):
    def b1(self):
        if tab.selected('mxnet'):
            net = nn.Sequential()
            net.add(nn.Conv2D(64, kernel_size=7, strides=2, padding=3),
                    nn.BatchNorm(), nn.Activation('relu'),
                    nn.MaxPool2D(pool_size=3, strides=2, padding=1))
            return net
        if tab.selected('pytorch'):
            return nn.Sequential(
                nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3),
                nn.LazyBatchNorm2d(), nn.ReLU(),
                nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
        if tab.selected('tensorflow'):
            return tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(64, kernel_size=7, strides=2,
                                       padding='same'),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Activation('relu'),
                tf.keras.layers.MaxPool2D(pool_size=3, strides=2,
                                          padding='same')])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ResNet(d2l.Classifier):
    arch: tuple
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = self.create_net()

    def b1(self):
        return nn.Sequential([
            nn.Conv(64, kernel_size=(7, 7), strides=(2, 2), padding='same'),
            nn.BatchNorm(not self.training), nn.relu,
            lambda x: nn.max_pool(x, window_shape=(3, 3), strides=(2, 2),
                                  padding='same')])
</code></pre>
<p>GoogLeNet uses four modules made up of Inception blocks.
However, ResNet uses four modules made up of residual blocks, each of which uses several residual blocks with the same number of output channels.
The number of channels in the first module is the same as the number of input channels. Since a max-pooling layer with a stride of 2 has already been used, it is not necessary to reduce the height and width. In the first residual block for each of the subsequent modules, the number of channels is doubled compared with that of the previous module, and the height and width are halved.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(ResNet)
def block(self, num_residuals, num_channels, first_block=False):
    blk = nn.Sequential()
    for i in range(num_residuals):
        if i == 0 and not first_block:
            blk.add(Residual(num_channels, use_1x1conv=True, strides=2))
        else:
            blk.add(Residual(num_channels))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(ResNet)
def block(self, num_residuals, num_channels, first_block=False):
    blk = []
    for i in range(num_residuals):
        if i == 0 and not first_block:
            blk.append(Residual(num_channels, use_1x1conv=True, strides=2))
        else:
            blk.append(Residual(num_channels))
    return nn.Sequential(*blk)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(ResNet)
def block(self, num_residuals, num_channels, first_block=False):
    blk = tf.keras.models.Sequential()
    for i in range(num_residuals):
        if i == 0 and not first_block:
            blk.add(Residual(num_channels, use_1x1conv=True, strides=2))
        else:
            blk.add(Residual(num_channels))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(ResNet)
def block(self, num_residuals, num_channels, first_block=False):
    blk = []
    for i in range(num_residuals):
        if i == 0 and not first_block:
            blk.append(Residual(num_channels, use_1x1conv=True,
                                strides=(2, 2), training=self.training))
        else:
            blk.append(Residual(num_channels, training=self.training))
    return nn.Sequential(blk)
</code></pre>
<p>Then, we add all the modules to ResNet. Here, two residual blocks are used for each module. Lastly, just like GoogLeNet, we add a global average pooling layer, followed by the fully connected layer output.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(ResNet)
def __init__(self, arch, lr=0.1, num_classes=10):
    super(ResNet, self).__init__()
    self.save_hyperparameters()
    if tab.selected('mxnet'):
        self.net = nn.Sequential()
        self.net.add(self.b1())
        for i, b in enumerate(arch):
            self.net.add(self.block(*b, first_block=(i==0)))
        self.net.add(nn.GlobalAvgPool2D(), nn.Dense(num_classes))
        self.net.initialize(init.Xavier())
    if tab.selected('pytorch'):
        self.net = nn.Sequential(self.b1())
        for i, b in enumerate(arch):
            self.net.add_module(f'b{i+2}', self.block(*b, first_block=(i==0)))
        self.net.add_module('last', nn.Sequential(
            nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(),
            nn.LazyLinear(num_classes)))
        self.net.apply(d2l.init_cnn)
    if tab.selected('tensorflow'):
        self.net = tf.keras.models.Sequential(self.b1())
        for i, b in enumerate(arch):
            self.net.add(self.block(*b, first_block=(i==0)))
        self.net.add(tf.keras.models.Sequential([
            tf.keras.layers.GlobalAvgPool2D(),
            tf.keras.layers.Dense(units=num_classes)]))
</code></pre>
<pre><code class="language-{.python .input}"># %%tab jax
@d2l.add_to_class(ResNet)
def create_net(self):
    net = nn.Sequential([self.b1()])
    for i, b in enumerate(self.arch):
        net.layers.extend([self.block(*b, first_block=(i==0))])
    net.layers.extend([nn.Sequential([
        # Flax does not provide a GlobalAvg2D layer
        lambda x: nn.avg_pool(x, window_shape=x.shape[1:3],
                              strides=x.shape[1:3], padding='valid'),
        lambda x: x.reshape((x.shape[0], -1)),
        nn.Dense(self.num_classes)])])
    return net
</code></pre>
<p>There are four convolutional layers in each module (excluding the $1\times 1$ convolutional layer). Together with the first $7\times 7$ convolutional layer and the final fully connected layer, there are 18 layers in total. Therefore, this model is commonly known as ResNet-18.
By configuring different numbers of channels and residual blocks in the module, we can create different ResNet models, such as the deeper 152-layer ResNet-152. Although the main architecture of ResNet is similar to that of GoogLeNet, ResNet's structure is simpler and easier to modify. All these factors have resulted in the rapid and widespread use of ResNet. :numref:<code>fig_resnet18</code> depicts the full ResNet-18.</p>
<p><img src="chapter_convolutional-modern/../img/resnet18-90.svg" alt="The ResNet-18 architecture." />
:label:<code>fig_resnet18</code></p>
<p>Before training ResNet, let's [<strong>observe how the input shape changes across different modules in ResNet</strong>]. As in all the previous architectures, the resolution decreases while the number of channels increases up until the point where a global average pooling layer aggregates all features.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class ResNet18(ResNet):
    def __init__(self, lr=0.1, num_classes=10):
        super().__init__(((2, 64), (2, 128), (2, 256), (2, 512)),
                       lr, num_classes)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ResNet18(ResNet):
    arch: tuple = ((2, 64), (2, 128), (2, 256), (2, 512))
    lr: float = 0.1
    num_classes: int = 10
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet
ResNet18().layer_summary((1, 1, 96, 96))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
ResNet18().layer_summary((1, 96, 96, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
ResNet18(training=False).layer_summary((1, 96, 96, 1))
</code></pre>
<h2 id="training-13"><a class="header" href="#training-13">[<strong>Training</strong>]</a></h2>
<p>We train ResNet on the Fashion-MNIST dataset, just like before. ResNet is quite a powerful and flexible architecture. The plot capturing training and validation loss illustrates a significant gap between both graphs, with the training loss being considerably lower. For a network of this flexibility, more training data would offer distinct benefit in closing the gap and improving accuracy.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
model = ResNet18(lr=0.01)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
if tab.selected('pytorch'):
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
with d2l.try_gpu():
    model = ResNet18(lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="resnext"><a class="header" href="#resnext">ResNeXt</a></h2>
<p>:label:<code>subsec_resnext</code></p>
<p>One of the challenges one encounters in the design of ResNet is the trade-off between nonlinearity and dimensionality within a given block. That is, we could add more nonlinearity by increasing the number of layers, or by increasing the width of the convolutions. An alternative strategy is to increase the number of channels that can carry information between blocks. Unfortunately, the latter comes with a quadratic penalty since the computational cost of ingesting $c_\textrm{i}$ channels and emitting $c_\textrm{o}$ channels is proportional to $\mathcal{O}(c_\textrm{i} \cdot c_\textrm{o})$ (see our discussion in :numref:<code>sec_channels</code>).</p>
<p>We can take some inspiration from the Inception block of :numref:<code>fig_inception</code> which has information flowing through the block in separate groups. Applying the idea of multiple independent groups to the ResNet block of :numref:<code>fig_resnet_block</code> led to the design of ResNeXt :cite:<code>Xie.Girshick.Dollar.ea.2017</code>.
Different from the smorgasbord of transformations in Inception,
ResNeXt adopts the <em>same</em> transformation in all branches,
thus minimizing the need for manual tuning of each branch.</p>
<p><img src="chapter_convolutional-modern/../img/resnext-block.svg" alt="The ResNeXt block. The use of grouped convolution with $\mathit{g}$ groups is $\mathit{g}$ times faster than a dense convolution. It is a bottleneck residual block when the number of intermediate channels $\mathit{b}$ is less than $\mathit{c}$." />
:label:<code>fig_resnext_block</code></p>
<p>Breaking up a convolution from $c_\textrm{i}$ to $c_\textrm{o}$ channels into one of $g$ groups of size $c_\textrm{i}/g$ generating $g$ outputs of size $c_\textrm{o}/g$ is called, quite fittingly, a <em>grouped convolution</em>. The computational cost (proportionally) is reduced from $\mathcal{O}(c_\textrm{i} \cdot c_\textrm{o})$ to $\mathcal{O}(g \cdot (c_\textrm{i}/g) \cdot (c_\textrm{o}/g)) = \mathcal{O}(c_\textrm{i} \cdot c_\textrm{o} / g)$, i.e., it is $g$ times faster. Even better, the number of parameters needed to generate the output is also reduced from a $c_\textrm{i} \times c_\textrm{o}$ matrix to $g$ smaller matrices of size $(c_\textrm{i}/g) \times (c_\textrm{o}/g)$, again a $g$ times reduction. In what follows we assume that both $c_\textrm{i}$ and $c_\textrm{o}$ are divisible by $g$.</p>
<p>The only challenge in this design is that no information is exchanged between the $g$ groups. The ResNeXt block of
:numref:<code>fig_resnext_block</code> amends this in two ways: the grouped convolution with a $3 \times 3$ kernel is sandwiched in between two $1 \times 1$ convolutions. The second one serves double duty in changing the number of channels back. The benefit is that we only pay the $\mathcal{O}(c \cdot b)$ cost for $1 \times 1$ kernels and can make do with an $\mathcal{O}(b^2 / g)$ cost for $3 \times 3$ kernels. Similar to the residual block implementation in
:numref:<code>subsec_residual-blks</code>, the residual connection is replaced (thus generalized) by a $1 \times 1$ convolution.</p>
<p>The right-hand figure in :numref:<code>fig_resnext_block</code> provides a much more concise summary of the resulting network block. It will also play a major role in the design of generic modern CNNs in :numref:<code>sec_cnn-design</code>. Note that the idea of grouped convolutions dates back to the implementation of AlexNet :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>. When distributing the network across two GPUs with limited memory, the implementation treated each GPU as its own channel with no ill effects.</p>
<p>The following implementation of the <code>ResNeXtBlock</code> class takes as argument <code>groups</code> ($g$), with
<code>bot_channels</code> ($b$) intermediate (bottleneck) channels. Lastly, when we need to reduce the height and width of the representation, we add a stride of $2$ by setting <code>use_1x1conv=True, strides=2</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class ResNeXtBlock(nn.Block):  #@save
    """The ResNeXt block."""
    def __init__(self, num_channels, groups, bot_mul,
                 use_1x1conv=False, strides=1, **kwargs):
        super().__init__(**kwargs)
        bot_channels = int(round(num_channels * bot_mul))
        self.conv1 = nn.Conv2D(bot_channels, kernel_size=1, padding=0,
                               strides=1)
        self.conv2 = nn.Conv2D(bot_channels, kernel_size=3, padding=1, 
                               strides=strides, groups=bot_channels//groups)
        self.conv3 = nn.Conv2D(num_channels, kernel_size=1, padding=0,
                               strides=1)
        self.bn1 = nn.BatchNorm()
        self.bn2 = nn.BatchNorm()
        self.bn3 = nn.BatchNorm()
        if use_1x1conv:
            self.conv4 = nn.Conv2D(num_channels, kernel_size=1,
                                   strides=strides)
            self.bn4 = nn.BatchNorm()
        else:
            self.conv4 = None

    def forward(self, X):
        Y = npx.relu(self.bn1(self.conv1(X)))
        Y = npx.relu(self.bn2(self.conv2(Y)))
        Y = self.bn3(self.conv3(Y))
        if self.conv4:
            X = self.bn4(self.conv4(X))
        return npx.relu(Y + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class ResNeXtBlock(nn.Module):  #@save
    """The ResNeXt block."""
    def __init__(self, num_channels, groups, bot_mul, use_1x1conv=False,
                 strides=1):
        super().__init__()
        bot_channels = int(round(num_channels * bot_mul))
        self.conv1 = nn.LazyConv2d(bot_channels, kernel_size=1, stride=1)
        self.conv2 = nn.LazyConv2d(bot_channels, kernel_size=3,
                                   stride=strides, padding=1,
                                   groups=bot_channels//groups)
        self.conv3 = nn.LazyConv2d(num_channels, kernel_size=1, stride=1)
        self.bn1 = nn.LazyBatchNorm2d()
        self.bn2 = nn.LazyBatchNorm2d()
        self.bn3 = nn.LazyBatchNorm2d()
        if use_1x1conv:
            self.conv4 = nn.LazyConv2d(num_channels, kernel_size=1, 
                                       stride=strides)
            self.bn4 = nn.LazyBatchNorm2d()
        else:
            self.conv4 = None

    def forward(self, X):
        Y = F.relu(self.bn1(self.conv1(X)))
        Y = F.relu(self.bn2(self.conv2(Y)))
        Y = self.bn3(self.conv3(Y))
        if self.conv4:
            X = self.bn4(self.conv4(X))
        return F.relu(Y + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class ResNeXtBlock(tf.keras.Model):  #@save
    """The ResNeXt block."""
    def __init__(self, num_channels, groups, bot_mul, use_1x1conv=False,
                 strides=1):
        super().__init__()
        bot_channels = int(round(num_channels * bot_mul))
        self.conv1 = tf.keras.layers.Conv2D(bot_channels, 1, strides=1)
        self.conv2 = tf.keras.layers.Conv2D(bot_channels, 3, strides=strides,
                                            padding="same",
                                            groups=bot_channels//groups)
        self.conv3 = tf.keras.layers.Conv2D(num_channels, 1, strides=1)
        self.bn1 = tf.keras.layers.BatchNormalization()
        self.bn2 = tf.keras.layers.BatchNormalization()
        self.bn3 = tf.keras.layers.BatchNormalization()
        if use_1x1conv:
            self.conv4 = tf.keras.layers.Conv2D(num_channels, 1,
                                                strides=strides)
            self.bn4 = tf.keras.layers.BatchNormalization()
        else:
            self.conv4 = None

    def call(self, X):
        Y = tf.keras.activations.relu(self.bn1(self.conv1(X)))
        Y = tf.keras.activations.relu(self.bn2(self.conv2(Y)))
        Y = self.bn3(self.conv3(Y))
        if self.conv4:
            X = self.bn4(self.conv4(X))
        return tf.keras.activations.relu(Y + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ResNeXtBlock(nn.Module):  #@save
    """The ResNeXt block."""
    num_channels: int
    groups: int
    bot_mul: int
    use_1x1conv: bool = False
    strides: tuple = (1, 1)
    training: bool = True

    def setup(self):
        bot_channels = int(round(self.num_channels * self.bot_mul))
        self.conv1 = nn.Conv(bot_channels, kernel_size=(1, 1),
                               strides=(1, 1))
        self.conv2 = nn.Conv(bot_channels, kernel_size=(3, 3),
                               strides=self.strides, padding='same',
                               feature_group_count=bot_channels//self.groups)
        self.conv3 = nn.Conv(self.num_channels, kernel_size=(1, 1),
                               strides=(1, 1))
        self.bn1 = nn.BatchNorm(not self.training)
        self.bn2 = nn.BatchNorm(not self.training)
        self.bn3 = nn.BatchNorm(not self.training)
        if self.use_1x1conv:
            self.conv4 = nn.Conv(self.num_channels, kernel_size=(1, 1),
                                       strides=self.strides)
            self.bn4 = nn.BatchNorm(not self.training)
        else:
            self.conv4 = None

    def __call__(self, X):
        Y = nn.relu(self.bn1(self.conv1(X)))
        Y = nn.relu(self.bn2(self.conv2(Y)))
        Y = self.bn3(self.conv3(Y))
        if self.conv4:
            X = self.bn4(self.conv4(X))
        return nn.relu(Y + X)
</code></pre>
<p>Its use is entirely analogous to that of the <code>ResNetBlock</code> discussed previously. For instance, when using (<code>use_1x1conv=False, strides=1</code>), the input and output are of the same shape. Alternatively, setting <code>use_1x1conv=True, strides=2</code> halves the output height and width.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
blk = ResNeXtBlock(32, 16, 1)
if tab.selected('mxnet'):
    blk.initialize()
X = d2l.randn(4, 32, 96, 96)
blk(X).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
blk = ResNeXtBlock(32, 16, 1)
X = d2l.normal((4, 96, 96, 32))
Y = blk(X)
Y.shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
blk = ResNeXtBlock(32, 16, 1)
X = jnp.zeros((4, 96, 96, 32))
blk.init_with_output(d2l.get_key(), X)[0].shape
</code></pre>
<h2 id="summary-and-discussion-5"><a class="header" href="#summary-and-discussion-5">Summary and Discussion</a></h2>
<p>Nested function classes are desirable since they allow us to obtain strictly <em>more powerful</em> rather than also subtly <em>different</em> function classes when adding capacity. One way of accomplishing this is by letting additional layers to simply pass through the input to the output. Residual connections allow for this. As a consequence, this changes the inductive bias from simple functions being of the form $f(\mathbf{x}) = 0$ to simple functions looking like $f(\mathbf{x}) = \mathbf{x}$.</p>
<p>The residual mapping can learn the identity function more easily, such as pushing parameters in the weight layer to zero. We can train an effective <em>deep</em> neural network by having residual blocks. Inputs can forward propagate faster through the residual connections across layers. As a consequence, we can thus train much deeper networks. For instance, the original ResNet paper :cite:<code>He.Zhang.Ren.ea.2016</code> allowed for up to 152 layers. Another benefit of residual networks is that it allows us to add layers, initialized as the identity function, <em>during</em> the training process. After all, the default behavior of a layer is to let the data pass through unchanged. This can accelerate the training of very large networks in some cases.</p>
<p>Prior to residual connections,
bypassing paths with gating units were introduced
to effectively train highway networks with over 100 layers
:cite:<code>srivastava2015highway</code>.
Using identity functions as bypassing paths,
ResNet performed remarkably well
on multiple computer vision tasks.
Residual connections had a major influence on the design of subsequent deep neural networks, of either convolutional or sequential nature.
As we will introduce later,
the Transformer architecture :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code>
adopts residual connections (together with other design choices) and is pervasive
in areas as diverse as
language, vision, speech, and reinforcement learning.</p>
<p>ResNeXt is an example for how the design of convolutional neural networks has evolved over time: by being more frugal with computation and trading it off against the size of the activations (number of channels), it allows for faster and more accurate networks at lower cost. An alternative way of viewing grouped convolutions is to think of a block-diagonal matrix for the convolutional weights. Note that there are quite a few such "tricks" that lead to more efficient networks. For instance, ShiftNet :cite:<code>wu2018shift</code> mimicks the effects of a $3 \times 3$ convolution, simply by adding shifted activations to the channels, offering increased function complexity, this time without any computational cost.</p>
<p>A common feature of the designs we have discussed so far is that the network design is fairly manual, primarily relying on the ingenuity of the designer to find the "right" network hyperparameters. While clearly feasible, it is also very costly in terms of human time and there is no guarantee that the outcome is optimal in any sense. In :numref:<code>sec_cnn-design</code> we will discuss a number of strategies for obtaining high quality networks in a more automated fashion. In particular, we will review the notion of <em>network design spaces</em> that led to the RegNetX/Y models
:cite:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code>.</p>
<h2 id="exercises-47"><a class="header" href="#exercises-47">Exercises</a></h2>
<ol>
<li>What are the major differences between the Inception block in :numref:<code>fig_inception</code> and the residual block? How do they compare in terms of computation, accuracy, and the classes of functions they can describe?</li>
<li>Refer to Table 1 in the ResNet paper :cite:<code>He.Zhang.Ren.ea.2016</code> to implement different variants of the network.</li>
<li>For deeper networks, ResNet introduces a "bottleneck" architecture to reduce model complexity. Try to implement it.</li>
<li>In subsequent versions of ResNet, the authors changed the "convolution, batch normalization, and activation" structure to the "batch normalization, activation, and convolution" structure. Make this improvement yourself. See Figure 1 in :citet:<code>He.Zhang.Ren.ea.2016*1</code> for details.</li>
<li>Why can't we just increase the complexity of functions without bound, even if the function classes are nested?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/85">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/86">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/8737">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18006">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="densely-connected-networks-densenet"><a class="header" href="#densely-connected-networks-densenet">Densely Connected Networks (DenseNet)</a></h1>
<p>:label:<code>sec_densenet</code></p>
<p>ResNet significantly changed the view of how to parametrize the functions in deep networks. <em>DenseNet</em> (dense convolutional network) is to some extent the logical extension of this :cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.
DenseNet is characterized by both the connectivity pattern where
each layer connects to all the preceding layers
and the concatenation operation (rather than the addition operator in ResNet) to preserve and reuse features
from earlier layers.
To understand how to arrive at it, let's take a small detour to mathematics.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="from-resnet-to-densenet"><a class="header" href="#from-resnet-to-densenet">From ResNet to DenseNet</a></h2>
<p>Recall the Taylor expansion for functions. At the point $x = 0$ it can be written as</p>
<p>$$f(x) = f(0) + x \cdot \left[f'(0) + x \cdot \left[\frac{f''(0)}{2!}  + x \cdot \left[\frac{f'''(0)}{3!}  + \cdots \right]\right]\right].$$</p>
<p>The key point is that it decomposes a function into terms of increasingly higher order. In a similar vein, ResNet decomposes functions into</p>
<p>$$f(\mathbf{x}) = \mathbf{x} + g(\mathbf{x}).$$</p>
<p>That is, ResNet decomposes $f$ into a simple linear term and a more complex
nonlinear one.
What if we wanted to capture (not necessarily add) information beyond two terms?
One such solution is DenseNet :cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.</p>
<p><img src="chapter_convolutional-modern/../img/densenet-block.svg" alt="The main difference between ResNet (left) and DenseNet (right) in cross-layer connections: use of addition and use of concatenation. " />
:label:<code>fig_densenet_block</code></p>
<p>As shown in :numref:<code>fig_densenet_block</code>, the key difference between ResNet and DenseNet is that in the latter case outputs are <em>concatenated</em> (denoted by $[,]$) rather than added.
As a result, we perform a mapping from $\mathbf{x}$ to its values after applying an increasingly complex sequence of functions:</p>
<p>$$\mathbf{x} \to \left[
\mathbf{x},
f_1(\mathbf{x}),
f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right), f_3\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right), f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right)\right]\right), \ldots\right].$$</p>
<p>In the end, all these functions are combined in MLP to reduce the number of features again. In terms of implementation this is quite simple:
rather than adding terms, we concatenate them. The name DenseNet arises from the fact that the dependency graph between variables becomes quite dense. The final layer of such a chain is densely connected to all previous layers. The dense connections are shown in :numref:<code>fig_densenet</code>.</p>
<p><img src="chapter_convolutional-modern/../img/densenet.svg" alt="Dense connections in DenseNet. Note how the dimensionality increases with depth." />
:label:<code>fig_densenet</code></p>
<p>The main components that comprise a DenseNet are <em>dense blocks</em> and <em>transition layers</em>. The former define how the inputs and outputs are concatenated, while the latter control the number of channels so that it is not too large,
since the expansion $\mathbf{x} \to \left[\mathbf{x}, f_1(\mathbf{x}),
f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right), \ldots \right]$ can be quite high-dimensional.</p>
<h2 id="dense-blocks"><a class="header" href="#dense-blocks">[<strong>Dense Blocks</strong>]</a></h2>
<p>DenseNet uses the modified "batch normalization, activation, and convolution"
structure of ResNet (see the exercise in :numref:<code>sec_resnet</code>).
First, we implement this convolution block structure.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def conv_block(num_channels):
    blk = nn.Sequential()
    blk.add(nn.BatchNorm(),
            nn.Activation('relu'),
            nn.Conv2D(num_channels, kernel_size=3, padding=1))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def conv_block(num_channels):
    return nn.Sequential(
        nn.LazyBatchNorm2d(), nn.ReLU(),
        nn.LazyConv2d(num_channels, kernel_size=3, padding=1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class ConvBlock(tf.keras.layers.Layer):
    def __init__(self, num_channels):
        super(ConvBlock, self).__init__()
        self.bn = tf.keras.layers.BatchNormalization()
        self.relu = tf.keras.layers.ReLU()
        self.conv = tf.keras.layers.Conv2D(
            filters=num_channels, kernel_size=(3, 3), padding='same')

        self.listLayers = [self.bn, self.relu, self.conv]

    def call(self, x):
        y = x
        for layer in self.listLayers.layers:
            y = layer(y)
        y = tf.keras.layers.concatenate([x,y], axis=-1)
        return y
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ConvBlock(nn.Module):
    num_channels: int
    training: bool = True

    @nn.compact
    def __call__(self, X):
        Y = nn.relu(nn.BatchNorm(not self.training)(X))
        Y = nn.Conv(self.num_channels, kernel_size=(3, 3), padding=(1, 1))(Y)
        Y = jnp.concatenate((X, Y), axis=-1)
        return Y
</code></pre>
<p>A <em>dense block</em> consists of multiple convolution blocks, each using the same number of output channels. In the forward propagation, however, we concatenate the input and output of each convolution block on the channel dimension. Lazy evaluation allows us to adjust the dimensionality automatically.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class DenseBlock(nn.Block):
    def __init__(self, num_convs, num_channels):
        super().__init__()
        self.net = nn.Sequential()
        for _ in range(num_convs):
            self.net.add(conv_block(num_channels))

    def forward(self, X):
        for blk in self.net:
            Y = blk(X)
            # Concatenate input and output of each block along the channels
            X = np.concatenate((X, Y), axis=1)
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class DenseBlock(nn.Module):
    def __init__(self, num_convs, num_channels):
        super(DenseBlock, self).__init__()
        layer = []
        for i in range(num_convs):
            layer.append(conv_block(num_channels))
        self.net = nn.Sequential(*layer)

    def forward(self, X):
        for blk in self.net:
            Y = blk(X)
            # Concatenate input and output of each block along the channels
            X = torch.cat((X, Y), dim=1)
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class DenseBlock(tf.keras.layers.Layer):
    def __init__(self, num_convs, num_channels):
        super(DenseBlock, self).__init__()
        self.listLayers = []
        for _ in range(num_convs):
            self.listLayers.append(ConvBlock(num_channels))

    def call(self, x):
        for layer in self.listLayers.layers:
            x = layer(x)
        return x
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class DenseBlock(nn.Module):
    num_convs: int
    num_channels: int
    training: bool = True

    def setup(self):
        layer = []
        for i in range(self.num_convs):
            layer.append(ConvBlock(self.num_channels, self.training))
        self.net = nn.Sequential(layer)

    def __call__(self, X):
        return self.net(X)
</code></pre>
<p>In the following example,
we [<strong>define a <code>DenseBlock</code> instance</strong>] with two convolution blocks of 10 output channels.
When using an input with three channels, we will get an output with  $3 + 10 + 10=23$ channels. The number of convolution block channels controls the growth in the number of output channels relative to the number of input channels. This is also referred to as the <em>growth rate</em>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
blk = DenseBlock(2, 10)
if tab.selected('mxnet'):
    X = np.random.uniform(size=(4, 3, 8, 8))
    blk.initialize()
if tab.selected('pytorch'):
    X = torch.randn(4, 3, 8, 8)
if tab.selected('tensorflow'):
    X = tf.random.uniform((4, 8, 8, 3))
Y = blk(X)
Y.shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
blk = DenseBlock(2, 10)
X = jnp.zeros((4, 8, 8, 3))
Y = blk.init_with_output(d2l.get_key(), X)[0]
Y.shape
</code></pre>
<h2 id="transition-layers"><a class="header" href="#transition-layers">[<strong>Transition Layers</strong>]</a></h2>
<p>Since each dense block will increase the number of channels, adding too many of them will lead to an excessively complex model. A <em>transition layer</em> is used to control the complexity of the model. It reduces the number of channels by using a $1\times 1$ convolution. Moreover, it halves the height and width via average pooling with a stride of 2.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def transition_block(num_channels):
    blk = nn.Sequential()
    blk.add(nn.BatchNorm(), nn.Activation('relu'),
            nn.Conv2D(num_channels, kernel_size=1),
            nn.AvgPool2D(pool_size=2, strides=2))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def transition_block(num_channels):
    return nn.Sequential(
        nn.LazyBatchNorm2d(), nn.ReLU(),
        nn.LazyConv2d(num_channels, kernel_size=1),
        nn.AvgPool2d(kernel_size=2, stride=2))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class TransitionBlock(tf.keras.layers.Layer):
    def __init__(self, num_channels, **kwargs):
        super(TransitionBlock, self).__init__(**kwargs)
        self.batch_norm = tf.keras.layers.BatchNormalization()
        self.relu = tf.keras.layers.ReLU()
        self.conv = tf.keras.layers.Conv2D(num_channels, kernel_size=1)
        self.avg_pool = tf.keras.layers.AvgPool2D(pool_size=2, strides=2)

    def call(self, x):
        x = self.batch_norm(x)
        x = self.relu(x)
        x = self.conv(x)
        return self.avg_pool(x)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class TransitionBlock(nn.Module):
    num_channels: int
    training: bool = True

    @nn.compact
    def __call__(self, X):
        X = nn.BatchNorm(not self.training)(X)
        X = nn.relu(X)
        X = nn.Conv(self.num_channels, kernel_size=(1, 1))(X)
        X = nn.avg_pool(X, window_shape=(2, 2), strides=(2, 2))
        return X
</code></pre>
<p>[<strong>Apply a transition layer</strong>] with 10 channels to the output of the dense block in the previous example.  This reduces the number of output channels to 10, and halves the height and width.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
blk = transition_block(10)
blk.initialize()
blk(Y).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
blk = transition_block(10)
blk(Y).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
blk = TransitionBlock(10)
blk(Y).shape
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
blk = TransitionBlock(10)
blk.init_with_output(d2l.get_key(), Y)[0].shape
</code></pre>
<h2 id="densenet-model"><a class="header" href="#densenet-model">[<strong>DenseNet Model</strong>]</a></h2>
<p>Next, we will construct a DenseNet model. DenseNet first uses the same single convolutional layer and max-pooling layer as in ResNet.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class DenseNet(d2l.Classifier):
    def b1(self):
        if tab.selected('mxnet'):
            net = nn.Sequential()
            net.add(nn.Conv2D(64, kernel_size=7, strides=2, padding=3),
                nn.BatchNorm(), nn.Activation('relu'),
                nn.MaxPool2D(pool_size=3, strides=2, padding=1))
            return net
        if tab.selected('pytorch'):
            return nn.Sequential(
                nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3),
                nn.LazyBatchNorm2d(), nn.ReLU(),
                nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
        if tab.selected('tensorflow'):
            return tf.keras.models.Sequential([
                tf.keras.layers.Conv2D(
                    64, kernel_size=7, strides=2, padding='same'),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.ReLU(),
                tf.keras.layers.MaxPool2D(
                    pool_size=3, strides=2, padding='same')])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class DenseNet(d2l.Classifier):
    num_channels: int = 64
    growth_rate: int = 32
    arch: tuple = (4, 4, 4, 4)
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = self.create_net()

    def b1(self):
        return nn.Sequential([
            nn.Conv(64, kernel_size=(7, 7), strides=(2, 2), padding='same'),
            nn.BatchNorm(not self.training),
            nn.relu,
            lambda x: nn.max_pool(x, window_shape=(3, 3),
                                  strides=(2, 2), padding='same')
        ])
</code></pre>
<p>Then, similar to the four modules made up of residual blocks that ResNet uses,
DenseNet uses four dense blocks.
As with ResNet, we can set the number of convolutional layers used in each dense block. Here, we set it to 4, consistent with the ResNet-18 model in :numref:<code>sec_resnet</code>. Furthermore, we set the number of channels (i.e., growth rate) for the convolutional layers in the dense block to 32, so 128 channels will be added to each dense block.</p>
<p>In ResNet, the height and width are reduced between each module by a residual block with a stride of 2. Here, we use the transition layer to halve the height and width and halve the number of channels. Similar to ResNet, a global pooling layer and a fully connected layer are connected at the end to produce the output.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(DenseNet)
def __init__(self, num_channels=64, growth_rate=32, arch=(4, 4, 4, 4),
             lr=0.1, num_classes=10):
    super(DenseNet, self).__init__()
    self.save_hyperparameters()
    if tab.selected('mxnet'):
        self.net = nn.Sequential()
        self.net.add(self.b1())
        for i, num_convs in enumerate(arch):
            self.net.add(DenseBlock(num_convs, growth_rate))
            # The number of output channels in the previous dense block
            num_channels += num_convs * growth_rate
            # A transition layer that halves the number of channels is added
            # between the dense blocks
            if i != len(arch) - 1:
                num_channels //= 2
                self.net.add(transition_block(num_channels))
        self.net.add(nn.BatchNorm(), nn.Activation('relu'),
                     nn.GlobalAvgPool2D(), nn.Dense(num_classes))
        self.net.initialize(init.Xavier())
    if tab.selected('pytorch'):
        self.net = nn.Sequential(self.b1())
        for i, num_convs in enumerate(arch):
            self.net.add_module(f'dense_blk{i+1}', DenseBlock(num_convs,
                                                              growth_rate))
            # The number of output channels in the previous dense block
            num_channels += num_convs * growth_rate
            # A transition layer that halves the number of channels is added
            # between the dense blocks
            if i != len(arch) - 1:
                num_channels //= 2
                self.net.add_module(f'tran_blk{i+1}', transition_block(
                    num_channels))
        self.net.add_module('last', nn.Sequential(
            nn.LazyBatchNorm2d(), nn.ReLU(),
            nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(),
            nn.LazyLinear(num_classes)))
        self.net.apply(d2l.init_cnn)
    if tab.selected('tensorflow'):
        self.net = tf.keras.models.Sequential(self.b1())
        for i, num_convs in enumerate(arch):
            self.net.add(DenseBlock(num_convs, growth_rate))
            # The number of output channels in the previous dense block
            num_channels += num_convs * growth_rate
            # A transition layer that halves the number of channels is added
            # between the dense blocks
            if i != len(arch) - 1:
                num_channels //= 2
                self.net.add(TransitionBlock(num_channels))
        self.net.add(tf.keras.models.Sequential([
            tf.keras.layers.BatchNormalization(),
            tf.keras.layers.ReLU(),
            tf.keras.layers.GlobalAvgPool2D(),
            tf.keras.layers.Flatten(),
            tf.keras.layers.Dense(num_classes)]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(DenseNet)
def create_net(self):
    net = self.b1()
    for i, num_convs in enumerate(self.arch):
        net.layers.extend([DenseBlock(num_convs, self.growth_rate,
                                      training=self.training)])
        # The number of output channels in the previous dense block
        num_channels = self.num_channels + (num_convs * self.growth_rate)
        # A transition layer that halves the number of channels is added
        # between the dense blocks
        if i != len(self.arch) - 1:
            num_channels //= 2
            net.layers.extend([TransitionBlock(num_channels,
                                               training=self.training)])
    net.layers.extend([
        nn.BatchNorm(not self.training),
        nn.relu,
        lambda x: nn.avg_pool(x, window_shape=x.shape[1:3],
                              strides=x.shape[1:3], padding='valid'),
        lambda x: x.reshape((x.shape[0], -1)),
        nn.Dense(self.num_classes)
    ])
    return net
</code></pre>
<h2 id="training-14"><a class="header" href="#training-14">[<strong>Training</strong>]</a></h2>
<p>Since we are using a deeper network here, in this section, we will reduce the input height and width from 224 to 96 to simplify the computation.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
model = DenseNet(lr=0.01)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
with d2l.try_gpu():
    model = DenseNet(lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="summary-and-discussion-6"><a class="header" href="#summary-and-discussion-6">Summary and Discussion</a></h2>
<p>The main components that comprise DenseNet are dense blocks and transition layers. For the latter, we need to keep the dimensionality under control when composing the network by adding transition layers that shrink the number of channels again.
In terms of cross-layer connections, in contrast to ResNet, where inputs and outputs are added together, DenseNet concatenates inputs and outputs on the channel dimension.
Although these concatenation operations
reuse features to achieve computational efficiency,
unfortunately they lead to heavy GPU memory consumption.
As a result,
applying DenseNet may require more memory-efficient implementations that may increase training time :cite:<code>pleiss2017memory</code>.</p>
<h2 id="exercises-48"><a class="header" href="#exercises-48">Exercises</a></h2>
<ol>
<li>Why do we use average pooling rather than max-pooling in the transition layer?</li>
<li>One of the advantages mentioned in the DenseNet paper is that its model parameters are smaller than those of ResNet. Why is this the case?</li>
<li>One problem for which DenseNet has been criticized is its high memory consumption.
<ol>
<li>Is this really the case? Try to change the input shape to $224\times 224$ to compare the actual GPU memory consumption empirically.</li>
<li>Can you think of an alternative means of reducing the memory consumption? How would you need to change the framework?</li>
</ol>
</li>
<li>Implement the various DenseNet versions presented in Table 1 of the DenseNet paper :cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.</li>
<li>Design an MLP-based model by applying the DenseNet idea. Apply it to the housing price prediction task in :numref:<code>sec_kaggle_house</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/87">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/88">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/331">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18008">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="designing-convolution-network-architectures"><a class="header" href="#designing-convolution-network-architectures">Designing Convolution Network Architectures</a></h1>
<p>:label:<code>sec_cnn-design</code></p>
<p>The previous sections have taken us on a tour of modern network design for computer vision. Common to all the work we covered was that it greatly relied on the intuition of scientists. Many of the architectures are heavily informed by human creativity and to a much lesser extent by systematic exploration of the design space that deep networks offer. Nonetheless, this <em>network engineering</em> approach has been tremendously successful.</p>
<p>Ever since AlexNet (:numref:<code>sec_alexnet</code>)
beat conventional computer vision models on ImageNet,
it has become popular to construct very deep networks
by stacking blocks of convolutions, all designed according to the same pattern.
In particular, $3 \times 3$ convolutions were
popularized by VGG networks (:numref:<code>sec_vgg</code>).
NiN (:numref:<code>sec_nin</code>) showed that even $1 \times 1$ convolutions could
be beneficial by adding local nonlinearities.
Moreover, NiN solved the problem of aggregating information at the head of a network
by aggregating across all locations.
GoogLeNet (:numref:<code>sec_googlenet</code>) added multiple branches of different convolution width,
combining the advantages of VGG and NiN in its Inception block.
ResNets (:numref:<code>sec_resnet</code>)
changed the inductive bias towards the identity mapping (from $f(x) = 0$). This allowed for very deep networks. Almost a decade later, the ResNet design is still popular, a testament to its design. Lastly, ResNeXt (:numref:<code>subsec_resnext</code>) added grouped convolutions, offering a better trade-off between parameters and computation. A precursor to Transformers for vision, the Squeeze-and-Excitation Networks (SENets) allow for efficient information transfer between locations
:cite:<code>Hu.Shen.Sun.2018</code>. This was accomplished by computing a per-channel global attention function.</p>
<p>Up to now we have omitted networks obtained via <em>neural architecture search</em> (NAS) :cite:<code>zoph2016neural,liu2018darts</code>. We chose to do so since their cost is usually enormous, relying on brute-force search, genetic algorithms, reinforcement learning, or some other form of hyperparameter optimization. Given a fixed search space,
NAS uses a search strategy to automatically select
an architecture based on the returned performance estimation.
The outcome of NAS
is a single network instance. EfficientNets are a notable outcome of this search :cite:<code>tan2019efficientnet</code>.</p>
<p>In the following we discuss an idea that is quite different to the quest for the <em>single best network</em>. It is computationally relatively inexpensive, it leads to scientific insights on the way, and it is quite effective in terms of the quality of outcomes. Let's review the strategy by :citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code> to <em>design network design spaces</em>. The strategy combines the strength of manual design and NAS. It accomplishes this by operating on <em>distributions of networks</em> and optimizing the distributions in a way to obtain good performance for entire families of networks. The outcome of it are <em>RegNets</em>, specifically RegNetX and RegNetY, plus a range of guiding principles for the design of performant CNNs.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx, init
from mxnet.gluon import nn

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import tensorflow as tf
from d2l import tensorflow as d2l
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
</code></pre>
<h2 id="the-anynet-design-space"><a class="header" href="#the-anynet-design-space">The AnyNet Design Space</a></h2>
<p>:label:<code>subsec_the-anynet-design-space</code></p>
<p>The description below closely follows the reasoning in :citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code> with some abbreviations to make it fit in the scope of the book.
To begin, we need a template for the family of networks to explore. One of the commonalities of the designs in this chapter is that the networks consist of a <em>stem</em>, a <em>body</em> and a <em>head</em>. The stem performs initial image processing, often through convolutions with a larger window size. The body consists of multiple blocks, carrying out the bulk of the transformations needed to go from raw images to object representations. Lastly, the head converts this into the desired outputs, such as via a softmax regressor for multiclass classification.
The body, in turn, consists of multiple stages, operating on the image at decreasing resolutions. In fact, both the stem and each subsequent stage quarter the spatial resolution. Lastly, each stage consists of one or more blocks. This pattern is common to all networks, from VGG to ResNeXt. Indeed, for the design of generic AnyNet networks, :citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code> used the ResNeXt block of :numref:<code>fig_resnext_block</code>.</p>
<p><img src="chapter_convolutional-modern/../img/anynet.svg" alt="The AnyNet design space. The numbers $(\mathit{c}, \mathit{r})$ along each arrow indicate the number of channels $c$ and the resolution $\mathit{r} \times \mathit{r}$ of the images at that point. From left to right: generic network structure composed of stem, body, and head; body composed of four stages; detailed structure of a stage; two alternative structures for blocks, one without downsampling and one that halves the resolution in each dimension. Design choices include depth $\mathit{d_i}$, the number of output channels $\mathit{c_i}$, the number of groups $\mathit{g_i}$, and bottleneck ratio $\mathit{k_i}$ for any stage $\mathit{i}$." />
:label:<code>fig_anynet_full</code></p>
<p>Let's review the structure outlined in :numref:<code>fig_anynet_full</code> in detail. As mentioned, an AnyNet consists of a stem, body, and head. The stem takes as its input RGB images (3 channels), using a $3 \times 3$ convolution with a stride of $2$, followed by a batch norm, to halve the resolution from $r \times r$ to $r/2 \times r/2$. Moreover, it generates $c_0$ channels that serve as input to the body.</p>
<p>Since the network is designed to work well with ImageNet images of shape $224 \times 224 \times 3$, the body serves to reduce this to $7 \times 7 \times c_4$ through 4 stages (recall that $224 / 2^{1+4} = 7$), each with an eventual stride of $2$. Lastly, the head employs an entirely standard design via global average pooling, similar to NiN (:numref:<code>sec_nin</code>), followed by a fully connected layer to emit an $n$-dimensional vector for $n$-class classification.</p>
<p>Most of the relevant design decisions are inherent to the body of the network. It proceeds in stages, where each stage is composed of the same type of ResNeXt blocks as we discussed in :numref:<code>subsec_resnext</code>. The design there is again entirely generic: we begin with a block that halves the resolution by using a stride of $2$ (the rightmost in :numref:<code>fig_anynet_full</code>). To match this, the residual branch of the ResNeXt block needs to pass through a $1 \times 1$ convolution. This block is followed by a variable number of additional ResNeXt blocks that leave both resolution and the number of channels unchanged. Note that a common design practice is to add a slight bottleneck in the design of convolutional blocks.
As such, with bottleneck ratio $k_i \geq 1$ we afford some number of channels, $c_i/k_i$,  within each block for stage $i$ (as the experiments show, this is not really effective and should be skipped). Lastly, since we are dealing with ResNeXt blocks, we also need to pick the number of groups $g_i$ for grouped convolutions at stage $i$.</p>
<p>This seemingly generic design space provides us nonetheless with many parameters: we can set the block width (number of channels) $c_0, \ldots c_4$, the depth (number of blocks) per stage $d_1, \ldots d_4$, the bottleneck ratios $k_1, \ldots k_4$, and the group widths (numbers of groups) $g_1, \ldots g_4$.
In total this adds up to 17 parameters, resulting in an unreasonably large number of configurations that would warrant exploring. We need some tools to reduce this huge design space effectively. This is where the conceptual beauty of design spaces comes in. Before we do so, let's implement the generic design first.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class AnyNet(d2l.Classifier):
    def stem(self, num_channels):
        net = nn.Sequential()
        net.add(nn.Conv2D(num_channels, kernel_size=3, padding=1, strides=2),
                nn.BatchNorm(), nn.Activation('relu'))
        return net
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class AnyNet(d2l.Classifier):
    def stem(self, num_channels):
        return nn.Sequential(
            nn.LazyConv2d(num_channels, kernel_size=3, stride=2, padding=1),
            nn.LazyBatchNorm2d(), nn.ReLU())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class AnyNet(d2l.Classifier):
    def stem(self, num_channels):
        return tf.keras.models.Sequential([
            tf.keras.layers.Conv2D(num_channels, kernel_size=3, strides=2,
                                   padding='same'),
            tf.keras.layers.BatchNormalization(),
            tf.keras.layers.Activation('relu')])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class AnyNet(d2l.Classifier):
    arch: tuple
    stem_channels: int
    lr: float = 0.1
    num_classes: int = 10
    training: bool = True

    def setup(self):
        self.net = self.create_net()

    def stem(self, num_channels):
        return nn.Sequential([
            nn.Conv(num_channels, kernel_size=(3, 3), strides=(2, 2),
                    padding=(1, 1)),
            nn.BatchNorm(not self.training),
            nn.relu
        ])
</code></pre>
<p>Each stage consists of <code>depth</code> ResNeXt blocks,
where <code>num_channels</code> specifies the block width.
Note that the first block halves the height and width of input images.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(AnyNet)
def stage(self, depth, num_channels, groups, bot_mul):
    net = nn.Sequential()
    for i in range(depth):
        if i == 0:
            net.add(d2l.ResNeXtBlock(
                num_channels, groups, bot_mul, use_1x1conv=True, strides=2))
        else:
            net.add(d2l.ResNeXtBlock(
                num_channels, num_channels, groups, bot_mul))
    return net
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(AnyNet)
def stage(self, depth, num_channels, groups, bot_mul):
    blk = []
    for i in range(depth):
        if i == 0:
            blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul,
                use_1x1conv=True, strides=2))
        else:
            blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul))
    return nn.Sequential(*blk)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(AnyNet)
def stage(self, depth, num_channels, groups, bot_mul):
    net = tf.keras.models.Sequential()
    for i in range(depth):
        if i == 0:
            net.add(d2l.ResNeXtBlock(num_channels, groups, bot_mul,
                use_1x1conv=True, strides=2))
        else:
            net.add(d2l.ResNeXtBlock(num_channels, groups, bot_mul))
    return net
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(AnyNet)
def stage(self, depth, num_channels, groups, bot_mul):
    blk = []
    for i in range(depth):
        if i == 0:
            blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul,
                use_1x1conv=True, strides=(2, 2), training=self.training))
        else:
            blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul,
                                        training=self.training))
    return nn.Sequential(blk)
</code></pre>
<p>Putting the network stem, body, and head together,
we complete the implementation of AnyNet.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(AnyNet)
def __init__(self, arch, stem_channels, lr=0.1, num_classes=10):
    super(AnyNet, self).__init__()
    self.save_hyperparameters()
    if tab.selected('mxnet'):
        self.net = nn.Sequential()
        self.net.add(self.stem(stem_channels))
        for i, s in enumerate(arch):
            self.net.add(self.stage(*s))
        self.net.add(nn.GlobalAvgPool2D(), nn.Dense(num_classes))
        self.net.initialize(init.Xavier())
    if tab.selected('pytorch'):
        self.net = nn.Sequential(self.stem(stem_channels))
        for i, s in enumerate(arch):
            self.net.add_module(f'stage{i+1}', self.stage(*s))
        self.net.add_module('head', nn.Sequential(
            nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(),
            nn.LazyLinear(num_classes)))
        self.net.apply(d2l.init_cnn)
    if tab.selected('tensorflow'):
        self.net = tf.keras.models.Sequential(self.stem(stem_channels))
        for i, s in enumerate(arch):
            self.net.add(self.stage(*s))
        self.net.add(tf.keras.models.Sequential([
            tf.keras.layers.GlobalAvgPool2D(),
            tf.keras.layers.Dense(units=num_classes)]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(AnyNet)
def create_net(self):
    net = nn.Sequential([self.stem(self.stem_channels)])
    for i, s in enumerate(self.arch):
        net.layers.extend([self.stage(*s)])
    net.layers.extend([nn.Sequential([
        lambda x: nn.avg_pool(x, window_shape=x.shape[1:3],
                            strides=x.shape[1:3], padding='valid'),
        lambda x: x.reshape((x.shape[0], -1)),
        nn.Dense(self.num_classes)])])
    return net
</code></pre>
<h2 id="distributions-and-parameters-of-design-spaces"><a class="header" href="#distributions-and-parameters-of-design-spaces">Distributions and Parameters of Design Spaces</a></h2>
<p>As just discussed in :numref:<code>subsec_the-anynet-design-space</code>, parameters of a design space are hyperparameters of networks in that design space.
Consider the problem of identifying good parameters in the AnyNet design space. We could try finding the <em>single best</em> parameter choice for a given amount of computation (e.g., FLOPs and compute time). If we allowed for even only <em>two</em> possible choices for each parameter, we would have to explore $2^{17} = 131072$ combinations to find the best solution. This is clearly infeasible because of its exorbitant cost. Even worse, we do not really learn anything from this exercise in terms of how one should design a network. Next time we add, say, an X-stage, or a shift operation, or similar, we would need to start from scratch. Even worse, due to the stochasticity in training (rounding, shuffling, bit errors), no two runs are likely to produce exactly the same results. A better strategy would be to try to determine general guidelines of how the choices of parameters should be related. For instance, the bottleneck ratio, the number of channels, blocks, groups, or their change between layers should ideally be governed by a collection of simple rules. The approach in :citet:<code>radosavovic2019network</code> relies on the following four assumptions:</p>
<ol>
<li>We assume that general design principles actually exist, so that many networks satisfying these requirements should offer good performance. Consequently, identifying a <em>distribution</em> over networks can be a sensible strategy. In other words, we assume that there are many good needles in the haystack.</li>
<li>We need not train networks to convergence before we can assess whether a network is good. Instead, it is sufficient to use the intermediate results as reliable guidance for final accuracy. Using (approximate) proxies to optimize an objective is referred to as multi-fidelity optimization :cite:<code>forrester2007multi</code>. Consequently, design optimization is carried out, based on the accuracy achieved after only a few passes through the dataset, reducing the cost significantly.</li>
<li>Results obtained at a smaller scale (for smaller networks) generalize to larger ones. Consequently, optimization is carried out for networks that are structurally similar, but with a smaller number of blocks, fewer channels, etc. Only in the end will we need to verify that the so-found networks also offer good performance at scale.</li>
<li>Aspects of the design can be approximately factorized so that it is possible to infer their effect on the quality of the outcome somewhat independently. In other words, the optimization problem is moderately easy.</li>
</ol>
<p>These assumptions allow us to test many networks cheaply. In particular, we can <em>sample</em> uniformly from the space of configurations and evaluate their performance. Subsequently, we can evaluate the quality of the choice of parameters by reviewing the <em>distribution</em> of error/accuracy that can be achieved with said networks. Denote by $F(e)$ the cumulative distribution function (CDF) for errors committed by networks of a given design space, drawn using probability disribution $p$. That is,</p>
<p>$$F(e, p) \stackrel{\textrm{def}}{=} P_{\textrm{net} \sim p} {e(\textrm{net}) \leq e}.$$</p>
<p>Our goal is now to find a distribution $p$ over <em>networks</em> such that most networks have a very low error rate and where the support of $p$ is concise. Of course, this is computationally infeasible to perform accurately. We resort to a sample of networks $\mathcal{Z} \stackrel{\textrm{def}}{=} {\textrm{net}_1, \ldots \textrm{net}_n}$ (with errors $e_1, \ldots, e_n$, respectively) from $p$ and use the empirical CDF $\hat{F}(e, \mathcal{Z})$ instead:</p>
<p>$$\hat{F}(e, \mathcal{Z}) = \frac{1}{n}\sum_{i=1}^n \mathbf{1}(e_i \leq e).$$</p>
<p>Whenever the CDF for one set of choices majorizes (or matches) another CDF it follows that its choice of parameters is superior (or indifferent). Accordingly
:citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code> experimented with a shared network bottleneck ratio $k_i = k$ for all stages $i$ of the network. This gets rid of three of the four parameters governing the bottleneck ratio. To assess whether this (negatively) affects the performance one can draw networks from the constrained and from the unconstrained distribution and compare the corresonding CDFs. It turns out that this constraint does not affect the accuracy of the distribution of networks at all, as can be seen in the first panel of :numref:<code>fig_regnet-fig</code>.
Likewise, we could choose to pick the same group width $g_i = g$ occurring at the various stages of the network. Again, this does not affect performance, as can be seen in the second panel of :numref:<code>fig_regnet-fig</code>.
Both steps combined reduce the number of free parameters by six.</p>
<p><img src="chapter_convolutional-modern/../img/regnet-fig.png" alt="Comparing error empirical distribution functions of design spaces. $\textrm{AnyNet}\mathit{A}$ is the original design space; $\textrm{AnyNet}\mathit{B}$ ties the bottleneck ratios, $\textrm{AnyNet}\mathit{C}$ also ties group widths, $\textrm{AnyNet}\mathit{D}$ increases the network depth across stages. From left to right: (i) tying bottleneck ratios has no effect on performance; (ii) tying group widths has no effect on performance; (iii) increasing network widths (channels) across stages improves performance; (iv) increasing network depths across stages improves performance. Figure courtesy of :citet:Radosavovic.Kosaraju.Girshick.ea.2020." />
:label:<code>fig_regnet-fig</code></p>
<p>Next we look for ways to reduce the multitude of potential choices for width and depth of the stages. It is a reasonable assumption that, as we go deeper, the number of channels should increase, i.e., $c_i \geq c_{i-1}$ ($w_{i+1} \geq w_i$ per their notation in :numref:<code>fig_regnet-fig</code>), yielding
$\textrm{AnyNetX}<em>D$. Likewise, it is equally reasonable to assume that as the stages progress, they should become deeper, i.e., $d_i \geq d</em>{i-1}$, yielding $\textrm{AnyNetX}_E$. This can be experimentally verified in the third and fourth panel of :numref:<code>fig_regnet-fig</code>, respectively.</p>
<h2 id="regnet"><a class="header" href="#regnet">RegNet</a></h2>
<p>The resulting $\textrm{AnyNetX}_E$ design space consists of simple networks
following easy-to-interpret design principles:</p>
<ul>
<li>Share the bottleneck ratio $k_i = k$ for all stages $i$;</li>
<li>Share the group width $g_i = g$ for all stages $i$;</li>
<li>Increase network width across stages: $c_{i} \leq c_{i+1}$;</li>
<li>Increase network depth across stages: $d_{i} \leq d_{i+1}$.</li>
</ul>
<p>This leaves us with a final set of choices: how to pick the specific values for the above parameters of the eventual $\textrm{AnyNetX}_E$ design space. By studying the best-performing networks from the distribution in $\textrm{AnyNetX}_E$ one can observe the following: the width of the network ideally increases linearly with the block index across the network, i.e., $c_j \approx c_0 + c_a j$, where $j$ is the block index and slope $c_a &gt; 0$. Given that we get to choose a different block width only per stage, we arrive at a piecewise constant function, engineered to match this dependence. Furthermore, experiments also show that a bottleneck ratio of $k = 1$ performs best, i.e., we are advised not to use bottlenecks at all.</p>
<p>We recommend the interested reader reviews further details in the design of specific networks for different amounts of computation by perusing :citet:<code>Radosavovic.Kosaraju.Girshick.ea.2020</code>. For instance, an effective 32-layer RegNetX variant is given by $k = 1$ (no bottleneck), $g = 16$ (group width is 16), $c_1 = 32$ and $c_2 = 80$ channels for the first and second stage, respectively, chosen to be $d_1=4$ and $d_2=6$ blocks deep. The astonishing insight from the design is that it still applies, even when investigating networks at a larger scale. Even better, it even holds for Squeeze-and-Excitation (SE) network designs (RegNetY) that have a global channel activation :cite:<code>Hu.Shen.Sun.2018</code>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class RegNetX32(AnyNet):
    def __init__(self, lr=0.1, num_classes=10):
        stem_channels, groups, bot_mul = 32, 16, 1
        depths, channels = (4, 6), (32, 80)
        super().__init__(
            ((depths[0], channels[0], groups, bot_mul),
             (depths[1], channels[1], groups, bot_mul)),
            stem_channels, lr, num_classes)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class RegNetX32(AnyNet):
    lr: float = 0.1
    num_classes: int = 10
    stem_channels: int = 32
    arch: tuple = ((4, 32, 16, 1), (6, 80, 16, 1))
</code></pre>
<p>We can see that each RegNetX stage progressively reduces resolution and increases output channels.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
RegNetX32().layer_summary((1, 1, 96, 96))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
RegNetX32().layer_summary((1, 96, 96, 1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
RegNetX32(training=False).layer_summary((1, 96, 96, 1))
</code></pre>
<h2 id="training-15"><a class="header" href="#training-15">Training</a></h2>
<p>Training the 32-layer RegNetX on the Fashion-MNIST dataset is just like before.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch, jax
model = RegNetX32(lr=0.05)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
trainer = d2l.Trainer(max_epochs=10)
data = d2l.FashionMNIST(batch_size=128, resize=(96, 96))
with d2l.try_gpu():
    model = RegNetX32(lr=0.01)
    trainer.fit(model, data)
</code></pre>
<h2 id="discussion-9"><a class="header" href="#discussion-9">Discussion</a></h2>
<p>With desirable inductive biases (assumptions or preferences) like locality and translation invariance (:numref:<code>sec_why-conv</code>)
for vision, CNNs have been the dominant architectures in this area. This remained the case from LeNet up until Transformers (:numref:<code>sec_transformer</code>) :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021,touvron2021training</code> started surpassing CNNs in terms of accuracy. While much of the recent progress in terms of vision Transformers <em>can</em> be backported into CNNs :cite:<code>liu2022convnet</code>, it is only possible at a higher computational cost. Just as importantly, recent hardware optimizations (NVIDIA Ampere and Hopper) have only widened the gap in favor of Transformers.</p>
<p>It is worth noting that Transformers have a significantly lower degree of inductive bias towards locality and translation invariance than CNNs. That learned structures prevailed is due, not least, to the availability of large image collections, such as LAION-400m and LAION-5B :cite:<code>schuhmann2022laion</code> with up to 5 billion images. Quite surprisingly, some of the more relevant work in this context even includes MLPs :cite:<code>tolstikhin2021mlp</code>.</p>
<p>In sum, vision Transformers (:numref:<code>sec_vision-transformer</code>) by now lead in terms of
state-of-the-art performance in large-scale image classification,
showing that <em>scalability trumps inductive biases</em> :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021</code>.
This includes pretraining large-scale Transformers (:numref:<code>sec_large-pretraining-transformers</code>) with multi-head self-attention (:numref:<code>sec_multihead-attention</code>). We invite the readers to dive into these chapters for a much more detailed discussion.</p>
<h2 id="exercises-49"><a class="header" href="#exercises-49">Exercises</a></h2>
<ol>
<li>Increase the number of stages to four. Can you design a deeper RegNetX that performs better?</li>
<li>De-ResNeXt-ify RegNets by replacing the ResNeXt block with the ResNet block. How does your new model perform?</li>
<li>Implement multiple instances of a "VioNet" family by <em>violating</em> the design principles of RegNetX. How do they perform? Which of ($d_i$, $c_i$, $g_i$, $b_i$) is the most important factor?</li>
<li>Your goal is to design the "perfect" MLP. Can you use the design principles introduced above to find good architectures? Is it possible to extrapolate from small to large networks?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/7462">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/7463">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/8738">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18009">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recurrent-neural-networks"><a class="header" href="#recurrent-neural-networks">Recurrent Neural Networks</a></h1>
<p>:label:<code>chap_rnn</code></p>
<p>Up until now, we have focused primarily on fixed-length data.
When introducing linear and logistic regression
in :numref:<code>chap_regression</code> and :numref:<code>chap_classification</code>
and multilayer perceptrons in :numref:<code>chap_perceptrons</code>,
we were happy to assume that each feature vector $\mathbf{x}_i$
consisted of a fixed number of components $x_1, \dots, x_d$,
where each numerical feature $x_j$
corresponded to a particular attribute.
These datasets are sometimes called <em>tabular</em>,
because they can be arranged in tables,
where each example $i$ gets its own row,
and each attribute gets its own column.
Crucially, with tabular data, we seldom
assume any particular structure over the columns.</p>
<p>Subsequently, in :numref:<code>chap_cnn</code>,
we moved on to image data, where inputs consist
of the raw pixel values at each coordinate in an image.
Image data hardly fitted the bill
of a protypical tabular dataset.
There, we needed to call upon convolutional neural networks (CNNs)
to handle the hierarchical structure and invariances.
However, our data were still of fixed length.
Every Fashion-MNIST image is represented
as a $28 \times 28$ grid of pixel values.
Moreover, our goal was to develop a model
that looked at just one image and then
outputted a single prediction.
But what should we do when faced with a
sequence of images, as in a video,
or when tasked with producing
a sequentially structured prediction,
as in the case of image captioning?</p>
<p>A great many learning tasks require dealing with sequential data.
Image captioning, speech synthesis, and music generation
all require that models produce outputs consisting of sequences.
In other domains, such as time series prediction,
video analysis, and musical information retrieval,
a model must learn from inputs that are sequences.
These demands often arise simultaneously:
tasks such as translating passages of text
from one natural language to another,
engaging in dialogue, or controlling a robot,
demand that models both ingest and output
sequentially structured data.</p>
<p>Recurrent neural networks (RNNs) are deep learning models
that capture the dynamics of sequences via
<em>recurrent</em> connections, which can be thought of
as cycles in the network of nodes.
This might seem counterintuitive at first.
After all, it is the feedforward nature of neural networks
that makes the order of computation unambiguous.
However, recurrent edges are defined in a precise way
that ensures that no such ambiguity can arise.
Recurrent neural networks are <em>unrolled</em> across time steps (or sequence steps),
with the <em>same</em> underlying parameters applied at each step.
While the standard connections are applied <em>synchronously</em>
to propagate each layer's activations
to the subsequent layer <em>at the same time step</em>,
the recurrent connections are <em>dynamic</em>,
passing information across adjacent time steps.
As the unfolded view in :numref:<code>fig_unfolded-rnn</code> reveals,
RNNs can be thought of as feedforward neural networks
where each layer's parameters (both conventional and recurrent)
are shared across time steps.</p>
<p><img src="chapter_recurrent-neural-networks/../img/unfolded-rnn.svg" alt="On the left recurrent connections are depicted via cyclic edges. On the right, we unfold the RNN over time steps. Here, recurrent edges span adjacent time steps, while conventional connections are computed synchronously." />
:label:<code>fig_unfolded-rnn</code></p>
<p>Like neural networks more broadly,
RNNs have a long discipline-spanning history,
originating as models of the brain popularized
by cognitive scientists and subsequently adopted
as practical modeling tools employed
by the machine learning community.
As we do for deep learning more broadly,
in this book we adopt the machine learning perspective,
focusing on RNNs as practical tools that rose
to popularity in the 2010s owing to
breakthrough results on such diverse tasks
as handwriting recognition :cite:<code>graves2008novel</code>,
machine translation :cite:<code>Sutskever.Vinyals.Le.2014</code>,
and recognizing medical diagnoses :cite:<code>Lipton.Kale.2016</code>.
We point the reader interested in more
background material to a publicly available
comprehensive review :cite:<code>Lipton.Berkowitz.Elkan.2015</code>.
We also note that sequentiality is not unique to RNNs.
For example, the CNNs that we already introduced
can be adapted to handle data of varying length,
e.g., images of varying resolution.
Moreover, RNNs have recently ceded considerable
market share to Transformer models,
which will be covered in :numref:<code>chap_attention-and-transformers</code>.
However, RNNs rose to prominence as the default models
for handling complex sequential structure in deep learning,
and remain staple models for sequential modeling to this day.
The stories of RNNs and of sequence modeling
are inextricably linked, and this is as much
a chapter about the ABCs of sequence modeling problems
as it is a chapter about RNNs.</p>
<p>One key insight paved the way for a revolution in sequence modeling.
While the inputs and targets for many fundamental tasks in machine learning
cannot easily be represented as fixed-length vectors,
they can often nevertheless be represented as
varying-length sequences of fixed-length vectors.
For example, documents can be represented as sequences of words;
medical records can often be represented as sequences of events
(encounters, medications, procedures, lab tests, diagnoses);
videos can be represented as varying-length sequences of still images.</p>
<p>While sequence models have popped up in numerous application areas,
basic research in the area has been driven predominantly
by advances on core tasks in natural language processing.
Thus, throughout this chapter, we will focus
our exposition and examples on text data.
If you get the hang of these examples,
then applying the models to other data modalities
should be relatively straightforward.
In the next few sections, we introduce basic
notation for sequences and some evaluation measures
for assessing the quality of sequentially structured model outputs.
After that, we discuss basic concepts of a language model
and use this discussion to motivate our first RNN models.
Finally, we describe the method for calculating gradients
when backpropagating through RNNs and explore some challenges
that are often encountered when training such networks,
motivating the modern RNN architectures that will follow
in :numref:<code>chap_modern_rnn</code>.</p>
<pre><code class="language-toc">:maxdepth: 2

sequence
text-sequence
language-model
rnn
rnn-scratch
rnn-concise
bptt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-sequences"><a class="header" href="#working-with-sequences">Working with Sequences</a></h1>
<p>:label:<code>sec_sequence</code></p>
<p>Up until now, we have focused on models whose inputs
consisted of a single feature vector $\mathbf{x} \in \mathbb{R}^d$.
The main change of perspective when developing models
capable of processing sequences is that we now
focus on inputs that consist of an ordered list
of feature vectors $\mathbf{x}_1, \dots, \mathbf{x}_T$,
where each feature vector $\mathbf{x}_t$ is
indexed by a time step $t \in \mathbb{Z}^+$
lying in $\mathbb{R}^d$.</p>
<p>Some datasets consist of a single massive sequence.
Consider, for example, the extremely long streams
of sensor readings that might be available to climate scientists.
In such cases, we might create training datasets
by randomly sampling subsequences of some predetermined length.
More often, our data arrives as a collection of sequences.
Consider the following examples:
(i) a collection of documents,
each represented as its own sequence of words,
and each having its own length $T_i$;
(ii) sequence representation of
patient stays in the hospital,
where each stay consists of a number of events
and the sequence length depends roughly
on the length of the stay.</p>
<p>Previously, when dealing with individual inputs,
we assumed that they were sampled independently
from the same underlying distribution $P(X)$.
While we still assume that entire sequences
(e.g., entire documents or patient trajectories)
are sampled independently,
we cannot assume that the data arriving
at each time step are independent of each other.
For example, the words that likely to appear later in a document
depend heavily on words occurring earlier in the document.
The medicine a patient is likely to receive
on the 10th day of a hospital visit
depends heavily on what transpired
in the previous nine days.</p>
<p>This should come as no surprise.
If we did not believe that the elements in a sequence were related,
we would not have bothered to model them as a sequence in the first place.
Consider the usefulness of the auto-fill features
that are popular on search tools and modern email clients.
They are useful precisely because it is often possible
to predict (imperfectly, but better than random guessing)
what the likely continuations of a sequence might be,
given some initial prefix.
For most sequence models,
we do not require independence,
or even stationarity, of our sequences.
Instead, we require only that
the sequences themselves are sampled
from some fixed underlying distribution
over entire sequences.</p>
<p>This flexible approach allows for such phenomena
as (i) documents looking significantly different
at the beginning than at the end;
or (ii) patient status evolving either
towards recovery or towards death
over the course of a hospital stay;
or (iii) customer taste evolving in predictable ways
over the course of continued interaction with a recommender system.</p>
<p>We sometimes wish to predict a fixed target $y$
given sequentially structured input
(e.g., sentiment classification based on a movie review).
At other times, we wish to predict a sequentially structured target
($y_1, \ldots, y_T$)
given a fixed input (e.g., image captioning).
Still other times, our goal is to predict sequentially structured targets
based on sequentially structured inputs
(e.g., machine translation or video captioning).
Such sequence-to-sequence tasks take two forms:
(i) <em>aligned</em>: where the input at each time step
aligns with a corresponding target (e.g., part of speech tagging);
(ii) <em>unaligned</em>: where the input and target
do not necessarily exhibit a step-for-step correspondence
(e.g., machine translation).</p>
<p>Before we worry about handling targets of any kind,
we can tackle the most straightforward problem:
unsupervised density modeling (also called <em>sequence modeling</em>).
Here, given a collection of sequences,
our goal is to estimate the probability mass function
that tells us how likely we are to see any given sequence,
i.e., $p(\mathbf{x}_1, \ldots, \mathbf{x}_T)$.</p>
<pre><code class="language-{.python .input  n=6}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, np, npx, gluon, init
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=8}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import numpy as np
</code></pre>
<h2 id="autoregressive-models"><a class="header" href="#autoregressive-models">Autoregressive Models</a></h2>
<p>Before introducing specialized neural networks
designed to handle sequentially structured data,
let's take a look at some actual sequence data
and build up some basic intuitions and statistical tools.
In particular, we will focus on stock price data
from the FTSE 100 index (:numref:<code>fig_ftse100</code>).
At each <em>time step</em> $t \in \mathbb{Z}^+$, we observe
the price, $x_t$, of the index at that time.</p>
<p><img src="chapter_recurrent-neural-networks/../img/ftse100.png" alt="FTSE 100 index over about 30 years." />
:width:<code>400px</code>
:label:<code>fig_ftse100</code></p>
<p>Now suppose that a trader would like to make short-term trades,
strategically getting into or out of the index,
depending on whether they believe
that it will rise or decline
in the subsequent time step.
Absent any other features
(news, financial reporting data, etc.),
the only available signal for predicting
the subsequent value is the history of prices to date.
The trader is thus interested in knowing
the probability distribution</p>
<p>$$P(x_t \mid x_{t-1}, \ldots, x_1)$$</p>
<p>over prices that the index might take
in the subsequent time step.
While estimating the entire distribution
over a continuously valued random variable
can be difficult, the trader would be happy
to focus on a few key statistics of the distribution,
particularly the expected value and the variance.
One simple strategy for estimating the conditional expectation</p>
<p>$$\mathbb{E}[(x_t \mid x_{t-1}, \ldots, x_1)],$$</p>
<p>would be to apply a linear regression model
(recall :numref:<code>sec_linear_regression</code>).
Such models that regress the value of a signal
on the previous values of that same signal
are naturally called <em>autoregressive models</em>.
There is just one major problem: the number of inputs,
$x_{t-1}, \ldots, x_1$ varies, depending on $t$.
In other words, the number of inputs increases
with the amount of data that we encounter.
Thus if we want to treat our historical data
as a training set, we are left with the problem
that each example has a different number of features.
Much of what follows in this chapter
will revolve around techniques
for overcoming these challenges
when engaging in such <em>autoregressive</em> modeling problems
where the object of interest is
$P(x_t \mid x_{t-1}, \ldots, x_1)$
or some statistic(s) of this distribution.</p>
<p>A few strategies recur frequently.
First of all,
we might believe that although long sequences
$x_{t-1}, \ldots, x_1$ are available,
it may not be necessary
to look back so far in the history
when predicting the near future.
In this case we might content ourselves
to condition on some window of length $\tau$
and only use $x_{t-1}, \ldots, x_{t-\tau}$ observations.
The immediate benefit is that now the number of arguments
is always the same, at least for $t &gt; \tau$.
This allows us to train any linear model or deep network
that requires fixed-length vectors as inputs.
Second, we might develop models that maintain
some summary $h_t$ of the past observations
(see :numref:<code>fig_sequence-model</code>)
and at the same time update $h_t$
in addition to the prediction $\hat{x}<em>t$.
This leads to models that estimate not only $x_t$
with $\hat{x}<em>t = P(x_t \mid h</em>{t})$
but also updates of the form
$h_t = g(h</em>{t-1}, x_{t-1})$.
Since $h_t$ is never observed,
these models are also called
<em>latent autoregressive models</em>.</p>
<p><img src="chapter_recurrent-neural-networks/../img/sequence-model.svg" alt="A latent autoregressive model." />
:label:<code>fig_sequence-model</code></p>
<p>To construct training data from historical data, one
typically creates examples by sampling windows randomly.
In general, we do not expect time to stand still.
However, we often assume that while
the specific values of $x_t$ might change,
the dynamics according to which each subsequent
observation is generated given the previous observations do not.
Statisticians call dynamics that do not change <em>stationary</em>.</p>
<h2 id="sequence-models"><a class="header" href="#sequence-models">Sequence Models</a></h2>
<p>Sometimes, especially when working with language,
we wish to estimate the joint probability
of an entire sequence.
This is a common task when working with sequences
composed of discrete <em>tokens</em>, such as words.
Generally, these estimated functions are called <em>sequence models</em>
and for natural language data, they are called <em>language models</em>.
The field of sequence modeling has been driven so much by natural language processing,
that we often describe sequence models as "language models",
even when dealing with non-language data.
Language models prove useful for all sorts of reasons.
Sometimes we want to evaluate the likelihood of sentences.
For example, we might wish to compare
the naturalness of two candidate outputs
generated by a machine translation system
or by a speech recognition system.
But language modeling gives us not only
the capacity to <em>evaluate</em> likelihood,
but the ability to <em>sample</em> sequences,
and even to optimize for the most likely sequences.</p>
<p>While language modeling might not, at first glance, look
like an autoregressive problem,
we can reduce language modeling to autoregressive prediction
by decomposing the joint density  of a sequence $p(x_1, \ldots, x_T)$
into the product of conditional densities
in a left-to-right fashion
by applying the chain rule of probability:</p>
<p>$$P(x_1, \ldots, x_T) = P(x_1) \prod_{t=2}^T P(x_t \mid x_{t-1}, \ldots, x_1).$$</p>
<p>Note that if we are working with discrete signals such as words,
then the autoregressive model must be a probabilistic classifier,
outputting a full probability distribution
over the vocabulary for whatever word will come next,
given the leftwards context.</p>
<h3 id="markov-models"><a class="header" href="#markov-models">Markov Models</a></h3>
<p>:label:<code>subsec_markov-models</code></p>
<p>Now suppose that we wish to employ the strategy mentioned above,
where we condition only on the $\tau$ previous time steps,
i.e., $x_{t-1}, \ldots, x_{t-\tau}$, rather than
the entire sequence history $x_{t-1}, \ldots, x_1$.
Whenever we can throw away the history
beyond the previous $\tau$ steps
without any loss in predictive power,
we say that the sequence satisfies a <em>Markov condition</em>,
i.e., <em>that the future is conditionally independent of the past,
given the recent history</em>.
When $\tau = 1$, we say that the data is characterized
by a <em>first-order Markov model</em>,
and when $\tau = k$, we say that the data is characterized
by a $k^{\textrm{th}}$-order Markov model.
For when the first-order Markov condition holds ($\tau = 1$)
the factorization of our joint probability becomes a product
of probabilities of each word given the previous <em>word</em>:</p>
<p>$$P(x_1, \ldots, x_T) = P(x_1) \prod_{t=2}^T P(x_t \mid x_{t-1}).$$</p>
<p>We often find it useful to work with models that proceed
as though a Markov condition were satisfied,
even when we know that this is only <em>approximately</em> true.
With real text documents we continue to gain information
as we include more and more leftwards context.
But these gains diminish rapidly.
Thus, sometimes we compromise, obviating computational and statistical difficulties
by training models whose validity depends
on a $k^{\textrm{th}}$-order Markov condition.
Even today's massive RNN- and Transformer-based language models
seldom incorporate more than thousands of words of context.</p>
<p>With discrete data, a true Markov model
simply counts the number of times
that each word has occurred in each context, producing
the relative frequency estimate of $P(x_t \mid x_{t-1})$.
Whenever the data assumes only discrete values
(as in language),
the most likely sequence of words can be computed efficiently
using dynamic programming.</p>
<h3 id="the-order-of-decoding"><a class="header" href="#the-order-of-decoding">The Order of Decoding</a></h3>
<p>You may be wondering why we represented
the factorization of a text sequence $P(x_1, \ldots, x_T)$
as a left-to-right chain of conditional probabilities.
Why not right-to-left or some other, seemingly random order?
In principle, there is nothing wrong with unfolding
$P(x_1, \ldots, x_T)$ in reverse order.
The result is a valid factorization:</p>
<p>$$P(x_1, \ldots, x_T) = P(x_T) \prod_{t=T-1}^1 P(x_t \mid x_{t+1}, \ldots, x_T).$$</p>
<p>However, there are many reasons why factorizing text
in the same direction in which we read it
(left-to-right for most languages,
but right-to-left for Arabic and Hebrew)
is preferred for the task of language modeling.
First, this is just a more natural direction for us to think about.
After all we all read text every day,
and this process is guided by our ability
to anticipate which words and phrases
are likely to come next.
Just think of how many times you have completed
someone else's sentence.
Thus, even if we had no other reason to prefer such in-order decodings,
they would be useful if only because we have better intuitions
for what should be likely when predicting in this order.</p>
<p>Second, by factorizing in order,
we can assign probabilities to arbitrarily long sequences
using the same language model.
To convert a probability over steps $1$ through $t$
into one that extends to word $t+1$ we simply
multiply by the conditional probability
of the additional token given the previous ones:
$P(x_{t+1}, \ldots, x_1) = P(x_{t}, \ldots, x_1) \cdot P(x_{t+1} \mid x_{t}, \ldots, x_1)$.</p>
<p>Third, we have stronger predictive models
for predicting adjacent words than
words at arbitrary other locations.
While all orders of factorization are valid,
they do not necessarily all represent equally easy
predictive modeling problems.
This is true not only for language,
but for other kinds of data as well,
e.g., when the data is causally structured.
For example, we believe that future events cannot influence the past.
Hence, if we change $x_t$, we may be able to influence
what happens for $x_{t+1}$ going forward but not the converse.
That is, if we change $x_t$, the distribution over past events will not change.
In some contexts, this makes it easier to predict $P(x_{t+1} \mid x_t)$
than to predict $P(x_t \mid x_{t+1})$.
For instance, in some cases, we can find $x_{t+1} = f(x_t) + \epsilon$
for some additive noise $\epsilon$,
whereas the converse is not true :cite:<code>Hoyer.Janzing.Mooij.ea.2009</code>.
This is great news, since it is typically the forward direction
that we are interested in estimating.
The book by :citet:<code>Peters.Janzing.Scholkopf.2017</code> contains more on this topic.
We barely scratch the surface of it.</p>
<h2 id="training-16"><a class="header" href="#training-16">Training</a></h2>
<p>Before we focus our attention on text data,
let's first try this out with some
continuous-valued synthetic data.</p>
<p>(<strong>Here, our 1000 synthetic data will follow
the trigonometric <code>sin</code> function,
applied to 0.01 times the time step.
To make the problem a little more interesting,
we corrupt each sample with additive noise.</strong>)
From this sequence we extract training examples,
each consisting of features and a label.</p>
<pre><code class="language-{.python .input  n=10}">%%tab all
class Data(d2l.DataModule):
    def __init__(self, batch_size=16, T=1000, num_train=600, tau=4):
        self.save_hyperparameters()
        self.time = d2l.arange(1, T + 1, dtype=d2l.float32)
        if tab.selected('mxnet', 'pytorch'):
            self.x = d2l.sin(0.01 * self.time) + d2l.randn(T) * 0.2
        if tab.selected('tensorflow'):
            self.x = d2l.sin(0.01 * self.time) + d2l.normal([T]) * 0.2
        if tab.selected('jax'):
            key = d2l.get_key()
            self.x = d2l.sin(0.01 * self.time) + jax.random.normal(key,
                                                                   [T]) * 0.2
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
data = Data()
d2l.plot(data.time, data.x, 'time', 'x', xlim=[1, 1000], figsize=(6, 3))
</code></pre>
<p>To begin, we try a model that acts as if
the data satisfied a $\tau^{\textrm{th}}$-order Markov condition,
and thus predicts $x_t$ using only the past $\tau$ observations.
[<strong>Thus for each time step we have an example
with label $y  = x_t$ and features
$\mathbf{x}<em>t = [x</em>{t-\tau}, \ldots, x_{t-1}]$.</strong>]
The astute reader might have noticed that
this results in $1000-\tau$ examples,
since we lack sufficient history for $y_1, \ldots, y_\tau$.
While we could pad the first $\tau$ sequences with zeros,
to keep things simple, we drop them for now.
The resulting dataset contains $T - \tau$ examples,
where each input to the model has sequence length $\tau$.
We (<strong>create a data iterator on the first 600 examples</strong>),
covering a period of the sin function.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(Data)
def get_dataloader(self, train):
    features = [self.x[i : self.T-self.tau+i] for i in range(self.tau)]
    self.features = d2l.stack(features, 1)
    self.labels = d2l.reshape(self.x[self.tau:], (-1, 1))
    i = slice(0, self.num_train) if train else slice(self.num_train, None)
    return self.get_tensorloader([self.features, self.labels], train, i)
</code></pre>
<p>In this example our model will be a standard linear regression.</p>
<pre><code class="language-{.python .input}">%%tab all
model = d2l.LinearRegression(lr=0.01)
trainer = d2l.Trainer(max_epochs=5)
trainer.fit(model, data)
</code></pre>
<h2 id="prediction-1"><a class="header" href="#prediction-1">Prediction</a></h2>
<p>[<strong>To evaluate our model, we first check
how well it performs at one-step-ahead prediction</strong>].</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
onestep_preds = d2l.numpy(model(data.features))
d2l.plot(data.time[data.tau:], [data.labels, onestep_preds], 'time', 'x',
         legend=['labels', '1-step preds'], figsize=(6, 3))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
onestep_preds = model.apply({'params': trainer.state.params}, data.features)
d2l.plot(data.time[data.tau:], [data.labels, onestep_preds], 'time', 'x',
         legend=['labels', '1-step preds'], figsize=(6, 3))
</code></pre>
<p>These predictions look good,
even near the end at $t=1000$.</p>
<p>But what if we only observed sequence data
up until time step 604 (<code>n_train + tau</code>)
and wished to make predictions several steps
into the future?
Unfortunately, we cannot directly compute
the one-step-ahead prediction for time step 609,
because we do not know the corresponding inputs,
having seen only up to $x_{604}$.
We can address this problem by plugging in
our earlier predictions as inputs to our model
for making subsequent predictions,
projecting forward, one step at a time,
until reaching the desired time step:</p>
<p>$$\begin{aligned}
\hat{x}<em>{605} &amp;= f(x</em>{601}, x_{602}, x_{603}, x_{604}), \
\hat{x}<em>{606} &amp;= f(x</em>{602}, x_{603}, x_{604}, \hat{x}<em>{605}), \
\hat{x}</em>{607} &amp;= f(x_{603}, x_{604}, \hat{x}<em>{605}, \hat{x}</em>{606}),\
\hat{x}<em>{608} &amp;= f(x</em>{604}, \hat{x}<em>{605}, \hat{x}</em>{606}, \hat{x}<em>{607}),\
\hat{x}</em>{609} &amp;= f(\hat{x}<em>{605}, \hat{x}</em>{606}, \hat{x}<em>{607}, \hat{x}</em>{608}),\
&amp;\vdots\end{aligned}$$</p>
<p>Generally, for an observed sequence $x_1, \ldots, x_t$,
its predicted output $\hat{x}<em>{t+k}$ at time step $t+k$
is called the $k$<em>-step-ahead prediction</em>.
Since we have observed up to $x</em>{604}$,
its $k$-step-ahead prediction is $\hat{x}_{604+k}$.
In other words, we will have to
keep on using our own predictions
to make multistep-ahead predictions.
Let's see how well this goes.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
multistep_preds = d2l.zeros(data.T)
multistep_preds[:] = data.x
for i in range(data.num_train + data.tau, data.T):
    multistep_preds[i] = model(
        d2l.reshape(multistep_preds[i-data.tau : i], (1, -1)))
multistep_preds = d2l.numpy(multistep_preds)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
multistep_preds = tf.Variable(d2l.zeros(data.T))
multistep_preds[:].assign(data.x)
for i in range(data.num_train + data.tau, data.T):
    multistep_preds[i].assign(d2l.reshape(model(
        d2l.reshape(multistep_preds[i-data.tau : i], (1, -1))), ()))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
multistep_preds = d2l.zeros(data.T)
multistep_preds = multistep_preds.at[:].set(data.x)
for i in range(data.num_train + data.tau, data.T):
    pred = model.apply({'params': trainer.state.params},
                       d2l.reshape(multistep_preds[i-data.tau : i], (1, -1)))
    multistep_preds = multistep_preds.at[i].set(pred.item())
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
d2l.plot([data.time[data.tau:], data.time[data.num_train+data.tau:]],
         [onestep_preds, multistep_preds[data.num_train+data.tau:]], 'time',
         'x', legend=['1-step preds', 'multistep preds'], figsize=(6, 3))
</code></pre>
<p>Unfortunately, in this case we fail spectacularly.
The predictions decay to a constant
pretty quickly after a few steps.
Why did the algorithm perform so much worse
when predicting further into the future?
Ultimately, this is down to the fact
that errors build up.
Let's say that after step 1 we have some error $\epsilon_1 = \bar\epsilon$.
Now the <em>input</em> for step 2 is perturbed by $\epsilon_1$,
hence we suffer some error in the order of
$\epsilon_2 = \bar\epsilon + c \epsilon_1$
for some constant $c$, and so on.
The predictions can diverge rapidly
from the true observations.
You may already be familiar
with this common phenomenon.
For instance, weather forecasts for the next 24 hours
tend to be pretty accurate but beyond that,
accuracy declines rapidly.
We will discuss methods for improving this
throughout this chapter and beyond.</p>
<p>Let's [<strong>take a closer look at the difficulties in $k$-step-ahead predictions</strong>]
by computing predictions on the entire sequence for $k = 1, 4, 16, 64$.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
def k_step_pred(k):
    features = []
    for i in range(data.tau):
        features.append(data.x[i : i+data.T-data.tau-k+1])
    # The (i+tau)-th element stores the (i+1)-step-ahead predictions
    for i in range(k):
        preds = model(d2l.stack(features[i : i+data.tau], 1))
        features.append(d2l.reshape(preds, -1))
    return features[data.tau:]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def k_step_pred(k):
    features = []
    for i in range(data.tau):
        features.append(data.x[i : i+data.T-data.tau-k+1])
    # The (i+tau)-th element stores the (i+1)-step-ahead predictions
    for i in range(k):
        preds = model.apply({'params': trainer.state.params},
                            d2l.stack(features[i : i+data.tau], 1))
        features.append(d2l.reshape(preds, -1))
    return features[data.tau:]
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
steps = (1, 4, 16, 64)
preds = k_step_pred(steps[-1])
d2l.plot(data.time[data.tau+steps[-1]-1:],
         [d2l.numpy(preds[k-1]) for k in steps], 'time', 'x',
         legend=[f'{k}-step preds' for k in steps], figsize=(6, 3))
</code></pre>
<p>This clearly illustrates how the quality of the prediction changes
as we try to predict further into the future.
While the 4-step-ahead predictions still look good,
anything beyond that is almost useless.</p>
<h2 id="summary-33"><a class="header" href="#summary-33">Summary</a></h2>
<p>There is quite a difference in difficulty
between interpolation and extrapolation.
Consequently, if you have a sequence, always respect
the temporal order of the data when training,
i.e., never train on future data.
Given this kind of data,
sequence models require specialized statistical tools for estimation.
Two popular choices are autoregressive models
and latent-variable autoregressive models.
For causal models (e.g., time going forward),
estimating the forward direction is typically
a lot easier than the reverse direction.
For an observed sequence up to time step $t$,
its predicted output at time step $t+k$
is the $k$<em>-step-ahead prediction</em>.
As we predict further in time by increasing $k$,
the errors accumulate and the quality of the prediction degrades,
often dramatically.</p>
<h2 id="exercises-50"><a class="header" href="#exercises-50">Exercises</a></h2>
<ol>
<li>Improve the model in the experiment of this section.
<ol>
<li>Incorporate more than the past four observations? How many do you really need?</li>
<li>How many past observations would you need if there was no noise? Hint: you can write $\sin$ and $\cos$ as a differential equation.</li>
<li>Can you incorporate older observations while keeping the total number of features constant? Does this improve accuracy? Why?</li>
<li>Change the neural network architecture and evaluate the performance. You may train the new model with more epochs. What do you observe?</li>
</ol>
</li>
<li>An investor wants to find a good security to buy.
They look at past returns to decide which one is likely to do well.
What could possibly go wrong with this strategy?</li>
<li>Does causality also apply to text? To which extent?</li>
<li>Give an example for when a latent autoregressive model
might be needed to capture the dynamic of the data.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/113">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/114">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1048">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18010">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-raw-text-into-sequence-data"><a class="header" href="#converting-raw-text-into-sequence-data">Converting Raw Text into Sequence Data</a></h1>
<p>:label:<code>sec_text-sequence</code></p>
<p>Throughout this book,
we will often work with text data
represented as sequences
of words, characters, or word pieces.
To get going, we will need some basic
tools for converting raw text
into sequences of the appropriate form.
Typical preprocessing pipelines
execute the following steps:</p>
<ol>
<li>Load text as strings into memory.</li>
<li>Split the strings into tokens (e.g., words or characters).</li>
<li>Build a vocabulary dictionary to associate each vocabulary element with a numerical index.</li>
<li>Convert the text into sequences of numerical indices.</li>
</ol>
<pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
import collections
import re
from d2l import mxnet as d2l
from mxnet import np, npx
import random
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
import collections
import re
from d2l import torch as d2l
import torch
import random
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
import collections
import re
from d2l import tensorflow as d2l
import tensorflow as tf
import random
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import collections
from d2l import jax as d2l
import jax
from jax import numpy as jnp
import random
import re
</code></pre>
<h2 id="reading-the-dataset-2"><a class="header" href="#reading-the-dataset-2">Reading the Dataset</a></h2>
<p>Here, we will work with H. G. Wells'
<a href="http://www.gutenberg.org/ebooks/35">The Time Machine</a>,
a book containing just over 30,000 words.
While real applications will typically
involve significantly larger datasets,
this is sufficient to demonstrate
the preprocessing pipeline.
The following <code>_download</code> method
(<strong>reads the raw text into a string</strong>).</p>
<pre><code class="language-{.python .input  n=5}">%%tab all
class TimeMachine(d2l.DataModule): #@save
    """The Time Machine dataset."""
    def _download(self):
        fname = d2l.download(d2l.DATA_URL + 'timemachine.txt', self.root,
                             '090b5e7e70c295757f55df93cb0a180b9691891a')
        with open(fname) as f:
            return f.read()

data = TimeMachine()
raw_text = data._download()
raw_text[:60]
</code></pre>
<p>For simplicity, we ignore punctuation and capitalization when preprocessing the raw text.</p>
<pre><code class="language-{.python .input  n=6}">%%tab all
@d2l.add_to_class(TimeMachine)  #@save
def _preprocess(self, text):
    return re.sub('[^A-Za-z]+', ' ', text).lower()

text = data._preprocess(raw_text)
text[:60]
</code></pre>
<h2 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h2>
<p><em>Tokens</em> are the atomic (indivisible) units of text.
Each time step corresponds to 1 token,
but what precisely constitutes a token is a design choice.
For example, we could represent the sentence
"Baby needs a new pair of shoes"
as a sequence of 7 words,
where the set of all words comprise
a large vocabulary (typically tens
or hundreds of thousands of words).
Or we would represent the same sentence
as a much longer sequence of 30 characters,
using a much smaller vocabulary
(there are only 256 distinct ASCII characters).
Below, we tokenize our preprocessed text
into a sequence of characters.</p>
<pre><code class="language-{.python .input  n=7}">%%tab all
@d2l.add_to_class(TimeMachine)  #@save
def _tokenize(self, text):
    return list(text)

tokens = data._tokenize(text)
','.join(tokens[:30])
</code></pre>
<h2 id="vocabulary"><a class="header" href="#vocabulary">Vocabulary</a></h2>
<p>These tokens are still strings.
However, the inputs to our models
must ultimately consist
of numerical inputs.
[<strong>Next, we introduce a class
for constructing <em>vocabularies</em>,
i.e., objects that associate
each distinct token value
with a unique index.</strong>]
First, we determine the set of unique tokens in our training <em>corpus</em>.
We then assign a numerical index to each unique token.
Rare vocabulary elements are often dropped for convenience.
Whenever we encounter a token at training or test time
that had not been previously seen or was dropped from the vocabulary,
we represent it by a special "&lt;unk&gt;" token,
signifying that this is an <em>unknown</em> value.</p>
<pre><code class="language-{.python .input  n=8}">%%tab all
class Vocab:  #@save
    """Vocabulary for text."""
    def __init__(self, tokens=[], min_freq=0, reserved_tokens=[]):
        # Flatten a 2D list if needed
        if tokens and isinstance(tokens[0], list):
            tokens = [token for line in tokens for token in line]
        # Count token frequencies
        counter = collections.Counter(tokens)
        self.token_freqs = sorted(counter.items(), key=lambda x: x[1],
                                  reverse=True)
        # The list of unique tokens
        self.idx_to_token = list(sorted(set(['&lt;unk&gt;'] + reserved_tokens + [
            token for token, freq in self.token_freqs if freq &gt;= min_freq])))
        self.token_to_idx = {token: idx
                             for idx, token in enumerate(self.idx_to_token)}

    def __len__(self):
        return len(self.idx_to_token)

    def __getitem__(self, tokens):
        if not isinstance(tokens, (list, tuple)):
            return self.token_to_idx.get(tokens, self.unk)
        return [self.__getitem__(token) for token in tokens]

    def to_tokens(self, indices):
        if hasattr(indices, '__len__') and len(indices) &gt; 1:
            return [self.idx_to_token[int(index)] for index in indices]
        return self.idx_to_token[indices]

    @property
    def unk(self):  # Index for the unknown token
        return self.token_to_idx['&lt;unk&gt;']
</code></pre>
<p>We now [<strong>construct a vocabulary</strong>] for our dataset,
converting the sequence of strings
into a list of numerical indices.
Note that we have not lost any information
and can easily convert our dataset
back to its original (string) representation.</p>
<pre><code class="language-{.python .input  n=9}">%%tab all
vocab = Vocab(tokens)
indices = vocab[tokens[:10]]
print('indices:', indices)
print('words:', vocab.to_tokens(indices))
</code></pre>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Using the above classes and methods,
we [<strong>package everything into the following
<code>build</code> method of the <code>TimeMachine</code> class</strong>],
which returns <code>corpus</code>, a list of token indices, and <code>vocab</code>,
the vocabulary of <em>The Time Machine</em> corpus.
The modifications we did here are:
(i) we tokenize text into characters, not words,
to simplify the training in later sections;
(ii) <code>corpus</code> is a single list, not a list of token lists,
since each text line in <em>The Time Machine</em> dataset
is not necessarily a sentence or paragraph.</p>
<pre><code class="language-{.python .input  n=10}">%%tab all
@d2l.add_to_class(TimeMachine)  #@save
def build(self, raw_text, vocab=None):
    tokens = self._tokenize(self._preprocess(raw_text))
    if vocab is None: vocab = Vocab(tokens)
    corpus = [vocab[token] for token in tokens]
    return corpus, vocab

corpus, vocab = data.build(raw_text)
len(corpus), len(vocab)
</code></pre>
<h2 id="exploratory-language-statistics"><a class="header" href="#exploratory-language-statistics">Exploratory Language Statistics</a></h2>
<p>:label:<code>subsec_natural-lang-stat</code></p>
<p>Using the real corpus and the <code>Vocab</code> class defined over words,
we can inspect basic statistics concerning word use in our corpus.
Below, we construct a vocabulary from words used in <em>The Time Machine</em>
and print the ten most frequently occurring of them.</p>
<pre><code class="language-{.python .input  n=11}">%%tab all
words = text.split()
vocab = Vocab(words)
vocab.token_freqs[:10]
</code></pre>
<p>Note that (<strong>the ten most frequent words</strong>)
are not all that descriptive.
You might even imagine that
we might see a very similar list
if we had chosen any book at random.
Articles like "the" and "a",
pronouns like "i" and "my",
and prepositions like "of", "to", and "in"
occur often because they serve common syntactic roles.
Such words that are common but not particularly descriptive
are often called (<em><strong>stop words</strong></em>) and,
in previous generations of text classifiers
based on so-called bag-of-words representations,
they were most often filtered out.
However, they carry meaning and
it is not necessary to filter them out
when working with modern RNN- and
Transformer-based neural models.
If you look further down the list,
you will notice
that word frequency decays quickly.
The $10^{\textrm{th}}$ most frequent word
is less than $1/5$ as common as the most popular.
Word frequency tends to follow a power law distribution
(specifically the Zipfian) as we go down the ranks.
To get a better idea, we [<strong>plot the figure of the word frequency</strong>].</p>
<pre><code class="language-{.python .input  n=12}">%%tab all
freqs = [freq for token, freq in vocab.token_freqs]
d2l.plot(freqs, xlabel='token: x', ylabel='frequency: n(x)',
         xscale='log', yscale='log')
</code></pre>
<p>After dealing with the first few words as exceptions,
all the remaining words roughly follow a straight line on a log--log plot.
This phenomenon is captured by <em>Zipf's law</em>,
which states that the frequency $n_i$
of the $i^\textrm{th}$ most frequent word is:</p>
<p>$$n_i \propto \frac{1}{i^\alpha},$$
:eqlabel:<code>eq_zipf_law</code></p>
<p>which is equivalent to</p>
<p>$$\log n_i = -\alpha \log i + c,$$</p>
<p>where $\alpha$ is the exponent that characterizes
the distribution and $c$ is a constant.
This should already give us pause for thought if we want
to model words by counting statistics.
After all, we will significantly overestimate the frequency of the tail, also known as the infrequent words. But [<strong>what about the other word combinations, such as two consecutive words (bigrams), three consecutive words (trigrams)</strong>], and beyond?
Let's see whether the bigram frequency behaves in the same manner as the single word (unigram) frequency.</p>
<pre><code class="language-{.python .input  n=13}">%%tab all
bigram_tokens = ['--'.join(pair) for pair in zip(words[:-1], words[1:])]
bigram_vocab = Vocab(bigram_tokens)
bigram_vocab.token_freqs[:10]
</code></pre>
<p>One thing is notable here. Out of the ten most frequent word pairs, nine are composed of both stop words and only one is relevant to the actual book---"the time". Furthermore, let's see whether the trigram frequency behaves in the same manner.</p>
<pre><code class="language-{.python .input  n=14}">%%tab all
trigram_tokens = ['--'.join(triple) for triple in zip(
    words[:-2], words[1:-1], words[2:])]
trigram_vocab = Vocab(trigram_tokens)
trigram_vocab.token_freqs[:10]
</code></pre>
<p>Now, let's [<strong>visualize the token frequency</strong>] among these three models: unigrams, bigrams, and trigrams.</p>
<pre><code class="language-{.python .input  n=15}">%%tab all
bigram_freqs = [freq for token, freq in bigram_vocab.token_freqs]
trigram_freqs = [freq for token, freq in trigram_vocab.token_freqs]
d2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel='token: x',
         ylabel='frequency: n(x)', xscale='log', yscale='log',
         legend=['unigram', 'bigram', 'trigram'])
</code></pre>
<p>This figure is quite exciting.
First, beyond unigram words, sequences of words
also appear to be following Zipf's law,
albeit with a smaller exponent
$\alpha$ in :eqref:<code>eq_zipf_law</code>,
depending on the sequence length.
Second, the number of distinct $n$-grams is not that large.
This gives us hope that there is quite a lot of structure in language.
Third, many $n$-grams occur very rarely.
This makes certain methods unsuitable for language modeling
and motivates the use of deep learning models.
We will discuss this in the next section.</p>
<h2 id="summary-34"><a class="header" href="#summary-34">Summary</a></h2>
<p>Text is among the most common forms of sequence data encountered in deep learning.
Common choices for what constitutes a token are characters, words, and word pieces.
To preprocess text, we usually (i) split text into tokens; (ii) build a vocabulary to map token strings to numerical indices; and (iii) convert text data into token indices for models to manipulate.
In practice, the frequency of words tends to follow Zipf's law. This is true not just for individual words (unigrams), but also for $n$-grams.</p>
<h2 id="exercises-51"><a class="header" href="#exercises-51">Exercises</a></h2>
<ol>
<li>In the experiment of this section, tokenize text into words and vary the <code>min_freq</code> argument value of the <code>Vocab</code> instance. Qualitatively characterize how changes in <code>min_freq</code> impact the size of the resulting vocabulary.</li>
<li>Estimate the exponent of Zipfian distribution for unigrams, bigrams, and trigrams in this corpus.</li>
<li>Find some other sources of data (download a standard machine learning dataset, pick another public domain book,
scrape a website, etc). For each, tokenize the data at both the word and character levels. How do the vocabulary sizes compare with <em>The Time Machine</em> corpus at equivalent values of <code>min_freq</code>. Estimate the exponent of the Zipfian distribution corresponding to the unigram and bigram distributions for these corpora. How do they compare with the values that you observed for <em>The Time Machine</em> corpus?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/117">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/118">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1049">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18011">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-models"><a class="header" href="#language-models">Language Models</a></h1>
<p>:label:<code>sec_language-model</code></p>
<p>In :numref:<code>sec_text-sequence</code>, we saw how to map text sequences into tokens, where these tokens can be viewed as a sequence of discrete observations such as words or characters. Assume that the tokens in a text sequence of length $T$ are in turn $x_1, x_2, \ldots, x_T$.
The goal of <em>language models</em>
is to estimate the joint probability of the whole sequence:</p>
<p>$$P(x_1, x_2, \ldots, x_T),$$</p>
<p>where statistical tools
in :numref:<code>sec_sequence</code>
can be applied.</p>
<p>Language models are incredibly useful. For instance, an ideal language model should generate natural text on its own, simply by drawing one token at a time $x_t \sim P(x_t \mid x_{t-1}, \ldots, x_1)$.
Quite unlike the monkey using a typewriter, all text emerging from such a model would pass as natural language, e.g., English text. Furthermore, it would be sufficient for generating a meaningful dialog, simply by conditioning the text on previous dialog fragments.
Clearly we are still very far from designing such a system, since it would need to <em>understand</em> the text rather than just generate grammatically sensible content.</p>
<p>Nonetheless, language models are of great service even in their limited form.
For instance, the phrases "to recognize speech" and "to wreck a nice beach" sound very similar.
This can cause ambiguity in speech recognition,
which is easily resolved through a language model that rejects the second translation as outlandish.
Likewise, in a document summarization algorithm
it is worthwhile knowing that "dog bites man" is much more frequent than "man bites dog", or that "I want to eat grandma" is a rather disturbing statement, whereas "I want to eat, grandma" is much more benign.</p>
<pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from jax import numpy as jnp
</code></pre>
<h2 id="learning-language-models"><a class="header" href="#learning-language-models">Learning Language Models</a></h2>
<p>The obvious question is how we should model a document, or even a sequence of tokens.
Suppose that we tokenize text data at the word level.
Let's start by applying basic probability rules:</p>
<p>$$P(x_1, x_2, \ldots, x_T) = \prod_{t=1}^T P(x_t  \mid  x_1, \ldots, x_{t-1}).$$</p>
<p>For example,
the probability of a text sequence containing four words would be given as:</p>
<p>$$\begin{aligned}&amp;P(\textrm{deep}, \textrm{learning}, \textrm{is}, \textrm{fun}) \
=&amp;P(\textrm{deep}) P(\textrm{learning}  \mid  \textrm{deep}) P(\textrm{is}  \mid  \textrm{deep}, \textrm{learning}) P(\textrm{fun}  \mid  \textrm{deep}, \textrm{learning}, \textrm{is}).\end{aligned}$$</p>
<h3 id="markov-models-and-n-grams"><a class="header" href="#markov-models-and-n-grams">Markov Models and $n$-grams</a></h3>
<p>:label:<code>subsec_markov-models-and-n-grams</code></p>
<p>Among those sequence model analyses in :numref:<code>sec_sequence</code>,
let's apply Markov models to language modeling.
A distribution over sequences satisfies the Markov property of first order if $P(x_{t+1} \mid x_t, \ldots, x_1) = P(x_{t+1} \mid x_t)$. Higher orders correspond to longer dependencies. This leads to a number of approximations that we could apply to model a sequence:</p>
<p>$$
\begin{aligned}
P(x_1, x_2, x_3, x_4) &amp;=  P(x_1) P(x_2) P(x_3) P(x_4),\
P(x_1, x_2, x_3, x_4) &amp;=  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_2) P(x_4  \mid  x_3),\
P(x_1, x_2, x_3, x_4) &amp;=  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_1, x_2) P(x_4  \mid  x_2, x_3).
\end{aligned}
$$</p>
<p>The probability formulae that involve one, two, and three variables are typically referred to as <em>unigram</em>, <em>bigram</em>, and <em>trigram</em> models, respectively.
In order to compute the language model, we need to calculate the
probability of words and the conditional probability of a word given
the previous few words.
Note that
such probabilities are
language model parameters.</p>
<h3 id="word-frequency"><a class="header" href="#word-frequency">Word Frequency</a></h3>
<p>Here, we
assume that the training dataset is a large text corpus, such as all
Wikipedia entries, <a href="https://en.wikipedia.org/wiki/Project_Gutenberg">Project Gutenberg</a>,
and all text posted on the
web.
The probability of words can be calculated from the relative word
frequency of a given word in the training dataset.
For example, the estimate $\hat{P}(\textrm{deep})$ can be calculated as the
probability of any sentence starting with the word "deep". A
slightly less accurate approach would be to count all occurrences of
the word "deep" and divide it by the total number of words in
the corpus.
This works fairly well, particularly for frequent
words. Moving on, we could attempt to estimate</p>
<p>$$\hat{P}(\textrm{learning} \mid \textrm{deep}) = \frac{n(\textrm{deep, learning})}{n(\textrm{deep})},$$</p>
<p>where $n(x)$ and $n(x, x')$ are the number of occurrences of singletons
and consecutive word pairs, respectively.
Unfortunately,
estimating the
probability of a word pair is somewhat more difficult, since the
occurrences of "deep learning" are a lot less frequent.
In particular, for some unusual word combinations it may be tricky to
find enough occurrences to get accurate estimates.
As suggested by the empirical results in :numref:<code>subsec_natural-lang-stat</code>,
things take a turn for the worse for three-word combinations and beyond.
There will be many plausible three-word combinations that we likely will not see in our dataset.
Unless we provide some solution to assign such word combinations a nonzero count, we will not be able to use them in a language model. If the dataset is small or if the words are very rare, we might not find even a single one of them.</p>
<h3 id="laplace-smoothing"><a class="header" href="#laplace-smoothing">Laplace Smoothing</a></h3>
<p>A common strategy is to perform some form of <em>Laplace smoothing</em>.
The solution is to
add a small constant to all counts.
Denote by $n$ the total number of words in
the training set
and $m$ the number of unique words.
This solution helps with singletons, e.g., via</p>
<p>$$\begin{aligned}
\hat{P}(x) &amp; = \frac{n(x) + \epsilon_1/m}{n + \epsilon_1}, \
\hat{P}(x' \mid x) &amp; = \frac{n(x, x') + \epsilon_2 \hat{P}(x')}{n(x) + \epsilon_2}, \
\hat{P}(x'' \mid x,x') &amp; = \frac{n(x, x',x'') + \epsilon_3 \hat{P}(x'')}{n(x, x') + \epsilon_3}.
\end{aligned}$$</p>
<p>Here $\epsilon_1,\epsilon_2$, and $\epsilon_3$ are hyperparameters.
Take $\epsilon_1$ as an example:
when $\epsilon_1 = 0$, no smoothing is applied;
when $\epsilon_1$ approaches positive infinity,
$\hat{P}(x)$ approaches the uniform probability $1/m$.
The above is a rather primitive variant of what
other techniques can accomplish :cite:<code>Wood.Gasthaus.Archambeau.ea.2011</code>.</p>
<p>Unfortunately, models like this get unwieldy rather quickly
for the following reasons.
First,
as discussed in :numref:<code>subsec_natural-lang-stat</code>,
many $n$-grams occur very rarely,
making Laplace smoothing rather unsuitable for language modeling.
Second, we need to store all counts.
Third, this entirely ignores the meaning of the words. For
instance, "cat" and "feline" should occur in related contexts.
It is quite difficult to adjust such models to additional contexts,
whereas, deep learning based language models are well suited to
take this into account.
Last, long word
sequences are almost certain to be novel, hence a model that simply
counts the frequency of previously seen word sequences is bound to perform poorly there.
Therefore, we focus on using neural networks for language modeling
in the rest of the chapter.</p>
<h2 id="perplexity"><a class="header" href="#perplexity">Perplexity</a></h2>
<p>:label:<code>subsec_perplexity</code></p>
<p>Next, let's discuss about how to measure the quality of the language model, which we will then use to evaluate our models in the subsequent sections.
One way is to check how surprising the text is.
A good language model is able to predict, with high accuracy, the tokens that come next.
Consider the following continuations of the phrase "It is raining", as proposed by different language models:</p>
<ol>
<li>"It is raining outside"</li>
<li>"It is raining banana tree"</li>
<li>"It is raining piouw;kcj pwepoiut"</li>
</ol>
<p>In terms of quality, Example 1 is clearly the best. The words are sensible and logically coherent.
While it might not quite accurately reflect which word follows semantically ("in San Francisco" and "in winter" would have been perfectly reasonable extensions), the model is able to capture which kind of word follows.
Example 2 is considerably worse by producing a nonsensical extension. Nonetheless, at least the model has learned how to spell words and some degree of correlation between words. Last, Example 3 indicates a poorly trained model that does not fit data properly.</p>
<p>We might measure the quality of the model by computing  the likelihood of the sequence.
Unfortunately this is a number that is hard to understand and difficult to compare.
After all, shorter sequences are much more likely to occur than the longer ones,
hence evaluating the model on Tolstoy's magnum opus
<em>War and Peace</em> will inevitably produce a much smaller likelihood than, say, on Saint-Exupery's novella <em>The Little Prince</em>. What is missing is the equivalent of an average.</p>
<p>Information theory comes handy here.
We defined entropy, surprisal, and cross-entropy
when we introduced the softmax regression
(:numref:<code>subsec_info_theory_basics</code>).
If we want to compress text, we can ask about
predicting the next token given the current set of tokens.
A better language model should allow us to predict the next token more accurately.
Thus, it should allow us to spend fewer bits in compressing the sequence.
So we can measure it by the cross-entropy loss averaged
over all the $n$ tokens of a sequence:</p>
<p>$$\frac{1}{n} \sum_{t=1}^n -\log P(x_t \mid x_{t-1}, \ldots, x_1),$$
:eqlabel:<code>eq_avg_ce_for_lm</code></p>
<p>where $P$ is given by a language model and $x_t$ is the actual token observed at time step $t$ from the sequence.
This makes the performance on documents of different lengths comparable. For historical reasons, scientists in natural language processing prefer to use a quantity called <em>perplexity</em>. In a nutshell, it is the exponential of :eqref:<code>eq_avg_ce_for_lm</code>:</p>
<p>$$\exp\left(-\frac{1}{n} \sum_{t=1}^n \log P(x_t \mid x_{t-1}, \ldots, x_1)\right).$$</p>
<p>Perplexity can be best understood as the reciprocal of the geometric mean of the number of real choices that we have when deciding which token to pick next. Let's look at a number of cases:</p>
<ul>
<li>In the best case scenario, the model always perfectly estimates the probability of the target token as 1. In this case the perplexity of the model is 1.</li>
<li>In the worst case scenario, the model always predicts the probability of the target token as 0. In this situation, the perplexity is positive infinity.</li>
<li>At the baseline, the model predicts a uniform distribution over all the available tokens of the vocabulary. In this case, the perplexity equals the number of unique tokens of the vocabulary. In fact, if we were to store the sequence without any compression, this would be the best we could do for encoding it. Hence, this provides a nontrivial upper bound that any useful model must beat.</li>
</ul>
<h2 id="partitioning-sequences"><a class="header" href="#partitioning-sequences">Partitioning Sequences</a></h2>
<p>:label:<code>subsec_partitioning-seqs</code></p>
<p>We will design language models using neural networks
and use perplexity to evaluate
how good the model is at
predicting the next token given the current set of tokens
in text sequences.
Before introducing the model,
let's assume that it
processes a minibatch of sequences with predefined length
at a time.
Now the question is how to [<strong>read minibatches of input sequences and target sequences at random</strong>].</p>
<p>Suppose that the dataset takes the form of a sequence of $T$ token indices in <code>corpus</code>.
We will
partition it
into subsequences, where each subsequence has $n$ tokens (time steps).
To iterate over
(almost) all the tokens of the entire dataset
for each epoch
and obtain all possible length-$n$ subsequences,
we can introduce randomness.
More concretely,
at the beginning of each epoch,
discard the first $d$ tokens,
where $d\in [0,n)$ is uniformly sampled at random.
The rest of the sequence
is then partitioned
into $m=\lfloor (T-d)/n \rfloor$ subsequences.
Denote by $\mathbf x_t = [x_t, \ldots, x_{t+n-1}]$ the length-$n$ subsequence starting from token $x_t$ at time step $t$.
The resulting $m$ partitioned subsequences
are
$\mathbf x_d, \mathbf x_{d+n}, \ldots, \mathbf x_{d+n(m-1)}.$
Each subsequence will be used as an input sequence into the language model.</p>
<p>For language modeling,
the goal is to predict the next token based on the tokens we have seen so far; hence the targets (labels) are the original sequence, shifted by one token.
The target sequence for any input sequence $\mathbf x_t$
is $\mathbf x_{t+1}$ with length $n$.</p>
<p><img src="chapter_recurrent-neural-networks/../img/lang-model-data.svg" alt="Obtaining five pairs of input sequences and target sequences from partitioned length-5 subsequences." />
:label:<code>fig_lang_model_data</code></p>
<p>:numref:<code>fig_lang_model_data</code> shows an example of obtaining five pairs of input sequences and target sequences with $n=5$ and $d=2$.</p>
<pre><code class="language-{.python .input  n=5}">%%tab all
@d2l.add_to_class(d2l.TimeMachine)  #@save
def __init__(self, batch_size, num_steps, num_train=10000, num_val=5000):
    super(d2l.TimeMachine, self).__init__()
    self.save_hyperparameters()
    corpus, self.vocab = self.build(self._download())
    array = d2l.tensor([corpus[i:i+num_steps+1] 
                        for i in range(len(corpus)-num_steps)])
    self.X, self.Y = array[:,:-1], array[:,1:]
</code></pre>
<p>To train language models,
we will randomly sample
pairs of input sequences and target sequences
in minibatches.
The following data loader randomly generates a minibatch from the dataset each time.
The argument <code>batch_size</code> specifies the number of subsequence examples in each minibatch
and <code>num_steps</code> is the subsequence length in tokens.</p>
<pre><code class="language-{.python .input  n=6}">%%tab all
@d2l.add_to_class(d2l.TimeMachine)  #@save
def get_dataloader(self, train):
    idx = slice(0, self.num_train) if train else slice(
        self.num_train, self.num_train + self.num_val)
    return self.get_tensorloader([self.X, self.Y], train, idx)
</code></pre>
<p>As we can see in the following,
a minibatch of target sequences
can be obtained
by shifting the input sequences
by one token.</p>
<pre><code class="language-{.python .input  n=7}">%%tab all
data = d2l.TimeMachine(batch_size=2, num_steps=10)
for X, Y in data.train_dataloader():
    print('X:', X, '\nY:', Y)
    break
</code></pre>
<h2 id="summary-and-discussion-7"><a class="header" href="#summary-and-discussion-7">Summary and Discussion</a></h2>
<p>Language models estimate the joint probability of a text sequence. For long sequences, $n$-grams provide a convenient model by truncating the dependence. However, there is a lot of structure but not enough frequency to deal efficiently with infrequent word combinations via Laplace smoothing. Thus, we will focus on neural language modeling in subsequent sections.
To train language models, we can randomly sample pairs of input sequences and target sequences in minibatches. After training, we will use perplexity to measure the language model quality.</p>
<p>Language models can be scaled up with increased data size, model size, and amount in training compute. Large language models can perform desired tasks by predicting output text given input text instructions. As we will discuss later (e.g., :numref:<code>sec_large-pretraining-transformers</code>),
at the present moment
large language models form the basis of state-of-the-art systems across diverse tasks.</p>
<h2 id="exercises-52"><a class="header" href="#exercises-52">Exercises</a></h2>
<ol>
<li>Suppose there are 100,000 words in the training dataset. How much word frequency and multi-word adjacent frequency does a four-gram need to store?</li>
<li>How would you model a dialogue?</li>
<li>What other methods can you think of for reading long sequence data?</li>
<li>Consider our method for discarding a uniformly random number of the first few tokens at the beginning of each epoch.
<ol>
<li>Does it really lead to a perfectly uniform distribution over the sequences on the document?</li>
<li>What would you have to do to make things even more uniform?</li>
</ol>
</li>
<li>If we want a sequence example to be a complete sentence, what kind of problem does this introduce in minibatch sampling? How can we fix it?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/117">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/118">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1049">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18012">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recurrent-neural-networks-1"><a class="header" href="#recurrent-neural-networks-1">Recurrent Neural Networks</a></h1>
<p>:label:<code>sec_rnn</code></p>
<p>In :numref:<code>sec_language-model</code> we described Markov models and $n$-grams for language modeling, where the conditional probability of token $x_t$ at time step $t$ only depends on the $n-1$ previous tokens.
If we want to incorporate the possible effect of tokens earlier than time step $t-(n-1)$ on $x_t$,
we need to increase $n$.
However, the number of model parameters would also increase exponentially with it, as we need to store $|\mathcal{V}|^n$ numbers for a vocabulary set $\mathcal{V}$.
Hence, rather than modeling $P(x_t \mid x_{t-1}, \ldots, x_{t-n+1})$ it is preferable to use a latent variable model,</p>
<p>$$P(x_t \mid x_{t-1}, \ldots, x_1) \approx P(x_t \mid h_{t-1}),$$</p>
<p>where $h_{t-1}$ is a <em>hidden state</em>  that stores the sequence information up to time step $t-1$.
In general,
the hidden state at any time step $t$ could be computed based on both the current input $x_{t}$ and the previous hidden state $h_{t-1}$:</p>
<p>$$h_t = f(x_{t}, h_{t-1}).$$
:eqlabel:<code>eq_ht_xt</code></p>
<p>For a sufficiently powerful function $f$ in :eqref:<code>eq_ht_xt</code>, the latent variable model is not an approximation. After all, $h_t$ may simply store all the data it has observed so far.
However, it could potentially make both computation and storage expensive.</p>
<p>Recall that we have discussed hidden layers with hidden units in :numref:<code>chap_perceptrons</code>.
It is noteworthy that
hidden layers and hidden states refer to two very different concepts.
Hidden layers are, as explained, layers that are hidden from view on the path from input to output.
Hidden states are technically speaking <em>inputs</em> to whatever we do at a given step,
and they can only be computed by looking at data at previous time steps.</p>
<p><em>Recurrent neural networks</em> (RNNs) are neural networks with hidden states. Before introducing the RNN model, we first revisit the MLP model introduced in :numref:<code>sec_mlp</code>.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="neural-networks-without-hidden-states"><a class="header" href="#neural-networks-without-hidden-states">Neural Networks without Hidden States</a></h2>
<p>Let's take a look at an MLP with a single hidden layer.
Let the hidden layer's activation function be $\phi$.
Given a minibatch of examples $\mathbf{X} \in \mathbb{R}^{n \times d}$ with batch size $n$ and $d$ inputs, the hidden layer output $\mathbf{H} \in \mathbb{R}^{n \times h}$ is calculated as</p>
<p>$$\mathbf{H} = \phi(\mathbf{X} \mathbf{W}<em>{\textrm{xh}} + \mathbf{b}</em>\textrm{h}).$$
:eqlabel:<code>rnn_h_without_state</code></p>
<p>In :eqref:<code>rnn_h_without_state</code>, we have the weight parameter $\mathbf{W}<em>{\textrm{xh}} \in \mathbb{R}^{d \times h}$, the bias parameter $\mathbf{b}</em>\textrm{h} \in \mathbb{R}^{1 \times h}$, and the number of hidden units $h$, for the hidden layer.
So armed, we apply broadcasting (see :numref:<code>subsec_broadcasting</code>) during the summation.
Next, the hidden layer output $\mathbf{H}$ is used as input of the output layer, which is given by</p>
<p>$$\mathbf{O} = \mathbf{H} \mathbf{W}<em>{\textrm{hq}} + \mathbf{b}</em>\textrm{q},$$</p>
<p>where $\mathbf{O} \in \mathbb{R}^{n \times q}$ is the output variable, $\mathbf{W}<em>{\textrm{hq}} \in \mathbb{R}^{h \times q}$ is the weight parameter, and $\mathbf{b}</em>\textrm{q} \in \mathbb{R}^{1 \times q}$ is the bias parameter of the output layer.  If it is a classification problem, we can use $\mathrm{softmax}(\mathbf{O})$ to compute the probability distribution of the output categories.</p>
<p>This is entirely analogous to the regression problem we solved previously in :numref:<code>sec_sequence</code>, hence we omit details.
Suffice it to say that we can pick feature-label pairs at random and learn the parameters of our network via automatic differentiation and stochastic gradient descent.</p>
<h2 id="recurrent-neural-networks-with-hidden-states"><a class="header" href="#recurrent-neural-networks-with-hidden-states">Recurrent Neural Networks with Hidden States</a></h2>
<p>:label:<code>subsec_rnn_w_hidden_states</code></p>
<p>Matters are entirely different when we have hidden states. Let's look at the structure in some more detail.</p>
<p>Assume that we have
a minibatch of inputs
$\mathbf{X}_t \in \mathbb{R}^{n \times d}$
at time step $t$.
In other words,
for a minibatch of $n$ sequence examples,
each row of $\mathbf{X}<em>t$ corresponds to one example at time step $t$ from the sequence.
Next,
denote by $\mathbf{H}<em>t  \in \mathbb{R}^{n \times h}$ the hidden layer output of time step $t$.
Unlike with MLP, here we save the hidden layer output $\mathbf{H}</em>{t-1}$ from the previous time step and introduce a new weight parameter $\mathbf{W}</em>{\textrm{hh}} \in \mathbb{R}^{h \times h}$ to describe how to use the hidden layer output of the previous time step in the current time step. Specifically, the calculation of the hidden layer output of the current time step is determined by the input of the current time step together with the hidden layer output of the previous time step:</p>
<p>$$\mathbf{H}<em>t = \phi(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xh}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hh}}  + \mathbf{b}</em>\textrm{h}).$$
:eqlabel:<code>rnn_h_with_state</code></p>
<p>Compared with :eqref:<code>rnn_h_without_state</code>, :eqref:<code>rnn_h_with_state</code> adds one more term $\mathbf{H}<em>{t-1} \mathbf{W}</em>{\textrm{hh}}$ and thus
instantiates :eqref:<code>eq_ht_xt</code>.
From the relationship between hidden layer outputs $\mathbf{H}<em>t$ and $\mathbf{H}</em>{t-1}$ of adjacent time steps,
we know that these variables captured and retained the sequence's historical information up to their current time step, just like the state or memory of the neural network's current time step. Therefore, such a hidden layer output is called a <em>hidden state</em>.
Since the hidden state uses the same definition of the previous time step in the current time step, the computation of :eqref:<code>rnn_h_with_state</code> is <em>recurrent</em>. Hence, as we said, neural networks with hidden states
based on recurrent computation are named
<em>recurrent neural networks</em>.
Layers that perform
the computation of :eqref:<code>rnn_h_with_state</code>
in RNNs
are called <em>recurrent layers</em>.</p>
<p>There are many different ways for constructing RNNs.
Those with a hidden state defined by :eqref:<code>rnn_h_with_state</code> are very common.
For time step $t$,
the output of the output layer is similar to the computation in the MLP:</p>
<p>$$\mathbf{O}<em>t = \mathbf{H}<em>t \mathbf{W}</em>{\textrm{hq}} + \mathbf{b}</em>\textrm{q}.$$</p>
<p>Parameters of the RNN
include the weights $\mathbf{W}<em>{\textrm{xh}} \in \mathbb{R}^{d \times h}, \mathbf{W}</em>{\textrm{hh}} \in \mathbb{R}^{h \times h}$,
and the bias $\mathbf{b}<em>\textrm{h} \in \mathbb{R}^{1 \times h}$
of the hidden layer,
together with the weights $\mathbf{W}</em>{\textrm{hq}} \in \mathbb{R}^{h \times q}$
and the bias $\mathbf{b}_\textrm{q} \in \mathbb{R}^{1 \times q}$
of the output layer.
It is worth mentioning that
even at different time steps,
RNNs always use these model parameters.
Therefore, the parametrization cost of an RNN
does not grow as the number of time steps increases.</p>
<p>:numref:<code>fig_rnn</code> illustrates the computational logic of an RNN at three adjacent time steps.
At any time step $t$,
the computation of the hidden state can be treated as:
(i) concatenating the input $\mathbf{X}<em>t$ at the current time step $t$ and the hidden state $\mathbf{H}</em>{t-1}$ at the previous time step $t-1$;
(ii) feeding the concatenation result into a fully connected layer with the activation function $\phi$.
The output of such a fully connected layer is the hidden state $\mathbf{H}<em>t$ of the current time step $t$.
In this case,
the model parameters are the concatenation of $\mathbf{W}</em>{\textrm{xh}}$ and $\mathbf{W}<em>{\textrm{hh}}$, and a bias of $\mathbf{b}</em>\textrm{h}$, all from :eqref:<code>rnn_h_with_state</code>.
The hidden state of the current time step $t$, $\mathbf{H}<em>t$, will participate in computing the hidden state $\mathbf{H}</em>{t+1}$ of the next time step $t+1$.
What is more, $\mathbf{H}_t$ will also be
fed into the fully connected output layer
to compute the output
$\mathbf{O}_t$ of the current time step $t$.</p>
<p><img src="chapter_recurrent-neural-networks/../img/rnn.svg" alt="An RNN with a hidden state." />
:label:<code>fig_rnn</code></p>
<p>We just mentioned that the calculation of $\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xh}} + \mathbf{H}<em>{t-1} \mathbf{W}</em>{\textrm{hh}}$ for the hidden state is equivalent to
matrix multiplication of the
concatenation of $\mathbf{X}<em>t$ and $\mathbf{H}</em>{t-1}$
and the
concatenation of $\mathbf{W}<em>{\textrm{xh}}$ and $\mathbf{W}</em>{\textrm{hh}}$.
Though this can be proven mathematically,
in the following we just use a simple code snippet as a demonstration.
To begin with,
we define matrices <code>X</code>, <code>W_xh</code>, <code>H</code>, and <code>W_hh</code>, whose shapes are (3, 1), (1, 4), (3, 4), and (4, 4), respectively.
Multiplying <code>X</code> by <code>W_xh</code>, and <code>H</code> by <code>W_hh</code>, and then adding these two products,
we obtain a matrix of shape (3, 4).</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
X, W_xh = d2l.randn(3, 1), d2l.randn(1, 4)
H, W_hh = d2l.randn(3, 4), d2l.randn(4, 4)
d2l.matmul(X, W_xh) + d2l.matmul(H, W_hh)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X, W_xh = d2l.normal((3, 1)), d2l.normal((1, 4))
H, W_hh = d2l.normal((3, 4)), d2l.normal((4, 4))
d2l.matmul(X, W_xh) + d2l.matmul(H, W_hh)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X, W_xh = jax.random.normal(d2l.get_key(), (3, 1)), jax.random.normal(
                                                        d2l.get_key(), (1, 4))
H, W_hh = jax.random.normal(d2l.get_key(), (3, 4)), jax.random.normal(
                                                        d2l.get_key(), (4, 4))
d2l.matmul(X, W_xh) + d2l.matmul(H, W_hh)
</code></pre>
<p>Now we concatenate the matrices <code>X</code> and <code>H</code>
along columns (axis 1),
and the matrices
<code>W_xh</code> and <code>W_hh</code> along rows (axis 0).
These two concatenations
result in
matrices of shape (3, 5)
and of shape (5, 4), respectively.
Multiplying these two concatenated matrices,
we obtain the same output matrix of shape (3, 4)
as above.</p>
<pre><code class="language-{.python .input}">%%tab all
d2l.matmul(d2l.concat((X, H), 1), d2l.concat((W_xh, W_hh), 0))
</code></pre>
<h2 id="rnn-based-character-level-language-models"><a class="header" href="#rnn-based-character-level-language-models">RNN-Based Character-Level Language Models</a></h2>
<p>Recall that for language modeling in :numref:<code>sec_language-model</code>,
we aim to predict the next token based on
the current and past tokens;
thus we shift the original sequence by one token
as the targets (labels).
:citet:<code>Bengio.Ducharme.Vincent.ea.2003</code> first proposed
to use a neural network for language modeling.
In the following we illustrate how RNNs can be used to build a language model.
Let the minibatch size be one, and the sequence of the text be "machine".
To simplify training in subsequent sections,
we tokenize text into characters rather than words
and consider a <em>character-level language model</em>.
:numref:<code>fig_rnn_train</code> demonstrates how to predict the next character based on the current and previous characters via an RNN for character-level language modeling.</p>
<p><img src="chapter_recurrent-neural-networks/../img/rnn-train.svg" alt="A character-level language model based on the RNN. The input and target sequences are &quot;machin&quot; and &quot;achine&quot;, respectively." />
:label:<code>fig_rnn_train</code></p>
<p>During the training process,
we run a softmax operation on the output from the output layer for each time step, and then use the cross-entropy loss to compute the error between the model output and the target.
Because of the recurrent computation of the hidden state in the hidden layer, the output, $\mathbf{O}_3$,  of time step 3 in :numref:<code>fig_rnn_train</code> is determined by the text sequence "m", "a", and "c". Since the next character of the sequence in the training data is "h", the loss of time step 3 will depend on the probability distribution of the next character generated based on the feature sequence "m", "a", "c" and the target "h" of this time step.</p>
<p>In practice, each token is represented by a $d$-dimensional vector, and we use a batch size $n&gt;1$. Therefore, the input $\mathbf X_t$ at time step $t$ will be an $n\times d$ matrix, which is identical to what we discussed in :numref:<code>subsec_rnn_w_hidden_states</code>.</p>
<p>In the following sections, we will implement RNNs
for character-level language models.</p>
<h2 id="summary-35"><a class="header" href="#summary-35">Summary</a></h2>
<p>A neural network that uses recurrent computation for hidden states is called a recurrent neural network (RNN).
The hidden state of an RNN can capture historical information of the sequence up to the current time step. With recurrent computation, the number of RNN model parameters does not grow as the number of time steps increases. As for applications, an RNN can be used to create character-level language models.</p>
<h2 id="exercises-53"><a class="header" href="#exercises-53">Exercises</a></h2>
<ol>
<li>If we use an RNN to predict the next character in a text sequence, what is the required dimension for any output?</li>
<li>Why can RNNs express the conditional probability of a token at some time step based on all the previous tokens in the text sequence?</li>
<li>What happens to the gradient if you backpropagate through a long sequence?</li>
<li>What are some of the problems associated with the language model described in this section?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/337">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1050">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1051">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/180013">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recurrent-neural-network-implementation-from-scratch"><a class="header" href="#recurrent-neural-network-implementation-from-scratch">Recurrent Neural Network Implementation from Scratch</a></h1>
<p>:label:<code>sec_rnn-scratch</code></p>
<p>We are now ready to implement an RNN from scratch.
In particular, we will train this RNN to function
as a character-level language model
(see :numref:<code>sec_rnn</code>)
and train it on a corpus consisting of
the entire text of H. G. Wells' <em>The Time Machine</em>,
following the data processing steps
outlined in :numref:<code>sec_text-sequence</code>.
We start by loading the dataset.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import autograd, gluon, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import math
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input  n=5}">%%tab jax
%matplotlib inline
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
import math
</code></pre>
<h2 id="rnn-model"><a class="header" href="#rnn-model">RNN Model</a></h2>
<p>We begin by defining a class
to implement the RNN model
(:numref:<code>subsec_rnn_w_hidden_states</code>).
Note that the number of hidden units <code>num_hiddens</code>
is a tunable hyperparameter.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class RNNScratch(d2l.Module):  #@save
    """The RNN model implemented from scratch."""
    def __init__(self, num_inputs, num_hiddens, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.W_xh = d2l.randn(num_inputs, num_hiddens) * sigma
            self.W_hh = d2l.randn(
                num_hiddens, num_hiddens) * sigma
            self.b_h = d2l.zeros(num_hiddens)
        if tab.selected('pytorch'):
            self.W_xh = nn.Parameter(
                d2l.randn(num_inputs, num_hiddens) * sigma)
            self.W_hh = nn.Parameter(
                d2l.randn(num_hiddens, num_hiddens) * sigma)
            self.b_h = nn.Parameter(d2l.zeros(num_hiddens))
        if tab.selected('tensorflow'):
            self.W_xh = tf.Variable(d2l.normal(
                (num_inputs, num_hiddens)) * sigma)
            self.W_hh = tf.Variable(d2l.normal(
                (num_hiddens, num_hiddens)) * sigma)
            self.b_h = tf.Variable(d2l.zeros(num_hiddens))
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab jax
class RNNScratch(nn.Module):  #@save
    """The RNN model implemented from scratch."""
    num_inputs: int
    num_hiddens: int
    sigma: float = 0.01

    def setup(self):
        self.W_xh = self.param('W_xh', nn.initializers.normal(self.sigma),
                               (self.num_inputs, self.num_hiddens))
        self.W_hh = self.param('W_hh', nn.initializers.normal(self.sigma),
                               (self.num_hiddens, self.num_hiddens))
        self.b_h = self.param('b_h', nn.initializers.zeros, (self.num_hiddens))
</code></pre>
<p>[<strong>The <code>forward</code> method below defines how to compute
the output and hidden state at any time step,
given the current input and the state of the model
at the previous time step.</strong>]
Note that the RNN model loops through
the outermost dimension of <code>inputs</code>,
updating the hidden state
one time step at a time.
The model here uses a $\tanh$ activation function (:numref:<code>subsec_tanh</code>).</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(RNNScratch)  #@save
def forward(self, inputs, state=None):
    if state is None:
        # Initial state with shape: (batch_size, num_hiddens)
        if tab.selected('mxnet'):
            state = d2l.zeros((inputs.shape[1], self.num_hiddens),
                              ctx=inputs.ctx)
        if tab.selected('pytorch'):
            state = d2l.zeros((inputs.shape[1], self.num_hiddens),
                              device=inputs.device)
        if tab.selected('tensorflow'):
            state = d2l.zeros((inputs.shape[1], self.num_hiddens))
    else:
        state, = state
        if tab.selected('tensorflow'):
            state = d2l.reshape(state, (-1, self.num_hiddens))
    outputs = []
    for X in inputs:  # Shape of inputs: (num_steps, batch_size, num_inputs) 
        state = d2l.tanh(d2l.matmul(X, self.W_xh) +
                         d2l.matmul(state, self.W_hh) + self.b_h)
        outputs.append(state)
    return outputs, state
</code></pre>
<pre><code class="language-{.python .input  n=9}">%%tab jax
@d2l.add_to_class(RNNScratch)  #@save
def __call__(self, inputs, state=None):
    if state is not None:
        state, = state
    outputs = []
    for X in inputs:  # Shape of inputs: (num_steps, batch_size, num_inputs) 
        state = d2l.tanh(d2l.matmul(X, self.W_xh) + (
            d2l.matmul(state, self.W_hh) if state is not None else 0)
                         + self.b_h)
        outputs.append(state)
    return outputs, state
</code></pre>
<p>We can feed a minibatch of input sequences into an RNN model as follows.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
batch_size, num_inputs, num_hiddens, num_steps = 2, 16, 32, 100
rnn = RNNScratch(num_inputs, num_hiddens)
X = d2l.ones((num_steps, batch_size, num_inputs))
outputs, state = rnn(X)
</code></pre>
<pre><code class="language-{.python .input  n=11}">%%tab jax
batch_size, num_inputs, num_hiddens, num_steps = 2, 16, 32, 100
rnn = RNNScratch(num_inputs, num_hiddens)
X = d2l.ones((num_steps, batch_size, num_inputs))
(outputs, state), _ = rnn.init_with_output(d2l.get_key(), X)
</code></pre>
<p>Let's check whether the RNN model
produces results of the correct shapes
to ensure that the dimensionality
of the hidden state remains unchanged.</p>
<pre><code class="language-{.python .input}">%%tab all
def check_len(a, n):  #@save
    """Check the length of a list."""
    assert len(a) == n, f'list\'s length {len(a)} != expected length {n}'
    
def check_shape(a, shape):  #@save
    """Check the shape of a tensor."""
    assert a.shape == shape, \
            f'tensor\'s shape {a.shape} != expected shape {shape}'

check_len(outputs, num_steps)
check_shape(outputs[0], (batch_size, num_hiddens))
check_shape(state, (batch_size, num_hiddens))
</code></pre>
<h2 id="rnn-based-language-model"><a class="header" href="#rnn-based-language-model">RNN-Based Language Model</a></h2>
<p>The following <code>RNNLMScratch</code> class defines
an RNN-based language model,
where we pass in our RNN
via the <code>rnn</code> argument
of the <code>__init__</code> method.
When training language models,
the inputs and outputs are
from the same vocabulary.
Hence, they have the same dimension,
which is equal to the vocabulary size.
Note that we use perplexity to evaluate the model.
As discussed in :numref:<code>subsec_perplexity</code>, this ensures
that sequences of different length are comparable.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class RNNLMScratch(d2l.Classifier):  #@save
    """The RNN-based language model implemented from scratch."""
    def __init__(self, rnn, vocab_size, lr=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.init_params()
        
    def init_params(self):
        self.W_hq = nn.Parameter(
            d2l.randn(
                self.rnn.num_hiddens, self.vocab_size) * self.rnn.sigma)
        self.b_q = nn.Parameter(d2l.zeros(self.vocab_size)) 

    def training_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('ppl', d2l.exp(l), train=True)
        return l
        
    def validation_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('ppl', d2l.exp(l), train=False)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
class RNNLMScratch(d2l.Classifier):  #@save
    """The RNN-based language model implemented from scratch."""
    def __init__(self, rnn, vocab_size, lr=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.init_params()
        
    def init_params(self):
        if tab.selected('mxnet'):
            self.W_hq = d2l.randn(
                self.rnn.num_hiddens, self.vocab_size) * self.rnn.sigma
            self.b_q = d2l.zeros(self.vocab_size)        
            for param in self.get_scratch_params():
                param.attach_grad()
        if tab.selected('tensorflow'):
            self.W_hq = tf.Variable(d2l.normal(
                (self.rnn.num_hiddens, self.vocab_size)) * self.rnn.sigma)
            self.b_q = tf.Variable(d2l.zeros(self.vocab_size))
        
    def training_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('ppl', d2l.exp(l), train=True)
        return l
        
    def validation_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('ppl', d2l.exp(l), train=False)
</code></pre>
<pre><code class="language-{.python .input  n=14}">%%tab jax
class RNNLMScratch(d2l.Classifier):  #@save
    """The RNN-based language model implemented from scratch."""
    rnn: nn.Module
    vocab_size: int
    lr: float = 0.01

    def setup(self):
        self.W_hq = self.param('W_hq', nn.initializers.normal(self.rnn.sigma),
                               (self.rnn.num_hiddens, self.vocab_size))
        self.b_q = self.param('b_q', nn.initializers.zeros, (self.vocab_size))

    def training_step(self, params, batch, state):
        value, grads = jax.value_and_grad(
            self.loss, has_aux=True)(params, batch[:-1], batch[-1], state)
        l, _ = value
        self.plot('ppl', d2l.exp(l), train=True)
        return value, grads

    def validation_step(self, params, batch, state):
        l, _ = self.loss(params, batch[:-1], batch[-1], state)
        self.plot('ppl', d2l.exp(l), train=False)
</code></pre>
<h3 id="one-hot-encoding"><a class="header" href="#one-hot-encoding">[<strong>One-Hot Encoding</strong>]</a></h3>
<p>Recall that each token is represented
by a numerical index indicating the
position in the vocabulary of the
corresponding word/character/word piece.
You might be tempted to build a neural network
with a single input node (at each time step),
where the index could be fed in as a scalar value.
This works when we are dealing with numerical inputs
like price or temperature, where any two values
sufficiently close together
should be treated similarly.
But this does not quite make sense.
The $45^{\textrm{th}}$ and $46^{\textrm{th}}$ words
in our vocabulary happen to be "their" and "said",
whose meanings are not remotely similar.</p>
<p>When dealing with such categorical data,
the most common strategy is to represent
each item by a <em>one-hot encoding</em>
(recall from :numref:<code>subsec_classification-problem</code>).
A one-hot encoding is a vector whose length
is given by the size of the vocabulary $N$,
where all entries are set to $0$,
except for the entry corresponding
to our token, which is set to $1$.
For example, if the vocabulary had five elements,
then the one-hot vectors corresponding
to indices 0 and 2 would be the following.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
npx.one_hot(np.array([0, 2]), 5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
F.one_hot(torch.tensor([0, 2]), 5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
tf.one_hot(tf.constant([0, 2]), 5)
</code></pre>
<pre><code class="language-{.python .input  n=18}">%%tab jax
jax.nn.one_hot(jnp.array([0, 2]), 5)
</code></pre>
<p>(<strong>The minibatches that we sample at each iteration
will take the shape (batch size, number of time steps).
Once representing each input as a one-hot vector,
we can think of each minibatch as a three-dimensional tensor,
where the length along the third axis
is given by the vocabulary size (<code>len(vocab)</code>).</strong>)
We often transpose the input so that we will obtain an output
of shape (number of time steps, batch size, vocabulary size).
This will allow us to loop more conveniently through the outermost dimension
for updating hidden states of a minibatch,
time step by time step
(e.g., in the above <code>forward</code> method).</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(RNNLMScratch)  #@save
def one_hot(self, X):    
    # Output shape: (num_steps, batch_size, vocab_size)    
    if tab.selected('mxnet'):
        return npx.one_hot(X.T, self.vocab_size)
    if tab.selected('pytorch'):
        return F.one_hot(X.T, self.vocab_size).type(torch.float32)
    if tab.selected('tensorflow'):
        return tf.one_hot(tf.transpose(X), self.vocab_size)
    if tab.selected('jax'):
        return jax.nn.one_hot(X.T, self.vocab_size)
</code></pre>
<h3 id="transforming-rnn-outputs"><a class="header" href="#transforming-rnn-outputs">Transforming RNN Outputs</a></h3>
<p>The language model uses a fully connected output layer
to transform RNN outputs into token predictions at each time step.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(RNNLMScratch)  #@save
def output_layer(self, rnn_outputs):
    outputs = [d2l.matmul(H, self.W_hq) + self.b_q for H in rnn_outputs]
    return d2l.stack(outputs, 1)

@d2l.add_to_class(RNNLMScratch)  #@save
def forward(self, X, state=None):
    embs = self.one_hot(X)
    rnn_outputs, _ = self.rnn(embs, state)
    return self.output_layer(rnn_outputs)
</code></pre>
<p>Let's [<strong>check whether the forward computation
produces outputs with the correct shape.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
model = RNNLMScratch(rnn, num_inputs)
outputs = model(d2l.ones((batch_size, num_steps), dtype=d2l.int64))
check_shape(outputs, (batch_size, num_steps, num_inputs))
</code></pre>
<pre><code class="language-{.python .input  n=23}">%%tab jax
model = RNNLMScratch(rnn, num_inputs)
outputs, _ = model.init_with_output(d2l.get_key(),
                                    d2l.ones((batch_size, num_steps),
                                             dtype=d2l.int32))
check_shape(outputs, (batch_size, num_steps, num_inputs))
</code></pre>
<h2 id="gradient-clipping"><a class="header" href="#gradient-clipping">[<strong>Gradient Clipping</strong>]</a></h2>
<p>While you are already used to thinking of neural networks
as "deep" in the sense that many layers
separate the input and output
even within a single time step,
the length of the sequence introduces
a new notion of depth.
In addition to the passing through the network
in the input-to-output direction,
inputs at the first time step
must pass through a chain of $T$ layers
along the time steps in order
to influence the output of the model
at the final time step.
Taking the backwards view, in each iteration,
we backpropagate gradients through time,
resulting in a chain of matrix-products
of length  $\mathcal{O}(T)$.
As mentioned in :numref:<code>sec_numerical_stability</code>,
this can result in numerical instability,
causing the gradients either to explode or vanish,
depending on the properties of the weight matrices.</p>
<p>Dealing with vanishing and exploding gradients
is a fundamental problem when designing RNNs
and has inspired some of the biggest advances
in modern neural network architectures.
In the next chapter, we will talk about
specialized architectures that were designed
in hopes of mitigating the vanishing gradient problem.
However, even modern RNNs often suffer
from exploding gradients.
One inelegant but ubiquitous solution
is to simply clip the gradients
forcing the resulting "clipped" gradients
to take smaller values.</p>
<p>Generally speaking, when optimizing some objective
by gradient descent, we iteratively update
the parameter of interest, say a vector $\mathbf{x}$,
but pushing it in the direction of the
negative gradient $\mathbf{g}$
(in stochastic gradient descent,
we calculate this gradient
on a randomly sampled minibatch).
For example, with learning rate $\eta &gt; 0$,
each update takes the form
$\mathbf{x} \gets \mathbf{x} - \eta \mathbf{g}$.
Let's further assume that the objective function $f$
is sufficiently smooth.
Formally, we say that the objective
is <em>Lipschitz continuous</em> with constant $L$,
meaning that for any $\mathbf{x}$ and $\mathbf{y}$, we have</p>
<p>$$|f(\mathbf{x}) - f(\mathbf{y})| \leq L |\mathbf{x} - \mathbf{y}|.$$</p>
<p>As you can see, when we update the parameter vector by subtracting $\eta \mathbf{g}$,
the change in the value of the objective
depends on the learning rate,
the norm of the gradient and $L$ as follows:</p>
<p>$$|f(\mathbf{x}) - f(\mathbf{x} - \eta\mathbf{g})| \leq L \eta|\mathbf{g}|.$$</p>
<p>In other words, the objective cannot
change by more than $L \eta |\mathbf{g}|$.
Having a small value for this upper bound
might be viewed as good or bad.
On the downside, we are limiting the speed
at which we can reduce the value of the objective.
On the bright side, this limits by just how much
we can go wrong in any one gradient step.</p>
<p>When we say that gradients explode,
we mean that $|\mathbf{g}|$
becomes excessively large.
In this worst case, we might do so much
damage in a single gradient step that we
could undo all of the progress made over
the course of thousands of training iterations.
When gradients can be so large,
neural network training often diverges,
failing to reduce the value of the objective.
At other times, training eventually converges
but is unstable owing to massive spikes in the loss.</p>
<p>One way to limit the size of $L \eta |\mathbf{g}|$
is to shrink the learning rate $\eta$ to tiny values.
This has the advantage that we do not bias the updates.
But what if we only <em>rarely</em> get large gradients?
This drastic move slows down our progress at all steps,
just to deal with the rare exploding gradient events.
A popular alternative is to adopt a <em>gradient clipping</em> heuristic
projecting the gradients $\mathbf{g}$ onto a ball
of some given radius $\theta$ as follows:</p>
<p>(<strong>$$\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{|\mathbf{g}|}\right) \mathbf{g}.$$</strong>)</p>
<p>This ensures that the gradient norm never exceeds $\theta$
and that the updated gradient is entirely aligned
with the original direction of $\mathbf{g}$.
It also has the desirable side-effect
of limiting the influence any given minibatch
(and within it any given sample)
can exert on the parameter vector.
This bestows a certain degree of robustness to the model.
To be clear, it is a hack.
Gradient clipping means that we are not always
following the true gradient and it is hard
to reason analytically about the possible side effects.
However, it is a very useful hack,
and is widely adopted in RNN implementations
in most deep learning frameworks.</p>
<p>Below we define a method to clip gradients,
which is invoked by the <code>fit_epoch</code> method of
the <code>d2l.Trainer</code> class (see :numref:<code>sec_linear_scratch</code>).
Note that when computing the gradient norm,
we are concatenating all model parameters,
treating them as a single giant parameter vector.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(d2l.Trainer)  #@save
def clip_gradients(self, grad_clip_val, model):
    params = model.parameters()
    if not isinstance(params, list):
        params = [p.data() for p in params.values()]    
    norm = math.sqrt(sum((p.grad ** 2).sum() for p in params))
    if norm &gt; grad_clip_val:
        for param in params:
            param.grad[:] *= grad_clip_val / norm
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(d2l.Trainer)  #@save
def clip_gradients(self, grad_clip_val, model):
    params = [p for p in model.parameters() if p.requires_grad]
    norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params))
    if norm &gt; grad_clip_val:
        for param in params:
            param.grad[:] *= grad_clip_val / norm
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(d2l.Trainer)  #@save
def clip_gradients(self, grad_clip_val, grads):
    grad_clip_val = tf.constant(grad_clip_val, dtype=tf.float32)
    new_grads = [tf.convert_to_tensor(grad) if isinstance(
        grad, tf.IndexedSlices) else grad for grad in grads]    
    norm = tf.math.sqrt(sum((tf.reduce_sum(grad ** 2)) for grad in new_grads))
    if tf.greater(norm, grad_clip_val):
        for i, grad in enumerate(new_grads):
            new_grads[i] = grad * grad_clip_val / norm
        return new_grads
    return grads
</code></pre>
<pre><code class="language-{.python .input  n=27}">%%tab jax
@d2l.add_to_class(d2l.Trainer)  #@save
def clip_gradients(self, grad_clip_val, grads):
    grad_leaves, _ = jax.tree_util.tree_flatten(grads)
    norm = jnp.sqrt(sum(jnp.vdot(x, x) for x in grad_leaves))
    clip = lambda grad: jnp.where(norm &lt; grad_clip_val,
                                  grad, grad * (grad_clip_val / norm))
    return jax.tree_util.tree_map(clip, grads)
</code></pre>
<h2 id="training-17"><a class="header" href="#training-17">Training</a></h2>
<p>Using <em>The Time Machine</em> dataset (<code>data</code>),
we train a character-level language model (<code>model</code>)
based on the RNN (<code>rnn</code>) implemented from scratch.
Note that we first calculate the gradients,
then clip them, and finally
update the model parameters
using the clipped gradients.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.TimeMachine(batch_size=1024, num_steps=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    rnn = RNNScratch(num_inputs=len(data.vocab), num_hiddens=32)
    model = RNNLMScratch(rnn, vocab_size=len(data.vocab), lr=1)
    trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        rnn = RNNScratch(num_inputs=len(data.vocab), num_hiddens=32)
        model = RNNLMScratch(rnn, vocab_size=len(data.vocab), lr=1)
    trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<h2 id="decoding"><a class="header" href="#decoding">Decoding</a></h2>
<p>Once a language model has been learned,
we can use it not only to predict the next token
but to continue predicting each subsequent one,
treating the previously predicted token as though
it were the next in the input.
Sometimes we will just want to generate text
as though we were starting at the beginning
of a document.
However, it is often useful to condition
the language model on a user-supplied prefix.
For example, if we were developing an
autocomplete feature for a search engine
or to assist users in writing emails,
we would want to feed in what they
had written so far (the prefix),
and then generate a likely continuation.</p>
<p>[<strong>The following <code>predict</code> method
generates a continuation, one character at a time,
after ingesting a user-provided <code>prefix</code></strong>].
When looping through the characters in <code>prefix</code>,
we keep passing the hidden state
to the next time step
but do not generate any output.
This is called the <em>warm-up</em> period.
After ingesting the prefix, we are now
ready to begin emitting the subsequent characters,
each of which will be fed back into the model
as the input at the next time step.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(RNNLMScratch)  #@save
def predict(self, prefix, num_preds, vocab, device=None):
    state, outputs = None, [vocab[prefix[0]]]
    for i in range(len(prefix) + num_preds - 1):
        if tab.selected('mxnet'):
            X = d2l.tensor([[outputs[-1]]], ctx=device)
        if tab.selected('pytorch'):
            X = d2l.tensor([[outputs[-1]]], device=device)
        if tab.selected('tensorflow'):
            X = d2l.tensor([[outputs[-1]]])
        embs = self.one_hot(X)
        rnn_outputs, state = self.rnn(embs, state)
        if i &lt; len(prefix) - 1:  # Warm-up period
            outputs.append(vocab[prefix[i + 1]])
        else:  # Predict num_preds steps
            Y = self.output_layer(rnn_outputs)
            outputs.append(int(d2l.reshape(d2l.argmax(Y, axis=2), 1)))
    return ''.join([vocab.idx_to_token[i] for i in outputs])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(RNNLMScratch)  #@save
def predict(self, prefix, num_preds, vocab, params):
    state, outputs = None, [vocab[prefix[0]]]
    for i in range(len(prefix) + num_preds - 1):
        X = d2l.tensor([[outputs[-1]]])
        embs = self.one_hot(X)
        rnn_outputs, state = self.rnn.apply({'params': params['rnn']},
                                            embs, state)
        if i &lt; len(prefix) - 1:  # Warm-up period
            outputs.append(vocab[prefix[i + 1]])
        else:  # Predict num_preds steps
            Y = self.apply({'params': params}, rnn_outputs,
                           method=self.output_layer)
            outputs.append(int(d2l.reshape(d2l.argmax(Y, axis=2), 1)))
    return ''.join([vocab.idx_to_token[i] for i in outputs])
</code></pre>
<p>In the following, we specify the prefix
and have it generate 20 additional characters.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
model.predict('it has', 20, data.vocab)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
model.predict('it has', 20, data.vocab, trainer.state.params)
</code></pre>
<p>While implementing the above RNN model from scratch is instructive, it is not convenient.
In the next section, we will see how to leverage deep learning frameworks to whip up RNNs
using standard architectures, and to reap performance gains
by relying on highly optimized library functions.</p>
<h2 id="summary-36"><a class="header" href="#summary-36">Summary</a></h2>
<p>We can train RNN-based language models to generate text following the user-provided text prefix.
A simple RNN language model consists of input encoding, RNN modeling, and output generation.
During training, gradient clipping can mitigate the problem of exploding gradients but does not address the problem of vanishing gradients. In the experiment, we implemented a simple RNN language model and trained it with gradient clipping on sequences of text, tokenized at the character level. By conditioning on a prefix, we can use a language model to generate likely continuations, which proves useful in many applications, e.g., autocomplete features.</p>
<h2 id="exercises-54"><a class="header" href="#exercises-54">Exercises</a></h2>
<ol>
<li>Does the implemented language model predict the next token based on all the past tokens up to the very first token in <em>The Time Machine</em>?</li>
<li>Which hyperparameter controls the length of history used for prediction?</li>
<li>Show that one-hot encoding is equivalent to picking a different embedding for each object.</li>
<li>Adjust the hyperparameters (e.g., number of epochs, number of hidden units, number of time steps in a minibatch, and learning rate) to improve the perplexity. How low can you go while sticking with this simple architecture?</li>
<li>Replace one-hot encoding with learnable embeddings. Does this lead to better performance?</li>
<li>Conduct an experiment to determine how well this language model
trained on <em>The Time Machine</em> works on other books by H. G. Wells,
e.g., <em>The War of the Worlds</em>.</li>
<li>Conduct another experiment to evaluate the perplexity of this model
on books written by other authors.</li>
<li>Modify the prediction method so as to use sampling
rather than picking the most likely next character.
<ul>
<li>What happens?</li>
<li>Bias the model towards more likely outputs, e.g.,
by sampling from $q(x_t \mid x_{t-1}, \ldots, x_1) \propto P(x_t \mid x_{t-1}, \ldots, x_1)^\alpha$ for $\alpha &gt; 1$.</li>
</ul>
</li>
<li>Run the code in this section without clipping the gradient. What happens?</li>
<li>Replace the activation function used in this section with ReLU
and repeat the experiments in this section. Do we still need gradient clipping? Why?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/336">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/486">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1052">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18014">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-implementation-of-recurrent-neural-networks"><a class="header" href="#concise-implementation-of-recurrent-neural-networks">Concise Implementation of Recurrent Neural Networks</a></h1>
<p>:label:<code>sec_rnn-concise</code></p>
<p>Like most of our from-scratch implementations,
:numref:<code>sec_rnn-scratch</code> was designed
to provide insight into how each component works.
But when you are using RNNs every day
or writing production code,
you will want to rely more on libraries
that cut down on both implementation time
(by supplying library code for common models and functions)
and computation time
(by optimizing the heck out of these library implementations).
This section will show you how to implement
the same language model more efficiently
using the high-level API provided
by your deep learning framework.
We begin, as before, by loading
<em>The Time Machine</em> dataset.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn, rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
</code></pre>
<h2 id="defining-the-model-5"><a class="header" href="#defining-the-model-5">[<strong>Defining the Model</strong>]</a></h2>
<p>We define the following class
using the RNN implemented
by high-level APIs.</p>
<p>:begin_tab:<code>mxnet</code>
Specifically, to initialize the hidden state,
we invoke the member method <code>begin_state</code>.
This returns a list that contains
an initial hidden state
for each example in the minibatch,
whose shape is
(number of hidden layers, batch size, number of hidden units).
For some models to be introduced later
(e.g., long short-term memory),
this list will also contain other information.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Flax does not provide an RNNCell for concise implementation of Vanilla RNNs
as of today. There are more advanced variants of RNNs like LSTMs and GRUs
which are available in the Flax <code>linen</code> API.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class RNN(d2l.Module):  #@save
    """The RNN model implemented with high-level APIs."""
    def __init__(self, num_hiddens):
        super().__init__()
        self.save_hyperparameters()        
        self.rnn = rnn.RNN(num_hiddens)
        
    def forward(self, inputs, H=None):
        if H is None:
            H, = self.rnn.begin_state(inputs.shape[1], ctx=inputs.ctx)
        outputs, (H, ) = self.rnn(inputs, (H, ))
        return outputs, H
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class RNN(d2l.Module):  #@save
    """The RNN model implemented with high-level APIs."""
    def __init__(self, num_inputs, num_hiddens):
        super().__init__()
        self.save_hyperparameters()
        self.rnn = nn.RNN(num_inputs, num_hiddens)
        
    def forward(self, inputs, H=None):
        return self.rnn(inputs, H)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class RNN(d2l.Module):  #@save
    """The RNN model implemented with high-level APIs."""
    def __init__(self, num_hiddens):
        super().__init__()
        self.save_hyperparameters()            
        self.rnn = tf.keras.layers.SimpleRNN(
            num_hiddens, return_sequences=True, return_state=True,
            time_major=True)
        
    def forward(self, inputs, H=None):
        outputs, H = self.rnn(inputs, H)
        return outputs, H
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class RNN(nn.Module):  #@save
    """The RNN model implemented with high-level APIs."""
    num_hiddens: int

    @nn.compact
    def __call__(self, inputs, H=None):
        raise NotImplementedError
</code></pre>
<p>Inheriting from the <code>RNNLMScratch</code> class in :numref:<code>sec_rnn-scratch</code>,
the following <code>RNNLM</code> class defines a complete RNN-based language model.
Note that we need to create a separate fully connected output layer.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class RNNLM(d2l.RNNLMScratch):  #@save
    """The RNN-based language model implemented with high-level APIs."""
    def init_params(self):
        self.linear = nn.LazyLinear(self.vocab_size)
        
    def output_layer(self, hiddens):
        return d2l.swapaxes(self.linear(hiddens), 0, 1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
class RNNLM(d2l.RNNLMScratch):  #@save
    """The RNN-based language model implemented with high-level APIs."""
    def init_params(self):
        if tab.selected('mxnet'):
            self.linear = nn.Dense(self.vocab_size, flatten=False)
            self.initialize()
        if tab.selected('tensorflow'):
            self.linear = tf.keras.layers.Dense(self.vocab_size)
        
    def output_layer(self, hiddens):
        if tab.selected('mxnet'):
            return d2l.swapaxes(self.linear(hiddens), 0, 1)        
        if tab.selected('tensorflow'):
            return d2l.transpose(self.linear(hiddens), (1, 0, 2))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class RNNLM(d2l.RNNLMScratch):  #@save
    """The RNN-based language model implemented with high-level APIs."""
    training: bool = True

    def setup(self):
        self.linear = nn.Dense(self.vocab_size)

    def output_layer(self, hiddens):
        return d2l.swapaxes(self.linear(hiddens), 0, 1)

    def forward(self, X, state=None):
        embs = self.one_hot(X)
        rnn_outputs, _ = self.rnn(embs, state, self.training)
        return self.output_layer(rnn_outputs)
</code></pre>
<h2 id="training-and-predicting"><a class="header" href="#training-and-predicting">Training and Predicting</a></h2>
<p>Before training the model, let's [<strong>make a prediction
with a model initialized with random weights.</strong>]
Given that we have not trained the network,
it will generate nonsensical predictions.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
data = d2l.TimeMachine(batch_size=1024, num_steps=32)
if tab.selected('mxnet', 'tensorflow'):
    rnn = RNN(num_hiddens=32)
if tab.selected('pytorch'):
    rnn = RNN(num_inputs=len(data.vocab), num_hiddens=32)
model = RNNLM(rnn, vocab_size=len(data.vocab), lr=1)
model.predict('it has', 20, data.vocab)
</code></pre>
<p>Next, we [<strong>train our model, leveraging the high-level API</strong>].</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
if tab.selected('mxnet', 'pytorch'):
    trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<p>Compared with :numref:<code>sec_rnn-scratch</code>,
this model achieves comparable perplexity,
but runs faster due to the optimized implementations.
As before, we can generate predicted tokens
following the specified prefix string.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
model.predict('it has', 20, data.vocab)
</code></pre>
<h2 id="summary-37"><a class="header" href="#summary-37">Summary</a></h2>
<p>High-level APIs in deep learning frameworks provide implementations of standard RNNs.
These libraries help you to avoid wasting time reimplementing standard models.
Moreover,
framework implementations are often highly optimized,
leading to significant (computational) performance gains
when compared with implementations from scratch.</p>
<h2 id="exercises-55"><a class="header" href="#exercises-55">Exercises</a></h2>
<ol>
<li>Can you make the RNN model overfit using the high-level APIs?</li>
<li>Implement the autoregressive model of :numref:<code>sec_sequence</code> using an RNN.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/335">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1053">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/2211">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18015">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backpropagation-through-time"><a class="header" href="#backpropagation-through-time">Backpropagation Through Time</a></h1>
<p>:label:<code>sec_bptt</code></p>
<p>If you completed the exercises in :numref:<code>sec_rnn-scratch</code>,
you would have seen that gradient clipping is vital
for preventing the occasional massive gradients
from destabilizing training.
We hinted that the exploding gradients
stem from backpropagating across long sequences.
Before introducing a slew of modern RNN architectures,
let's take a closer look at how <em>backpropagation</em>
works in sequence models in mathematical detail.
Hopefully, this discussion will bring some precision
to the notion of <em>vanishing</em> and <em>exploding</em> gradients.
If you recall our discussion of forward and backward
propagation through computational graphs
when we introduced MLPs in :numref:<code>sec_backprop</code>,
then forward propagation in RNNs
should be relatively straightforward.
Applying backpropagation in RNNs
is called <em>backpropagation through time</em> :cite:<code>Werbos.1990</code>.
This procedure requires us to expand (or unroll)
the computational graph of an RNN
one time step at a time.
The unrolled RNN is essentially
a feedforward neural network
with the special property
that the same parameters
are repeated throughout the unrolled network,
appearing at each time step.
Then, just as in any feedforward neural network,
we can apply the chain rule,
backpropagating gradients through the unrolled net.
The gradient with respect to each parameter
must be summed across all places
that the parameter occurs in the unrolled net.
Handling such weight tying should be familiar
from our chapters on convolutional neural networks.</p>
<p>Complications arise because sequences
can be rather long.
It is not unusual to work with text sequences
consisting of over a thousand tokens.
Note that this poses problems both from
a computational (too much memory)
and optimization (numerical instability)
standpoint.
Input from the first step passes through
over 1000 matrix products before arriving at the output,
and another 1000 matrix products
are required to compute the gradient.
We now analyze what can go wrong and
how to address it in practice.</p>
<h2 id="analysis-of-gradients-in-rnns"><a class="header" href="#analysis-of-gradients-in-rnns">Analysis of Gradients in RNNs</a></h2>
<p>:label:<code>subsec_bptt_analysis</code></p>
<p>We start with a simplified model of how an RNN works.
This model ignores details about the specifics
of the hidden state and how it is updated.
The mathematical notation here
does not explicitly distinguish
scalars, vectors, and matrices.
We are just trying to develop some intuition.
In this simplified model,
we denote $h_t$ as the hidden state,
$x_t$ as input, and $o_t$ as output
at time step $t$.
Recall our discussions in
:numref:<code>subsec_rnn_w_hidden_states</code>
that the input and the hidden state
can be concatenated before being multiplied
by one weight variable in the hidden layer.
Thus, we use $w_\textrm{h}$ and $w_\textrm{o}$ to indicate the weights
of the hidden layer and the output layer, respectively.
As a result, the hidden states and outputs
at each time step are</p>
<p>$$\begin{aligned}h_t &amp;= f(x_t, h_{t-1}, w_\textrm{h}),\o_t &amp;= g(h_t, w_\textrm{o}),\end{aligned}$$
:eqlabel:<code>eq_bptt_ht_ot</code></p>
<p>where $f$ and $g$ are transformations
of the hidden layer and the output layer, respectively.
Hence, we have a chain of values
${\ldots, (x_{t-1}, h_{t-1}, o_{t-1}), (x_{t}, h_{t}, o_t), \ldots}$
that depend on each other via recurrent computation.
The forward propagation is fairly straightforward.
All we need is to loop through the $(x_t, h_t, o_t)$ triples one time step at a time.
The discrepancy between output $o_t$ and the desired target $y_t$
is then evaluated by an objective function
across all the $T$ time steps as</p>
<p>$$L(x_1, \ldots, x_T, y_1, \ldots, y_T, w_\textrm{h}, w_\textrm{o}) = \frac{1}{T}\sum_{t=1}^T l(y_t, o_t).$$</p>
<p>For backpropagation, matters are a bit trickier,
especially when we compute the gradients
with regard to the parameters $w_\textrm{h}$ of the objective function $L$.
To be specific, by the chain rule,</p>
<p>$$\begin{aligned}\frac{\partial L}{\partial w_\textrm{h}}  &amp; = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial w_\textrm{h}}  \&amp; = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial o_t} \frac{\partial g(h_t, w_\textrm{o})}{\partial h_t}  \frac{\partial h_t}{\partial w_\textrm{h}}.\end{aligned}$$
:eqlabel:<code>eq_bptt_partial_L_wh</code></p>
<p>The first and the second factors of the
product in :eqref:<code>eq_bptt_partial_L_wh</code>
are easy to compute.
The third factor $\partial h_t/\partial w_\textrm{h}$ is where things get tricky,
since we need to recurrently compute the effect of the parameter $w_\textrm{h}$ on $h_t$.
According to the recurrent computation
in :eqref:<code>eq_bptt_ht_ot</code>,
$h_t$ depends on both $h_{t-1}$ and $w_\textrm{h}$,
where computation of $h_{t-1}$
also depends on $w_\textrm{h}$.
Thus, evaluating the total derivate of $h_t$
with respect to $w_\textrm{h}$ using the chain rule yields</p>
<p>$$\frac{\partial h_t}{\partial w_\textrm{h}}= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}} +\frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_\textrm{h}}.$$
:eqlabel:<code>eq_bptt_partial_ht_wh_recur</code></p>
<p>To derive the above gradient, assume that we have
three sequences ${a_{t}},{b_{t}},{c_{t}}$
satisfying $a_{0}=0$ and $a_{t}=b_{t}+c_{t}a_{t-1}$ for $t=1, 2,\ldots$.
Then for $t\geq 1$, it is easy to show</p>
<p>$$a_{t}=b_{t}+\sum_{i=1}^{t-1}\left(\prod_{j=i+1}^{t}c_{j}\right)b_{i}.$$
:eqlabel:<code>eq_bptt_at</code></p>
<p>By substituting $a_t$, $b_t$, and $c_t$ according to</p>
<p>$$\begin{aligned}a_t &amp;= \frac{\partial h_t}{\partial w_\textrm{h}},\
b_t &amp;= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}}, \
c_t &amp;= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}},\end{aligned}$$</p>
<p>the gradient computation in :eqref:<code>eq_bptt_partial_ht_wh_recur</code> satisfies
$a_{t}=b_{t}+c_{t}a_{t-1}$.
Thus, per :eqref:<code>eq_bptt_at</code>,
we can remove the recurrent computation
in :eqref:<code>eq_bptt_partial_ht_wh_recur</code> with</p>
<p>$$\frac{\partial h_t}{\partial w_\textrm{h}}=\frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}}+\sum_{i=1}^{t-1}\left(\prod_{j=i+1}^{t} \frac{\partial f(x_{j},h_{j-1},w_\textrm{h})}{\partial h_{j-1}} \right) \frac{\partial f(x_{i},h_{i-1},w_\textrm{h})}{\partial w_\textrm{h}}.$$
:eqlabel:<code>eq_bptt_partial_ht_wh_gen</code></p>
<p>While we can use the chain rule to compute $\partial h_t/\partial w_\textrm{h}$ recursively,
this chain can get very long whenever $t$ is large.
Let's discuss a number of strategies for dealing with this problem.</p>
<h3 id="full-computation"><a class="header" href="#full-computation">Full Computation</a></h3>
<p>One idea might be to compute the full sum in :eqref:<code>eq_bptt_partial_ht_wh_gen</code>.
However, this is very slow and gradients can blow up,
since subtle changes in the initial conditions
can potentially affect the outcome a lot.
That is, we could see things similar to the butterfly effect,
where minimal changes in the initial conditions
lead to disproportionate changes in the outcome.
This is generally undesirable.
After all, we are looking for robust estimators that generalize well.
Hence this strategy is almost never used in practice.</p>
<h3 id="truncating-time-steps"><a class="header" href="#truncating-time-steps">Truncating Time Steps###</a></h3>
<p>Alternatively,
we can truncate the sum in
:eqref:<code>eq_bptt_partial_ht_wh_gen</code>
after $\tau$ steps.
This is what we have been discussing so far.
This leads to an <em>approximation</em> of the true gradient,
simply by terminating the sum at $\partial h_{t-\tau}/\partial w_\textrm{h}$.
In practice this works quite well.
It is what is commonly referred to as truncated
backpropgation through time :cite:<code>Jaeger.2002</code>.
One of the consequences of this is that the model
focuses primarily on short-term influence
rather than long-term consequences.
This is actually <em>desirable</em>, since it biases the estimate
towards simpler and more stable models.</p>
<h3 id="randomized-truncation"><a class="header" href="#randomized-truncation">Randomized Truncation</a></h3>
<p>Last, we can replace $\partial h_t/\partial w_\textrm{h}$
by a random variable which is correct in expectation
but truncates the sequence.
This is achieved by using a sequence of $\xi_t$
with predefined $0 \leq \pi_t \leq 1$,
where $P(\xi_t = 0) = 1-\pi_t$ and
$P(\xi_t = \pi_t^{-1}) = \pi_t$, thus $E[\xi_t] = 1$.
We use this to replace the gradient
$\partial h_t/\partial w_\textrm{h}$
in :eqref:<code>eq_bptt_partial_ht_wh_recur</code>
with</p>
<p>$$z_t= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}} +\xi_t \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_\textrm{h}}.$$</p>
<p>It follows from the definition of $\xi_t$
that $E[z_t] = \partial h_t/\partial w_\textrm{h}$.
Whenever $\xi_t = 0$ the recurrent computation
terminates at that time step $t$.
This leads to a weighted sum of sequences of varying lengths,
where long sequences are rare but appropriately overweighted.
This idea was proposed by
:citet:<code>Tallec.Ollivier.2017</code>.</p>
<h3 id="comparing-strategies"><a class="header" href="#comparing-strategies">Comparing Strategies</a></h3>
<p><img src="chapter_recurrent-neural-networks/../img/truncated-bptt.svg" alt="Comparing strategies for computing gradients in RNNs. From top to bottom: randomized truncation, regular truncation, and full computation." />
:label:<code>fig_truncated_bptt</code></p>
<p>:numref:<code>fig_truncated_bptt</code> illustrates the three strategies
when analyzing the first few characters of <em>The Time Machine</em>
using backpropagation through time for RNNs:</p>
<ul>
<li>The first row is the randomized truncation that partitions the text into segments of varying lengths.</li>
<li>The second row is the regular truncation that breaks the text into subsequences of the same length. This is what we have been doing in RNN experiments.</li>
<li>The third row is the full backpropagation through time that leads to a computationally infeasible expression.</li>
</ul>
<p>Unfortunately, while appealing in theory,
randomized truncation does not work
much better than regular truncation,
most likely due to a number of factors.
First, the effect of an observation
after a number of backpropagation steps
into the past is quite sufficient
to capture dependencies in practice.
Second, the increased variance counteracts the fact
that the gradient is more accurate with more steps.
Third, we actually <em>want</em> models that have only
a short range of interactions.
Hence, regularly truncated backpropagation through time
has a slight regularizing effect that can be desirable.</p>
<h2 id="backpropagation-through-time-in-detail"><a class="header" href="#backpropagation-through-time-in-detail">Backpropagation Through Time in Detail</a></h2>
<p>After discussing the general principle,
let's discuss backpropagation through time in detail.
In contrast to the analysis in :numref:<code>subsec_bptt_analysis</code>,
in the following we will show how to compute
the gradients of the objective function
with respect to all the decomposed model parameters.
To keep things simple, we consider
an RNN without bias parameters,
whose activation function in the hidden layer
uses the identity mapping ($\phi(x)=x$).
For time step $t$, let the single example input
and the target be $\mathbf{x}_t \in \mathbb{R}^d$ and $y_t$, respectively.
The hidden state $\mathbf{h}_t \in \mathbb{R}^h$
and the output $\mathbf{o}_t \in \mathbb{R}^q$
are computed as</p>
<p>$$\begin{aligned}\mathbf{h}<em>t &amp;= \mathbf{W}</em>\textrm{hx} \mathbf{x}<em>t + \mathbf{W}</em>\textrm{hh} \mathbf{h}<em>{t-1},\
\mathbf{o}<em>t &amp;= \mathbf{W}</em>\textrm{qh} \mathbf{h}</em>{t},\end{aligned}$$</p>
<p>where $\mathbf{W}<em>\textrm{hx} \in \mathbb{R}^{h \times d}$, $\mathbf{W}</em>\textrm{hh} \in \mathbb{R}^{h \times h}$, and
$\mathbf{W}_\textrm{qh} \in \mathbb{R}^{q \times h}$
are the weight parameters.
Denote by $l(\mathbf{o}_t, y_t)$
the loss at time step $t$.
Our objective function,
the loss over $T$ time steps
from the beginning of the sequence is thus</p>
<p>$$L = \frac{1}{T} \sum_{t=1}^T l(\mathbf{o}_t, y_t).$$</p>
<p>In order to visualize the dependencies among
model variables and parameters during computation
of the RNN,
we can draw a computational graph for the model,
as shown in :numref:<code>fig_rnn_bptt</code>.
For example, the computation of the hidden states of time step 3,
$\mathbf{h}<em>3$, depends on the model parameters
$\mathbf{W}</em>\textrm{hx}$ and $\mathbf{W}_\textrm{hh}$,
the hidden state of the previous time step $\mathbf{h}_2$,
and the input of the current time step $\mathbf{x}_3$.</p>
<p><img src="chapter_recurrent-neural-networks/../img/rnn-bptt.svg" alt="Computational graph showing dependencies for an RNN model with three time steps. Boxes represent variables (not shaded) or parameters (shaded) and circles represent operators." />
:label:<code>fig_rnn_bptt</code></p>
<p>As just mentioned, the model parameters in :numref:<code>fig_rnn_bptt</code>
are $\mathbf{W}<em>\textrm{hx}$, $\mathbf{W}</em>\textrm{hh}$, and $\mathbf{W}<em>\textrm{qh}$.
Generally, training this model requires
gradient computation with respect to these parameters
$\partial L/\partial \mathbf{W}</em>\textrm{hx}$, $\partial L/\partial \mathbf{W}<em>\textrm{hh}$, and $\partial L/\partial \mathbf{W}</em>\textrm{qh}$.
According to the dependencies in :numref:<code>fig_rnn_bptt</code>,
we can traverse in the opposite direction of the arrows
to calculate and store the gradients in turn.
To flexibly express the multiplication of
matrices, vectors, and scalars of different shapes
in the chain rule,
we continue to use the $\textrm{prod}$ operator
as described in :numref:<code>sec_backprop</code>.</p>
<p>First of all, differentiating the objective function
with respect to the model output at any time step $t$
is fairly straightforward:</p>
<p>$$\frac{\partial L}{\partial \mathbf{o}_t} =  \frac{\partial l (\mathbf{o}_t, y_t)}{T \cdot \partial \mathbf{o}_t} \in \mathbb{R}^q.$$
:eqlabel:<code>eq_bptt_partial_L_ot</code></p>
<p>Now we can calculate the gradient of the objective
with respect to the parameter $\mathbf{W}<em>\textrm{qh}$
in the output layer:
$\partial L/\partial \mathbf{W}</em>\textrm{qh} \in \mathbb{R}^{q \times h}$.
Based on :numref:<code>fig_rnn_bptt</code>,
the objective $L$ depends on $\mathbf{W}_\textrm{qh}$
via $\mathbf{o}_1, \ldots, \mathbf{o}_T$.
Using the chain rule yields</p>
<p>$$
\frac{\partial L}{\partial \mathbf{W}<em>\textrm{qh}}
= \sum</em>{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}<em>t}, \frac{\partial \mathbf{o}<em>t}{\partial \mathbf{W}</em>\textrm{qh}}\right)
= \sum</em>{t=1}^T \frac{\partial L}{\partial \mathbf{o}_t} \mathbf{h}_t^\top,
$$</p>
<p>where $\partial L/\partial \mathbf{o}_t$
is given by :eqref:<code>eq_bptt_partial_L_ot</code>.</p>
<p>Next, as shown in :numref:<code>fig_rnn_bptt</code>,
at the final time step $T$,
the objective function
$L$ depends on the hidden state $\mathbf{h}_T$
only via $\mathbf{o}_T$.
Therefore, we can easily find the gradient
$\partial L/\partial \mathbf{h}_T \in \mathbb{R}^h$
using the chain rule:</p>
<p>$$\frac{\partial L}{\partial \mathbf{h}_T} = \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}_T}, \frac{\partial \mathbf{o}_T}{\partial \mathbf{h}<em>T} \right) = \mathbf{W}</em>\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_T}.$$
:eqlabel:<code>eq_bptt_partial_L_hT_final_step</code></p>
<p>It gets trickier for any time step $t &lt; T$,
where the objective function $L$ depends on
$\mathbf{h}<em>t$ via $\mathbf{h}</em>{t+1}$ and $\mathbf{o}_t$.
According to the chain rule,
the gradient of the hidden state
$\partial L/\partial \mathbf{h}_t \in \mathbb{R}^h$
at any time step $t &lt; T$ can be recurrently computed as:</p>
<p>$$\frac{\partial L}{\partial \mathbf{h}<em>t} = \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}</em>{t+1}}, \frac{\partial \mathbf{h}_{t+1}}{\partial \mathbf{h}_t} \right) + \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}<em>t}, \frac{\partial \mathbf{o}<em>t}{\partial \mathbf{h}<em>t} \right) = \mathbf{W}</em>\textrm{hh}^\top \frac{\partial L}{\partial \mathbf{h}</em>{t+1}} + \mathbf{W}</em>\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_t}.$$
:eqlabel:<code>eq_bptt_partial_L_ht_recur</code></p>
<p>For analysis, expanding the recurrent computation
for any time step $1 \leq t \leq T$ gives</p>
<p>$$\frac{\partial L}{\partial \mathbf{h}<em>t}= \sum</em>{i=t}^T {\left(\mathbf{W}<em>\textrm{hh}^\top\right)}^{T-i} \mathbf{W}</em>\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_{T+t-i}}.$$
:eqlabel:<code>eq_bptt_partial_L_ht</code></p>
<p>We can see from :eqref:<code>eq_bptt_partial_L_ht</code>
that this simple linear example already
exhibits some key problems of long sequence models:
it involves potentially very large powers of $\mathbf{W}_\textrm{hh}^\top$.
In it, eigenvalues smaller than 1 vanish
and eigenvalues larger than 1 diverge.
This is numerically unstable,
which manifests itself in the form of vanishing
and exploding gradients.
One way to address this is to truncate the time steps
at a computationally convenient size
as discussed in :numref:<code>subsec_bptt_analysis</code>.
In practice, this truncation can also be effected
by detaching the gradient after a given number of time steps.
Later on, we will see how more sophisticated sequence models
such as long short-term memory can alleviate this further.</p>
<p>Finally, :numref:<code>fig_rnn_bptt</code> shows
that the objective function $L$
depends on model parameters $\mathbf{W}<em>\textrm{hx}$ and $\mathbf{W}</em>\textrm{hh}$
in the hidden layer via hidden states
$\mathbf{h}<em>1, \ldots, \mathbf{h}<em>T$.
To compute gradients with respect to such parameters
$\partial L / \partial \mathbf{W}</em>\textrm{hx} \in \mathbb{R}^{h \times d}$ and $\partial L / \partial \mathbf{W}</em>\textrm{hh} \in \mathbb{R}^{h \times h}$,
we apply the chain rule giving</p>
<p>$$
\begin{aligned}
\frac{\partial L}{\partial \mathbf{W}<em>\textrm{hx}}
&amp;= \sum</em>{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}<em>t}, \frac{\partial \mathbf{h}<em>t}{\partial \mathbf{W}</em>\textrm{hx}}\right)
= \sum</em>{t=1}^T \frac{\partial L}{\partial \mathbf{h}<em>t} \mathbf{x}<em>t^\top,\
\frac{\partial L}{\partial \mathbf{W}</em>\textrm{hh}}
&amp;= \sum</em>{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}<em>t}, \frac{\partial \mathbf{h}<em>t}{\partial \mathbf{W}</em>\textrm{hh}}\right)
= \sum</em>{t=1}^T \frac{\partial L}{\partial \mathbf{h}<em>t} \mathbf{h}</em>{t-1}^\top,
\end{aligned}
$$</p>
<p>where $\partial L/\partial \mathbf{h}_t$
which is recurrently computed by
:eqref:<code>eq_bptt_partial_L_hT_final_step</code>
and :eqref:<code>eq_bptt_partial_L_ht_recur</code>
is the key quantity that affects the numerical stability.</p>
<p>Since backpropagation through time is the application of backpropagation in RNNs,
as we have explained in :numref:<code>sec_backprop</code>,
training RNNs alternates forward propagation with
backpropagation through time.
Moreover, backpropagation through time
computes and stores the above gradients in turn.
Specifically, stored intermediate values
are reused to avoid duplicate calculations,
such as storing $\partial L/\partial \mathbf{h}<em>t$
to be used in computation of both $\partial L / \partial \mathbf{W}</em>\textrm{hx}$
and $\partial L / \partial \mathbf{W}_\textrm{hh}$.</p>
<h2 id="summary-38"><a class="header" href="#summary-38">Summary</a></h2>
<p>Backpropagation through time is merely an application of backpropagation to sequence models with a hidden state.
Truncation, such as regular or randomized, is needed for computational convenience and numerical stability.
High powers of matrices can lead to divergent or vanishing eigenvalues. This manifests itself in the form of exploding or vanishing gradients.
For efficient computation, intermediate values are cached during backpropagation through time.</p>
<h2 id="exercises-56"><a class="header" href="#exercises-56">Exercises</a></h2>
<ol>
<li>Assume that we have a symmetric matrix $\mathbf{M} \in \mathbb{R}^{n \times n}$ with eigenvalues $\lambda_i$ whose corresponding eigenvectors are $\mathbf{v}<em>i$ ($i = 1, \ldots, n$). Without loss of generality, assume that they are ordered in the order $|\lambda_i| \geq |\lambda</em>{i+1}|$.
<ol>
<li>Show that $\mathbf{M}^k$ has eigenvalues $\lambda_i^k$.</li>
<li>Prove that for a random vector $\mathbf{x} \in \mathbb{R}^n$, with high probability $\mathbf{M}^k \mathbf{x}$ will be very much aligned with the eigenvector $\mathbf{v}_1$
of $\mathbf{M}$. Formalize this statement.</li>
<li>What does the above result mean for gradients in RNNs?</li>
</ol>
</li>
<li>Besides gradient clipping, can you think of any other methods to cope with gradient explosion in recurrent neural networks?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/334">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-recurrent-neural-networks"><a class="header" href="#modern-recurrent-neural-networks">Modern Recurrent Neural Networks</a></h1>
<p>:label:<code>chap_modern_rnn</code></p>
<p>The previous chapter introduced the key ideas
behind recurrent neural networks (RNNs).
However, just as with convolutional neural networks,
there has been a tremendous amount of innovation
in RNN architectures, culminating in several complex
designs that have proven successful in practice.
In particular, the most popular designs
feature mechanisms for mitigating the notorious
numerical instability faced by RNNs,
as typified by vanishing and exploding gradients.
Recall that in :numref:<code>chap_rnn</code> we dealt
with exploding gradients by applying a blunt
gradient clipping heuristic.
Despite the efficacy of this hack,
it leaves open the problem of vanishing gradients.</p>
<p>In this chapter, we introduce the key ideas behind
the most successful RNN architectures for sequences,
which stem from two papers.
The first, <em>Long Short-Term Memory</em> :cite:<code>Hochreiter.Schmidhuber.1997</code>,
introduces the <em>memory cell</em>, a unit of computation that replaces
traditional nodes in the hidden layer of a network.
With these memory cells, networks are able
to overcome difficulties with training
encountered by earlier recurrent networks.
Intuitively, the memory cell avoids
the vanishing gradient problem
by keeping values in each memory cell's internal state
cascading along a recurrent edge with weight 1
across many successive time steps.
A set of multiplicative gates help the network
to determine not only the inputs to allow
into the memory state,
but when the content of the memory state
should influence the model's output.</p>
<p>The second paper, <em>Bidirectional Recurrent Neural Networks</em> :cite:<code>Schuster.Paliwal.1997</code>,
introduces an architecture in which information
from both the future (subsequent time steps)
and the past (preceding time steps)
are used to determine the output
at any point in the sequence.
This is in contrast to previous networks,
in which only past input can affect the output.
Bidirectional RNNs have become a mainstay
for sequence labeling tasks in natural language processing,
among a myriad of other tasks.
Fortunately, the two innovations are not mutually exclusive,
and have been successfully combined for phoneme classification
:cite:<code>Graves.Schmidhuber.2005</code> and handwriting recognition :cite:<code>graves2008novel</code>.</p>
<p>The first sections in this chapter will explain the LSTM architecture,
a lighter-weight version called the gated recurrent unit (GRU),
the key ideas behind bidirectional RNNs
and a brief explanation of how RNN layers
are stacked together to form deep RNNs.
Subsequently, we will explore the application of RNNs
in sequence-to-sequence tasks,
introducing machine translation
along with key ideas such as <em>encoder--decoder</em> architectures and <em>beam search</em>.</p>
<pre><code class="language-toc">:maxdepth: 2

lstm
gru
deep-rnn
bi-rnn
machine-translation-and-dataset
encoder-decoder
seq2seq
beam-search
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="long-short-term-memory-lstm"><a class="header" href="#long-short-term-memory-lstm">Long Short-Term Memory (LSTM)</a></h1>
<p>:label:<code>sec_lstm</code></p>
<p>Shortly after the first Elman-style RNNs were trained using backpropagation
:cite:<code>elman1990finding</code>, the problems of learning long-term dependencies
(owing to vanishing and exploding gradients)
became salient, with Bengio and Hochreiter
discussing the problem
:cite:<code>bengio1994learning,Hochreiter.Bengio.Frasconi.ea.2001</code>.
Hochreiter had articulated this problem as early
as 1991 in his Master's thesis, although the results
were not widely known because the thesis was written in German.
While gradient clipping helps with exploding gradients,
handling vanishing gradients appears
to require a more elaborate solution.
One of the first and most successful techniques
for addressing vanishing gradients
came in the form of the long short-term memory (LSTM) model
due to :citet:<code>Hochreiter.Schmidhuber.1997</code>.
LSTMs resemble standard recurrent neural networks
but here each ordinary recurrent node
is replaced by a <em>memory cell</em>.
Each memory cell contains an <em>internal state</em>,
i.e., a node with a self-connected recurrent edge of fixed weight 1,
ensuring that the gradient can pass across many time steps
without vanishing or exploding.</p>
<p>The term "long short-term memory" comes from the following intuition.
Simple recurrent neural networks
have <em>long-term memory</em> in the form of weights.
The weights change slowly during training,
encoding general knowledge about the data.
They also have <em>short-term memory</em>
in the form of ephemeral activations,
which pass from each node to successive nodes.
The LSTM model introduces an intermediate type of storage via the memory cell.
A memory cell is a composite unit,
built from simpler nodes
in a specific connectivity pattern,
with the novel inclusion of multiplicative nodes.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="gated-memory-cell"><a class="header" href="#gated-memory-cell">Gated Memory Cell</a></h2>
<p>Each memory cell is equipped with an <em>internal state</em>
and a number of multiplicative gates that determine whether
(i) a given input should impact the internal state (the <em>input gate</em>),
(ii) the internal state should be flushed to $0$ (the <em>forget gate</em>),
and (iii) the internal state of a given neuron
should be allowed to impact the cell's output (the <em>output</em> gate).</p>
<h3 id="gated-hidden-state"><a class="header" href="#gated-hidden-state">Gated Hidden State</a></h3>
<p>The key distinction between vanilla RNNs and LSTMs
is that the latter support gating of the hidden state.
This means that we have dedicated mechanisms for
when a hidden state should be <em>updated</em> and
also for when it should be <em>reset</em>.
These mechanisms are learned and they address the concerns listed above.
For instance, if the first token is of great importance
we will learn not to update the hidden state after the first observation.
Likewise, we will learn to skip irrelevant temporary observations.
Last, we will learn to reset the latent state whenever needed.
We discuss this in detail below.</p>
<h3 id="input-gate-forget-gate-and-output-gate"><a class="header" href="#input-gate-forget-gate-and-output-gate">Input Gate, Forget Gate, and Output Gate</a></h3>
<p>The data feeding into the LSTM gates are
the input at the current time step and
the hidden state of the previous time step,
as illustrated in :numref:<code>fig_lstm_0</code>.
Three fully connected layers with sigmoid activation functions
compute the values of the input, forget, and output gates.
As a result of the sigmoid activation,
all values of the three gates
are in the range of $(0, 1)$.
Additionally, we require an <em>input node</em>,
typically computed with a <em>tanh</em> activation function.
Intuitively, the <em>input gate</em> determines how much
of the input node's value should be added
to the current memory cell internal state.
The <em>forget gate</em> determines whether to keep
the current value of the memory or flush it.
And the <em>output gate</em> determines whether
the memory cell should influence the output
at the current time step.</p>
<p><img src="chapter_recurrent-modern/../img/lstm-0.svg" alt="Computing the input gate, the forget gate, and the output gate in an LSTM model." />
:label:<code>fig_lstm_0</code></p>
<p>Mathematically, suppose that there are $h$ hidden units,
the batch size is $n$, and the number of inputs is $d$.
Thus, the input is $\mathbf{X}<em>t \in \mathbb{R}^{n \times d}$
and the hidden state of the previous time step
is $\mathbf{H}</em>{t-1} \in \mathbb{R}^{n \times h}$.
Correspondingly, the gates at time step $t$
are defined as follows: the input gate is $\mathbf{I}_t \in \mathbb{R}^{n \times h}$,
the forget gate is $\mathbf{F}_t \in \mathbb{R}^{n \times h}$,
and the output gate is $\mathbf{O}_t \in \mathbb{R}^{n \times h}$.
They are calculated as follows:</p>
<p>$$
\begin{aligned}
\mathbf{I}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xi}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hi}} + \mathbf{b}</em>\textrm{i}),\
\mathbf{F}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xf}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hf}} + \mathbf{b}</em>\textrm{f}),\
\mathbf{O}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xo}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{ho}} + \mathbf{b}</em>\textrm{o}),
\end{aligned}
$$</p>
<p>where $\mathbf{W}<em>{\textrm{xi}}, \mathbf{W}</em>{\textrm{xf}}, \mathbf{W}<em>{\textrm{xo}} \in \mathbb{R}^{d \times h}$ and $\mathbf{W}</em>{\textrm{hi}}, \mathbf{W}<em>{\textrm{hf}}, \mathbf{W}</em>{\textrm{ho}} \in \mathbb{R}^{h \times h}$ are weight parameters
and $\mathbf{b}<em>\textrm{i}, \mathbf{b}</em>\textrm{f}, \mathbf{b}_\textrm{o} \in \mathbb{R}^{1 \times h}$ are bias parameters.
Note that broadcasting
(see :numref:<code>subsec_broadcasting</code>)
is triggered during the summation.
We use sigmoid functions
(as introduced in :numref:<code>sec_mlp</code>)
to map the input values to the interval $(0, 1)$.</p>
<h3 id="input-node"><a class="header" href="#input-node">Input Node</a></h3>
<p>Next we design the memory cell.
Since we have not specified the action of the various gates yet,
we first introduce the <em>input node</em>
$\tilde{\mathbf{C}}_t \in \mathbb{R}^{n \times h}$.
Its computation is similar to that of the three gates described above,
but uses a $\tanh$ function with a value range for $(-1, 1)$ as the activation function.
This leads to the following equation at time step $t$:</p>
<p>$$\tilde{\mathbf{C}}<em>t = \textrm{tanh}(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xc}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hc}} + \mathbf{b}</em>\textrm{c}),$$</p>
<p>where $\mathbf{W}<em>{\textrm{xc}} \in \mathbb{R}^{d \times h}$ and $\mathbf{W}</em>{\textrm{hc}} \in \mathbb{R}^{h \times h}$ are weight parameters and $\mathbf{b}_\textrm{c} \in \mathbb{R}^{1 \times h}$ is a bias parameter.</p>
<p>A quick illustration of the input node is shown in :numref:<code>fig_lstm_1</code>.</p>
<p><img src="chapter_recurrent-modern/../img/lstm-1.svg" alt="Computing the input node in an LSTM model." />
:label:<code>fig_lstm_1</code></p>
<h3 id="memory-cell-internal-state"><a class="header" href="#memory-cell-internal-state">Memory Cell Internal State</a></h3>
<p>In LSTMs, the input gate $\mathbf{I}_t$ governs
how much we take new data into account via $\tilde{\mathbf{C}}_t$
and the forget gate $\mathbf{F}<em>t$ addresses
how much of the old cell internal state $\mathbf{C}</em>{t-1} \in \mathbb{R}^{n \times h}$ we retain.
Using the Hadamard (elementwise) product operator $\odot$
we arrive at the following update equation:</p>
<p>$$\mathbf{C}_t = \mathbf{F}<em>t \odot \mathbf{C}</em>{t-1} + \mathbf{I}_t \odot \tilde{\mathbf{C}}_t.$$</p>
<p>If the forget gate is always 1 and the input gate is always 0,
the memory cell internal state $\mathbf{C}_{t-1}$
will remain constant forever,
passing unchanged to each subsequent time step.
However, input gates and forget gates
give the model the flexibility of being able to learn
when to keep this value unchanged
and when to perturb it in response
to subsequent inputs.
In practice, this design alleviates the vanishing gradient problem,
resulting in models that are much easier to train,
especially when facing datasets with long sequence lengths.</p>
<p>We thus arrive at the flow diagram in :numref:<code>fig_lstm_2</code>.</p>
<p><img src="chapter_recurrent-modern/../img/lstm-2.svg" alt="Computing the memory cell internal state in an LSTM model." /></p>
<p>:label:<code>fig_lstm_2</code></p>
<h3 id="hidden-state"><a class="header" href="#hidden-state">Hidden State</a></h3>
<p>Last, we need to define how to compute the output
of the memory cell, i.e., the hidden state $\mathbf{H}_t \in \mathbb{R}^{n \times h}$, as seen by other layers.
This is where the output gate comes into play.
In LSTMs, we first apply $\tanh$ to the memory cell internal state
and then apply another point-wise multiplication,
this time with the output gate.
This ensures that the values of $\mathbf{H}_t$
are always in the interval $(-1, 1)$:</p>
<p>$$\mathbf{H}_t = \mathbf{O}_t \odot \tanh(\mathbf{C}_t).$$</p>
<p>Whenever the output gate is close to 1,
we allow the memory cell internal state to impact the subsequent layers uninhibited,
whereas for output gate values close to 0,
we prevent the current memory from impacting other layers of the network
at the current time step.
Note that a memory cell can accrue information
across many time steps without impacting the rest of the network
(as long as the output gate takes values close to 0),
and then suddenly impact the network at a subsequent time step
as soon as the output gate flips from values close to 0
to values close to 1. :numref:<code>fig_lstm_3</code> has a graphical illustration of the data flow.</p>
<p><img src="chapter_recurrent-modern/../img/lstm-3.svg" alt="Computing the hidden state in an LSTM model." />
:label:<code>fig_lstm_3</code></p>
<h2 id="implementation-from-scratch-4"><a class="header" href="#implementation-from-scratch-4">Implementation from Scratch</a></h2>
<p>Now let's implement an LSTM from scratch.
As same as the experiments in :numref:<code>sec_rnn-scratch</code>,
we first load <em>The Time Machine</em> dataset.</p>
<h3 id="initializing-model-parameters-1"><a class="header" href="#initializing-model-parameters-1">[<strong>Initializing Model Parameters</strong>]</a></h3>
<p>Next, we need to define and initialize the model parameters.
As previously, the hyperparameter <code>num_hiddens</code>
dictates the number of hidden units.
We initialize weights following a Gaussian distribution
with 0.01 standard deviation,
and we set the biases to 0.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class LSTMScratch(d2l.Module):
    def __init__(self, num_inputs, num_hiddens, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()

        if tab.selected('mxnet'):
            init_weight = lambda *shape: d2l.randn(*shape) * sigma
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              d2l.zeros(num_hiddens))
        if tab.selected('pytorch'):
            init_weight = lambda *shape: nn.Parameter(d2l.randn(*shape) * sigma)
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              nn.Parameter(d2l.zeros(num_hiddens)))
        if tab.selected('tensorflow'):
            init_weight = lambda *shape: tf.Variable(d2l.normal(shape) * sigma)
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              tf.Variable(d2l.zeros(num_hiddens)))

        self.W_xi, self.W_hi, self.b_i = triple()  # Input gate
        self.W_xf, self.W_hf, self.b_f = triple()  # Forget gate
        self.W_xo, self.W_ho, self.b_o = triple()  # Output gate
        self.W_xc, self.W_hc, self.b_c = triple()  # Input node
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class LSTMScratch(d2l.Module):
    num_inputs: int
    num_hiddens: int
    sigma: float = 0.01

    def setup(self):
        init_weight = lambda name, shape: self.param(name,
                                                     nn.initializers.normal(self.sigma),
                                                     shape)
        triple = lambda name : (
            init_weight(f'W_x{name}', (self.num_inputs, self.num_hiddens)),
            init_weight(f'W_h{name}', (self.num_hiddens, self.num_hiddens)),
            self.param(f'b_{name}', nn.initializers.zeros, (self.num_hiddens)))

        self.W_xi, self.W_hi, self.b_i = triple('i')  # Input gate
        self.W_xf, self.W_hf, self.b_f = triple('f')  # Forget gate
        self.W_xo, self.W_ho, self.b_o = triple('o')  # Output gate
        self.W_xc, self.W_hc, self.b_c = triple('c')  # Input node
</code></pre>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
[<strong>The actual model</strong>] is defined as described above,
consisting of three gates and an input node.
Note that only the hidden state is passed to the output layer.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
[<strong>The actual model</strong>] is defined as described above,
consisting of three gates and an input node.
Note that only the hidden state is passed to the output layer.
A long for-loop in the <code>forward</code> method will result in an extremely long
JIT compilation time for the first run. As a solution to this, instead
of using a for-loop to update the state with every time step,
JAX has <code>jax.lax.scan</code> utility transformation to achieve the same behavior.
It takes in an initial state called <code>carry</code> and an <code>inputs</code> array which
is scanned on its leading axis. The <code>scan</code> transformation ultimately
returns the final state and the stacked outputs as expected.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(LSTMScratch)
def forward(self, inputs, H_C=None):
    if H_C is None:
        # Initial state with shape: (batch_size, num_hiddens)
        if tab.selected('mxnet'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          ctx=inputs.ctx)
            C = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          ctx=inputs.ctx)
        if tab.selected('pytorch'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          device=inputs.device)
            C = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          device=inputs.device)
        if tab.selected('tensorflow'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens))
            C = d2l.zeros((inputs.shape[1], self.num_hiddens))
    else:
        H, C = H_C
    outputs = []
    for X in inputs:
        I = d2l.sigmoid(d2l.matmul(X, self.W_xi) +
                        d2l.matmul(H, self.W_hi) + self.b_i)
        F = d2l.sigmoid(d2l.matmul(X, self.W_xf) +
                        d2l.matmul(H, self.W_hf) + self.b_f)
        O = d2l.sigmoid(d2l.matmul(X, self.W_xo) +
                        d2l.matmul(H, self.W_ho) + self.b_o)
        C_tilde = d2l.tanh(d2l.matmul(X, self.W_xc) +
                           d2l.matmul(H, self.W_hc) + self.b_c)
        C = F * C + I * C_tilde
        H = O * d2l.tanh(C)
        outputs.append(H)
    return outputs, (H, C)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(LSTMScratch)
def forward(self, inputs, H_C=None):
    # Use lax.scan primitive instead of looping over the
    # inputs, since scan saves time in jit compilation.
    def scan_fn(carry, X):
        H, C = carry
        I = d2l.sigmoid(d2l.matmul(X, self.W_xi) + (
            d2l.matmul(H, self.W_hi)) + self.b_i)
        F = d2l.sigmoid(d2l.matmul(X, self.W_xf) +
                        d2l.matmul(H, self.W_hf) + self.b_f)
        O = d2l.sigmoid(d2l.matmul(X, self.W_xo) +
                        d2l.matmul(H, self.W_ho) + self.b_o)
        C_tilde = d2l.tanh(d2l.matmul(X, self.W_xc) +
                           d2l.matmul(H, self.W_hc) + self.b_c)
        C = F * C + I * C_tilde
        H = O * d2l.tanh(C)
        return (H, C), H  # return carry, y

    if H_C is None:
        batch_size = inputs.shape[1]
        carry = jnp.zeros((batch_size, self.num_hiddens)), \
                jnp.zeros((batch_size, self.num_hiddens))
    else:
        carry = H_C

    # scan takes the scan_fn, initial carry state, xs with leading axis to be scanned
    carry, outputs = jax.lax.scan(scan_fn, carry, inputs)
    return outputs, carry
</code></pre>
<h3 id="training-and-prediction"><a class="header" href="#training-and-prediction">[<strong>Training</strong>] and Prediction</a></h3>
<p>Let's train an LSTM model by instantiating the <code>RNNLMScratch</code> class from :numref:<code>sec_rnn-scratch</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.TimeMachine(batch_size=1024, num_steps=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    lstm = LSTMScratch(num_inputs=len(data.vocab), num_hiddens=32)
    model = d2l.RNNLMScratch(lstm, vocab_size=len(data.vocab), lr=4)
    trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        lstm = LSTMScratch(num_inputs=len(data.vocab), num_hiddens=32)
        model = d2l.RNNLMScratch(lstm, vocab_size=len(data.vocab), lr=4)
    trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<h2 id="concise-implementation-4"><a class="header" href="#concise-implementation-4">[<strong>Concise Implementation</strong>]</a></h2>
<p>Using high-level APIs,
we can directly instantiate an LSTM model.
This encapsulates all the configuration details
that we made explicit above.
The code is significantly faster as it uses
compiled operators rather than Python
for many details that we spelled out before.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class LSTM(d2l.RNN):
    def __init__(self, num_hiddens):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        self.rnn = rnn.LSTM(num_hiddens)

    def forward(self, inputs, H_C=None):
        if H_C is None: H_C = self.rnn.begin_state(
            inputs.shape[1], ctx=inputs.ctx)
        return self.rnn(inputs, H_C)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class LSTM(d2l.RNN):
    def __init__(self, num_inputs, num_hiddens):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        self.rnn = nn.LSTM(num_inputs, num_hiddens)

    def forward(self, inputs, H_C=None):
        return self.rnn(inputs, H_C)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class LSTM(d2l.RNN):
    def __init__(self, num_hiddens):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        self.rnn = tf.keras.layers.LSTM(
                num_hiddens, return_sequences=True,
                return_state=True, time_major=True)

    def forward(self, inputs, H_C=None):
        outputs, *H_C = self.rnn(inputs, H_C)
        return outputs, H_C
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class LSTM(d2l.RNN):
    num_hiddens: int

    @nn.compact
    def __call__(self, inputs, H_C=None, training=False):
        if H_C is None:
            batch_size = inputs.shape[1]
            H_C = nn.OptimizedLSTMCell.initialize_carry(jax.random.PRNGKey(0),
                                                        (batch_size,),
                                                        self.num_hiddens)

        LSTM = nn.scan(nn.OptimizedLSTMCell, variable_broadcast="params",
                       in_axes=0, out_axes=0, split_rngs={"params": False})

        H_C, outputs = LSTM()(H_C, inputs)
        return outputs, H_C
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('pytorch'):
    lstm = LSTM(num_inputs=len(data.vocab), num_hiddens=32)
if tab.selected('mxnet', 'tensorflow', 'jax'):
    lstm = LSTM(num_hiddens=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    model = d2l.RNNLM(lstm, vocab_size=len(data.vocab), lr=4)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        model = d2l.RNNLM(lstm, vocab_size=len(data.vocab), lr=4)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
model.predict('it has', 20, data.vocab)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
model.predict('it has', 20, data.vocab, trainer.state.params)
</code></pre>
<p>LSTMs are the prototypical latent variable autoregressive model with nontrivial state control.
Many variants thereof have been proposed over the years, e.g., multiple layers, residual connections, different types of regularization. However, training LSTMs and other sequence models (such as GRUs) is quite costly because of the long range dependency of the sequence.
Later we will encounter alternative models such as Transformers that can be used in some cases.</p>
<h2 id="summary-39"><a class="header" href="#summary-39">Summary</a></h2>
<p>While LSTMs were published in 1997,
they rose to great prominence
with some victories in prediction competitions in the mid-2000s,
and became the dominant models for sequence learning from 2011
until the rise of Transformer models, starting in 2017.
Even Tranformers owe some of their key ideas
to architecture design innovations introduced by the LSTM.</p>
<p>LSTMs have three types of gates:
input gates, forget gates, and output gates
that control the flow of information.
The hidden layer output of LSTM includes the hidden state and the memory cell internal state.
Only the hidden state is passed into the output layer while
the memory cell internal state remains entirely internal.
LSTMs can alleviate vanishing and exploding gradients.</p>
<h2 id="exercises-57"><a class="header" href="#exercises-57">Exercises</a></h2>
<ol>
<li>Adjust the hyperparameters and analyze their influence on running time, perplexity, and the output sequence.</li>
<li>How would you need to change the model to generate proper words rather than just sequences of characters?</li>
<li>Compare the computational cost for GRUs, LSTMs, and regular RNNs for a given hidden dimension. Pay special attention to the training and inference cost.</li>
<li>Since the candidate memory cell ensures that the value range is between $-1$ and $1$ by  using the $\tanh$ function, why does the hidden state need to use the $\tanh$ function again to ensure that the output value range is between $-1$ and $1$?</li>
<li>Implement an LSTM model for time series prediction rather than character sequence prediction.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/343">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1057">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3861">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18016">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gated-recurrent-units-gru"><a class="header" href="#gated-recurrent-units-gru">Gated Recurrent Units (GRU)</a></h1>
<p>:label:<code>sec_gru</code></p>
<p>As RNNs and particularly the LSTM architecture (:numref:<code>sec_lstm</code>)
rapidly gained popularity during the 2010s,
a number of researchers began to experiment
with simplified architectures in hopes
of retaining the key idea of incorporating
an internal state and multiplicative gating mechanisms
but with the aim of speeding up computation.
The gated recurrent unit (GRU) :cite:<code>Cho.Van-Merrienboer.Bahdanau.ea.2014</code>
offered a streamlined version of the LSTM memory cell
that often achieves comparable performance
but with the advantage of being faster
to compute :cite:<code>Chung.Gulcehre.Cho.ea.2014</code>.</p>
<pre><code class="language-{.python .input  n=5}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<pre><code class="language-{.python .input  n=6}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=7}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input  n=8}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="reset-gate-and-update-gate"><a class="header" href="#reset-gate-and-update-gate">Reset Gate and Update Gate</a></h2>
<p>Here, the LSTM's three gates are replaced by two:
the <em>reset gate</em> and the <em>update gate</em>.
As with LSTMs, these gates are given sigmoid activations,
forcing their values to lie in the interval $(0, 1)$.
Intuitively, the reset gate controls how much of the previous state
we might still want to remember.
Likewise, an update gate would allow us to control
how much of the new state is just a copy of the old one.
:numref:<code>fig_gru_1</code> illustrates the inputs for both
the reset and update gates in a GRU,
given the input of the current time step
and the hidden state of the previous time step.
The outputs of the gates are given
by two fully connected layers
with a sigmoid activation function.</p>
<p><img src="chapter_recurrent-modern/../img/gru-1.svg" alt="Computing the reset gate and the update gate in a GRU model." />
:label:<code>fig_gru_1</code></p>
<p>Mathematically, for a given time step $t$,
suppose that the input is a minibatch
$\mathbf{X}<em>t \in \mathbb{R}^{n \times d}$
(number of examples $=n$; number of inputs $=d$)
and the hidden state of the previous time step
is $\mathbf{H}</em>{t-1} \in \mathbb{R}^{n \times h}$
(number of hidden units $=h$).
Then the reset gate $\mathbf{R}_t \in \mathbb{R}^{n \times h}$
and update gate $\mathbf{Z}_t \in \mathbb{R}^{n \times h}$ are computed as follows:</p>
<p>$$
\begin{aligned}
\mathbf{R}<em>t = \sigma(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xr}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hr}} + \mathbf{b}</em>\textrm{r}),\
\mathbf{Z}<em>t = \sigma(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xz}} + \mathbf{H}</em>{t-1} \mathbf{W}<em>{\textrm{hz}} + \mathbf{b}</em>\textrm{z}),
\end{aligned}
$$</p>
<p>where $\mathbf{W}<em>{\textrm{xr}}, \mathbf{W}</em>{\textrm{xz}} \in \mathbb{R}^{d \times h}$
and $\mathbf{W}<em>{\textrm{hr}}, \mathbf{W}</em>{\textrm{hz}} \in \mathbb{R}^{h \times h}$
are weight parameters and $\mathbf{b}<em>\textrm{r}, \mathbf{b}</em>\textrm{z} \in \mathbb{R}^{1 \times h}$
are bias parameters.</p>
<h2 id="candidate-hidden-state"><a class="header" href="#candidate-hidden-state">Candidate Hidden State</a></h2>
<p>Next, we integrate the reset gate $\mathbf{R}_t$
with the regular updating mechanism
in :eqref:<code>rnn_h_with_state</code>,
leading to the following
<em>candidate hidden state</em>
$\tilde{\mathbf{H}}_t \in \mathbb{R}^{n \times h}$ at time step $t$:</p>
<p>$$\tilde{\mathbf{H}}<em>t = \tanh(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xh}} + \left(\mathbf{R}<em>t \odot \mathbf{H}</em>{t-1}\right) \mathbf{W}</em>{\textrm{hh}} + \mathbf{b}_\textrm{h}),$$
:eqlabel:<code>gru_tilde_H</code></p>
<p>where $\mathbf{W}<em>{\textrm{xh}} \in \mathbb{R}^{d \times h}$ and $\mathbf{W}</em>{\textrm{hh}} \in \mathbb{R}^{h \times h}$
are weight parameters,
$\mathbf{b}_\textrm{h} \in \mathbb{R}^{1 \times h}$
is the bias,
and the symbol $\odot$ is the Hadamard (elementwise) product operator.
Here we use a tanh activation function.</p>
<p>The result is a <em>candidate</em>, since we still need
to incorporate the action of the update gate.
Comparing with :eqref:<code>rnn_h_with_state</code>,
the influence of the previous states
can now be reduced with the
elementwise multiplication of
$\mathbf{R}<em>t$ and $\mathbf{H}</em>{t-1}$
in :eqref:<code>gru_tilde_H</code>.
Whenever the entries in the reset gate $\mathbf{R}_t$ are close to 1,
we recover a vanilla RNN such as that in :eqref:<code>rnn_h_with_state</code>.
For all entries of the reset gate $\mathbf{R}_t$ that are close to 0,
the candidate hidden state is the result of an MLP with $\mathbf{X}_t$ as input.
Any pre-existing hidden state is thus <em>reset</em> to defaults.</p>
<p>:numref:<code>fig_gru_2</code> illustrates the computational flow after applying the reset gate.</p>
<p><img src="chapter_recurrent-modern/../img/gru-2.svg" alt="Computing the candidate hidden state in a GRU model." />
:label:<code>fig_gru_2</code></p>
<h2 id="hidden-state-1"><a class="header" href="#hidden-state-1">Hidden State</a></h2>
<p>Finally, we need to incorporate the effect of the update gate $\mathbf{Z}_t$.
This determines the extent to which the new hidden state $\mathbf{H}<em>t \in \mathbb{R}^{n \times h}$
matches the old state $\mathbf{H}</em>{t-1}$ compared with how much
it resembles the new candidate state $\tilde{\mathbf{H}}_t$.
The update gate $\mathbf{Z}<em>t$ can be used for this purpose,
simply by taking elementwise convex combinations
of $\mathbf{H}</em>{t-1}$ and $\tilde{\mathbf{H}}_t$.
This leads to the final update equation for the GRU:</p>
<p>$$\mathbf{H}_t = \mathbf{Z}<em>t \odot \mathbf{H}</em>{t-1}  + (1 - \mathbf{Z}_t) \odot \tilde{\mathbf{H}}_t.$$</p>
<p>Whenever the update gate $\mathbf{Z}_t$ is close to 1,
we simply retain the old state.
In this case the information from $\mathbf{X}_t$ is ignored,
effectively skipping time step $t$ in the dependency chain.
By contrast, whenever $\mathbf{Z}_t$ is close to 0,
the new latent state $\mathbf{H}_t$ approaches the candidate latent state $\tilde{\mathbf{H}}_t$.
:numref:<code>fig_gru_3</code> shows the computational flow after the update gate is in action.</p>
<p><img src="chapter_recurrent-modern/../img/gru-3.svg" alt="Computing the hidden state in a GRU model." />
:label:<code>fig_gru_3</code></p>
<p>In summary, GRUs have the following two distinguishing features:</p>
<ul>
<li>Reset gates help capture short-term dependencies in sequences.</li>
<li>Update gates help capture long-term dependencies in sequences.</li>
</ul>
<h2 id="implementation-from-scratch-5"><a class="header" href="#implementation-from-scratch-5">Implementation from Scratch</a></h2>
<p>To gain a better understanding of the GRU model, let's implement it from scratch.</p>
<h3 id="initializing-model-parameters-2"><a class="header" href="#initializing-model-parameters-2">(<strong>Initializing Model Parameters</strong>)</a></h3>
<p>The first step is to initialize the model parameters.
We draw the weights from a Gaussian distribution
with standard deviation to be <code>sigma</code> and set the bias to 0.
The hyperparameter <code>num_hiddens</code> defines the number of hidden units.
We instantiate all weights and biases relating to the update gate,
the reset gate, and the candidate hidden state.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class GRUScratch(d2l.Module):
    def __init__(self, num_inputs, num_hiddens, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        
        if tab.selected('mxnet'):
            init_weight = lambda *shape: d2l.randn(*shape) * sigma
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              d2l.zeros(num_hiddens))            
        if tab.selected('pytorch'):
            init_weight = lambda *shape: nn.Parameter(d2l.randn(*shape) * sigma)
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              nn.Parameter(d2l.zeros(num_hiddens)))
        if tab.selected('tensorflow'):
            init_weight = lambda *shape: tf.Variable(d2l.normal(shape) * sigma)
            triple = lambda: (init_weight(num_inputs, num_hiddens),
                              init_weight(num_hiddens, num_hiddens),
                              tf.Variable(d2l.zeros(num_hiddens)))            
            
        self.W_xz, self.W_hz, self.b_z = triple()  # Update gate
        self.W_xr, self.W_hr, self.b_r = triple()  # Reset gate
        self.W_xh, self.W_hh, self.b_h = triple()  # Candidate hidden state        
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class GRUScratch(d2l.Module):
    num_inputs: int
    num_hiddens: int
    sigma: float = 0.01

    def setup(self):
        init_weight = lambda name, shape: self.param(name,
                                                     nn.initializers.normal(self.sigma),
                                                     shape)
        triple = lambda name : (
            init_weight(f'W_x{name}', (self.num_inputs, self.num_hiddens)),
            init_weight(f'W_h{name}', (self.num_hiddens, self.num_hiddens)),
            self.param(f'b_{name}', nn.initializers.zeros, (self.num_hiddens)))

        self.W_xz, self.W_hz, self.b_z = triple('z')  # Update gate
        self.W_xr, self.W_hr, self.b_r = triple('r')  # Reset gate
        self.W_xh, self.W_hh, self.b_h = triple('h')  # Candidate hidden state
</code></pre>
<h3 id="defining-the-model-6"><a class="header" href="#defining-the-model-6">Defining the Model</a></h3>
<p>Now we are ready to [<strong>define the GRU forward computation</strong>].
Its structure is the same as that of the basic RNN cell,
except that the update equations are more complex.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(GRUScratch)
def forward(self, inputs, H=None):
    if H is None:
        # Initial state with shape: (batch_size, num_hiddens)
        if tab.selected('mxnet'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          ctx=inputs.ctx)
        if tab.selected('pytorch'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens),
                          device=inputs.device)
        if tab.selected('tensorflow'):
            H = d2l.zeros((inputs.shape[1], self.num_hiddens))
    outputs = []
    for X in inputs:
        Z = d2l.sigmoid(d2l.matmul(X, self.W_xz) +
                        d2l.matmul(H, self.W_hz) + self.b_z)
        R = d2l.sigmoid(d2l.matmul(X, self.W_xr) + 
                        d2l.matmul(H, self.W_hr) + self.b_r)
        H_tilde = d2l.tanh(d2l.matmul(X, self.W_xh) + 
                           d2l.matmul(R * H, self.W_hh) + self.b_h)
        H = Z * H + (1 - Z) * H_tilde
        outputs.append(H)
    return outputs, H
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(GRUScratch)
def forward(self, inputs, H=None):
    # Use lax.scan primitive instead of looping over the
    # inputs, since scan saves time in jit compilation
    def scan_fn(H, X):
        Z = d2l.sigmoid(d2l.matmul(X, self.W_xz) + d2l.matmul(H, self.W_hz) +
                        self.b_z)
        R = d2l.sigmoid(d2l.matmul(X, self.W_xr) +
                        d2l.matmul(H, self.W_hr) + self.b_r)
        H_tilde = d2l.tanh(d2l.matmul(X, self.W_xh) +
                           d2l.matmul(R * H, self.W_hh) + self.b_h)
        H = Z * H + (1 - Z) * H_tilde
        return H, H  # return carry, y

    if H is None:
        batch_size = inputs.shape[1]
        carry = jnp.zeros((batch_size, self.num_hiddens))
    else:
        carry = H

    # scan takes the scan_fn, initial carry state, xs with leading axis to be scanned
    carry, outputs = jax.lax.scan(scan_fn, carry, inputs)
    return outputs, carry
</code></pre>
<h3 id="training-18"><a class="header" href="#training-18">Training</a></h3>
<p>[<strong>Training</strong>] a language model on <em>The Time Machine</em> dataset
works in exactly the same manner as in :numref:<code>sec_rnn-scratch</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.TimeMachine(batch_size=1024, num_steps=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    gru = GRUScratch(num_inputs=len(data.vocab), num_hiddens=32)
    model = d2l.RNNLMScratch(gru, vocab_size=len(data.vocab), lr=4)
    trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        gru = GRUScratch(num_inputs=len(data.vocab), num_hiddens=32)
        model = d2l.RNNLMScratch(gru, vocab_size=len(data.vocab), lr=4)
    trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<h2 id="concise-implementation-5"><a class="header" href="#concise-implementation-5">[<strong>Concise Implementation</strong>]</a></h2>
<p>In high-level APIs, we can directly instantiate a GRU model.
This encapsulates all the configuration detail that we made explicit above.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class GRU(d2l.RNN):
    def __init__(self, num_inputs, num_hiddens):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.rnn = rnn.GRU(num_hiddens)
        if tab.selected('pytorch'):
            self.rnn = nn.GRU(num_inputs, num_hiddens)
        if tab.selected('tensorflow'):
            self.rnn = tf.keras.layers.GRU(num_hiddens, return_sequences=True, 
                                           return_state=True)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class GRU(d2l.RNN):
    num_hiddens: int

    @nn.compact
    def __call__(self, inputs, H=None, training=False):
        if H is None:
            batch_size = inputs.shape[1]
            H = nn.GRUCell.initialize_carry(jax.random.PRNGKey(0),
                                            (batch_size,), self.num_hiddens)

        GRU = nn.scan(nn.GRUCell, variable_broadcast="params",
                      in_axes=0, out_axes=0, split_rngs={"params": False})

        H, outputs = GRU()(H, inputs)
        return outputs, H
</code></pre>
<p>The code is significantly faster in training as it uses compiled operators
rather than Python.</p>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('mxnet', 'pytorch', 'tensorflow'):
    gru = GRU(num_inputs=len(data.vocab), num_hiddens=32)
if tab.selected('jax'):
    gru = GRU(num_hiddens=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=4)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=4)
trainer.fit(model, data)
</code></pre>
<p>After training, we print out the perplexity on the training set
and the predicted sequence following the provided prefix.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
model.predict('it has', 20, data.vocab)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
model.predict('it has', 20, data.vocab, trainer.state.params)
</code></pre>
<h2 id="summary-40"><a class="header" href="#summary-40">Summary</a></h2>
<p>Compared with LSTMs, GRUs achieve similar performance but tend to be lighter computationally.
Generally, compared with simple RNNs, gated RNNS, just like LSTMs and GRUs,
can better capture dependencies for sequences with large time step distances.
GRUs contain basic RNNs as their extreme case whenever the reset gate is switched on.
They can also skip subsequences by turning on the update gate.</p>
<h2 id="exercises-58"><a class="header" href="#exercises-58">Exercises</a></h2>
<ol>
<li>Assume that we only want to use the input at time step $t'$ to predict the output at time step $t &gt; t'$. What are the best values for the reset and update gates for each time step?</li>
<li>Adjust the hyperparameters and analyze their influence on running time, perplexity, and the output sequence.</li>
<li>Compare runtime, perplexity, and the output strings for <code>rnn.RNN</code> and <code>rnn.GRU</code> implementations with each other.</li>
<li>What happens if you implement only parts of a GRU, e.g., with only a reset gate or only an update gate?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/342">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1056">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3860">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18017">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deep-recurrent-neural-networks"><a class="header" href="#deep-recurrent-neural-networks">Deep Recurrent Neural Networks</a></h1>
<p>:label:<code>sec_deep_rnn</code></p>
<p>Up until now, we have focused on defining networks
consisting of a sequence input,
a single hidden RNN layer,
and an output layer.
Despite having just one hidden layer
between the input at any time step
and the corresponding output,
there is a sense in which these networks are deep.
Inputs from the first time step can influence
the outputs at the final time step $T$
(often 100s or 1000s of steps later).
These inputs pass through $T$ applications
of the recurrent layer before reaching
the final output.
However, we often also wish to retain the ability
to express complex relationships
between the inputs at a given time step
and the outputs at that same time step.
Thus we often construct RNNs that are deep
not only in the time direction
but also in the input-to-output direction.
This is precisely the notion of depth
that we have already encountered
in our development of MLPs
and deep CNNs.</p>
<p>The standard method for building this sort of deep RNN
is strikingly simple: we stack the RNNs on top of each other.
Given a sequence of length $T$, the first RNN produces
a sequence of outputs, also of length $T$.
These, in turn, constitute the inputs to the next RNN layer.
In this short section, we illustrate this design pattern
and present a simple example for how to code up such stacked RNNs.
Below, in :numref:<code>fig_deep_rnn</code>, we illustrate
a deep RNN with $L$ hidden layers.
Each hidden state operates on a sequential input
and produces a sequential output.
Moreover, any RNN cell (white box in :numref:<code>fig_deep_rnn</code>) at each time step
depends on both the same layer's
value at the previous time step
and the previous layer's value
at the same time step.</p>
<p><img src="chapter_recurrent-modern/../img/deep-rnn.svg" alt="Architecture of a deep RNN." />
:label:<code>fig_deep_rnn</code></p>
<p>Formally, suppose that we have a minibatch input
$\mathbf{X}_t \in \mathbb{R}^{n \times d}$
(number of examples $=n$; number of inputs in each example $=d$) at time step $t$.
At the same time step,
let the hidden state of the $l^\textrm{th}$ hidden layer ($l=1,\ldots,L$) be $\mathbf{H}_t^{(l)} \in \mathbb{R}^{n \times h}$
(number of hidden units $=h$)
and the output layer variable be
$\mathbf{O}_t \in \mathbb{R}^{n \times q}$
(number of outputs: $q$).
Setting $\mathbf{H}_t^{(0)} = \mathbf{X}_t$,
the hidden state of
the $l^\textrm{th}$ hidden layer
that uses the activation function $\phi_l$
is calculated as follows:</p>
<p>$$\mathbf{H}<em>t^{(l)} = \phi_l(\mathbf{H}<em>t^{(l-1)} \mathbf{W}</em>{\textrm{xh}}^{(l)} + \mathbf{H}</em>{t-1}^{(l)} \mathbf{W}<em>{\textrm{hh}}^{(l)}  + \mathbf{b}</em>\textrm{h}^{(l)}),$$
:eqlabel:<code>eq_deep_rnn_H</code></p>
<p>where the weights $\mathbf{W}<em>{\textrm{xh}}^{(l)} \in \mathbb{R}^{h \times h}$ and $\mathbf{W}</em>{\textrm{hh}}^{(l)} \in \mathbb{R}^{h \times h}$, together with
the bias $\mathbf{b}_\textrm{h}^{(l)} \in \mathbb{R}^{1 \times h}$,
are the model parameters of the $l^\textrm{th}$ hidden layer.</p>
<p>At the end, the calculation of the output layer
is only based on the hidden state
of the final $L^\textrm{th}$ hidden layer:</p>
<p>$$\mathbf{O}<em>t = \mathbf{H}<em>t^{(L)} \mathbf{W}</em>{\textrm{hq}} + \mathbf{b}</em>\textrm{q},$$</p>
<p>where the weight $\mathbf{W}<em>{\textrm{hq}} \in \mathbb{R}^{h \times q}$
and the bias $\mathbf{b}</em>\textrm{q} \in \mathbb{R}^{1 \times q}$
are the model parameters of the output layer.</p>
<p>Just as with MLPs, the number of hidden layers $L$
and the number of hidden units $h$ are hyperparameters
that we can tune.
Common RNN layer widths ($h$) are in the range $(64, 2056)$,
and common depths ($L$) are in the range $(1, 8)$.
In addition, we can easily get a deep-gated RNN
by replacing the hidden state computation in :eqref:<code>eq_deep_rnn_H</code>
with that from an LSTM or a GRU.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="implementation-from-scratch-6"><a class="header" href="#implementation-from-scratch-6">Implementation from Scratch</a></h2>
<p>To implement a multilayer RNN from scratch,
we can treat each layer as an <code>RNNScratch</code> instance
with its own learnable parameters.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
class StackedRNNScratch(d2l.Module):
    def __init__(self, num_inputs, num_hiddens, num_layers, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.rnns = [d2l.RNNScratch(num_inputs if i==0 else num_hiddens,
                                    num_hiddens, sigma)
                     for i in range(num_layers)]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class StackedRNNScratch(d2l.Module):
    def __init__(self, num_inputs, num_hiddens, num_layers, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.rnns = nn.Sequential(*[d2l.RNNScratch(
            num_inputs if i==0 else num_hiddens, num_hiddens, sigma)
                                    for i in range(num_layers)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class StackedRNNScratch(d2l.Module):
    num_inputs: int
    num_hiddens: int
    num_layers: int
    sigma: float = 0.01

    def setup(self):
        self.rnns = [d2l.RNNScratch(self.num_inputs if i==0 else self.num_hiddens,
                                    self.num_hiddens, self.sigma)
                     for i in range(self.num_layers)]
</code></pre>
<p>The multilayer forward computation
simply performs forward computation
layer by layer.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(StackedRNNScratch)
def forward(self, inputs, Hs=None):
    outputs = inputs
    if Hs is None: Hs = [None] * self.num_layers
    for i in range(self.num_layers):
        outputs, Hs[i] = self.rnns[i](outputs, Hs[i])
        outputs = d2l.stack(outputs, 0)
    return outputs, Hs
</code></pre>
<p>As an example, we train a deep GRU model on
<em>The Time Machine</em> dataset (same as in :numref:<code>sec_rnn-scratch</code>).
To keep things simple we set the number of layers to 2.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.TimeMachine(batch_size=1024, num_steps=32)
if tab.selected('mxnet', 'pytorch', 'jax'):
    rnn_block = StackedRNNScratch(num_inputs=len(data.vocab),
                                  num_hiddens=32, num_layers=2)
    model = d2l.RNNLMScratch(rnn_block, vocab_size=len(data.vocab), lr=2)
    trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        rnn_block = StackedRNNScratch(num_inputs=len(data.vocab),
                                  num_hiddens=32, num_layers=2)
        model = d2l.RNNLMScratch(rnn_block, vocab_size=len(data.vocab), lr=2)
    trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<h2 id="concise-implementation-6"><a class="header" href="#concise-implementation-6">Concise Implementation</a></h2>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
Fortunately many of the logistical details required
to implement multiple layers of an RNN
are readily available in high-level APIs.
Our concise implementation will use such built-in functionalities.
The code generalizes the one we used previously in :numref:<code>sec_gru</code>,
letting us specify the number of layers explicitly
rather than picking the default of only one layer.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Flax takes a minimalistic approach while implementing
RNNs. Defining the number of layers in an RNN or combining it with dropout
is not available out of the box.
Our concise implementation will use all built-in functionalities and
add <code>num_layers</code> and <code>dropout</code> features on top.
The code generalizes the one we used previously in :numref:<code>sec_gru</code>,
allowing specification of the number of layers explicitly
rather than picking the default of a single layer.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class GRU(d2l.RNN):  #@save
    """The multilayer GRU model."""
    def __init__(self, num_hiddens, num_layers, dropout=0):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        self.rnn = rnn.GRU(num_hiddens, num_layers, dropout=dropout)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class GRU(d2l.RNN):  #@save
    """The multilayer GRU model."""
    def __init__(self, num_inputs, num_hiddens, num_layers, dropout=0):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        self.rnn = nn.GRU(num_inputs, num_hiddens, num_layers,
                          dropout=dropout)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class GRU(d2l.RNN):  #@save
    """The multilayer GRU model."""
    def __init__(self, num_hiddens, num_layers, dropout=0):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        gru_cells = [tf.keras.layers.GRUCell(num_hiddens, dropout=dropout)
                     for _ in range(num_layers)]
        self.rnn = tf.keras.layers.RNN(gru_cells, return_sequences=True,
                                       return_state=True, time_major=True)

    def forward(self, X, state=None):
        outputs, *state = self.rnn(X, state)
        return outputs, state
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class GRU(d2l.RNN):  #@save
    """The multilayer GRU model."""
    num_hiddens: int
    num_layers: int
    dropout: float = 0

    @nn.compact
    def __call__(self, X, state=None, training=False):
        outputs = X
        new_state = []
        if state is None:
            batch_size = X.shape[1]
            state = [nn.GRUCell.initialize_carry(jax.random.PRNGKey(0),
                    (batch_size,), self.num_hiddens)] * self.num_layers

        GRU = nn.scan(nn.GRUCell, variable_broadcast="params",
                      in_axes=0, out_axes=0, split_rngs={"params": False})

        # Introduce a dropout layer after every GRU layer except last
        for i in range(self.num_layers - 1):
            layer_i_state, X = GRU()(state[i], outputs)
            new_state.append(layer_i_state)
            X = nn.Dropout(self.dropout, deterministic=not training)(X)

        # Final GRU layer without dropout
        out_state, X = GRU()(state[-1], X)
        new_state.append(out_state)
        return X, jnp.array(new_state)
</code></pre>
<p>The architectural decisions such as choosing hyperparameters
are very similar to those of :numref:<code>sec_gru</code>.
We pick the same number of inputs and outputs
as we have distinct tokens, i.e., <code>vocab_size</code>.
The number of hidden units is still 32.
The only difference is that we now
(<strong>select a nontrivial number of hidden layers
by specifying the value of <code>num_layers</code>.</strong>)</p>
<pre><code class="language-{.python .input}">%%tab mxnet
gru = GRU(num_hiddens=32, num_layers=2)
model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=2)

# Running takes &gt; 1h (pending fix from MXNet)
# trainer.fit(model, data)
# model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, tensorflow, jax
if tab.selected('tensorflow', 'jax'):
    gru = GRU(num_hiddens=32, num_layers=2)
if tab.selected('pytorch'):
    gru = GRU(num_inputs=len(data.vocab), num_hiddens=32, num_layers=2)
if tab.selected('pytorch', 'jax'):
    model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=2)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=2)
trainer.fit(model, data)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
model.predict('it has', 20, data.vocab)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
model.predict('it has', 20, data.vocab, trainer.state.params)
</code></pre>
<h2 id="summary-41"><a class="header" href="#summary-41">Summary</a></h2>
<p>In deep RNNs, the hidden state information is passed
to the next time step of the current layer
and the current time step of the next layer.
There exist many different flavors of deep RNNs, such as LSTMs, GRUs, or vanilla RNNs.
Conveniently, these models are all available
as parts of the high-level APIs of deep learning frameworks.
Initialization of models requires care.
Overall, deep RNNs require considerable amount of work
(such as learning rate and clipping)
to ensure proper convergence.</p>
<h2 id="exercises-59"><a class="header" href="#exercises-59">Exercises</a></h2>
<ol>
<li>Replace the GRU by an LSTM and compare the accuracy and training speed.</li>
<li>Increase the training data to include multiple books. How low can you go on the perplexity scale?</li>
<li>Would you want to combine sources of different authors when modeling text? Why is this a good idea? What could go wrong?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/340">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1058">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3862">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18018">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bidirectional-recurrent-neural-networks"><a class="header" href="#bidirectional-recurrent-neural-networks">Bidirectional Recurrent Neural Networks</a></h1>
<p>:label:<code>sec_bi_rnn</code></p>
<p>So far, our working example of a sequence learning task has been language modeling,
where we aim to predict the next token given all previous tokens in a sequence.
In this scenario, we wish only to condition upon the leftward context,
and thus the unidirectional chaining of a standard RNN seems appropriate.
However, there are many other sequence learning tasks contexts
where it is perfectly fine to condition the prediction at every time step
on both the leftward and the rightward context.
Consider, for example, part of speech detection.
Why shouldn't we take the context in both directions into account
when assessing the part of speech associated with a given word?</p>
<p>Another common task---often useful as a pretraining exercise
prior to fine-tuning a model on an actual task of interest---is
to mask out random tokens in a text document and then to train
a sequence model to predict the values of the missing tokens.
Note that depending on what comes after the blank,
the likely value of the missing token changes dramatically:</p>
<ul>
<li>I am <code>___</code>.</li>
<li>I am <code>___</code> hungry.</li>
<li>I am <code>___</code> hungry, and I can eat half a pig.</li>
</ul>
<p>In the first sentence "happy" seems to be a likely candidate.
The words "not" and "very" seem plausible in the second sentence,
but "not" seems incompatible with the third sentences.</p>
<p>Fortunately, a simple technique transforms any unidirectional RNN
into a bidirectional RNN :cite:<code>Schuster.Paliwal.1997</code>.
We simply implement two unidirectional RNN layers
chained together in opposite directions
and acting on the same input (:numref:<code>fig_birnn</code>).
For the first RNN layer,
the first input is $\mathbf{x}_1$
and the last input is $\mathbf{x}_T$,
but for the second RNN layer,
the first input is $\mathbf{x}_T$
and the last input is $\mathbf{x}_1$.
To produce the output of this bidirectional RNN layer,
we simply concatenate together the corresponding outputs
of the two underlying unidirectional RNN layers.</p>
<p><img src="chapter_recurrent-modern/../img/birnn.svg" alt="Architecture of a bidirectional RNN." />
:label:<code>fig_birnn</code></p>
<p>Formally for any time step $t$,
we consider a minibatch input $\mathbf{X}_t \in \mathbb{R}^{n \times d}$
(number of examples $=n$; number of inputs in each example $=d$)
and let the hidden layer activation function be $\phi$.
In the bidirectional architecture,
the forward and backward hidden states for this time step
are $\overrightarrow{\mathbf{H}}_t  \in \mathbb{R}^{n \times h}$
and $\overleftarrow{\mathbf{H}}_t  \in \mathbb{R}^{n \times h}$, respectively,
where $h$ is the number of hidden units.
The forward and backward hidden state updates are as follows:</p>
<p>$$
\begin{aligned}
\overrightarrow{\mathbf{H}}<em>t &amp;= \phi(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xh}}^{(f)} + \overrightarrow{\mathbf{H}}</em>{t-1} \mathbf{W}<em>{\textrm{hh}}^{(f)}  + \mathbf{b}</em>\textrm{h}^{(f)}),\
\overleftarrow{\mathbf{H}}<em>t &amp;= \phi(\mathbf{X}<em>t \mathbf{W}</em>{\textrm{xh}}^{(b)} + \overleftarrow{\mathbf{H}}</em>{t+1} \mathbf{W}<em>{\textrm{hh}}^{(b)}  + \mathbf{b}</em>\textrm{h}^{(b)}),
\end{aligned}
$$</p>
<p>where the weights $\mathbf{W}<em>{\textrm{xh}}^{(f)} \in \mathbb{R}^{d \times h}, \mathbf{W}</em>{\textrm{hh}}^{(f)} \in \mathbb{R}^{h \times h}, \mathbf{W}<em>{\textrm{xh}}^{(b)} \in \mathbb{R}^{d \times h}, \textrm{ and } \mathbf{W}</em>{\textrm{hh}}^{(b)} \in \mathbb{R}^{h \times h}$, and the biases $\mathbf{b}<em>\textrm{h}^{(f)} \in \mathbb{R}^{1 \times h}$ and $\mathbf{b}</em>\textrm{h}^{(b)} \in \mathbb{R}^{1 \times h}$ are all the model parameters.</p>
<p>Next, we concatenate the forward and backward hidden states
$\overrightarrow{\mathbf{H}}_t$ and $\overleftarrow{\mathbf{H}}_t$
to obtain the hidden state $\mathbf{H}_t \in \mathbb{R}^{n \times 2h}$ for feeding into the output layer.
In deep bidirectional RNNs with multiple hidden layers,
such information is passed on as <em>input</em> to the next bidirectional layer.
Last, the output layer computes the output
$\mathbf{O}_t \in \mathbb{R}^{n \times q}$ (number of outputs $=q$):</p>
<p>$$\mathbf{O}<em>t = \mathbf{H}<em>t \mathbf{W}</em>{\textrm{hq}} + \mathbf{b}</em>\textrm{q}.$$</p>
<p>Here, the weight matrix $\mathbf{W}<em>{\textrm{hq}} \in \mathbb{R}^{2h \times q}$
and the bias $\mathbf{b}</em>\textrm{q} \in \mathbb{R}^{1 \times q}$
are the model parameters of the output layer.
While technically, the two directions can have different numbers of hidden units,
this design choice is seldom made in practice.
We now demonstrate a simple implementation of a bidirectional RNN.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import npx, np
from mxnet.gluon import rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from jax import numpy as jnp
</code></pre>
<h2 id="implementation-from-scratch-7"><a class="header" href="#implementation-from-scratch-7">Implementation from Scratch</a></h2>
<p>If we want to implement a bidirectional RNN from scratch, we can
include two unidirectional <code>RNNScratch</code> instances
with separate learnable parameters.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class BiRNNScratch(d2l.Module):
    def __init__(self, num_inputs, num_hiddens, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.f_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma)
        self.b_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma)
        self.num_hiddens *= 2  # The output dimension will be doubled
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class BiRNNScratch(d2l.Module):
    num_inputs: int
    num_hiddens: int
    sigma: float = 0.01

    def setup(self):
        self.f_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma)
        self.b_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma)
        self.num_hiddens *= 2  # The output dimension will be doubled
</code></pre>
<p>States of forward and backward RNNs
are updated separately,
while outputs of these two RNNs are concatenated.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(BiRNNScratch)
def forward(self, inputs, Hs=None):
    f_H, b_H = Hs if Hs is not None else (None, None)
    f_outputs, f_H = self.f_rnn(inputs, f_H)
    b_outputs, b_H = self.b_rnn(reversed(inputs), b_H)
    outputs = [d2l.concat((f, b), -1) for f, b in zip(
        f_outputs, reversed(b_outputs))]
    return outputs, (f_H, b_H)
</code></pre>
<h2 id="concise-implementation-7"><a class="header" href="#concise-implementation-7">Concise Implementation</a></h2>
<p>:begin_tab:<code>pytorch, mxnet, tensorflow</code>
Using the high-level APIs,
we can implement bidirectional RNNs more concisely.
Here we take a GRU model as an example.
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
Flax API does not offer RNN layers and hence there is no
notion of any <code>bidirectional</code> argument. One needs to manually
reverse the inputs as shown in the scratch implementation,
if a bidirectional layer is needed.
:end_tab:</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
class BiGRU(d2l.RNN):
    def __init__(self, num_inputs, num_hiddens):
        d2l.Module.__init__(self)
        self.save_hyperparameters()
        if tab.selected('mxnet'):
            self.rnn = rnn.GRU(num_hiddens, bidirectional=True)
        if tab.selected('pytorch'):
            self.rnn = nn.GRU(num_inputs, num_hiddens, bidirectional=True)
        self.num_hiddens *= 2
</code></pre>
<h2 id="summary-42"><a class="header" href="#summary-42">Summary</a></h2>
<p>In bidirectional RNNs, the hidden state for each time step is simultaneously determined by the data prior to and after the current time step. Bidirectional RNNs are mostly useful for sequence encoding and the estimation of observations given bidirectional context. Bidirectional RNNs are very costly to train due to long gradient chains.</p>
<h2 id="exercises-60"><a class="header" href="#exercises-60">Exercises</a></h2>
<ol>
<li>If the different directions use a different number of hidden units, how will the shape of $\mathbf{H}_t$ change?</li>
<li>Design a bidirectional RNN with multiple hidden layers.</li>
<li>Polysemy is common in natural languages. For example, the word "bank" has different meanings in contexts “i went to the bank to deposit cash” and “i went to the bank to sit down”. How can we design a neural network model such that given a context sequence and a word, a vector representation of the word in the correct context will be returned? What type of neural architectures is preferred for handling polysemy?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/339">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1059">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18019">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="machine-translation-and-the-dataset"><a class="header" href="#machine-translation-and-the-dataset">Machine Translation and the Dataset</a></h1>
<p>:label:<code>sec_machine_translation</code></p>
<p>Among the major breakthroughs that prompted
widespread interest in modern RNNs
was a major advance in the applied field of
statistical  <em>machine translation</em>.
Here, the model is presented with a sentence in one language
and must predict the corresponding sentence in another.
Note that here the sentences may be of different lengths,
and that corresponding words in the two sentences
may not occur in the same order,
owing to differences
in the two language's grammatical structure.</p>
<p>Many problems have this flavor of mapping
between two such "unaligned" sequences.
Examples include mapping
from dialog prompts to replies
or from questions to answers.
Broadly, such problems are called
<em>sequence-to-sequence</em> (seq2seq) problems
and they are our focus for
both the remainder of this chapter
and much of :numref:<code>chap_attention-and-transformers</code>.</p>
<p>In this section, we introduce the machine translation problem
and an example dataset that we will use in the subsequent examples.
For decades, statistical formulations of translation between languages
had been popular :cite:<code>Brown.Cocke.Della-Pietra.ea.1988,Brown.Cocke.Della-Pietra.ea.1990</code>,
even before researchers got neural network approaches working
(methods were often lumped together under the term <em>neural machine translation</em>).</p>
<p>First we will need some new code to process our data.
Unlike the language modeling that we saw in :numref:<code>sec_language-model</code>,
here each example consists of two separate text sequences,
one in the source language and another (the translation) in the target language.
The following code snippets will show how
to load the preprocessed data into minibatches for training.</p>
<pre><code class="language-{.python .input  n=2}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
import os
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
from d2l import torch as d2l
import torch
import os
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
import os
</code></pre>
<pre><code class="language-{.python .input  n=4}">%%tab jax
from d2l import jax as d2l
from jax import numpy as jnp
import os
</code></pre>
<h2 id="downloading-and-preprocessing-the-dataset"><a class="header" href="#downloading-and-preprocessing-the-dataset">[<strong>Downloading and Preprocessing the Dataset</strong>]</a></h2>
<p>To begin, we download an English--French dataset
that consists of <a href="http://www.manythings.org/anki/">bilingual sentence pairs from the Tatoeba Project</a>.
Each line in the dataset is a tab-delimited pair
consisting of an English text sequence (the <em>source</em>)
and the translated French text sequence (the <em>target</em>).
Note that each text sequence
can be just one sentence,
or a paragraph of multiple sentences.</p>
<pre><code class="language-{.python .input  n=5}">%%tab all
class MTFraEng(d2l.DataModule):  #@save
    """The English-French dataset."""
    def _download(self):
        d2l.extract(d2l.download(
            d2l.DATA_URL+'fra-eng.zip', self.root, 
            '94646ad1522d915e7b0f9296181140edcf86a4f5'))
        with open(self.root + '/fra-eng/fra.txt', encoding='utf-8') as f:
            return f.read()
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
data = MTFraEng() 
raw_text = data._download()
print(raw_text[:75])
</code></pre>
<p>After downloading the dataset,
we [<strong>proceed with several preprocessing steps</strong>]
for the raw text data.
For instance, we replace non-breaking space with space,
convert uppercase letters to lowercase ones,
and insert space between words and punctuation marks.</p>
<pre><code class="language-{.python .input  n=6}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def _preprocess(self, text):
    # Replace non-breaking space with space
    text = text.replace('\u202f', ' ').replace('\xa0', ' ')
    # Insert space between words and punctuation marks
    no_space = lambda char, prev_char: char in ',.!?' and prev_char != ' '
    out = [' ' + char if i &gt; 0 and no_space(char, text[i - 1]) else char
           for i, char in enumerate(text.lower())]
    return ''.join(out)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
text = data._preprocess(raw_text)
print(text[:80])
</code></pre>
<h2 id="tokenization-1"><a class="header" href="#tokenization-1">[<strong>Tokenization</strong>]</a></h2>
<p>Unlike the character-level tokenization
in :numref:<code>sec_language-model</code>,
for machine translation
we prefer word-level tokenization here
(today's state-of-the-art models use
more complex tokenization techniques).
The following <code>_tokenize</code> method
tokenizes the first <code>max_examples</code> text sequence pairs,
where each token is either a word or a punctuation mark.
We append the special “&lt;eos&gt;” token
to the end of every sequence to indicate the
end of the sequence.
When a model is predicting
by generating a sequence token after token,
the generation of the “&lt;eos&gt;” token
can suggest that the output sequence is complete.
In the end, the method below returns
two lists of token lists: <code>src</code> and <code>tgt</code>.
Specifically, <code>src[i]</code> is a list of tokens from the
$i^\textrm{th}$ text sequence in the source language (English here)
and <code>tgt[i]</code> is that in the target language (French here).</p>
<pre><code class="language-{.python .input  n=7}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def _tokenize(self, text, max_examples=None):
    src, tgt = [], []
    for i, line in enumerate(text.split('\n')):
        if max_examples and i &gt; max_examples: break
        parts = line.split('\t')
        if len(parts) == 2:
            # Skip empty tokens
            src.append([t for t in f'{parts[0]} &lt;eos&gt;'.split(' ') if t])
            tgt.append([t for t in f'{parts[1]} &lt;eos&gt;'.split(' ') if t])
    return src, tgt
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
src, tgt = data._tokenize(text)
src[:6], tgt[:6]
</code></pre>
<p>Let's [<strong>plot the histogram of the number of tokens per text sequence.</strong>]
In this simple English--French dataset,
most of the text sequences have fewer than 20 tokens.</p>
<pre><code class="language-{.python .input  n=8}">%%tab all
#@save
def show_list_len_pair_hist(legend, xlabel, ylabel, xlist, ylist):
    """Plot the histogram for list length pairs."""
    d2l.set_figsize()
    _, _, patches = d2l.plt.hist(
        [[len(l) for l in xlist], [len(l) for l in ylist]])
    d2l.plt.xlabel(xlabel)
    d2l.plt.ylabel(ylabel)
    for patch in patches[1].patches:
        patch.set_hatch('/')
    d2l.plt.legend(legend)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
show_list_len_pair_hist(['source', 'target'], '# tokens per sequence',
                        'count', src, tgt);
</code></pre>
<h2 id="loading-sequences-of-fixed-length"><a class="header" href="#loading-sequences-of-fixed-length">Loading Sequences of Fixed Length</a></h2>
<p>:label:<code>subsec_loading-seq-fixed-len</code></p>
<p>Recall that in language modeling
[<strong>each example sequence</strong>],
either a segment of one sentence
or a span over multiple sentences,
(<strong>had a fixed length.</strong>)
This was specified by the <code>num_steps</code>
(number of time steps or tokens) argument from :numref:<code>sec_language-model</code>.
In machine translation, each example is
a pair of source and target text sequences,
where the two text sequences may have different lengths.</p>
<p>For computational efficiency,
we can still process a minibatch of text sequences
at one time by <em>truncation</em> and <em>padding</em>.
Suppose that every sequence in the same minibatch
should have the same length <code>num_steps</code>.
If a text sequence has fewer than <code>num_steps</code> tokens,
we will keep appending the special "&lt;pad&gt;" token
to its end until its length reaches <code>num_steps</code>.
Otherwise, we will truncate the text sequence
by only taking its first <code>num_steps</code> tokens
and discarding the remaining.
In this way, every text sequence
will have the same length
to be loaded in minibatches of the same shape.
Furthermore, we also record length of the source sequence excluding padding tokens.
This information will be needed by some models that we will cover later.</p>
<p>Since the machine translation dataset
consists of pairs of languages,
we can build two vocabularies for
both the source language and
the target language separately.
With word-level tokenization,
the vocabulary size will be significantly larger
than that using character-level tokenization.
To alleviate this,
here we treat infrequent tokens
that appear less than twice
as the same unknown ("&lt;unk&gt;") token.
As we will explain later (:numref:<code>fig_seq2seq</code>),
when training with target sequences,
the decoder output (label tokens)
can be the same decoder input (target tokens),
shifted by one token;
and the special beginning-of-sequence "&lt;bos&gt;" token
will be used as the first input token
for predicting the target sequence (:numref:<code>fig_seq2seq_predict</code>).</p>
<pre><code class="language-{.python .input  n=9}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def __init__(self, batch_size, num_steps=9, num_train=512, num_val=128):
    super(MTFraEng, self).__init__()
    self.save_hyperparameters()
    self.arrays, self.src_vocab, self.tgt_vocab = self._build_arrays(
        self._download())
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def _build_arrays(self, raw_text, src_vocab=None, tgt_vocab=None):
    def _build_array(sentences, vocab, is_tgt=False):
        pad_or_trim = lambda seq, t: (
            seq[:t] if len(seq) &gt; t else seq + ['&lt;pad&gt;'] * (t - len(seq)))
        sentences = [pad_or_trim(s, self.num_steps) for s in sentences]
        if is_tgt:
            sentences = [['&lt;bos&gt;'] + s for s in sentences]
        if vocab is None:
            vocab = d2l.Vocab(sentences, min_freq=2)
        array = d2l.tensor([vocab[s] for s in sentences])
        valid_len = d2l.reduce_sum(
            d2l.astype(array != vocab['&lt;pad&gt;'], d2l.int32), 1)
        return array, vocab, valid_len
    src, tgt = self._tokenize(self._preprocess(raw_text), 
                              self.num_train + self.num_val)
    src_array, src_vocab, src_valid_len = _build_array(src, src_vocab)
    tgt_array, tgt_vocab, _ = _build_array(tgt, tgt_vocab, True)
    return ((src_array, tgt_array[:,:-1], src_valid_len, tgt_array[:,1:]),
            src_vocab, tgt_vocab)
</code></pre>
<h2 id="reading-the-dataset-3"><a class="header" href="#reading-the-dataset-3">[<strong>Reading the Dataset</strong>]</a></h2>
<p>Finally, we define the <code>get_dataloader</code> method
to return the data iterator.</p>
<pre><code class="language-{.python .input  n=10}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def get_dataloader(self, train):
    idx = slice(0, self.num_train) if train else slice(self.num_train, None)
    return self.get_tensorloader(self.arrays, train, idx)
</code></pre>
<p>Let's [<strong>read the first minibatch from the English--French dataset.</strong>]</p>
<pre><code class="language-{.python .input  n=11}">%%tab all
data = MTFraEng(batch_size=3)
src, tgt, src_valid_len, label = next(iter(data.train_dataloader()))
print('source:', d2l.astype(src, d2l.int32))
print('decoder input:', d2l.astype(tgt, d2l.int32))
print('source len excluding pad:', d2l.astype(src_valid_len, d2l.int32))
print('label:', d2l.astype(label, d2l.int32))
</code></pre>
<p>We show a pair of source and target sequences
processed by the above <code>_build_arrays</code> method
(in the string format).</p>
<pre><code class="language-{.python .input  n=12}">%%tab all
@d2l.add_to_class(MTFraEng)  #@save
def build(self, src_sentences, tgt_sentences):
    raw_text = '\n'.join([src + '\t' + tgt for src, tgt in zip(
        src_sentences, tgt_sentences)])
    arrays, _, _ = self._build_arrays(
        raw_text, self.src_vocab, self.tgt_vocab)
    return arrays
</code></pre>
<pre><code class="language-{.python .input  n=13}">%%tab all
src, tgt, _,  _ = data.build(['hi .'], ['salut .'])
print('source:', data.src_vocab.to_tokens(d2l.astype(src[0], d2l.int32)))
print('target:', data.tgt_vocab.to_tokens(d2l.astype(tgt[0], d2l.int32)))
</code></pre>
<h2 id="summary-43"><a class="header" href="#summary-43">Summary</a></h2>
<p>In natural language processing, <em>machine translation</em> refers to the task of automatically mapping from a sequence representing a string of text in a <em>source</em> language to a string representing a plausible translation in a <em>target</em> language. Using word-level tokenization, the vocabulary size will be significantly larger than that using character-level tokenization, but the sequence lengths will be much shorter. To mitigate the large vocabulary size, we can treat infrequent tokens as some "unknown" token. We can truncate and pad text sequences so that all of them will have the same length to be loaded in minibatches. Modern implementations often bucket sequences with similar lengths to avoid wasting excessive computation on padding.</p>
<h2 id="exercises-61"><a class="header" href="#exercises-61">Exercises</a></h2>
<ol>
<li>Try different values of the <code>max_examples</code> argument in the <code>_tokenize</code> method. How does this affect the vocabulary sizes of the source language and the target language?</li>
<li>Text in some languages such as Chinese and Japanese does not have word boundary indicators (e.g., space). Is word-level tokenization still a good idea for such cases? Why or why not?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/344">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1060">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3863">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18020">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="the-encoder--decoder-architecture"><a class="header" href="#the-encoder--decoder-architecture">The Encoder--Decoder Architecture</a></h1>
<p>:label:<code>sec_encoder-decoder</code></p>
<p>In general sequence-to-sequence problems
like machine translation
(:numref:<code>sec_machine_translation</code>),
inputs and outputs are of varying lengths
that are unaligned.
The standard approach to handling this sort of data
is to design an <em>encoder--decoder</em> architecture (:numref:<code>fig_encoder_decoder</code>)
consisting of two major components:
an <em>encoder</em> that takes a variable-length sequence as input,
and a <em>decoder</em> that acts as a conditional language model,
taking in the encoded input
and the leftwards context of the target sequence
and predicting the subsequent token in the target sequence.</p>
<p><img src="chapter_recurrent-modern/../img/encoder-decoder.svg" alt="The encoder--decoder architecture." />
:label:<code>fig_encoder_decoder</code></p>
<p>Let's take machine translation from English to French as an example.
Given an input sequence in English:
"They", "are", "watching", ".",
this encoder--decoder architecture
first encodes the variable-length input into a state,
then decodes the state
to generate the translated sequence,
token by token, as output:
"Ils", "regardent", ".".
Since the encoder--decoder architecture
forms the basis of different sequence-to-sequence models
in subsequent sections,
this section will convert this architecture
into an interface that will be implemented later.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet.gluon import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
</code></pre>
<h2 id="encoder"><a class="header" href="#encoder">(<strong>Encoder</strong>)</a></h2>
<p>In the encoder interface,
we just specify that
the encoder takes variable-length sequences as input <code>X</code>.
The implementation will be provided
by any model that inherits this base <code>Encoder</code> class.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Encoder(nn.Block):  #@save
    """The base encoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def forward(self, X, *args):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Encoder(nn.Module):  #@save
    """The base encoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def forward(self, X, *args):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Encoder(tf.keras.layers.Layer):  #@save
    """The base encoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def call(self, X, *args):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Encoder(nn.Module):  #@save
    """The base encoder interface for the encoder--decoder architecture."""
    def setup(self):
        raise NotImplementedError

    # Later there can be additional arguments (e.g., length excluding padding)
    def __call__(self, X, *args):
        raise NotImplementedError
</code></pre>
<h2 id="decoder"><a class="header" href="#decoder">[<strong>Decoder</strong>]</a></h2>
<p>In the following decoder interface,
we add an additional <code>init_state</code> method
to convert the encoder output (<code>enc_all_outputs</code>)
into the encoded state.
Note that this step
may require extra inputs,
such as the valid length of the input,
which was explained
in :numref:<code>sec_machine_translation</code>.
To generate a variable-length sequence token by token,
every time the decoder may map an input
(e.g., the generated token at the previous time step)
and the encoded state
into an output token at the current time step.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Decoder(nn.Block):  #@save
    """The base decoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def init_state(self, enc_all_outputs, *args):
        raise NotImplementedError

    def forward(self, X, state):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Decoder(nn.Module):  #@save
    """The base decoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def init_state(self, enc_all_outputs, *args):
        raise NotImplementedError

    def forward(self, X, state):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Decoder(tf.keras.layers.Layer):  #@save
    """The base decoder interface for the encoder--decoder architecture."""
    def __init__(self):
        super().__init__()

    # Later there can be additional arguments (e.g., length excluding padding)
    def init_state(self, enc_all_outputs, *args):
        raise NotImplementedError

    def call(self, X, state):
        raise NotImplementedError
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Decoder(nn.Module):  #@save
    """The base decoder interface for the encoder--decoder architecture."""
    def setup(self):
        raise NotImplementedError

    # Later there can be additional arguments (e.g., length excluding padding)
    def init_state(self, enc_all_outputs, *args):
        raise NotImplementedError

    def __call__(self, X, state):
        raise NotImplementedError
</code></pre>
<h2 id="putting-the-encoder-and-decoder-together"><a class="header" href="#putting-the-encoder-and-decoder-together">[<strong>Putting the Encoder and Decoder Together</strong>]</a></h2>
<p>In the forward propagation,
the output of the encoder
is used to produce the encoded state,
and this state will be further used
by the decoder as one of its input.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, pytorch
class EncoderDecoder(d2l.Classifier):  #@save
    """The base class for the encoder--decoder architecture."""
    def __init__(self, encoder, decoder):
        super().__init__()
        self.encoder = encoder
        self.decoder = decoder

    def forward(self, enc_X, dec_X, *args):
        enc_all_outputs = self.encoder(enc_X, *args)
        dec_state = self.decoder.init_state(enc_all_outputs, *args)
        # Return decoder output only
        return self.decoder(dec_X, dec_state)[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class EncoderDecoder(d2l.Classifier):  #@save
    """The base class for the encoder--decoder architecture."""
    def __init__(self, encoder, decoder):
        super().__init__()
        self.encoder = encoder
        self.decoder = decoder

    def call(self, enc_X, dec_X, *args):
        enc_all_outputs = self.encoder(enc_X, *args, training=True)
        dec_state = self.decoder.init_state(enc_all_outputs, *args)
        # Return decoder output only
        return self.decoder(dec_X, dec_state, training=True)[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class EncoderDecoder(d2l.Classifier):  #@save
    """The base class for the encoder--decoder architecture."""
    encoder: nn.Module
    decoder: nn.Module
    training: bool

    def __call__(self, enc_X, dec_X, *args):
        enc_all_outputs = self.encoder(enc_X, *args, training=self.training)
        dec_state = self.decoder.init_state(enc_all_outputs, *args)
        # Return decoder output only
        return self.decoder(dec_X, dec_state, training=self.training)[0]
</code></pre>
<p>In the next section,
we will see how to apply RNNs to design
sequence-to-sequence models based on
this encoder--decoder architecture.</p>
<h2 id="summary-44"><a class="header" href="#summary-44">Summary</a></h2>
<p>Encoder-decoder architectures
can handle inputs and outputs
that both consist of variable-length sequences
and thus are suitable for sequence-to-sequence problems
such as machine translation.
The encoder takes a variable-length sequence as input
and transforms it into a state with a fixed shape.
The decoder maps the encoded state of a fixed shape
to a variable-length sequence.</p>
<h2 id="exercises-62"><a class="header" href="#exercises-62">Exercises</a></h2>
<ol>
<li>Suppose that we use neural networks to implement the encoder--decoder architecture. Do the encoder and the decoder have to be the same type of neural network?</li>
<li>Besides machine translation, can you think of another application where the encoder--decoder architecture can be applied?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/341">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1061">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3864">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18021">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="sequence-to-sequence-learning-for-machine-translation"><a class="header" href="#sequence-to-sequence-learning-for-machine-translation">Sequence-to-Sequence Learning for Machine Translation</a></h1>
<p>:label:<code>sec_seq2seq</code></p>
<p>In so-called sequence-to-sequence problems such as machine translation
(as discussed in :numref:<code>sec_machine_translation</code>),
where inputs and outputs each consist
of variable-length unaligned sequences,
we generally rely on encoder--decoder architectures
(:numref:<code>sec_encoder-decoder</code>).
In this section,
we will demonstrate the application
of an encoder--decoder architecture,
where both the encoder and decoder
are implemented as RNNs,
to the task of machine translation
:cite:<code>Sutskever.Vinyals.Le.2014,Cho.Van-Merrienboer.Gulcehre.ea.2014</code>.</p>
<p>Here, the encoder RNN will take a variable-length sequence as input
and transform it into a fixed-shape hidden state.
Later, in :numref:<code>chap_attention-and-transformers</code>,
we will introduce attention mechanisms,
which allow us to access encoded inputs
without having to compress the entire input
into a single fixed-length representation.</p>
<p>Then to generate the output sequence,
one token at a time,
the decoder model,
consisting of a separate RNN,
will predict each successive target token
given both the input sequence
and the preceding tokens in the output.
During training, the decoder will typically
be conditioned upon the preceding tokens
in the official "ground truth" label.
However, at test time, we will want to condition
each output of the decoder on the tokens already predicted.
Note that if we ignore the encoder,
the decoder in a sequence-to-sequence architecture
behaves just like a normal language model.
:numref:<code>fig_seq2seq</code> illustrates
how to use two RNNs
for sequence-to-sequence learning
in machine translation.</p>
<p><img src="chapter_recurrent-modern/../img/seq2seq.svg" alt="Sequence-to-sequence learning with an RNN encoder and an RNN decoder." />
:label:<code>fig_seq2seq</code></p>
<p>In :numref:<code>fig_seq2seq</code>,
the special "&lt;eos&gt;" token
marks the end of the sequence.
Our model can stop making predictions
once this token is generated.
At the initial time step of the RNN decoder,
there are two special design decisions to be aware of:
First, we begin every input with a special
beginning-of-sequence "&lt;bos&gt;" token.
Second, we may feed
the final hidden state of the encoder
into the decoder
at every single decoding time step :cite:<code>Cho.Van-Merrienboer.Gulcehre.ea.2014</code>.
In some other designs,
such as that of :citet:<code>Sutskever.Vinyals.Le.2014</code>,
the final hidden state of the RNN encoder
is used
to initiate the hidden state of the decoder
only at the first decoding step.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
import collections
from d2l import mxnet as d2l
import math
from mxnet import np, npx, init, gluon, autograd
from mxnet.gluon import nn, rnn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
import collections
from d2l import torch as d2l
import math
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import collections
from d2l import tensorflow as d2l
import math
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import collections
from d2l import jax as d2l
from flax import linen as nn
from functools import partial
import jax
from jax import numpy as jnp
import math
import optax
</code></pre>
<h2 id="teacher-forcing"><a class="header" href="#teacher-forcing">Teacher Forcing</a></h2>
<p>While running the encoder on the input sequence
is relatively straightforward,
handling the input and output
of the decoder requires more care.
The most common approach is sometimes called <em>teacher forcing</em>.
Here, the original target sequence (token labels)
is fed into the decoder as input.
More concretely,
the special beginning-of-sequence token
and the original target sequence,
excluding the final token,
are concatenated as input to the decoder,
while the decoder output (labels for training) is
the original target sequence,
shifted by one token:
"&lt;bos&gt;", "Ils", "regardent", "." $\rightarrow$
"Ils", "regardent", ".", "&lt;eos&gt;" (:numref:<code>fig_seq2seq</code>).</p>
<p>Our implementation in
:numref:<code>subsec_loading-seq-fixed-len</code>
prepared training data for teacher forcing,
where shifting tokens for self-supervised learning
is similar to the training of language models in
:numref:<code>sec_language-model</code>.
An alternative approach is
to feed the <em>predicted</em> token
from the previous time step
as the current input to the decoder.</p>
<p>In the following, we explain the design
depicted in :numref:<code>fig_seq2seq</code>
in greater detail.
We will train this model for machine translation
on the English--French dataset as introduced in
:numref:<code>sec_machine_translation</code>.</p>
<h2 id="encoder-1"><a class="header" href="#encoder-1">Encoder</a></h2>
<p>Recall that the encoder transforms an input sequence of variable length
into a fixed-shape <em>context variable</em> $\mathbf{c}$ (see :numref:<code>fig_seq2seq</code>).</p>
<p>Consider a single sequence example (batch size 1).
Suppose the input sequence is $x_1, \ldots, x_T$,
such that $x_t$ is the $t^{\textrm{th}}$ token.
At time step $t$, the RNN transforms
the input feature vector $\mathbf{x}_t$ for $x_t$
and the hidden state $\mathbf{h} _{t-1}$
from the previous time step
into the current hidden state $\mathbf{h}_t$.
We can use a function $f$ to express
the transformation of the RNN's recurrent layer:</p>
<p>$$\mathbf{h}_t = f(\mathbf{x}<em>t, \mathbf{h}</em>{t-1}). $$</p>
<p>In general, the encoder transforms
the hidden states at all time steps
into a context variable through a customized function $q$:</p>
<p>$$\mathbf{c} =  q(\mathbf{h}_1, \ldots, \mathbf{h}_T).$$</p>
<p>For example, in :numref:<code>fig_seq2seq</code>,
the context variable is just the hidden state $\mathbf{h}_T$
corresponding to the encoder RNN's representation
after processing the final token of the input sequence.</p>
<p>In this example, we have used a unidirectional RNN
to design the encoder,
where the hidden state only depends on the input subsequence
at and before the time step of the hidden state.
We can also construct encoders using bidirectional RNNs.
In this case, a hidden state depends on the subsequence before and after the time step
(including the input at the current time step),
which encodes the information of the entire sequence.</p>
<p>Now let's [<strong>implement the RNN encoder</strong>].
Note that we use an <em>embedding layer</em>
to obtain the feature vector for each token in the input sequence.
The weight of an embedding layer is a matrix,
where the number of rows corresponds to
the size of the input vocabulary (<code>vocab_size</code>)
and number of columns corresponds to
the feature vector's dimension (<code>embed_size</code>).
For any input token index $i$,
the embedding layer fetches the $i^{\textrm{th}}$ row
(starting from 0) of the weight matrix
to return its feature vector.
Here we implement the encoder with a multilayer GRU.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Seq2SeqEncoder(d2l.Encoder):  #@save
    """The RNN encoder for sequence-to-sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(num_hiddens, num_layers, dropout)
        self.initialize(init.Xavier())
            
    def forward(self, X, *args):
        # X shape: (batch_size, num_steps)
        embs = self.embedding(d2l.transpose(X))
        # embs shape: (num_steps, batch_size, embed_size)    
        outputs, state = self.rnn(embs)
        # outputs shape: (num_steps, batch_size, num_hiddens)
        # state shape: (num_layers, batch_size, num_hiddens)
        return outputs, state
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def init_seq2seq(module):  #@save
    """Initialize weights for sequence-to-sequence learning."""
    if type(module) == nn.Linear:
         nn.init.xavier_uniform_(module.weight)
    if type(module) == nn.GRU:
        for param in module._flat_weights_names:
            if "weight" in param:
                nn.init.xavier_uniform_(module._parameters[param])
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Seq2SeqEncoder(d2l.Encoder):  #@save
    """The RNN encoder for sequence-to-sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(embed_size, num_hiddens, num_layers, dropout)
        self.apply(init_seq2seq)
            
    def forward(self, X, *args):
        # X shape: (batch_size, num_steps)
        embs = self.embedding(d2l.astype(d2l.transpose(X), d2l.int64))
        # embs shape: (num_steps, batch_size, embed_size)
        outputs, state = self.rnn(embs)
        # outputs shape: (num_steps, batch_size, num_hiddens)
        # state shape: (num_layers, batch_size, num_hiddens)
        return outputs, state
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Seq2SeqEncoder(d2l.Encoder):  #@save
    """The RNN encoder for sequence-to-sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = tf.keras.layers.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(num_hiddens, num_layers, dropout)
            
    def call(self, X, *args):
        # X shape: (batch_size, num_steps)
        embs = self.embedding(d2l.transpose(X))
        # embs shape: (num_steps, batch_size, embed_size)    
        outputs, state = self.rnn(embs)
        # outputs shape: (num_steps, batch_size, num_hiddens)
        # state shape: (num_layers, batch_size, num_hiddens)
        return outputs, state
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Seq2SeqEncoder(d2l.Encoder):  #@save
    """The RNN encoder for sequence-to-sequence learning."""
    vocab_size: int
    embed_size: int
    num_hiddens: int
    num_layers: int
    dropout: float = 0

    def setup(self):
        self.embedding = nn.Embed(self.vocab_size, self.embed_size)
        self.rnn = d2l.GRU(self.num_hiddens, self.num_layers, self.dropout)

    def __call__(self, X, *args, training=False):
        # X shape: (batch_size, num_steps)
        embs = self.embedding(d2l.astype(d2l.transpose(X), d2l.int32))
        # embs shape: (num_steps, batch_size, embed_size)
        outputs, state = self.rnn(embs, training=training)
        # outputs shape: (num_steps, batch_size, num_hiddens)
        # state shape: (num_layers, batch_size, num_hiddens)
        return outputs, state
</code></pre>
<p>Let's use a concrete example
to [<strong>illustrate the above encoder implementation.</strong>]
Below, we instantiate a two-layer GRU encoder
whose number of hidden units is 16.
Given a minibatch of sequence inputs <code>X</code>
(batch size $=4$; number of time steps $=9$),
the hidden states of the final layer
at all the time steps
(<code>enc_outputs</code> returned by the encoder's recurrent layers)
are a tensor of shape
(number of time steps, batch size, number of hidden units).</p>
<pre><code class="language-{.python .input}">%%tab all
vocab_size, embed_size, num_hiddens, num_layers = 10, 8, 16, 2
batch_size, num_steps = 4, 9
encoder = Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers)
X = d2l.zeros((batch_size, num_steps))
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    enc_outputs, enc_state = encoder(X)
if tab.selected('jax'):
    (enc_outputs, enc_state), _ = encoder.init_with_output(d2l.get_key(), X)

d2l.check_shape(enc_outputs, (num_steps, batch_size, num_hiddens))
</code></pre>
<p>Since we are using a GRU here,
the shape of the multilayer hidden states
at the final time step is
(number of hidden layers, batch size, number of hidden units).</p>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('mxnet', 'pytorch', 'jax'):
    d2l.check_shape(enc_state, (num_layers, batch_size, num_hiddens))
if tab.selected('tensorflow'):
    d2l.check_len(enc_state, num_layers)
    d2l.check_shape(enc_state[0], (batch_size, num_hiddens))
</code></pre>
<h2 id="decoder-1"><a class="header" href="#decoder-1">[<strong>Decoder</strong>]</a></h2>
<p>:label:<code>sec_seq2seq_decoder</code></p>
<p>Given a target output sequence $y_1, y_2, \ldots, y_{T'}$
for each time step $t'$
(we use $t^\prime$ to differentiate from the input sequence time steps),
the decoder assigns a predicted probability
to each possible token occurring at step $y_{t'+1}$
conditioned upon the previous tokens in the target
$y_1, \ldots, y_{t'}$
and the context variable
$\mathbf{c}$, i.e., $P(y_{t'+1} \mid y_1, \ldots, y_{t'}, \mathbf{c})$.</p>
<p>To predict the subsequent token $t^\prime+1$ in the target sequence,
the RNN decoder takes the previous step's target token $y_{t^\prime}$,
the hidden RNN state from the previous time step $\mathbf{s}<em>{t^\prime-1}$,
and the context variable $\mathbf{c}$ as its input,
and transforms them into the hidden state
$\mathbf{s}</em>{t^\prime}$ at the current time step.
We can use a function $g$ to express
the transformation of the decoder's hidden layer:</p>
<p>$$\mathbf{s}<em>{t^\prime} = g(y</em>{t^\prime-1}, \mathbf{c}, \mathbf{s}_{t^\prime-1}).$$
:eqlabel:<code>eq_seq2seq_s_t</code></p>
<p>After obtaining the hidden state of the decoder,
we can use an output layer and the softmax operation
to compute the predictive distribution
$p(y_{t^{\prime}+1} \mid y_1, \ldots, y_{t^\prime}, \mathbf{c})$
over the subsequent output token ${t^\prime+1}$.</p>
<p>Following :numref:<code>fig_seq2seq</code>,
when implementing the decoder as follows,
we directly use the hidden state at the final time step
of the encoder
to initialize the hidden state of the decoder.
This requires that the RNN encoder and the RNN decoder
have the same number of layers and hidden units.
To further incorporate the encoded input sequence information,
the context variable is concatenated
with the decoder input at all the time steps.
To predict the probability distribution of the output token,
we use a fully connected layer
to transform the hidden state
at the final layer of the RNN decoder.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Seq2SeqDecoder(d2l.Decoder):
    """The RNN decoder for sequence to sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(num_hiddens, num_layers, dropout)
        self.dense = nn.Dense(vocab_size, flatten=False)
        self.initialize(init.Xavier())
            
    def init_state(self, enc_all_outputs, *args):
        return enc_all_outputs 

    def forward(self, X, state):
        # X shape: (batch_size, num_steps)
        # embs shape: (num_steps, batch_size, embed_size)
        embs = self.embedding(d2l.transpose(X))
        enc_output, hidden_state = state
        # context shape: (batch_size, num_hiddens)
        context = enc_output[-1]
        # Broadcast context to (num_steps, batch_size, num_hiddens)
        context = np.tile(context, (embs.shape[0], 1, 1))
        # Concat at the feature dimension
        embs_and_context = d2l.concat((embs, context), -1)
        outputs, hidden_state = self.rnn(embs_and_context, hidden_state)
        outputs = d2l.swapaxes(self.dense(outputs), 0, 1)
        # outputs shape: (batch_size, num_steps, vocab_size)
        # hidden_state shape: (num_layers, batch_size, num_hiddens)
        return outputs, [enc_output, hidden_state]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Seq2SeqDecoder(d2l.Decoder):
    """The RNN decoder for sequence to sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(embed_size+num_hiddens, num_hiddens,
                           num_layers, dropout)
        self.dense = nn.LazyLinear(vocab_size)
        self.apply(init_seq2seq)
            
    def init_state(self, enc_all_outputs, *args):
        return enc_all_outputs

    def forward(self, X, state):
        # X shape: (batch_size, num_steps)
        # embs shape: (num_steps, batch_size, embed_size)
        embs = self.embedding(d2l.astype(d2l.transpose(X), d2l.int32))
        enc_output, hidden_state = state
        # context shape: (batch_size, num_hiddens)
        context = enc_output[-1]
        # Broadcast context to (num_steps, batch_size, num_hiddens)
        context = context.repeat(embs.shape[0], 1, 1)
        # Concat at the feature dimension
        embs_and_context = d2l.concat((embs, context), -1)
        outputs, hidden_state = self.rnn(embs_and_context, hidden_state)
        outputs = d2l.swapaxes(self.dense(outputs), 0, 1)
        # outputs shape: (batch_size, num_steps, vocab_size)
        # hidden_state shape: (num_layers, batch_size, num_hiddens)
        return outputs, [enc_output, hidden_state]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Seq2SeqDecoder(d2l.Decoder):
    """The RNN decoder for sequence to sequence learning."""
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.embedding = tf.keras.layers.Embedding(vocab_size, embed_size)
        self.rnn = d2l.GRU(num_hiddens, num_layers, dropout)
        self.dense = tf.keras.layers.Dense(vocab_size)
            
    def init_state(self, enc_all_outputs, *args):
        return enc_all_outputs

    def call(self, X, state):
        # X shape: (batch_size, num_steps)
        # embs shape: (num_steps, batch_size, embed_size)
        embs = self.embedding(d2l.transpose(X))
        enc_output, hidden_state = state
        # context shape: (batch_size, num_hiddens)
        context = enc_output[-1]
        # Broadcast context to (num_steps, batch_size, num_hiddens)
        context = tf.tile(tf.expand_dims(context, 0), (embs.shape[0], 1, 1))
        # Concat at the feature dimension
        embs_and_context = d2l.concat((embs, context), -1)
        outputs, hidden_state = self.rnn(embs_and_context, hidden_state)
        outputs = d2l.transpose(self.dense(outputs), (1, 0, 2))
        # outputs shape: (batch_size, num_steps, vocab_size)
        # hidden_state shape: (num_layers, batch_size, num_hiddens)
        return outputs, [enc_output, hidden_state]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Seq2SeqDecoder(d2l.Decoder):
    """The RNN decoder for sequence to sequence learning."""
    vocab_size: int
    embed_size: int
    num_hiddens: int
    num_layers: int
    dropout: float = 0

    def setup(self):
        self.embedding = nn.Embed(self.vocab_size, self.embed_size)
        self.rnn = d2l.GRU(self.num_hiddens, self.num_layers, self.dropout)
        self.dense = nn.Dense(self.vocab_size)

    def init_state(self, enc_all_outputs, *args):
        return enc_all_outputs

    def __call__(self, X, state, training=False):
        # X shape: (batch_size, num_steps)
        # embs shape: (num_steps, batch_size, embed_size)
        embs = self.embedding(d2l.astype(d2l.transpose(X), d2l.int32))
        enc_output, hidden_state = state
        # context shape: (batch_size, num_hiddens)
        context = enc_output[-1]
        # Broadcast context to (num_steps, batch_size, num_hiddens)
        context = jnp.tile(context, (embs.shape[0], 1, 1))
        # Concat at the feature dimension
        embs_and_context = d2l.concat((embs, context), -1)
        outputs, hidden_state = self.rnn(embs_and_context, hidden_state,
                                         training=training)
        outputs = d2l.swapaxes(self.dense(outputs), 0, 1)
        # outputs shape: (batch_size, num_steps, vocab_size)
        # hidden_state shape: (num_layers, batch_size, num_hiddens)
        return outputs, [enc_output, hidden_state]
</code></pre>
<p>To [<strong>illustrate the implemented decoder</strong>],
below we instantiate it with the same hyperparameters from the aforementioned encoder.
As we can see, the output shape of the decoder becomes (batch size, number of time steps, vocabulary size),
where the final dimension of the tensor stores the predicted token distribution.</p>
<pre><code class="language-{.python .input}">%%tab all
decoder = Seq2SeqDecoder(vocab_size, embed_size, num_hiddens, num_layers)
if tab.selected('mxnet', 'pytorch', 'tensorflow'):
    state = decoder.init_state(encoder(X))
    dec_outputs, state = decoder(X, state)
if tab.selected('jax'):
    state = decoder.init_state(encoder.init_with_output(d2l.get_key(), X)[0])
    (dec_outputs, state), _ = decoder.init_with_output(d2l.get_key(), X,
                                                       state)


d2l.check_shape(dec_outputs, (batch_size, num_steps, vocab_size))
if tab.selected('mxnet', 'pytorch', 'jax'):
    d2l.check_shape(state[1], (num_layers, batch_size, num_hiddens))
if tab.selected('tensorflow'):
    d2l.check_len(state[1], num_layers)
    d2l.check_shape(state[1][0], (batch_size, num_hiddens))
</code></pre>
<p>The layers in the above RNN encoder--decoder model
are summarized in :numref:<code>fig_seq2seq_details</code>.</p>
<p><img src="chapter_recurrent-modern/../img/seq2seq-details.svg" alt="Layers in an RNN encoder--decoder model." />
:label:<code>fig_seq2seq_details</code></p>
<h2 id="encoder--decoder-for-sequence-to-sequence-learning"><a class="header" href="#encoder--decoder-for-sequence-to-sequence-learning">Encoder--Decoder for Sequence-to-Sequence Learning</a></h2>
<p>Putting it all together in code yields the following:</p>
<pre><code class="language-{.python .input}">%%tab pytorch, tensorflow, mxnet
class Seq2Seq(d2l.EncoderDecoder):  #@save
    """The RNN encoder--decoder for sequence to sequence learning."""
    def __init__(self, encoder, decoder, tgt_pad, lr):
        super().__init__(encoder, decoder)
        self.save_hyperparameters()
        
    def validation_step(self, batch):
        Y_hat = self(*batch[:-1])
        self.plot('loss', self.loss(Y_hat, batch[-1]), train=False)
        
    def configure_optimizers(self):
        # Adam optimizer is used here
        if tab.selected('mxnet'):
            return gluon.Trainer(self.parameters(), 'adam',
                                 {'learning_rate': self.lr})
        if tab.selected('pytorch'):
            return torch.optim.Adam(self.parameters(), lr=self.lr)
        if tab.selected('tensorflow'):
            return tf.keras.optimizers.Adam(learning_rate=self.lr)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Seq2Seq(d2l.EncoderDecoder):  #@save
    """The RNN encoder--decoder for sequence to sequence learning."""
    encoder: nn.Module
    decoder: nn.Module
    tgt_pad: int
    lr: float

    def validation_step(self, params, batch, state):
        l, _ = self.loss(params, batch[:-1], batch[-1], state)
        self.plot('loss', l, train=False)

    def configure_optimizers(self):
        # Adam optimizer is used here
        return optax.adam(learning_rate=self.lr)
</code></pre>
<h2 id="loss-function-with-masking"><a class="header" href="#loss-function-with-masking">Loss Function with Masking</a></h2>
<p>At each time step, the decoder predicts
a probability distribution for the output tokens.
As with language modeling,
we can apply softmax
to obtain the distribution
and calculate the cross-entropy loss for optimization.
Recall from :numref:<code>sec_machine_translation</code>
that the special padding tokens
are appended to the end of sequences
and so sequences of varying lengths
can be efficiently loaded
in minibatches of the same shape.
However, prediction of padding tokens
should be excluded from loss calculations.
To this end, we can
[<strong>mask irrelevant entries with zero values</strong>]
so that multiplication
of any irrelevant prediction
with zero equates to zero.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(Seq2Seq)
def loss(self, Y_hat, Y):
    l = super(Seq2Seq, self).loss(Y_hat, Y, averaged=False)
    mask = d2l.astype(d2l.reshape(Y, -1) != self.tgt_pad, d2l.float32)
    return d2l.reduce_sum(l * mask) / d2l.reduce_sum(mask)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(Seq2Seq)
@partial(jax.jit, static_argnums=(0, 5))
def loss(self, params, X, Y, state, averaged=False):
    Y_hat = state.apply_fn({'params': params}, *X,
                           rngs={'dropout': state.dropout_rng})
    Y_hat = d2l.reshape(Y_hat, (-1, Y_hat.shape[-1]))
    Y = d2l.reshape(Y, (-1,))
    fn = optax.softmax_cross_entropy_with_integer_labels
    l = fn(Y_hat, Y)
    mask = d2l.astype(d2l.reshape(Y, -1) != self.tgt_pad, d2l.float32)
    return d2l.reduce_sum(l * mask) / d2l.reduce_sum(mask), {}
</code></pre>
<h2 id="training-19"><a class="header" href="#training-19">[<strong>Training</strong>]</a></h2>
<p>:label:<code>sec_seq2seq_training</code></p>
<p>Now we can [<strong>create and train an RNN encoder--decoder model</strong>]
for sequence-to-sequence learning on the machine translation dataset.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.MTFraEng(batch_size=128) 
embed_size, num_hiddens, num_layers, dropout = 256, 256, 2, 0.2
if tab.selected('mxnet', 'pytorch', 'jax'):
    encoder = Seq2SeqEncoder(
        len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout)
    decoder = Seq2SeqDecoder(
        len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout)
if tab.selected('mxnet', 'pytorch'):
    model = Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                    lr=0.005)
if tab.selected('jax'):
    model = Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                    lr=0.005, training=True)
if tab.selected('mxnet', 'pytorch', 'jax'):
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        encoder = Seq2SeqEncoder(
            len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout)
        decoder = Seq2SeqDecoder(
            len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout)
        model = Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                        lr=0.005)
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<h2 id="prediction-2"><a class="header" href="#prediction-2">[<strong>Prediction</strong>]</a></h2>
<p>To predict the output sequence
at each step,
the predicted token from the previous
time step is fed into the decoder as an input.
One simple strategy is to sample whichever token
that has been assigned by the decoder the highest probability
when predicting at each step.
As in training, at the initial time step
the beginning-of-sequence ("&lt;bos&gt;") token
is fed into the decoder.
This prediction process
is illustrated in :numref:<code>fig_seq2seq_predict</code>.
When the end-of-sequence ("&lt;eos&gt;") token is predicted,
the prediction of the output sequence is complete.</p>
<p><img src="chapter_recurrent-modern/../img/seq2seq-predict.svg" alt="Predicting the output sequence token by token using an RNN encoder--decoder." />
:label:<code>fig_seq2seq_predict</code></p>
<p>In the next section, we will introduce
more sophisticated strategies
based on beam search (:numref:<code>sec_beam-search</code>).</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
@d2l.add_to_class(d2l.EncoderDecoder)  #@save
def predict_step(self, batch, device, num_steps,
                 save_attention_weights=False):
    if tab.selected('mxnet', 'pytorch'):
        batch = [d2l.to(a, device) for a in batch]
    src, tgt, src_valid_len, _ = batch
    if tab.selected('mxnet', 'pytorch'):
        enc_all_outputs = self.encoder(src, src_valid_len)
    if tab.selected('tensorflow'):
        enc_all_outputs = self.encoder(src, src_valid_len, training=False)
    dec_state = self.decoder.init_state(enc_all_outputs, src_valid_len)
    outputs, attention_weights = [d2l.expand_dims(tgt[:, 0], 1), ], []
    for _ in range(num_steps):
        if tab.selected('mxnet', 'pytorch'):
            Y, dec_state = self.decoder(outputs[-1], dec_state)
        if tab.selected('tensorflow'):
            Y, dec_state = self.decoder(outputs[-1], dec_state, training=False)
        outputs.append(d2l.argmax(Y, 2))
        # Save attention weights (to be covered later)
        if save_attention_weights:
            attention_weights.append(self.decoder.attention_weights)
    return d2l.concat(outputs[1:], 1), attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(d2l.EncoderDecoder)  #@save
def predict_step(self, params, batch, num_steps,
                 save_attention_weights=False):
    src, tgt, src_valid_len, _ = batch
    enc_all_outputs, inter_enc_vars = self.encoder.apply(
        {'params': params['encoder']}, src, src_valid_len, training=False,
        mutable='intermediates')
    # Save encoder attention weights if inter_enc_vars containing encoder
    # attention weights is not empty. (to be covered later)
    enc_attention_weights = []
    if bool(inter_enc_vars) and save_attention_weights:
        # Encoder Attention Weights saved in the intermediates collection
        enc_attention_weights = inter_enc_vars[
            'intermediates']['enc_attention_weights'][0]

    dec_state = self.decoder.init_state(enc_all_outputs, src_valid_len)
    outputs, attention_weights = [d2l.expand_dims(tgt[:,0], 1), ], []
    for _ in range(num_steps):
        (Y, dec_state), inter_dec_vars = self.decoder.apply(
            {'params': params['decoder']}, outputs[-1], dec_state,
            training=False, mutable='intermediates')
        outputs.append(d2l.argmax(Y, 2))
        # Save attention weights (to be covered later)
        if save_attention_weights:
            # Decoder Attention Weights saved in the intermediates collection
            dec_attention_weights = inter_dec_vars[
                'intermediates']['dec_attention_weights'][0]
            attention_weights.append(dec_attention_weights)
    return d2l.concat(outputs[1:], 1), (attention_weights,
                                        enc_attention_weights)
</code></pre>
<h2 id="evaluation-of-predicted-sequences"><a class="header" href="#evaluation-of-predicted-sequences">Evaluation of Predicted Sequences</a></h2>
<p>We can evaluate a predicted sequence
by comparing it with the
target sequence (the ground truth).
But what precisely is the appropriate measure
for comparing similarity between two sequences?</p>
<p>Bilingual Evaluation Understudy (BLEU),
though originally proposed for evaluating
machine translation results :cite:<code>Papineni.Roukos.Ward.ea.2002</code>,
has been extensively used in measuring
the quality of output sequences for different applications.
In principle, for any $n$-gram (:numref:<code>subsec_markov-models-and-n-grams</code>) in the predicted sequence,
BLEU evaluates whether this $n$-gram appears
in the target sequence.</p>
<p>Denote by $p_n$ the precision of an $n$-gram,
defined as the ratio
of the number of matched $n$-grams in
the predicted and target sequences
to the number of $n$-grams in the predicted sequence.
To explain, given a target sequence $A$, $B$, $C$, $D$, $E$, $F$,
and a predicted sequence $A$, $B$, $B$, $C$, $D$,
we have $p_1 = 4/5$,  $p_2 = 3/4$, $p_3 = 1/3$, and $p_4 = 0$.
Now let $\textrm{len}<em>{\textrm{label}}$ and $\textrm{len}</em>{\textrm{pred}}$
be the numbers of tokens in the target sequence
and the predicted sequence, respectively.
Then, BLEU is defined as</p>
<p>$$ \exp\left(\min\left(0, 1 - \frac{\textrm{len}<em>{\textrm{label}}}{\textrm{len}</em>{\textrm{pred}}}\right)\right) \prod_{n=1}^k p_n^{1/2^n},$$
:eqlabel:<code>eq_bleu</code></p>
<p>where $k$ is the longest $n$-gram for matching.</p>
<p>Based on the definition of BLEU in :eqref:<code>eq_bleu</code>,
whenever the predicted sequence is the same as the target sequence, BLEU is 1.
Moreover,
since matching longer $n$-grams is more difficult,
BLEU assigns a greater weight
when a longer $n$-gram has high precision.
Specifically, when $p_n$ is fixed,
$p_n^{1/2^n}$ increases as $n$ grows (the original paper uses $p_n^{1/n}$).
Furthermore,
since
predicting shorter sequences
tends to yield a higher $p_n$ value,
the coefficient before the multiplication term in :eqref:<code>eq_bleu</code>
penalizes shorter predicted sequences.
For example, when $k=2$,
given the target sequence $A$, $B$, $C$, $D$, $E$, $F$ and the predicted sequence $A$, $B$,
although $p_1 = p_2 = 1$, the penalty factor $\exp(1-6/2) \approx 0.14$ lowers the BLEU.</p>
<p>We [<strong>implement the BLEU measure</strong>] as follows.</p>
<pre><code class="language-{.python .input}">%%tab all
def bleu(pred_seq, label_seq, k):  #@save
    """Compute the BLEU."""
    pred_tokens, label_tokens = pred_seq.split(' '), label_seq.split(' ')
    len_pred, len_label = len(pred_tokens), len(label_tokens)
    score = math.exp(min(0, 1 - len_label / len_pred))
    for n in range(1, min(k, len_pred) + 1):
        num_matches, label_subs = 0, collections.defaultdict(int)
        for i in range(len_label - n + 1):
            label_subs[' '.join(label_tokens[i: i + n])] += 1
        for i in range(len_pred - n + 1):
            if label_subs[' '.join(pred_tokens[i: i + n])] &gt; 0:
                num_matches += 1
                label_subs[' '.join(pred_tokens[i: i + n])] -= 1
        score *= math.pow(num_matches / (len_pred - n + 1), math.pow(0.5, n))
    return score
</code></pre>
<p>In the end,
we use the trained RNN encoder--decoder
to [<strong>translate a few English sentences into French</strong>]
and compute the BLEU of the results.</p>
<pre><code class="language-{.python .input}">%%tab all
engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .']
fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .']
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    preds, _ = model.predict_step(
        data.build(engs, fras), d2l.try_gpu(), data.num_steps)
if tab.selected('jax'):
    preds, _ = model.predict_step(trainer.state.params, data.build(engs, fras),
                                  data.num_steps)
for en, fr, p in zip(engs, fras, preds):
    translation = []
    for token in data.tgt_vocab.to_tokens(p):
        if token == '&lt;eos&gt;':
            break
        translation.append(token)        
    print(f'{en} =&gt; {translation}, bleu,'
          f'{bleu(" ".join(translation), fr, k=2):.3f}')
</code></pre>
<h2 id="summary-45"><a class="header" href="#summary-45">Summary</a></h2>
<p>Following the design of the encoder--decoder architecture, we can use two RNNs to design a model for sequence-to-sequence learning.
In encoder--decoder training, the teacher forcing approach feeds original output sequences (in contrast to predictions) into the decoder.
When implementing the encoder and the decoder, we can use multilayer RNNs.
We can use masks to filter out irrelevant computations, such as when calculating the loss.
For evaluating output sequences,
BLEU is a popular measure that matches $n$-grams between the predicted sequence and the target sequence.</p>
<h2 id="exercises-63"><a class="header" href="#exercises-63">Exercises</a></h2>
<ol>
<li>Can you adjust the hyperparameters to improve the translation results?</li>
<li>Rerun the experiment without using masks in the loss calculation. What results do you observe? Why?</li>
<li>If the encoder and the decoder differ in the number of layers or the number of hidden units, how can we initialize the hidden state of the decoder?</li>
<li>In training, replace teacher forcing with feeding the prediction at the previous time step into the decoder. How does this influence the performance?</li>
<li>Rerun the experiment by replacing GRU with LSTM.</li>
<li>Are there any other ways to design the output layer of the decoder?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/345">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1062">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3865">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18022">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beam-search"><a class="header" href="#beam-search">Beam Search</a></h1>
<p>:label:<code>sec_beam-search</code></p>
<p>In :numref:<code>sec_seq2seq</code>,
we introduced the encoder--decoder architecture,
and the standard techniques for training them end-to-end. However, when it came to test-time prediction,
we mentioned only the <em>greedy</em> strategy,
where we select at each time step
the token given the highest
predicted probability of coming next,
until, at some time step,
we find that we have predicted
the special end-of-sequence "&lt;eos&gt;" token.
In this section, we will begin
by formalizing this <em>greedy search</em> strategy
and identifying some problems
that practitioners tend to run into.
Subsequently, we compare this strategy
with two alternatives:
<em>exhaustive search</em> (illustrative but not practical)
and <em>beam search</em> (the standard method in practice).</p>
<p>Let's begin by setting up our mathematical notation,
borrowing conventions from :numref:<code>sec_seq2seq</code>.
At any time step $t'$, the decoder outputs
predictions representing the probability
of each token in the vocabulary
coming next in the sequence
(the likely value of $y_{t'+1}$),
conditioned on the previous tokens
$y_1, \ldots, y_{t'}$ and
the context variable $\mathbf{c}$,
produced by the encoder
to represent the input sequence.
To quantify computational cost,
denote by $\mathcal{Y}$
the output vocabulary
(including the special end-of-sequence token "&lt;eos&gt;").
Let's also specify the maximum number of tokens
of an output sequence as $T'$.
Our goal is to search for an ideal output from all
$\mathcal{O}(\left|\mathcal{Y}\right|^{T'})$
possible output sequences.
Note that this slightly overestimates
the number of distinct outputs
because there are no subsequent tokens
once the  "&lt;eos&gt;" token occurs.
However, for our purposes,
this number roughly captures
the size of the search space.</p>
<h2 id="greedy-search"><a class="header" href="#greedy-search">Greedy Search</a></h2>
<p>Consider the simple <em>greedy search</em> strategy from :numref:<code>sec_seq2seq</code>.
Here, at any time step $t'$,
we simply select the token
with the highest conditional probability
from $\mathcal{Y}$, i.e.,</p>
<p>$$y_{t'} = \operatorname*{argmax}<em>{y \in \mathcal{Y}} P(y \mid y_1, \ldots, y</em>{t'-1}, \mathbf{c}).$$</p>
<p>Once our model outputs "&lt;eos&gt;"
(or we reach the maximum length $T'$)
the output sequence is completed.</p>
<p>This strategy might look reasonable,
and in fact it is not so bad!
Considering how computationally undemanding it is,
you'd be hard pressed to get more bang for your buck.
However, if we put aside efficiency for a minute,
it might seem more reasonable to search
for the <em>most likely sequence</em>,
not the sequence of (greedily selected) <em>most likely tokens</em>.
It turns out that these two objects can be quite different.
The most likely sequence is the one that maximizes the expression
$\prod_{t'=1}^{T'} P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c})$.
In our machine translation example,
if the decoder truly recovered the probabilities
of the underlying generative process,
then this would give us the most likely translation.
Unfortunately, there is no guarantee
that greedy search will give us this sequence.</p>
<p>Let's illustrate it with an example.
Suppose that there are four tokens
"A", "B", "C", and "&lt;eos&gt;" in the output dictionary.
In :numref:<code>fig_s2s-prob1</code>,
the four numbers under each time step represent
the conditional probabilities of generating "A", "B", "C",
and "&lt;eos&gt;" respectively, at that time step.</p>
<p><img src="chapter_recurrent-modern/../img/s2s-prob1.svg" alt="At each time step, greedy search selects the token with the highest conditional probability." />
:label:<code>fig_s2s-prob1</code></p>
<p>At each time step, greedy search selects
the token with the highest conditional probability.
Therefore, the output sequence "A", "B", "C", and "&lt;eos&gt;"
will be predicted (:numref:<code>fig_s2s-prob1</code>).
The conditional probability of this output sequence
is $0.5\times0.4\times0.4\times0.6 = 0.048$.</p>
<p>Next, let's look at another example in :numref:<code>fig_s2s-prob2</code>.
Unlike in :numref:<code>fig_s2s-prob1</code>,
at time step 2 we select the token "C",
which has the <em>second</em> highest conditional probability.</p>
<p><img src="chapter_recurrent-modern/../img/s2s-prob2.svg" alt="The four numbers under each time step represent the conditional probabilities of generating &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, and &quot;&lt;eos&gt;&quot; at that time step. At time step 2, the token &quot;C&quot;, which has the second highest conditional probability, is selected." />
:label:<code>fig_s2s-prob2</code></p>
<p>Since the output subsequences at time steps 1 and 2,
on which time step 3 is based,
have changed from "A" and "B" in :numref:<code>fig_s2s-prob1</code>
to "A" and "C" in :numref:<code>fig_s2s-prob2</code>,
the conditional probability of each token
at time step 3 has also changed in :numref:<code>fig_s2s-prob2</code>.
Suppose that we choose the token "B" at time step 3.
Now time step 4 is conditional on
the output subsequence at the first three time steps
"A", "C", and "B",
which has changed from "A", "B", and "C" in :numref:<code>fig_s2s-prob1</code>.
Therefore, the conditional probability of generating
each token at time step 4 in :numref:<code>fig_s2s-prob2</code>
is also different from that in :numref:<code>fig_s2s-prob1</code>.
As a result, the conditional probability of the output sequence
"A", "C", "B", and "&lt;eos&gt;" in :numref:<code>fig_s2s-prob2</code>
is $0.5\times0.3 \times0.6\times0.6=0.054$,
which is greater than that of greedy search in :numref:<code>fig_s2s-prob1</code>.
In this example, the output sequence "A", "B", "C", and "&lt;eos&gt;"
obtained by the greedy search is not optimal.</p>
<h2 id="exhaustive-search"><a class="header" href="#exhaustive-search">Exhaustive Search</a></h2>
<p>If the goal is to obtain the most likely sequence,
we may consider using <em>exhaustive search</em>:
enumerate all the possible output sequences
with their conditional probabilities,
and then output the one that scores
the highest predicted probability.</p>
<p>While this would certainly give us what we desire,
it would come at a prohibitive computational cost
of $\mathcal{O}(\left|\mathcal{Y}\right|^{T'})$,
exponential in the sequence length and with an enormous
base given by the vocabulary size.
For example, when $|\mathcal{Y}|=10000$ and $T'=10$,
both small numbers when compared with ones in real applications, we will need to evaluate $10000^{10} = 10^{40}$ sequences, which is already beyond the capabilities of any foreseeable computers.
On the other hand, the computational cost of greedy search is
$\mathcal{O}(\left|\mathcal{Y}\right|T')$:
miraculously cheap but far from optimal.
For example, when $|\mathcal{Y}|=10000$ and $T'=10$,
we only need to evaluate $10000\times10=10^5$ sequences.</p>
<h2 id="beam-search-1"><a class="header" href="#beam-search-1">Beam Search</a></h2>
<p>You could view sequence decoding strategies as lying on a spectrum,
with <em>beam search</em> striking a compromise
between the efficiency of greedy search
and the optimality of exhaustive search.
The most straightforward version of beam search
is characterized by a single hyperparameter,
the <em>beam size</em>, $k$.
Let's explain this terminology.
At time step 1, we select the $k$ tokens
with the highest predicted probabilities.
Each of them will be the first token of
$k$ candidate output sequences, respectively.
At each subsequent time step,
based on the $k$ candidate output sequences
at the previous time step,
we continue to select $k$ candidate output sequences
with the highest predicted probabilities
from $k\left|\mathcal{Y}\right|$ possible choices.</p>
<p><img src="chapter_recurrent-modern/../img/beam-search.svg" alt="The process of beam search (beam size $=2$; maximum length of an output sequence $=3$). The candidate output sequences are $\mathit{A}$, $\mathit{C}$, $\mathit{AB}$, $\mathit{CE}$, $\mathit{ABD}$, and $\mathit{CED}$." />
:label:<code>fig_beam-search</code></p>
<p>:numref:<code>fig_beam-search</code> demonstrates the
process of beam search with an example.
Suppose that the output vocabulary
contains only five elements:
$\mathcal{Y} = {A, B, C, D, E}$,
where one of them is “&lt;eos&gt;”.
Let the beam size be two and
the maximum length of an output sequence be three.
At time step 1,
suppose that the tokens with the highest conditional probabilities
$P(y_1 \mid \mathbf{c})$ are $A$ and $C$.
At time step 2, for all $y_2 \in \mathcal{Y},$
we compute</p>
<p>$$\begin{aligned}P(A, y_2 \mid \mathbf{c}) = P(A \mid \mathbf{c})P(y_2 \mid A, \mathbf{c}),\ P(C, y_2 \mid \mathbf{c}) = P(C \mid \mathbf{c})P(y_2 \mid C, \mathbf{c}),\end{aligned}$$</p>
<p>and pick the largest two among these ten values, say
$P(A, B \mid \mathbf{c})$ and $P(C, E \mid \mathbf{c})$.
Then at time step 3, for all $y_3 \in \mathcal{Y}$, we compute</p>
<p>$$\begin{aligned}P(A, B, y_3 \mid \mathbf{c}) = P(A, B \mid \mathbf{c})P(y_3 \mid A, B, \mathbf{c}),\P(C, E, y_3 \mid \mathbf{c}) = P(C, E \mid \mathbf{c})P(y_3 \mid C, E, \mathbf{c}),\end{aligned}$$</p>
<p>and pick the largest two among these ten values, say
$P(A, B, D \mid \mathbf{c})$   and  $P(C, E, D \mid  \mathbf{c}).$
As a result, we get six candidates output sequences:
(i) $A$; (ii) $C$; (iii) $A$, $B$; (iv) $C$, $E$; (v) $A$, $B$, $D$; and (vi) $C$, $E$, $D$.</p>
<p>In the end, we obtain the set of final candidate output sequences
based on these six sequences (e.g., discard portions including and after “&lt;eos&gt;”).
Then we choose the output sequence which maximizes the following score:</p>
<p>$$ \frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}\mid \mathbf{c}) = \frac{1}{L^\alpha} \sum_{t'=1}^L \log P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c});$$
:eqlabel:<code>eq_beam-search-score</code></p>
<p>here $L$ is the length of the final candidate sequence
and $\alpha$ is usually set to 0.75.
Since a longer sequence has more logarithmic terms
in the summation of :eqref:<code>eq_beam-search-score</code>,
the term $L^\alpha$ in the denominator penalizes
long sequences.</p>
<p>The computational cost of beam search is $\mathcal{O}(k\left|\mathcal{Y}\right|T')$.
This result is in between that of greedy search and that of exhaustive search.
Greedy search can be treated as a special case of beam search
arising when the beam size is set to 1.</p>
<h2 id="summary-46"><a class="header" href="#summary-46">Summary</a></h2>
<p>Sequence searching strategies include
greedy search, exhaustive search, and beam search.
Beam search provides a trade-off between accuracy and
computational cost via the flexible choice of the beam size.</p>
<h2 id="exercises-64"><a class="header" href="#exercises-64">Exercises</a></h2>
<ol>
<li>Can we treat exhaustive search as a special type of beam search? Why or why not?</li>
<li>Apply beam search in the machine translation problem in :numref:<code>sec_seq2seq</code>. How does the beam size affect the translation results and the prediction speed?</li>
<li>We used language modeling for generating text following  user-provided prefixes in :numref:<code>sec_rnn-scratch</code>. Which kind of search strategy does it use? Can you improve it?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/338">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attention-mechanisms-and-transformers"><a class="header" href="#attention-mechanisms-and-transformers">Attention Mechanisms and Transformers</a></h1>
<p>:label:<code>chap_attention-and-transformers</code></p>
<p>The earliest years of the deep learning boom were driven primarily
by results produced using the multilayer perceptron,
convolutional network, and recurrent network architectures.
Remarkably, the model architectures that underpinned
many of deep learning's breakthroughs in the 2010s
had changed remarkably little relative to their
antecedents despite the lapse of nearly 30 years.
While plenty of new methodological innovations
made their way into most practitioner's toolkits---ReLU
activations, residual layers, batch normalization, dropout,
and adaptive learning rate schedules come to mind---the core
underlying architectures were clearly recognizable as
scaled-up implementations of classic ideas.
Despite thousands of papers proposing alternative ideas,
models resembling classical convolutional neural networks (:numref:<code>chap_cnn</code>)
retained <em>state-of-the-art</em> status in computer vision
and models resembling Sepp Hochreiter's original design
for the LSTM recurrent neural network (:numref:<code>sec_lstm</code>),
dominated most applications in natural language processing.
Arguably, to that point, the rapid emergence of deep learning
appeared to be primarily attributable to shifts
in the available computational resources
(thanks to innovations in parallel computing with GPUs)
and the availability of massive data resources
(thanks to cheap storage and Internet services).
While these factors may indeed remain the primary drivers
behind this technology's increasing power
we are also witnessing, at long last,
a sea change in the landscape of dominant architectures.</p>
<p>At the present moment, the dominant models
for nearly all natural language processing tasks
are based on the Transformer architecture.
Given any new task in natural language processing, the default first-pass approach
is to grab a large Transformer-based pretrained model,
(e.g., BERT :cite:<code>Devlin.Chang.Lee.ea.2018</code>, ELECTRA :cite:<code>clark2019electra</code>, RoBERTa :cite:<code>Liu.Ott.Goyal.ea.2019</code>, or Longformer :cite:<code>beltagy2020longformer</code>)
adapting the output layers as necessary,
and fine-tuning the model on the available
data for the downstream task.
If you have been paying attention to the last few years
of breathless news coverage centered on OpenAI's
large language models, then you have been tracking a conversation
centered on the GPT-2 and GPT-3 Transformer-based models :cite:<code>Radford.Wu.Child.ea.2019,brown2020language</code>.
Meanwhile, the vision Transformer has emerged
as a default model for diverse vision tasks,
including image recognition, object detection,
semantic segmentation, and superresolution :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021,liu2021swin</code>.
Transformers also showed up as competitive methods
for speech recognition :cite:<code>gulati2020conformer</code>,
reinforcement learning :cite:<code>chen2021decision</code>,
and graph neural networks :cite:<code>dwivedi2020generalization</code>.</p>
<p>The core idea behind the Transformer model is the <em>attention mechanism</em>,
an innovation that was originally envisioned as an enhancement
for encoder--decoder RNNs applied to sequence-to-sequence applications,
such as machine translations :cite:<code>Bahdanau.Cho.Bengio.2014</code>.
You might recall that in the first sequence-to-sequence models
for machine translation :cite:<code>Sutskever.Vinyals.Le.2014</code>,
the entire input was compressed by the encoder
into a single fixed-length vector to be fed into the decoder.
The intuition behind attention is that rather than compressing the input,
it might be better for the decoder to revisit the input sequence at every step.
Moreover, rather than always seeing the same representation of the input,
one might imagine that the decoder should selectively focus
on particular parts of the input sequence at particular decoding steps.
Bahdanau's attention mechanism provided a simple means
by which the decoder could dynamically <em>attend</em> to different
parts of the input at each decoding step.
The high-level idea is that the encoder could produce a representation
of length equal to the original input sequence.
Then, at decoding time, the decoder can (via some control mechanism)
receive as input a context vector consisting of a weighted sum
of the representations on the input at each time step.
Intuitively, the weights determine the extent
to which each step's context "focuses" on each input token,
and the key is to make this process
for assigning the weights differentiable
so that it can be learned along with
all of the other neural network parameters.</p>
<p>Initially, the idea was a remarkably successful
enhancement to the recurrent neural networks
that already dominated machine translation applications.
The models performed better than the original
encoder--decoder sequence-to-sequence architectures.
Furthermore, researchers noted that some nice qualitative insights
sometimes emerged from inspecting the pattern of attention weights.
In translation tasks, attention models
often assigned high attention weights to cross-lingual synonyms
when generating the corresponding words in the target language.
For example, when translating the sentence "my feet hurt"
to "j'ai mal au pieds", the neural network might assign
high attention weights to the representation of "feet"
when generating the corresponding French word "pieds".
These insights spurred claims that attention models confer "interpretability"
although what precisely the attention weights mean---i.e.,
how, if at all, they should be <em>interpreted</em> remains a hazy research topic.</p>
<p>However, attention mechanisms soon emerged as more significant concerns,
beyond their usefulness as an enhancement for encoder--decoder recurrent neural networks
and their putative usefulness for picking out salient inputs.
:citet:<code>Vaswani.Shazeer.Parmar.ea.2017</code> proposed
the Transformer architecture for machine translation,
dispensing with recurrent connections altogether,
and instead relying on cleverly arranged attention mechanisms
to capture all relationships among input and output tokens.
The architecture performed remarkably well,
and by 2018 the Transformer began showing up
in the majority of state-of-the-art natural language processing systems.
Moreover, at the same time, the dominant practice in natural language processing
became to pretrain large-scale models
on enormous generic background corpora
to optimize some self-supervised pretraining objective,
and then to fine-tune these models
using the available downstream data.
The gap between Transformers and traditional architectures
grew especially wide when applied in this pretraining paradigm,
and thus the ascendance of Transformers coincided
with the ascendence of such large-scale pretrained models,
now sometimes called <em>foundation models</em> :cite:<code>bommasani2021opportunities</code>.</p>
<p>In this chapter, we introduce attention models,
starting with the most basic intuitions
and the simplest instantiations of the idea.
We then work our way up to the Transformer architecture,
the vision Transformer, and the landscape
of modern Transformer-based pretrained models.</p>
<pre><code class="language-toc">:maxdepth: 2

queries-keys-values
attention-pooling
attention-scoring-functions
bahdanau-attention
multihead-attention
self-attention-and-positional-encoding
transformer
vision-transformer
large-pretraining-transformers
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow')
</code></pre>
<h1 id="queries-keys-and-values"><a class="header" href="#queries-keys-and-values">Queries, Keys, and Values</a></h1>
<p>:label:<code>sec_queries-keys-values</code></p>
<p>So far all the networks we have reviewed crucially relied on the input being of a well-defined size. For instance, the images in ImageNet are of size $224 \times 224$ pixels and CNNs are specifically tuned to this size. Even in natural language processing the input size for RNNs is well defined and fixed. Variable size is addressed by sequentially processing one token at a time, or by specially designed convolution kernels :cite:<code>Kalchbrenner.Grefenstette.Blunsom.2014</code>. This approach can lead to significant problems when the input is truly of varying size with varying information content, such as in :numref:<code>sec_seq2seq</code> in the transformation of text :cite:<code>Sutskever.Vinyals.Le.2014</code>. In particular, for long sequences it becomes quite difficult to keep track of everything that has already been generated or even viewed by the network. Even explicit tracking heuristics such as proposed by :citet:<code>yang2016neural</code> only offer limited benefit.</p>
<p>Compare this to databases. In their simplest form they are collections of keys ($k$) and values ($v$). For instance, our database $\mathcal{D}$ might consist of tuples {("Zhang", "Aston"), ("Lipton", "Zachary"), ("Li", "Mu"), ("Smola", "Alex"), ("Hu", "Rachel"), ("Werness", "Brent")} with the last name being the key and the first name being the value. We can operate on $\mathcal{D}$, for instance with the exact query ($q$) for "Li" which would return the value "Mu". If ("Li", "Mu") was not a record in $\mathcal{D}$, there would be no valid answer. If we also allowed for approximate matches, we would retrieve ("Lipton", "Zachary") instead. This quite simple and trivial example nonetheless teaches us a number of useful things:</p>
<ul>
<li>We can design queries $q$ that operate on ($k$,$v$) pairs in such a manner as to be valid regardless of the  database size.</li>
<li>The same query can receive different answers, according to the contents of the database.</li>
<li>The "code" being executed for operating on a large state space (the database) can be quite simple (e.g., exact match, approximate match, top-$k$).</li>
<li>There is no need to compress or simplify the database to make the operations effective.</li>
</ul>
<p>Clearly we would not have introduced a simple database here if it wasn't for the purpose of explaining deep learning. Indeed, this leads to one of the most exciting concepts introduced in deep learning in the past decade: the <em>attention mechanism</em> :cite:<code>Bahdanau.Cho.Bengio.2014</code>. We will cover the specifics of its application to machine translation later. For now, simply consider the following: denote by $\mathcal{D} \stackrel{\textrm{def}}{=} {(\mathbf{k}_1, \mathbf{v}_1), \ldots (\mathbf{k}_m, \mathbf{v}_m)}$ a database of $m$ tuples of <em>keys</em> and <em>values</em>. Moreover, denote by $\mathbf{q}$ a <em>query</em>. Then we can define the <em>attention</em> over $\mathcal{D}$ as</p>
<p>$$\textrm{Attention}(\mathbf{q}, \mathcal{D}) \stackrel{\textrm{def}}{=} \sum_{i=1}^m \alpha(\mathbf{q}, \mathbf{k}_i) \mathbf{v}_i,$$
:eqlabel:<code>eq_attention_pooling</code></p>
<p>where $\alpha(\mathbf{q}, \mathbf{k}_i) \in \mathbb{R}$ ($i = 1, \ldots, m$) are scalar attention weights. The operation itself is typically referred to as <em>attention pooling</em>. The name <em>attention</em> derives from the fact that the operation pays particular attention to the terms for which the weight $\alpha$ is significant (i.e., large). As such, the attention over $\mathcal{D}$ generates a linear combination of values contained in the database. In fact, this contains the above example as a special case where all but one weight is zero. We have a number of special cases:</p>
<ul>
<li>The weights $\alpha(\mathbf{q}, \mathbf{k}_i)$ are nonnegative. In this case the output of the attention mechanism is contained in the convex cone spanned by the values $\mathbf{v}_i$.</li>
<li>The weights $\alpha(\mathbf{q}, \mathbf{k}_i)$ form a convex combination, i.e., $\sum_i \alpha(\mathbf{q}, \mathbf{k}_i) = 1$ and $\alpha(\mathbf{q}, \mathbf{k}_i) \geq 0$ for all $i$. This is the most common setting in deep learning.</li>
<li>Exactly one of the weights $\alpha(\mathbf{q}, \mathbf{k}_i)$ is $1$, while all others are $0$. This is akin to a traditional database query.</li>
<li>All weights are equal, i.e., $\alpha(\mathbf{q}, \mathbf{k}_i) = \frac{1}{m}$ for all $i$. This amounts to averaging across the entire database, also called average pooling in deep learning.</li>
</ul>
<p>A common strategy for ensuring that the weights sum up to $1$ is to normalize them via</p>
<p>$$\alpha(\mathbf{q}, \mathbf{k}_i) = \frac{\alpha(\mathbf{q}, \mathbf{k}_i)}{{\sum_j} \alpha(\mathbf{q}, \mathbf{k}_j)}.$$</p>
<p>In particular, to ensure that the weights are also nonnegative, one can resort to exponentiation. This means that we can now pick <em>any</em> function  $a(\mathbf{q}, \mathbf{k})$ and then apply the softmax operation used for multinomial models to it via</p>
<p>$$\alpha(\mathbf{q}, \mathbf{k}_i) = \frac{\exp(a(\mathbf{q}, \mathbf{k}_i))}{\sum_j \exp(a(\mathbf{q}, \mathbf{k}_j))}. $$
:eqlabel:<code>eq_softmax_attention</code></p>
<p>This operation is readily available in all deep learning frameworks. It is differentiable and its gradient never vanishes, all of which are desirable properties in a model. Note though, the attention mechanism introduced above is not the only option. For instance, we can design a non-differentiable attention model that can be trained using reinforcement learning methods :cite:<code>Mnih.Heess.Graves.ea.2014</code>. As one would expect, training such a model is quite complex. Consequently the bulk of modern attention research
follows the framework outlined in :numref:<code>fig_qkv</code>. We thus focus our exposition on this family of differentiable mechanisms.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/qkv.svg" alt="The attention mechanism computes a linear combination over values $\mathbf{v}\mathit{i}$ via attention pooling, where weights are derived according to the compatibility between a query $\mathbf{q}$ and keys $\mathbf{k}\mathit{i}$." />
:label:<code>fig_qkv</code></p>
<p>What is quite remarkable is that the actual "code" for executing on the set of keys and values, namely the query, can be quite concise, even though the space to operate on is significant. This is a desirable property for a network layer as it does not require too many parameters to learn. Just as convenient is the fact that attention can operate on arbitrarily large databases without the need to change the way the attention pooling operation is performed.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=2}">%%tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from jax import numpy as jnp
</code></pre>
<h2 id="visualization-1"><a class="header" href="#visualization-1">Visualization</a></h2>
<p>One of the benefits of the attention mechanism is that it can be quite intuitive, particularly when the weights are nonnegative and sum to $1$. In this case we might <em>interpret</em> large weights as a way for the model to select components of relevance. While this is a good intuition, it is important to remember that it is just that, an <em>intuition</em>. Regardless, we may want to visualize its effect on the given set of keys when applying a variety of different queries. This function will come in handy later.</p>
<p>We thus define the <code>show_heatmaps</code> function. Note that it does not take a matrix (of attention weights) as its input but rather a tensor with four axes, allowing for an array of different queries and weights. Consequently the input <code>matrices</code> has the shape (number of rows for display, number of columns for display, number of queries, number of keys). This will come in handy later on when we want to visualize the workings that are to design Transformers.</p>
<pre><code class="language-{.python .input  n=17}">%%tab all
#@save
def show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5),
                  cmap='Reds'):
    """Show heatmaps of matrices."""
    d2l.use_svg_display()
    num_rows, num_cols, _, _ = matrices.shape
    fig, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize,
                                 sharex=True, sharey=True, squeeze=False)
    for i, (row_axes, row_matrices) in enumerate(zip(axes, matrices)):
        for j, (ax, matrix) in enumerate(zip(row_axes, row_matrices)):
            if tab.selected('pytorch', 'mxnet', 'tensorflow'):
                pcm = ax.imshow(d2l.numpy(matrix), cmap=cmap)
            if tab.selected('jax'):
                pcm = ax.imshow(matrix, cmap=cmap)
            if i == num_rows - 1:
                ax.set_xlabel(xlabel)
            if j == 0:
                ax.set_ylabel(ylabel)
            if titles:
                ax.set_title(titles[j])
    fig.colorbar(pcm, ax=axes, shrink=0.6);
</code></pre>
<p>As a quick sanity check let's visualize the identity matrix, representing a case
where the attention weight is $1$ only when the query and the key are the same.</p>
<pre><code class="language-{.python .input  n=20}">%%tab all
attention_weights = d2l.reshape(d2l.eye(10), (1, 1, 10, 10))
show_heatmaps(attention_weights, xlabel='Keys', ylabel='Queries')
</code></pre>
<h2 id="summary-47"><a class="header" href="#summary-47">Summary</a></h2>
<p>The attention mechanism allows us to aggregate data from many (key, value) pairs. So far our discussion was
quite abstract, simply describing a way to pool data. We have not explained yet where those mysterious queries, keys, and values might arise from. Some intuition might help here: for instance, in a regression setting, the query might correspond to the location where the regression should be carried out. The keys are the locations where past data was observed and the values are the (regression) values themselves. This is the so-called Nadaraya--Watson estimator :cite:<code>Nadaraya.1964,Watson.1964</code> that we will be studying in the next section.</p>
<p>By design, the attention mechanism provides a <em>differentiable</em> means of control
by which a neural network can select elements from a set and to construct an associated weighted sum over representations.</p>
<h2 id="exercises-65"><a class="header" href="#exercises-65">Exercises</a></h2>
<ol>
<li>Suppose that you wanted to reimplement approximate (key, query) matches as used in classical databases, which attention function would you pick?</li>
<li>Suppose that the attention function is given by $a(\mathbf{q}, \mathbf{k}_i) = \mathbf{q}^\top \mathbf{k}_i$ and that $\mathbf{k}_i = \mathbf{v}<em>i$ for $i = 1, \ldots, m$. Denote by $p(\mathbf{k}<em>i; \mathbf{q})$ the probability distribution over keys when using the softmax normalization in :eqref:<code>eq_softmax_attention</code>. Prove that $\nabla</em>{\mathbf{q}} \mathop{\textrm{Attention}}(\mathbf{q}, \mathcal{D}) = \textrm{Cov}</em>{p(\mathbf{k}_i; \mathbf{q})}[\mathbf{k}_i]$.</li>
<li>Design a differentiable search engine using the attention mechanism.</li>
<li>Review the design of the Squeeze and Excitation Networks :cite:<code>Hu.Shen.Sun.2018</code> and interpret them through the lens of the attention mechanism.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/1596">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1592">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1710">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18024">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attention-pooling-by-similarity"><a class="header" href="#attention-pooling-by-similarity">Attention Pooling by Similarity</a></h1>
<p>:label:<code>sec_attention-pooling</code></p>
<p>Now that we have introduced the primary components of the attention mechanism, let's use them in a rather classical setting, namely regression and classification via kernel density estimation :cite:<code>Nadaraya.1964,Watson.1964</code>. This detour simply provides additional background: it is entirely optional and can be skipped if needed.
At their core, Nadaraya--Watson estimators rely on some similarity kernel $\alpha(\mathbf{q}, \mathbf{k})$ relating queries $\mathbf{q}$ to keys $\mathbf{k}$. Some common kernels are</p>
<p>$$\begin{aligned}
\alpha(\mathbf{q}, \mathbf{k}) &amp; = \exp\left(-\frac{1}{2} |\mathbf{q} - \mathbf{k}|^2 \right) &amp;&amp; \textrm{Gaussian;} \
\alpha(\mathbf{q}, \mathbf{k}) &amp; = 1 \textrm{ if } |\mathbf{q} - \mathbf{k}| \leq 1 &amp;&amp; \textrm{Boxcar;} \
\alpha(\mathbf{q}, \mathbf{k}) &amp; = \mathop{\mathrm{max}}\left(0, 1 - |\mathbf{q} - \mathbf{k}|\right) &amp;&amp; \textrm{Epanechikov.}
\end{aligned}
$$</p>
<p>There are many more choices that we could pick. See a <a href="https://en.wikipedia.org/wiki/Kernel_(statistics)">Wikipedia article</a> for a more extensive review and how the choice of kernels is related to kernel density estimation, sometimes also called <em>Parzen Windows</em> :cite:<code>parzen1957consistent</code>. All of the kernels are heuristic and can be tuned. For instance, we can adjust the width, not only on a global basis but even on a per-coordinate basis. Regardless, all of them lead to the following equation for regression and classification alike:</p>
<p>$$f(\mathbf{q}) = \sum_i \mathbf{v}_i \frac{\alpha(\mathbf{q}, \mathbf{k}_i)}{\sum_j \alpha(\mathbf{q}, \mathbf{k}_j)}.$$</p>
<p>In the case of a (scalar) regression with observations $(\mathbf{x}_i, y_i)$ for features and labels respectively, $\mathbf{v}_i = y_i$ are scalars, $\mathbf{k}_i = \mathbf{x}_i$ are vectors, and the query $\mathbf{q}$ denotes the new location where $f$ should be evaluated. In the case of (multiclass) classification, we use one-hot-encoding of $y_i$ to obtain $\mathbf{v}_i$. One of the convenient properties of this estimator is that it requires no training. Even more so, if we suitably narrow the kernel with increasing amounts of data, the approach is consistent :cite:<code>mack1982weak</code>, i.e., it will converge to some statistically optimal solution. Let's start by inspecting some kernels.</p>
<pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
npx.set_np()
d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
import numpy as np

d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
import numpy as np

d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
import jax
from jax import numpy as jnp
from flax import linen as nn
</code></pre>
<h2 id="kernels-and-data"><a class="header" href="#kernels-and-data">[<strong>Kernels and Data</strong>]</a></h2>
<p>All the kernels $\alpha(\mathbf{k}, \mathbf{q})$ defined in this section are <em>translation and rotation invariant</em>; that is, if we shift and rotate $\mathbf{k}$ and $\mathbf{q}$ in the same manner, the value of $\alpha$ remains unchanged. For simplicity we thus pick scalar arguments $k, q \in \mathbb{R}$ and pick the key $k = 0$ as the origin. This yields:</p>
<pre><code class="language-{.python .input}">%%tab all
# Define some kernels
def gaussian(x):
    return d2l.exp(-x**2 / 2)

def boxcar(x):
    return d2l.abs(x) &lt; 1.0

def constant(x):
    return 1.0 + 0 * x
 
if tab.selected('pytorch'):
    def epanechikov(x):
        return torch.max(1 - d2l.abs(x), torch.zeros_like(x))
if tab.selected('mxnet'):
    def epanechikov(x):
        return np.maximum(1 - d2l.abs(x), 0)
if tab.selected('tensorflow'):
    def epanechikov(x):
        return tf.maximum(1 - d2l.abs(x), 0)
if tab.selected('jax'):
    def epanechikov(x):
        return jnp.maximum(1 - d2l.abs(x), 0)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
fig, axes = d2l.plt.subplots(1, 4, sharey=True, figsize=(12, 3))

kernels = (gaussian, boxcar, constant, epanechikov)
names = ('Gaussian', 'Boxcar', 'Constant', 'Epanechikov')
x = d2l.arange(-2.5, 2.5, 0.1)
for kernel, name, ax in zip(kernels, names, axes):
    if tab.selected('pytorch', 'mxnet', 'tensorflow'):
        ax.plot(d2l.numpy(x), d2l.numpy(kernel(x)))
    if tab.selected('jax'):
        ax.plot(x, kernel(x))
    ax.set_xlabel(name)

d2l.plt.show()
</code></pre>
<p>Different kernels correspond to different notions of range and smoothness. For instance, the boxcar kernel only attends to observations within a distance of $1$ (or some otherwise defined hyperparameter) and does so indiscriminately.</p>
<p>To see Nadaraya--Watson estimation in action, let's define some training data. In the following we use the dependency</p>
<p>$$y_i = 2\sin(x_i) + x_i + \epsilon,$$</p>
<p>where $\epsilon$ is drawn from a normal distribution with zero mean and unit variance. We draw 40 training examples.</p>
<pre><code class="language-{.python .input}">%%tab all
def f(x):
    return 2 * d2l.sin(x) + x

n = 40
if tab.selected('pytorch'):
    x_train, _ = torch.sort(d2l.rand(n) * 5)
    y_train = f(x_train) + d2l.randn(n)
if tab.selected('mxnet'):
    x_train = np.sort(d2l.rand(n) * 5, axis=None)
    y_train = f(x_train) + d2l.randn(n)
if tab.selected('tensorflow'):
    x_train = tf.sort(d2l.rand((n,1)) * 5, 0)
    y_train = f(x_train) + d2l.normal((n, 1))
if tab.selected('jax'):
    x_train = jnp.sort(jax.random.uniform(d2l.get_key(), (n,)) * 5)
    y_train = f(x_train) + jax.random.normal(d2l.get_key(), (n,))
x_val = d2l.arange(0, 5, 0.1)
y_val = f(x_val)
</code></pre>
<h2 id="attention-pooling-via-nadaraya--watson-regression"><a class="header" href="#attention-pooling-via-nadaraya--watson-regression">[<strong>Attention Pooling via Nadaraya--Watson Regression</strong>]</a></h2>
<p>Now that we have data and kernels, all we need is a function that computes the kernel regression estimates. Note that we also want to obtain the relative kernel weights in order to perform some minor diagnostics. Hence we first compute the kernel between all training features (covariates) <code>x_train</code> and all validation features <code>x_val</code>. This yields a matrix, which we subsequently normalize. When multiplied with the training labels <code>y_train</code> we obtain the estimates.</p>
<p>Recall attention pooling in :eqref:<code>eq_attention_pooling</code>. Let each validation feature be a query, and each training feature--label pair be a key--value pair. As a result, the  normalized relative kernel weights (<code>attention_w</code> below) are the <em>attention weights</em>.</p>
<pre><code class="language-{.python .input}">%%tab all
def nadaraya_watson(x_train, y_train, x_val, kernel):
    dists = d2l.reshape(x_train, (-1, 1)) - d2l.reshape(x_val, (1, -1))
    # Each column/row corresponds to each query/key
    k = d2l.astype(kernel(dists), d2l.float32)
    # Normalization over keys for each query
    attention_w = k / d2l.reduce_sum(k, 0)
    if tab.selected('pytorch'):
        y_hat = y_train@attention_w
    if tab.selected('mxnet'):
        y_hat = np.dot(y_train, attention_w)
    if tab.selected('tensorflow'):
        y_hat = d2l.transpose(d2l.transpose(y_train)@attention_w)
    if tab.selected('jax'):
        y_hat = y_train@attention_w
    return y_hat, attention_w
</code></pre>
<p>Let's have a look at the kind of estimates that the different kernels produce.</p>
<pre><code class="language-{.python .input}">%%tab all
def plot(x_train, y_train, x_val, y_val, kernels, names, attention=False):
    fig, axes = d2l.plt.subplots(1, 4, sharey=True, figsize=(12, 3))
    for kernel, name, ax in zip(kernels, names, axes):
        y_hat, attention_w = nadaraya_watson(x_train, y_train, x_val, kernel)
        if attention:
            if tab.selected('pytorch', 'mxnet', 'tensorflow'):
                pcm = ax.imshow(d2l.numpy(attention_w), cmap='Reds')
            if tab.selected('jax'):
                pcm = ax.imshow(attention_w, cmap='Reds')
        else:
            ax.plot(x_val, y_hat)
            ax.plot(x_val, y_val, 'm--')
            ax.plot(x_train, y_train, 'o', alpha=0.5);
        ax.set_xlabel(name)
        if not attention:
            ax.legend(['y_hat', 'y'])
    if attention:
        fig.colorbar(pcm, ax=axes, shrink=0.7)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
plot(x_train, y_train, x_val, y_val, kernels, names)
</code></pre>
<p>The first thing that stands out is that all three nontrivial kernels (Gaussian, Boxcar, and Epanechikov) produce fairly workable estimates that are not too far from the true function. Only the constant kernel that leads to the trivial estimate $f(x) = \frac{1}{n} \sum_i y_i$ produces a rather unrealistic result. Let's inspect the attention weighting a bit more closely:</p>
<pre><code class="language-{.python .input}">%%tab all
plot(x_train, y_train, x_val, y_val, kernels, names, attention=True)
</code></pre>
<p>The visualization clearly shows why the estimates for Gaussian, Boxcar, and Epanechikov are very similar: after all, they are derived from very similar attention weights, despite the different functional form of the kernel. This raises the question as to whether this is always the case.</p>
<h2 id="adapting-attention-pooling"><a class="header" href="#adapting-attention-pooling">[<strong>Adapting Attention Pooling</strong>]</a></h2>
<p>We could replace the Gaussian kernel with one of a different width. That is, we could use
$\alpha(\mathbf{q}, \mathbf{k}) = \exp\left(-\frac{1}{2 \sigma^2} |\mathbf{q} - \mathbf{k}|^2 \right)$ where $\sigma^2$ determines the width of the kernel. Let's see whether this affects the outcomes.</p>
<pre><code class="language-{.python .input}">%%tab all
sigmas = (0.1, 0.2, 0.5, 1)
names = ['Sigma ' + str(sigma) for sigma in sigmas]

def gaussian_with_width(sigma): 
    return (lambda x: d2l.exp(-x**2 / (2*sigma**2)))

kernels = [gaussian_with_width(sigma) for sigma in sigmas]
plot(x_train, y_train, x_val, y_val, kernels, names)
</code></pre>
<p>Clearly, the narrower the kernel, the less smooth the estimate. At the same time, it adapts better to the local variations. Let's look at the corresponding attention weights.</p>
<pre><code class="language-{.python .input}">%%tab all
plot(x_train, y_train, x_val, y_val, kernels, names, attention=True)
</code></pre>
<p>As we would expect, the narrower the kernel, the narrower the range of large attention weights. It is also clear that picking the same width might not be ideal. In fact, :citet:<code>Silverman86</code> proposed a heuristic that depends on the local density. Many more such "tricks" have been proposed. For instance, :citet:<code>norelli2022asif</code> used a similar nearest-neighbor interpolation technique for designing cross-modal image and text representations.</p>
<p>The astute reader might wonder why we are providing this deep dive for a method that is over half a century old. First, it is one of the earliest precursors of modern attention mechanisms. Second, it is great for visualization. Third, and just as importantly, it demonstrates the limits of hand-crafted attention mechanisms. A much better strategy is to <em>learn</em> the mechanism, by learning the representations for queries and keys. This is what we will embark on in the following sections.</p>
<h2 id="summary-48"><a class="header" href="#summary-48">Summary</a></h2>
<p>Nadaraya--Watson kernel regression is an early precursor of the current attention mechanisms.
It can be used directly with little to no training or tuning, either for classification or regression.
The attention weight is assigned according to the similarity (or distance) between query and key, and according to how many similar observations are available.</p>
<h2 id="exercises-66"><a class="header" href="#exercises-66">Exercises</a></h2>
<ol>
<li>Parzen windows density estimates are given by $\hat{p}(\mathbf{x}) = \frac{1}{n} \sum_i k(\mathbf{x}, \mathbf{x}_i)$. Prove that for binary classification the function $\hat{p}(\mathbf{x}, y=1) - \hat{p}(\mathbf{x}, y=-1)$, as obtained by Parzen windows is equivalent to Nadaraya--Watson classification.</li>
<li>Implement stochastic gradient descent to learn a good value for kernel widths in Nadaraya--Watson regression.
<ol>
<li>What happens if you just use the above estimates to minimize $(f(\mathbf{x_i}) - y_i)^2$ directly? Hint: $y_i$ is part of the terms used to compute $f$.</li>
<li>Remove $(\mathbf{x}_i, y_i)$ from the estimate for $f(\mathbf{x}_i)$ and optimize over the kernel widths. Do you still observe overfitting?</li>
</ol>
</li>
<li>Assume that all $\mathbf{x}$ lie on the unit sphere, i.e., all satisfy $|\mathbf{x}| = 1$. Can you simplify the $|\mathbf{x} - \mathbf{x}_i|^2$ term in the exponential? Hint: we will later see that this is very closely related to dot product attention.</li>
<li>Recall that :citet:<code>mack1982weak</code> proved that Nadaraya--Watson estimation is consistent. How quickly should you reduce the scale for the attention mechanism as you get more data? Provide some intuition for your answer. Does it depend on the dimensionality of the data? How?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/1598">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1599">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3866">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18026">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="attention-scoring-functions"><a class="header" href="#attention-scoring-functions">Attention Scoring Functions</a></h1>
<p>:label:<code>sec_attention-scoring-functions</code></p>
<p>In :numref:<code>sec_attention-pooling</code>,
we used a number of different distance-based kernels, including a Gaussian kernel to model
interactions between queries and keys. As it turns out, distance functions are slightly more expensive to compute than dot products. As such,
with the softmax operation to ensure nonnegative attention weights,
much of the work has gone into <em>attention scoring functions</em> $a$ in :eqref:<code>eq_softmax_attention</code> and :numref:<code>fig_attention_output</code> that are simpler to compute.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/attention-output.svg" alt="Computing the output of attention pooling as a weighted average of values, where weights are computed with the attention scoring function $\mathit{a}$ and the softmax operation." />
:label:<code>fig_attention_output</code></p>
<pre><code class="language-{.python .input}">%%tab mxnet
import math
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import math
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
import math
</code></pre>
<h2 id="dot-product-attention"><a class="header" href="#dot-product-attention">[<strong>Dot Product Attention</strong>]</a></h2>
<p>Let's review the attention function (without exponentiation) from the Gaussian kernel for a moment:</p>
<p>$$
a(\mathbf{q}, \mathbf{k}_i) = -\frac{1}{2} |\mathbf{q} - \mathbf{k}_i|^2  = \mathbf{q}^\top \mathbf{k}_i -\frac{1}{2} |\mathbf{k}_i|^2  -\frac{1}{2} |\mathbf{q}|^2.
$$</p>
<p>First, note that the final term depends on $\mathbf{q}$ only. As such it is identical for all $(\mathbf{q}, \mathbf{k}_i)$ pairs. Normalizing the attention weights to $1$, as is done in :eqref:<code>eq_softmax_attention</code>, ensures that this term disappears entirely. Second, note that both batch and layer normalization (to be discussed later) lead to activations that have well-bounded, and often constant, norms $|\mathbf{k}_i|$. This is the case, for instance, whenever the keys $\mathbf{k}_i$ were generated by a layer norm. As such, we can drop it from the definition of $a$ without any major change in the outcome.</p>
<p>Last, we need to keep the order of magnitude of the arguments in the exponential function under control. Assume that all the elements of the query $\mathbf{q} \in \mathbb{R}^d$ and the key $\mathbf{k}_i \in \mathbb{R}^d$ are independent and identically drawn random variables with zero mean and unit variance. The dot product between both vectors has zero mean and a variance of $d$. To ensure that the variance of the dot product still remains $1$ regardless of vector length, we use the <em>scaled dot product attention</em> scoring function. That is, we rescale the dot product by $1/\sqrt{d}$. We thus arrive at the first commonly used attention function that is used, e.g., in Transformers :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code>:</p>
<p>$$ a(\mathbf{q}, \mathbf{k}_i) = \mathbf{q}^\top \mathbf{k}_i / \sqrt{d}.$$
:eqlabel:<code>eq_dot_product_attention</code></p>
<p>Note that attention weights $\alpha$ still need normalizing. We can simplify this further via :eqref:<code>eq_softmax_attention</code> by using the softmax operation:</p>
<p>$$\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q}, \mathbf{k}_i)) = \frac{\exp(\mathbf{q}^\top \mathbf{k}<em>i / \sqrt{d})}{\sum</em>{j=1} \exp(\mathbf{q}^\top \mathbf{k}_j / \sqrt{d})}.$$
:eqlabel:<code>eq_attn-scoring-alpha</code></p>
<p>As it turns out, all popular attention mechanisms use the softmax, hence we will limit ourselves to that in the remainder of this chapter.</p>
<h2 id="convenience-functions"><a class="header" href="#convenience-functions">Convenience Functions</a></h2>
<p>We need a few functions to make the attention mechanism efficient to deploy. This includes tools for dealing with strings of variable lengths (common for natural language processing) and tools for efficient evaluation on minibatches (batch matrix multiplication).</p>
<h3 id="masked-softmax-operation"><a class="header" href="#masked-softmax-operation">[<strong>Masked Softmax Operation</strong>]</a></h3>
<p>One of the most popular applications of the attention mechanism is to sequence models. Hence we need to be able to deal with sequences of different lengths. In some cases, such sequences may end up in the same minibatch, necessitating padding with dummy tokens for shorter sequences (see :numref:<code>sec_machine_translation</code> for an example). These special tokens do not carry meaning. For instance, assume that we have the following three sentences:</p>
<pre><code>Dive  into  Deep    Learning 
Learn to    code    &lt;blank&gt;
Hello world &lt;blank&gt; &lt;blank&gt;
</code></pre>
<p>Since we do not want blanks in our attention model we simply need to limit $\sum_{i=1}^n \alpha(\mathbf{q}, \mathbf{k}_i) \mathbf{v}<em>i$ to $\sum</em>{i=1}^l \alpha(\mathbf{q}, \mathbf{k}_i) \mathbf{v}_i$ for however long, $l \leq n$, the actual sentence is. Since it is such a common problem, it has a name: the <em>masked softmax operation</em>.</p>
<p>Let's implement it. Actually, the implementation cheats ever so slightly by setting the values of $\mathbf{v}_i$, for $i &gt; l$, to zero. Moreover, it sets the attention weights to a large negative number, such as $-10^{6}$, in order to make their contribution to gradients and values vanish in practice. This is done since linear algebra kernels and operators are heavily optimized for GPUs and it is faster to be slightly wasteful in computation rather than to have code with conditional (if then else) statements.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def masked_softmax(X, valid_lens):  #@save
    """Perform softmax operation by masking elements on the last axis."""
    # X: 3D tensor, valid_lens: 1D or 2D tensor
    if valid_lens is None:
        return npx.softmax(X)
    else:
        shape = X.shape
        if valid_lens.ndim == 1:
            valid_lens = valid_lens.repeat(shape[1])
        else:
            valid_lens = valid_lens.reshape(-1)
        # On the last axis, replace masked elements with a very large negative
        # value, whose exponentiation outputs 0
        X = npx.sequence_mask(X.reshape(-1, shape[-1]), valid_lens, True,
                              value=-1e6, axis=1)
        return npx.softmax(X).reshape(shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def masked_softmax(X, valid_lens):  #@save
    """Perform softmax operation by masking elements on the last axis."""
    # X: 3D tensor, valid_lens: 1D or 2D tensor 
    def _sequence_mask(X, valid_len, value=0):
        maxlen = X.size(1)
        mask = torch.arange((maxlen), dtype=torch.float32,
                            device=X.device)[None, :] &lt; valid_len[:, None]
        X[~mask] = value
        return X
    
    if valid_lens is None:
        return nn.functional.softmax(X, dim=-1)
    else:
        shape = X.shape
        if valid_lens.dim() == 1:
            valid_lens = torch.repeat_interleave(valid_lens, shape[1])
        else:
            valid_lens = valid_lens.reshape(-1)
        # On the last axis, replace masked elements with a very large negative
        # value, whose exponentiation outputs 0
        X = _sequence_mask(X.reshape(-1, shape[-1]), valid_lens, value=-1e6)
        return nn.functional.softmax(X.reshape(shape), dim=-1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def masked_softmax(X, valid_lens):  #@save
    """Perform softmax operation by masking elements on the last axis."""
    # X: 3D tensor, valid_lens: 1D or 2D tensor
    def _sequence_mask(X, valid_len, value=0):
        maxlen = X.shape[1]
        mask = tf.range(start=0, limit=maxlen, dtype=tf.float32)[
            None, :] &lt; tf.cast(valid_len[:, None], dtype=tf.float32)

        if len(X.shape) == 3:
            return tf.where(tf.expand_dims(mask, axis=-1), X, value)
        else:
            return tf.where(mask, X, value)
    
    if valid_lens is None:
        return tf.nn.softmax(X, axis=-1)
    else:
        shape = X.shape
        if len(valid_lens.shape) == 1:
            valid_lens = tf.repeat(valid_lens, repeats=shape[1])
            
        else:
            valid_lens = tf.reshape(valid_lens, shape=-1)
        # On the last axis, replace masked elements with a very large negative
        # value, whose exponentiation outputs 0    
        X = _sequence_mask(tf.reshape(X, shape=(-1, shape[-1])), valid_lens,
                           value=-1e6)    
        return tf.nn.softmax(tf.reshape(X, shape=shape), axis=-1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
def masked_softmax(X, valid_lens):  #@save
    """Perform softmax operation by masking elements on the last axis."""
    # X: 3D tensor, valid_lens: 1D or 2D tensor
    def _sequence_mask(X, valid_len, value=0):
        maxlen = X.shape[1]
        mask = jnp.arange((maxlen),
                          dtype=jnp.float32)[None, :] &lt; valid_len[:, None]
        return jnp.where(mask, X, value)

    if valid_lens is None:
        return nn.softmax(X, axis=-1)
    else:
        shape = X.shape
        if valid_lens.ndim == 1:
            valid_lens = jnp.repeat(valid_lens, shape[1])
        else:
            valid_lens = valid_lens.reshape(-1)
        # On the last axis, replace masked elements with a very large negative
        # value, whose exponentiation outputs 0
        X = _sequence_mask(X.reshape(-1, shape[-1]), valid_lens, value=-1e6)
        return nn.softmax(X.reshape(shape), axis=-1)
</code></pre>
<p>To [<strong>illustrate how this function works</strong>],
consider a minibatch of two examples of size $2 \times 4$,
where their valid lengths are $2$ and $3$, respectively.
As a result of the masked softmax operation,
values beyond the valid lengths for each pair of vectors are all masked as zero.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
masked_softmax(np.random.uniform(size=(2, 2, 4)), d2l.tensor([2, 3]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
masked_softmax(torch.rand(2, 2, 4), torch.tensor([2, 3]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
masked_softmax(tf.random.uniform(shape=(2, 2, 4)), tf.constant([2, 3]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
masked_softmax(jax.random.uniform(d2l.get_key(), (2, 2, 4)), jnp.array([2, 3]))
</code></pre>
<p>If we need more fine-grained control to specify the valid length for each of the two vectors of every example, we simply use a two-dimensional tensor of valid lengths. This yields:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
masked_softmax(np.random.uniform(size=(2, 2, 4)),
               d2l.tensor([[1, 3], [2, 4]]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
masked_softmax(torch.rand(2, 2, 4), d2l.tensor([[1, 3], [2, 4]]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
masked_softmax(tf.random.uniform((2, 2, 4)), tf.constant([[1, 3], [2, 4]]))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
masked_softmax(jax.random.uniform(d2l.get_key(), (2, 2, 4)),
               jnp.array([[1, 3], [2, 4]]))
</code></pre>
<h3 id="batch-matrix-multiplication"><a class="header" href="#batch-matrix-multiplication">Batch Matrix Multiplication</a></h3>
<p>:label:<code>subsec_batch_dot</code></p>
<p>Another commonly used operation is to multiply batches of matrices by one another. This comes in handy when we have minibatches of queries, keys, and values. More specifically, assume that</p>
<p>$$\mathbf{Q} = [\mathbf{Q}_1, \mathbf{Q}_2, \ldots, \mathbf{Q}_n]  \in \mathbb{R}^{n \times a \times b}, \
\mathbf{K} = [\mathbf{K}_1, \mathbf{K}_2, \ldots, \mathbf{K}_n]  \in \mathbb{R}^{n \times b \times c}.
$$</p>
<p>Then the batch matrix multiplication (BMM) computes the elementwise product</p>
<p>$$\textrm{BMM}(\mathbf{Q}, \mathbf{K}) = [\mathbf{Q}_1 \mathbf{K}_1, \mathbf{Q}_2 \mathbf{K}_2, \ldots, \mathbf{Q}_n \mathbf{K}_n] \in \mathbb{R}^{n \times a \times c}.$$
:eqlabel:<code>eq_batch-matrix-mul</code></p>
<p>Let's see this in action in a deep learning framework.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
Q = d2l.ones((2, 3, 4))
K = d2l.ones((2, 4, 6))
d2l.check_shape(npx.batch_dot(Q, K), (2, 3, 6))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
Q = d2l.ones((2, 3, 4))
K = d2l.ones((2, 4, 6))
d2l.check_shape(torch.bmm(Q, K), (2, 3, 6))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
Q = d2l.ones((2, 3, 4))
K = d2l.ones((2, 4, 6))
d2l.check_shape(tf.matmul(Q, K).numpy(), (2, 3, 6))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
Q = d2l.ones((2, 3, 4))
K = d2l.ones((2, 4, 6))
d2l.check_shape(jax.lax.batch_matmul(Q, K), (2, 3, 6))
</code></pre>
<h2 id="scaled-dot-product-attention"><a class="header" href="#scaled-dot-product-attention">[<strong>Scaled Dot Product Attention</strong>]</a></h2>
<p>Let's return to the dot product attention introduced in :eqref:<code>eq_dot_product_attention</code>.
In general, it requires that both the query and the key
have the same vector length, say $d$, even though this can be addressed easily by replacing
$\mathbf{q}^\top \mathbf{k}$ with $\mathbf{q}^\top \mathbf{M} \mathbf{k}$ where $\mathbf{M}$ is a matrix suitably chosen for translating between both spaces. For now assume that the dimensions match.</p>
<p>In practice, we often think of minibatches for efficiency,
such as computing attention for $n$ queries and $m$ key-value pairs,
where queries and keys are of length $d$
and values are of length $v$. The scaled dot product attention
of queries $\mathbf Q\in\mathbb R^{n\times d}$,
keys $\mathbf K\in\mathbb R^{m\times d}$,
and values $\mathbf V\in\mathbb R^{m\times v}$
thus can be written as</p>
<p>$$ \mathrm{softmax}\left(\frac{\mathbf Q \mathbf K^\top }{\sqrt{d}}\right) \mathbf V \in \mathbb{R}^{n\times v}.$$
:eqlabel:<code>eq_softmax_QK_V</code></p>
<p>Note that when applying this to a minibatch, we need the batch matrix multiplication introduced in :eqref:<code>eq_batch-matrix-mul</code>. In the following implementation of the scaled dot product attention,
we use dropout for model regularization.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class DotProductAttention(nn.Block):  #@save
    """Scaled dot product attention."""
    def __init__(self, dropout):
        super().__init__()
        self.dropout = nn.Dropout(dropout)

    # Shape of queries: (batch_size, no. of queries, d)
    # Shape of keys: (batch_size, no. of key-value pairs, d)
    # Shape of values: (batch_size, no. of key-value pairs, value dimension)
    # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
    def forward(self, queries, keys, values, valid_lens=None):
        d = queries.shape[-1]
        # Set transpose_b=True to swap the last two dimensions of keys
        scores = npx.batch_dot(queries, keys, transpose_b=True) / math.sqrt(d)
        self.attention_weights = masked_softmax(scores, valid_lens)
        return npx.batch_dot(self.dropout(self.attention_weights), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class DotProductAttention(nn.Module):  #@save
    """Scaled dot product attention."""
    def __init__(self, dropout):
        super().__init__()
        self.dropout = nn.Dropout(dropout)

    # Shape of queries: (batch_size, no. of queries, d)
    # Shape of keys: (batch_size, no. of key-value pairs, d)
    # Shape of values: (batch_size, no. of key-value pairs, value dimension)
    # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
    def forward(self, queries, keys, values, valid_lens=None):
        d = queries.shape[-1]
        # Swap the last two dimensions of keys with keys.transpose(1, 2)
        scores = torch.bmm(queries, keys.transpose(1, 2)) / math.sqrt(d)
        self.attention_weights = masked_softmax(scores, valid_lens)
        return torch.bmm(self.dropout(self.attention_weights), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class DotProductAttention(tf.keras.layers.Layer):  #@save
    """Scaled dot product attention."""
    def __init__(self, dropout):
        super().__init__()
        self.dropout = tf.keras.layers.Dropout(dropout)
        
    # Shape of queries: (batch_size, no. of queries, d)
    # Shape of keys: (batch_size, no. of key-value pairs, d)
    # Shape of values: (batch_size, no. of key-value pairs, value dimension)
    # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
    def call(self, queries, keys, values, valid_lens=None, **kwargs):
        d = queries.shape[-1]
        scores = tf.matmul(queries, keys, transpose_b=True)/tf.math.sqrt(
            tf.cast(d, dtype=tf.float32))
        self.attention_weights = masked_softmax(scores, valid_lens)
        return tf.matmul(self.dropout(self.attention_weights, **kwargs), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class DotProductAttention(nn.Module):  #@save
    """Scaled dot product attention."""
    dropout: float

    # Shape of queries: (batch_size, no. of queries, d)
    # Shape of keys: (batch_size, no. of key-value pairs, d)
    # Shape of values: (batch_size, no. of key-value pairs, value dimension)
    # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
    @nn.compact
    def __call__(self, queries, keys, values, valid_lens=None,
                 training=False):
        d = queries.shape[-1]
        # Swap the last two dimensions of keys with keys.swapaxes(1, 2)
        scores = queries@(keys.swapaxes(1, 2)) / math.sqrt(d)
        attention_weights = masked_softmax(scores, valid_lens)
        dropout_layer = nn.Dropout(self.dropout, deterministic=not training)
        return dropout_layer(attention_weights)@values, attention_weights
</code></pre>
<p>To [<strong>illustrate how the <code>DotProductAttention</code> class works</strong>],
we use the same keys, values, and valid lengths from the earlier toy example for additive attention. For the purpose of our example we assume that we have a minibatch size of $2$, a total of $10$ keys and values, and that the dimensionality of the values is $4$. Lastly, we assume that the valid length per observation is $2$ and $6$ respectively. Given that, we expect the output to be a $2 \times 1 \times 4$ tensor, i.e., one row per example of the minibatch.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
queries = d2l.normal(0, 1, (2, 1, 2))
keys = d2l.normal(0, 1, (2, 10, 2))
values = d2l.normal(0, 1, (2, 10, 4))
valid_lens = d2l.tensor([2, 6])

attention = DotProductAttention(dropout=0.5)
attention.initialize()
d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
queries = d2l.normal(0, 1, (2, 1, 2))
keys = d2l.normal(0, 1, (2, 10, 2))
values = d2l.normal(0, 1, (2, 10, 4))
valid_lens = d2l.tensor([2, 6])

attention = DotProductAttention(dropout=0.5)
attention.eval()
d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
queries = tf.random.normal(shape=(2, 1, 2))
keys = tf.random.normal(shape=(2, 10, 2))
values = tf.random.normal(shape=(2, 10, 4))
valid_lens = tf.constant([2, 6])

attention = DotProductAttention(dropout=0.5)
d2l.check_shape(attention(queries, keys, values, valid_lens, training=False),
                (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
queries = jax.random.normal(d2l.get_key(), (2, 1, 2))
keys = jax.random.normal(d2l.get_key(), (2, 10, 2))
values = jax.random.normal(d2l.get_key(), (2, 10, 4))
valid_lens = d2l.tensor([2, 6])

attention = DotProductAttention(dropout=0.5)
(output, attention_weights), params = attention.init_with_output(
    d2l.get_key(), queries, keys, values, valid_lens)
print(output)
</code></pre>
<p>Let's check whether the attention weights actually vanish for anything beyond the second and sixth column respectively (because of setting the valid length to $2$ and $6$).</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
d2l.show_heatmaps(d2l.reshape(attention.attention_weights, (1, 1, 2, 10)),
                  xlabel='Keys', ylabel='Queries')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
d2l.show_heatmaps(d2l.reshape(attention_weights, (1, 1, 2, 10)),
                  xlabel='Keys', ylabel='Queries')
</code></pre>
<h2 id="additive-attention"><a class="header" href="#additive-attention">[<strong>Additive Attention</strong>]</a></h2>
<p>:label:<code>subsec_additive-attention</code></p>
<p>When queries $\mathbf{q}$ and keys $\mathbf{k}$ are vectors of different dimension,
we can either use a matrix to address the mismatch via $\mathbf{q}^\top \mathbf{M} \mathbf{k}$, or we can use additive attention
as the scoring function. Another benefit is that, as its name indicates, the attention is additive. This can lead to some minor computational savings.
Given a query $\mathbf{q} \in \mathbb{R}^q$
and a key $\mathbf{k} \in \mathbb{R}^k$,
the <em>additive attention</em> scoring function :cite:<code>Bahdanau.Cho.Bengio.2014</code> is given by</p>
<p>$$a(\mathbf q, \mathbf k) = \mathbf w_v^\top \textrm{tanh}(\mathbf W_q\mathbf q + \mathbf W_k \mathbf k) \in \mathbb{R},$$
:eqlabel:<code>eq_additive-attn</code></p>
<p>where $\mathbf W_q\in\mathbb R^{h\times q}$, $\mathbf W_k\in\mathbb R^{h\times k}$,
and $\mathbf w_v\in\mathbb R^{h}$ are the learnable parameters. This term is then fed into a softmax to ensure both nonnegativity and normalization.
An equivalent interpretation of :eqref:<code>eq_additive-attn</code> is that the query and key are concatenated
and fed into an MLP with a single hidden layer.
Using $\tanh$ as the activation function and disabling bias terms,
we implement additive attention as follows:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class AdditiveAttention(nn.Block):  #@save
    """Additive attention."""
    def __init__(self, num_hiddens, dropout, **kwargs):
        super(AdditiveAttention, self).__init__(**kwargs)
        # Use flatten=False to only transform the last axis so that the
        # shapes for the other axes are kept the same
        self.W_k = nn.Dense(num_hiddens, use_bias=False, flatten=False)
        self.W_q = nn.Dense(num_hiddens, use_bias=False, flatten=False)
        self.w_v = nn.Dense(1, use_bias=False, flatten=False)
        self.dropout = nn.Dropout(dropout)

    def forward(self, queries, keys, values, valid_lens):
        queries, keys = self.W_q(queries), self.W_k(keys)
        # After dimension expansion, shape of queries: (batch_size, no. of
        # queries, 1, num_hiddens) and shape of keys: (batch_size, 1,
        # no. of key-value pairs, num_hiddens). Sum them up with
        # broadcasting
        features = np.expand_dims(queries, axis=2) + np.expand_dims(
            keys, axis=1)
        features = np.tanh(features)
        # There is only one output of self.w_v, so we remove the last
        # one-dimensional entry from the shape. Shape of scores:
        # (batch_size, no. of queries, no. of key-value pairs)
        scores = np.squeeze(self.w_v(features), axis=-1)
        self.attention_weights = masked_softmax(scores, valid_lens)
        # Shape of values: (batch_size, no. of key-value pairs, value
        # dimension)
        return npx.batch_dot(self.dropout(self.attention_weights), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class AdditiveAttention(nn.Module):  #@save
    """Additive attention."""
    def __init__(self, num_hiddens, dropout, **kwargs):
        super(AdditiveAttention, self).__init__(**kwargs)
        self.W_k = nn.LazyLinear(num_hiddens, bias=False)
        self.W_q = nn.LazyLinear(num_hiddens, bias=False)
        self.w_v = nn.LazyLinear(1, bias=False)
        self.dropout = nn.Dropout(dropout)

    def forward(self, queries, keys, values, valid_lens):
        queries, keys = self.W_q(queries), self.W_k(keys)
        # After dimension expansion, shape of queries: (batch_size, no. of
        # queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no. of
        # key-value pairs, num_hiddens). Sum them up with broadcasting
        features = queries.unsqueeze(2) + keys.unsqueeze(1)
        features = torch.tanh(features)
        # There is only one output of self.w_v, so we remove the last
        # one-dimensional entry from the shape. Shape of scores: (batch_size,
        # no. of queries, no. of key-value pairs)
        scores = self.w_v(features).squeeze(-1)
        self.attention_weights = masked_softmax(scores, valid_lens)
        # Shape of values: (batch_size, no. of key-value pairs, value
        # dimension)
        return torch.bmm(self.dropout(self.attention_weights), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class AdditiveAttention(tf.keras.layers.Layer):  #@save
    """Additive attention."""
    def __init__(self, key_size, query_size, num_hiddens, dropout, **kwargs):
        super().__init__(**kwargs)
        self.W_k = tf.keras.layers.Dense(num_hiddens, use_bias=False)
        self.W_q = tf.keras.layers.Dense(num_hiddens, use_bias=False)
        self.w_v = tf.keras.layers.Dense(1, use_bias=False)
        self.dropout = tf.keras.layers.Dropout(dropout)
        
    def call(self, queries, keys, values, valid_lens, **kwargs):
        queries, keys = self.W_q(queries), self.W_k(keys)
        # After dimension expansion, shape of queries: (batch_size, no. of
        # queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no. of
        # key-value pairs, num_hiddens). Sum them up with broadcasting
        features = tf.expand_dims(queries, axis=2) + tf.expand_dims(
            keys, axis=1)
        features = tf.nn.tanh(features)
        # There is only one output of self.w_v, so we remove the last
        # one-dimensional entry from the shape. Shape of scores: (batch_size,
        # no. of queries, no. of key-value pairs)
        scores = tf.squeeze(self.w_v(features), axis=-1)
        self.attention_weights = masked_softmax(scores, valid_lens)
        # Shape of values: (batch_size, no. of key-value pairs, value
        # dimension)
        return tf.matmul(self.dropout(
            self.attention_weights, **kwargs), values)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class AdditiveAttention(nn.Module):  #@save
    num_hiddens: int
    dropout: float

    def setup(self):
        self.W_k = nn.Dense(self.num_hiddens, use_bias=False)
        self.W_q = nn.Dense(self.num_hiddens, use_bias=False)
        self.w_v = nn.Dense(1, use_bias=False)

    @nn.compact
    def __call__(self, queries, keys, values, valid_lens, training=False):
        queries, keys = self.W_q(queries), self.W_k(keys)
        # After dimension expansion, shape of queries: (batch_size, no. of
        # queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no. of
        # key-value pairs, num_hiddens). Sum them up with broadcasting
        features = jnp.expand_dims(queries, axis=2) + jnp.expand_dims(keys, axis=1)
        features = nn.tanh(features)
        # There is only one output of self.w_v, so we remove the last
        # one-dimensional entry from the shape. Shape of scores: (batch_size,
        # no. of queries, no. of key-value pairs)
        scores = self.w_v(features).squeeze(-1)
        attention_weights = masked_softmax(scores, valid_lens)
        dropout_layer = nn.Dropout(self.dropout, deterministic=not training)
        # Shape of values: (batch_size, no. of key-value pairs, value
        # dimension)
        return dropout_layer(attention_weights)@values, attention_weights
</code></pre>
<p>Let's [<strong>see how <code>AdditiveAttention</code> works</strong>]. In our toy example we pick queries, keys and values of size
$(2, 1, 20)$, $(2, 10, 2)$ and $(2, 10, 4)$, respectively. This is identical to our choice for <code>DotProductAttention</code>, except that now the queries are $20$-dimensional. Likewise, we pick $(2, 6)$ as the valid lengths for the sequences in the minibatch.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
queries = d2l.normal(0, 1, (2, 1, 20))

attention = AdditiveAttention(num_hiddens=8, dropout=0.1)
attention.initialize()
d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
queries = d2l.normal(0, 1, (2, 1, 20))

attention = AdditiveAttention(num_hiddens=8, dropout=0.1)
attention.eval()
d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
queries = tf.random.normal(shape=(2, 1, 20))

attention = AdditiveAttention(key_size=2, query_size=20, num_hiddens=8,
                              dropout=0.1)
d2l.check_shape(attention(queries, keys, values, valid_lens, training=False),
                (2, 1, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
queries = jax.random.normal(d2l.get_key(), (2, 1, 20))
attention = AdditiveAttention(num_hiddens=8, dropout=0.1)
(output, attention_weights), params = attention.init_with_output(
    d2l.get_key(), queries, keys, values, valid_lens)
print(output)
</code></pre>
<p>When reviewing the attention function we see a behavior that is qualitatively quite similar to that of <code>DotProductAttention</code>. That is, only terms within the chosen valid length $(2, 6)$ are nonzero.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
d2l.show_heatmaps(d2l.reshape(attention.attention_weights, (1, 1, 2, 10)),
                  xlabel='Keys', ylabel='Queries')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
d2l.show_heatmaps(d2l.reshape(attention_weights, (1, 1, 2, 10)),
                  xlabel='Keys', ylabel='Queries')
</code></pre>
<h2 id="summary-49"><a class="header" href="#summary-49">Summary</a></h2>
<p>In this section we introduced the two key attention scoring functions: dot product and additive attention. They are effective tools for aggregating across sequences of variable length. In particular, the dot product attention is the mainstay of modern Transformer architectures. When queries and keys are vectors of different lengths,
we can use the additive attention scoring function instead. Optimizing these layers is one of the key areas of advance in recent years. For instance, <a href="https://docs.nvidia.com/deeplearning/transformer-engine/user-guide/index.html">NVIDIA's Transformer Library</a> and Megatron :cite:<code>shoeybi2019megatron</code> crucially rely on efficient variants of the attention mechanism. We will dive into this in quite a bit more detail as we review Transformers in later sections.</p>
<h2 id="exercises-67"><a class="header" href="#exercises-67">Exercises</a></h2>
<ol>
<li>Implement distance-based attention by modifying the <code>DotProductAttention</code> code. Note that you only need the squared norms of the keys $|\mathbf{k}_i|^2$ for an efficient implementation.</li>
<li>Modify the dot product attention to allow for queries and keys of different dimensionalities by employing a matrix to adjust dimensions.</li>
<li>How does the computational cost scale with the dimensionality of the keys, queries, values, and their number? What about the memory bandwidth requirements?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/346">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1064">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3867">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18027">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="the-bahdanau-attention-mechanism"><a class="header" href="#the-bahdanau-attention-mechanism">The Bahdanau Attention Mechanism</a></h1>
<p>:label:<code>sec_seq2seq_attention</code></p>
<p>When we encountered machine translation in :numref:<code>sec_seq2seq</code>,
we designed an encoder--decoder architecture for sequence-to-sequence learning
based on two RNNs :cite:<code>Sutskever.Vinyals.Le.2014</code>.
Specifically, the RNN encoder transforms a variable-length sequence
into a <em>fixed-shape</em> context variable.
Then, the RNN decoder generates the output (target) sequence token by token
based on the generated tokens and the context variable.</p>
<p>Recall :numref:<code>fig_seq2seq_details</code> which we repeat (:numref:<code>fig_s2s_attention_state</code>) with some additional detail. Conventionally, in an RNN all relevant information about a source sequence is translated into some internal <em>fixed-dimensional</em> state representation by the encoder. It is this very state that is used by the decoder as the complete and exclusive source of information for generating the translated sequence. In other words, the sequence-to-sequence mechanism treats the intermediate state as a sufficient statistic of whatever string might have served as input.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/seq2seq-state.svg" alt="Sequence-to-sequence model. The state, as generated by the encoder, is the only piece of information shared between the encoder and the decoder." />
:label:<code>fig_s2s_attention_state</code></p>
<p>While this is quite reasonable for short sequences, it is clear that it is infeasible for long ones, such as a book chapter or even just a very long sentence. After all, before too long there will simply not be enough "space" in the intermediate representation to store all that is important in the source sequence. Consequently the decoder will fail to translate long and complex sentences. One of the first to encounter this was :citet:<code>Graves.2013</code> who tried to design an RNN to generate handwritten text. Since the source text has arbitrary length they designed a differentiable attention model
to align text characters with the much longer pen trace,
where the alignment moves only in one direction. This, in turn, draws on decoding algorithms in speech recognition, e.g., hidden Markov models :cite:<code>rabiner1993fundamentals</code>.</p>
<p>Inspired by the idea of learning to align,
:citet:<code>Bahdanau.Cho.Bengio.2014</code> proposed a differentiable attention model
<em>without</em> the unidirectional alignment limitation.
When predicting a token,
if not all the input tokens are relevant,
the model aligns (or attends)
only to parts of the input sequence
that are deemed relevant to the current prediction. This is then used to update the current state before generating the next token. While quite innocuous in its description, this <em>Bahdanau attention mechanism</em> has arguably turned into one of the most influential ideas of the past decade in deep learning, giving rise to Transformers :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code> and many related new architectures.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
from mxnet import init, np, npx
from mxnet.gluon import rnn, nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="model-3"><a class="header" href="#model-3">Model</a></h2>
<p>We follow the notation introduced by the sequence-to-sequence architecture of :numref:<code>sec_seq2seq</code>, in particular :eqref:<code>eq_seq2seq_s_t</code>.
The key idea is that instead of keeping the state,
i.e., the context variable $\mathbf{c}$ summarizing the source sentence, as fixed, we dynamically update it, as a function of both the original text (encoder hidden states $\mathbf{h}<em>{t}$) and the text that was already generated (decoder hidden states $\mathbf{s}</em>{t'-1}$). This yields $\mathbf{c}_{t'}$, which is updated after any decoding time step $t'$. Suppose that the input sequence is of length $T$. In this case the context variable is the output of attention pooling:</p>
<p>$$\mathbf{c}<em>{t'} = \sum</em>{t=1}^{T} \alpha(\mathbf{s}<em>{t' - 1}, \mathbf{h}</em>{t}) \mathbf{h}_{t}.$$</p>
<p>We used $\mathbf{s}<em>{t' - 1}$ as the query, and
$\mathbf{h}</em>{t}$ as both the key and the value. Note that $\mathbf{c}<em>{t'}$ is then used to generate the state $\mathbf{s}</em>{t'}$ and to generate a new token: see :eqref:<code>eq_seq2seq_s_t</code>. In particular, the attention weight $\alpha$ is computed as in :eqref:<code>eq_attn-scoring-alpha</code>
using the additive attention scoring function
defined by :eqref:<code>eq_additive-attn</code>.
This RNN encoder--decoder architecture
using attention is depicted in :numref:<code>fig_s2s_attention_details</code>. Note that later this model was modified so as to include the already generated tokens in the decoder as further context (i.e., the attention sum does not stop at $T$ but rather it proceeds up to $t'-1$). For instance, see :citet:<code>chan2015listen</code> for a description of this strategy, as applied to speech recognition.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/seq2seq-details-attention.svg" alt="Layers in an RNN encoder--decoder model with the Bahdanau attention mechanism." />
:label:<code>fig_s2s_attention_details</code></p>
<h2 id="defining-the-decoder-with-attention"><a class="header" href="#defining-the-decoder-with-attention">Defining the Decoder with Attention</a></h2>
<p>To implement the RNN encoder--decoder with attention,
we only need to redefine the decoder (omitting the generated symbols from the attention function simplifies the design). Let's begin with [<strong>the base interface for decoders with attention</strong>] by defining the quite unsurprisingly named <code>AttentionDecoder</code> class.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
class AttentionDecoder(d2l.Decoder):  #@save
    """The base attention-based decoder interface."""
    def __init__(self):
        super().__init__()

    @property
    def attention_weights(self):
        raise NotImplementedError
</code></pre>
<p>We need to [<strong>implement the RNN decoder</strong>]
in the <code>Seq2SeqAttentionDecoder</code> class.
The state of the decoder is initialized with
(i) the hidden states of the last layer of the encoder at all time steps, used as keys and values for attention;
(ii) the hidden state of the encoder at all layers at the final time step, which serves to initialize the hidden state of the decoder;
and (iii) the valid length of the encoder, to exclude the padding tokens in attention pooling.
At each decoding time step, the hidden state of the final layer of the decoder, obtained at the previous time step, is used as the query of the attention mechanism.
Both the output of the attention mechanism and the input embedding are concatenated to serve as the input of the RNN decoder.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class Seq2SeqAttentionDecoder(AttentionDecoder):
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.attention = d2l.AdditiveAttention(num_hiddens, dropout)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = rnn.GRU(num_hiddens, num_layers, dropout=dropout)
        self.dense = nn.Dense(vocab_size, flatten=False)
        self.initialize(init.Xavier())

    def init_state(self, enc_outputs, enc_valid_lens):
        # Shape of outputs: (num_steps, batch_size, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        outputs, hidden_state = enc_outputs
        return (outputs.swapaxes(0, 1), hidden_state, enc_valid_lens)

    def forward(self, X, state):
        # Shape of enc_outputs: (batch_size, num_steps, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        enc_outputs, hidden_state, enc_valid_lens = state
        # Shape of the output X: (num_steps, batch_size, embed_size)
        X = self.embedding(X).swapaxes(0, 1)
        outputs, self._attention_weights = [], []
        for x in X:
            # Shape of query: (batch_size, 1, num_hiddens)
            query = np.expand_dims(hidden_state[-1], axis=1)
            # Shape of context: (batch_size, 1, num_hiddens)
            context = self.attention(
                query, enc_outputs, enc_outputs, enc_valid_lens)
            # Concatenate on the feature dimension
            x = np.concatenate((context, np.expand_dims(x, axis=1)), axis=-1)
            # Reshape x as (1, batch_size, embed_size + num_hiddens)
            out, hidden_state = self.rnn(x.swapaxes(0, 1), hidden_state)
            hidden_state = hidden_state[0]
            outputs.append(out)
            self._attention_weights.append(self.attention.attention_weights)
        # After fully connected layer transformation, shape of outputs:
        # (num_steps, batch_size, vocab_size)
        outputs = self.dense(np.concatenate(outputs, axis=0))
        return outputs.swapaxes(0, 1), [enc_outputs, hidden_state,
                                        enc_valid_lens]

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class Seq2SeqAttentionDecoder(AttentionDecoder):
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.attention = d2l.AdditiveAttention(num_hiddens, dropout)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = nn.GRU(
            embed_size + num_hiddens, num_hiddens, num_layers,
            dropout=dropout)
        self.dense = nn.LazyLinear(vocab_size)
        self.apply(d2l.init_seq2seq)

    def init_state(self, enc_outputs, enc_valid_lens):
        # Shape of outputs: (num_steps, batch_size, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        outputs, hidden_state = enc_outputs
        return (outputs.permute(1, 0, 2), hidden_state, enc_valid_lens)

    def forward(self, X, state):
        # Shape of enc_outputs: (batch_size, num_steps, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        enc_outputs, hidden_state, enc_valid_lens = state
        # Shape of the output X: (num_steps, batch_size, embed_size)
        X = self.embedding(X).permute(1, 0, 2)
        outputs, self._attention_weights = [], []
        for x in X:
            # Shape of query: (batch_size, 1, num_hiddens)
            query = torch.unsqueeze(hidden_state[-1], dim=1)
            # Shape of context: (batch_size, 1, num_hiddens)
            context = self.attention(
                query, enc_outputs, enc_outputs, enc_valid_lens)
            # Concatenate on the feature dimension
            x = torch.cat((context, torch.unsqueeze(x, dim=1)), dim=-1)
            # Reshape x as (1, batch_size, embed_size + num_hiddens)
            out, hidden_state = self.rnn(x.permute(1, 0, 2), hidden_state)
            outputs.append(out)
            self._attention_weights.append(self.attention.attention_weights)
        # After fully connected layer transformation, shape of outputs:
        # (num_steps, batch_size, vocab_size)
        outputs = self.dense(torch.cat(outputs, dim=0))
        return outputs.permute(1, 0, 2), [enc_outputs, hidden_state,
                                          enc_valid_lens]

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class Seq2SeqAttentionDecoder(AttentionDecoder):
    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,
                 dropout=0):
        super().__init__()
        self.attention = d2l.AdditiveAttention(num_hiddens, num_hiddens,
                                               num_hiddens, dropout)
        self.embedding = tf.keras.layers.Embedding(vocab_size, embed_size)
        self.rnn = tf.keras.layers.RNN(tf.keras.layers.StackedRNNCells(
            [tf.keras.layers.GRUCell(num_hiddens, dropout=dropout)
             for _ in range(num_layers)]), return_sequences=True,
                                       return_state=True)
        self.dense = tf.keras.layers.Dense(vocab_size)

    def init_state(self, enc_outputs, enc_valid_lens):
        # Shape of outputs: (batch_size, num_steps, num_hiddens).
        # Length of list hidden_state is num_layers, where the shape of its
        # element is (batch_size, num_hiddens)
        outputs, hidden_state = enc_outputs
        return (tf.transpose(outputs, (1, 0, 2)), hidden_state,
                enc_valid_lens)

    def call(self, X, state, **kwargs):
        # Shape of output enc_outputs: # (batch_size, num_steps, num_hiddens)
        # Length of list hidden_state is num_layers, where the shape of its
        # element is (batch_size, num_hiddens)
        enc_outputs, hidden_state, enc_valid_lens = state
        # Shape of the output X: (num_steps, batch_size, embed_size)
        X = self.embedding(X)  # Input X has shape: (batch_size, num_steps)
        X = tf.transpose(X, perm=(1, 0, 2))
        outputs, self._attention_weights = [], []
        for x in X:
            # Shape of query: (batch_size, 1, num_hiddens)
            query = tf.expand_dims(hidden_state[-1], axis=1)
            # Shape of context: (batch_size, 1, num_hiddens)
            context = self.attention(query, enc_outputs, enc_outputs,
                                     enc_valid_lens, **kwargs)
            # Concatenate on the feature dimension
            x = tf.concat((context, tf.expand_dims(x, axis=1)), axis=-1)
            out = self.rnn(x, hidden_state, **kwargs)
            hidden_state = out[1:]
            outputs.append(out[0])
            self._attention_weights.append(self.attention.attention_weights)
        # After fully connected layer transformation, shape of outputs:
        # (batch_size, num_steps, vocab_size)
        outputs = self.dense(tf.concat(outputs, axis=1))
        return outputs, [enc_outputs, hidden_state, enc_valid_lens]

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class Seq2SeqAttentionDecoder(nn.Module):
    vocab_size: int
    embed_size: int
    num_hiddens: int
    num_layers: int
    dropout: float = 0

    def setup(self):
        self.attention = d2l.AdditiveAttention(self.num_hiddens, self.dropout)
        self.embedding = nn.Embed(self.vocab_size, self.embed_size)
        self.dense = nn.Dense(self.vocab_size)
        self.rnn = d2l.GRU(num_hiddens, num_layers, dropout=self.dropout)

    def init_state(self, enc_outputs, enc_valid_lens, *args):
        # Shape of outputs: (num_steps, batch_size, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        outputs, hidden_state = enc_outputs
        # Attention Weights are returned as part of state; init with None
        return (outputs.transpose(1, 0, 2), hidden_state, enc_valid_lens)

    @nn.compact
    def __call__(self, X, state, training=False):
        # Shape of enc_outputs: (batch_size, num_steps, num_hiddens).
        # Shape of hidden_state: (num_layers, batch_size, num_hiddens)
        # Ignore Attention value in state
        enc_outputs, hidden_state, enc_valid_lens = state
        # Shape of the output X: (num_steps, batch_size, embed_size)
        X = self.embedding(X).transpose(1, 0, 2)
        outputs, attention_weights = [], []
        for x in X:
            # Shape of query: (batch_size, 1, num_hiddens)
            query = jnp.expand_dims(hidden_state[-1], axis=1)
            # Shape of context: (batch_size, 1, num_hiddens)
            context, attention_w = self.attention(query, enc_outputs,
                                                  enc_outputs, enc_valid_lens,
                                                  training=training)
            # Concatenate on the feature dimension
            x = jnp.concatenate((context, jnp.expand_dims(x, axis=1)), axis=-1)
            # Reshape x as (1, batch_size, embed_size + num_hiddens)
            out, hidden_state = self.rnn(x.transpose(1, 0, 2), hidden_state,
                                         training=training)
            outputs.append(out)
            attention_weights.append(attention_w)

        # Flax sow API is used to capture intermediate variables
        self.sow('intermediates', 'dec_attention_weights', attention_weights)

        # After fully connected layer transformation, shape of outputs:
        # (num_steps, batch_size, vocab_size)
        outputs = self.dense(jnp.concatenate(outputs, axis=0))
        return outputs.transpose(1, 0, 2), [enc_outputs, hidden_state,
                                            enc_valid_lens]
</code></pre>
<p>In the following, we [<strong>test the implemented
decoder</strong>] with attention
using a minibatch of four sequences, each of which are seven time steps long.</p>
<pre><code class="language-{.python .input}">%%tab all
vocab_size, embed_size, num_hiddens, num_layers = 10, 8, 16, 2
batch_size, num_steps = 4, 7
encoder = d2l.Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers)
decoder = Seq2SeqAttentionDecoder(vocab_size, embed_size, num_hiddens,
                                  num_layers)
if tab.selected('mxnet'):
    X = d2l.zeros((batch_size, num_steps))
    state = decoder.init_state(encoder(X), None)
    output, state = decoder(X, state)
if tab.selected('pytorch'):
    X = d2l.zeros((batch_size, num_steps), dtype=torch.long)
    state = decoder.init_state(encoder(X), None)
    output, state = decoder(X, state)
if tab.selected('tensorflow'):
    X = tf.zeros((batch_size, num_steps))
    state = decoder.init_state(encoder(X, training=False), None)
    output, state = decoder(X, state, training=False)
if tab.selected('jax'):
    X = jnp.zeros((batch_size, num_steps), dtype=jnp.int32)
    state = decoder.init_state(encoder.init_with_output(d2l.get_key(),
                                                        X, training=False)[0],
                               None)
    (output, state), _ = decoder.init_with_output(d2l.get_key(), X,
                                                  state, training=False)
d2l.check_shape(output, (batch_size, num_steps, vocab_size))
d2l.check_shape(state[0], (batch_size, num_steps, num_hiddens))
d2l.check_shape(state[1][0], (batch_size, num_hiddens))
</code></pre>
<h2 id="training-20"><a class="header" href="#training-20">[<strong>Training</strong>]</a></h2>
<p>Now that we specified the new decoder we can proceed analogously to :numref:<code>sec_seq2seq_training</code>:
specify the hyperparameters, instantiate
a regular encoder and a decoder with attention,
and train this model for machine translation.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.MTFraEng(batch_size=128)
embed_size, num_hiddens, num_layers, dropout = 256, 256, 2, 0.2
if tab.selected('mxnet', 'pytorch', 'jax'):
    encoder = d2l.Seq2SeqEncoder(
        len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout)
    decoder = Seq2SeqAttentionDecoder(
        len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout)
if tab.selected('mxnet', 'pytorch'):
    model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                        lr=0.005)
if tab.selected('jax'):
    model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                        lr=0.005, training=True)
if tab.selected('mxnet', 'pytorch', 'jax'):
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        encoder = d2l.Seq2SeqEncoder(
            len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout)
        decoder = Seq2SeqAttentionDecoder(
            len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout)
        model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                            lr=0.005)
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<p>After the model is trained,
we use it to [<strong>translate a few English sentences</strong>]
into French and compute their BLEU scores.</p>
<pre><code class="language-{.python .input}">%%tab all
engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .']
fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .']
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    preds, _ = model.predict_step(
        data.build(engs, fras), d2l.try_gpu(), data.num_steps)
if tab.selected('jax'):
    preds, _ = model.predict_step(
        trainer.state.params, data.build(engs, fras), data.num_steps)
for en, fr, p in zip(engs, fras, preds):
    translation = []
    for token in data.tgt_vocab.to_tokens(p):
        if token == '&lt;eos&gt;':
            break
        translation.append(token)
    print(f'{en} =&gt; {translation}, bleu,'
          f'{d2l.bleu(" ".join(translation), fr, k=2):.3f}')
</code></pre>
<p>Let's [<strong>visualize the attention weights</strong>]
when translating the last English sentence.
We see that each query assigns non-uniform weights
over key--value pairs.
It shows that at each decoding step,
different parts of the input sequences
are selectively aggregated in the attention pooling.</p>
<pre><code class="language-{.python .input}">%%tab all
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    _, dec_attention_weights = model.predict_step(
        data.build([engs[-1]], [fras[-1]]), d2l.try_gpu(), data.num_steps, True)
if tab.selected('jax'):
    _, (dec_attention_weights, _) = model.predict_step(
        trainer.state.params, data.build([engs[-1]], [fras[-1]]),
        data.num_steps, True)
attention_weights = d2l.concat(
    [step[0][0][0] for step in dec_attention_weights], 0)
attention_weights = d2l.reshape(attention_weights, (1, 1, -1, data.num_steps))
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
# Plus one to include the end-of-sequence token
d2l.show_heatmaps(
    attention_weights[:, :, :, :len(engs[-1].split()) + 1],
    xlabel='Key positions', ylabel='Query positions')
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
# Plus one to include the end-of-sequence token
d2l.show_heatmaps(
    attention_weights[:, :, :, :len(engs[-1].split()) + 1].cpu(),
    xlabel='Key positions', ylabel='Query positions')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# Plus one to include the end-of-sequence token
d2l.show_heatmaps(attention_weights[:, :, :, :len(engs[-1].split()) + 1],
                  xlabel='Key positions', ylabel='Query positions')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
# Plus one to include the end-of-sequence token
d2l.show_heatmaps(attention_weights[:, :, :, :len(engs[-1].split()) + 1],
                  xlabel='Key positions', ylabel='Query positions')
</code></pre>
<h2 id="summary-50"><a class="header" href="#summary-50">Summary</a></h2>
<p>When predicting a token, if not all the input tokens are relevant, the RNN encoder--decoder with the Bahdanau attention mechanism selectively aggregates different parts of the input sequence. This is achieved by treating the state (context variable) as an output of additive attention pooling.
In the RNN encoder--decoder, the Bahdanau attention mechanism treats the decoder hidden state at the previous time step as the query, and the encoder hidden states at all the time steps as both the keys and values.</p>
<h2 id="exercises-68"><a class="header" href="#exercises-68">Exercises</a></h2>
<ol>
<li>Replace GRU with LSTM in the experiment.</li>
<li>Modify the experiment to replace the additive attention scoring function with the scaled dot-product. How does it influence the training efficiency?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/347">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1065">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3868">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18028">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="multi-head-attention"><a class="header" href="#multi-head-attention">Multi-Head Attention</a></h1>
<p>:label:<code>sec_multihead-attention</code></p>
<p>In practice, given the same set of queries, keys, and values we may want our model to combine knowledge from
different behaviors of the same attention mechanism,
such as capturing dependencies of various ranges
(e.g., shorter-range vs. longer-range) within a sequence.
Thus, it may be beneficial to allow our attention mechanism to jointly use different representation subspaces of queries, keys, and values.</p>
<p>To this end, instead of performing
a single attention pooling,
queries, keys, and values
can be transformed
with $h$ independently learned linear projections.
Then these $h$ projected queries, keys, and values
are fed into attention pooling in parallel.
In the end,
$h$ attention-pooling outputs
are concatenated and
transformed with another learned linear projection
to produce the final output.
This design
is called <em>multi-head attention</em>,
where each of the $h$ attention pooling outputs
is a <em>head</em> :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code>.
Using fully connected layers
to perform learnable linear transformations,
:numref:<code>fig_multi-head-attention</code>
describes multi-head attention.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/multi-head-attention.svg" alt="Multi-head attention, where multiple heads are concatenated then linearly transformed." />
:label:<code>fig_multi-head-attention</code></p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
import math
from mxnet import autograd, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import math
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="model-4"><a class="header" href="#model-4">Model</a></h2>
<p>Before providing the implementation of multi-head attention,
let's formalize this model mathematically.
Given a query $\mathbf{q} \in \mathbb{R}^{d_q}$,
a key $\mathbf{k} \in \mathbb{R}^{d_k}$,
and a value $\mathbf{v} \in \mathbb{R}^{d_v}$,
each attention head $\mathbf{h}_i$  ($i = 1, \ldots, h$)
is computed as</p>
<p>$$\mathbf{h}_i = f(\mathbf W_i^{(q)}\mathbf q, \mathbf W_i^{(k)}\mathbf k,\mathbf W_i^{(v)}\mathbf v) \in \mathbb R^{p_v},$$</p>
<p>where
$\mathbf W_i^{(q)}\in\mathbb R^{p_q\times d_q}$,
$\mathbf W_i^{(k)}\in\mathbb R^{p_k\times d_k}$,
and $\mathbf W_i^{(v)}\in\mathbb R^{p_v\times d_v}$
are learnable parameters and
$f$ is attention pooling,
such as
additive attention and scaled dot product attention
in :numref:<code>sec_attention-scoring-functions</code>.
The multi-head attention output
is another linear transformation via
learnable parameters
$\mathbf W_o\in\mathbb R^{p_o\times h p_v}$
of the concatenation of $h$ heads:</p>
<p>$$\mathbf W_o \begin{bmatrix}\mathbf h_1\\vdots\\mathbf h_h\end{bmatrix} \in \mathbb{R}^{p_o}.$$</p>
<p>Based on this design, each head may attend
to different parts of the input.
More sophisticated functions
than the simple weighted average can be expressed.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>In our implementation,
we [<strong>choose the scaled dot product attention
for each head</strong>] of the multi-head attention.
To avoid significant growth of computational cost and parametrization cost,
we set $p_q = p_k = p_v = p_o / h$.
Note that $h$ heads can be computed in parallel
if we set the number of outputs
of linear transformations
for the query, key, and value
to $p_q h = p_k h = p_v h = p_o$.
In the following implementation,
$p_o$ is specified via the argument <code>num_hiddens</code>.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class MultiHeadAttention(d2l.Module):  #@save
    """Multi-head attention."""
    def __init__(self, num_hiddens, num_heads, dropout, use_bias=False,
                 **kwargs):
        super().__init__()
        self.num_heads = num_heads
        self.attention = d2l.DotProductAttention(dropout)
        self.W_q = nn.Dense(num_hiddens, use_bias=use_bias, flatten=False)
        self.W_k = nn.Dense(num_hiddens, use_bias=use_bias, flatten=False)
        self.W_v = nn.Dense(num_hiddens, use_bias=use_bias, flatten=False)
        self.W_o = nn.Dense(num_hiddens, use_bias=use_bias, flatten=False)

    def forward(self, queries, keys, values, valid_lens):
        # Shape of queries, keys, or values:
        # (batch_size, no. of queries or key-value pairs, num_hiddens)
        # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
        # After transposing, shape of output queries, keys, or values:
        # (batch_size * num_heads, no. of queries or key-value pairs,
        # num_hiddens / num_heads)
        queries = self.transpose_qkv(self.W_q(queries))
        keys = self.transpose_qkv(self.W_k(keys))
        values = self.transpose_qkv(self.W_v(values))

        if valid_lens is not None:
            # On axis 0, copy the first item (scalar or vector) for num_heads
            # times, then copy the next item, and so on
            valid_lens = valid_lens.repeat(self.num_heads, axis=0)

        # Shape of output: (batch_size * num_heads, no. of queries,
        # num_hiddens / num_heads)
        output = self.attention(queries, keys, values, valid_lens)
        
        # Shape of output_concat: (batch_size, no. of queries, num_hiddens)
        output_concat = self.transpose_output(output)
        return self.W_o(output_concat)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class MultiHeadAttention(d2l.Module):  #@save
    """Multi-head attention."""
    def __init__(self, num_hiddens, num_heads, dropout, bias=False, **kwargs):
        super().__init__()
        self.num_heads = num_heads
        self.attention = d2l.DotProductAttention(dropout)
        self.W_q = nn.LazyLinear(num_hiddens, bias=bias)
        self.W_k = nn.LazyLinear(num_hiddens, bias=bias)
        self.W_v = nn.LazyLinear(num_hiddens, bias=bias)
        self.W_o = nn.LazyLinear(num_hiddens, bias=bias)

    def forward(self, queries, keys, values, valid_lens):
        # Shape of queries, keys, or values:
        # (batch_size, no. of queries or key-value pairs, num_hiddens)
        # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
        # After transposing, shape of output queries, keys, or values:
        # (batch_size * num_heads, no. of queries or key-value pairs,
        # num_hiddens / num_heads)
        queries = self.transpose_qkv(self.W_q(queries))
        keys = self.transpose_qkv(self.W_k(keys))
        values = self.transpose_qkv(self.W_v(values))

        if valid_lens is not None:
            # On axis 0, copy the first item (scalar or vector) for num_heads
            # times, then copy the next item, and so on
            valid_lens = torch.repeat_interleave(
                valid_lens, repeats=self.num_heads, dim=0)

        # Shape of output: (batch_size * num_heads, no. of queries,
        # num_hiddens / num_heads)
        output = self.attention(queries, keys, values, valid_lens)
        # Shape of output_concat: (batch_size, no. of queries, num_hiddens)
        output_concat = self.transpose_output(output)
        return self.W_o(output_concat)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class MultiHeadAttention(d2l.Module):  #@save
    """Multi-head attention."""
    def __init__(self, key_size, query_size, value_size, num_hiddens,
                 num_heads, dropout, bias=False, **kwargs):
        super().__init__()
        self.num_heads = num_heads
        self.attention = d2l.DotProductAttention(dropout)
        self.W_q = tf.keras.layers.Dense(num_hiddens, use_bias=bias)
        self.W_k = tf.keras.layers.Dense(num_hiddens, use_bias=bias)
        self.W_v = tf.keras.layers.Dense(num_hiddens, use_bias=bias)
        self.W_o = tf.keras.layers.Dense(num_hiddens, use_bias=bias)
    
    def call(self, queries, keys, values, valid_lens, **kwargs):
        # Shape of queries, keys, or values:
        # (batch_size, no. of queries or key-value pairs, num_hiddens)
        # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
        # After transposing, shape of output queries, keys, or values:
        # (batch_size * num_heads, no. of queries or key-value pairs,
        # num_hiddens / num_heads)
        queries = self.transpose_qkv(self.W_q(queries))
        keys = self.transpose_qkv(self.W_k(keys))
        values = self.transpose_qkv(self.W_v(values))
        
        if valid_lens is not None:
            # On axis 0, copy the first item (scalar or vector) for num_heads
            # times, then copy the next item, and so on
            valid_lens = tf.repeat(valid_lens, repeats=self.num_heads, axis=0)
            
        # Shape of output: (batch_size * num_heads, no. of queries,
        # num_hiddens / num_heads)
        output = self.attention(queries, keys, values, valid_lens, **kwargs)
        
        # Shape of output_concat: (batch_size, no. of queries, num_hiddens)
        output_concat = self.transpose_output(output)
        return self.W_o(output_concat)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class MultiHeadAttention(nn.Module):  #@save
    num_hiddens: int
    num_heads: int
    dropout: float
    bias: bool = False

    def setup(self):
        self.attention = d2l.DotProductAttention(self.dropout)
        self.W_q = nn.Dense(self.num_hiddens, use_bias=self.bias)
        self.W_k = nn.Dense(self.num_hiddens, use_bias=self.bias)
        self.W_v = nn.Dense(self.num_hiddens, use_bias=self.bias)
        self.W_o = nn.Dense(self.num_hiddens, use_bias=self.bias)

    @nn.compact
    def __call__(self, queries, keys, values, valid_lens, training=False):
        # Shape of queries, keys, or values:
        # (batch_size, no. of queries or key-value pairs, num_hiddens)
        # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)
        # After transposing, shape of output queries, keys, or values:
        # (batch_size * num_heads, no. of queries or key-value pairs,
        # num_hiddens / num_heads)
        queries = self.transpose_qkv(self.W_q(queries))
        keys = self.transpose_qkv(self.W_k(keys))
        values = self.transpose_qkv(self.W_v(values))

        if valid_lens is not None:
            # On axis 0, copy the first item (scalar or vector) for num_heads
            # times, then copy the next item, and so on
            valid_lens = jnp.repeat(valid_lens, self.num_heads, axis=0)

        # Shape of output: (batch_size * num_heads, no. of queries,
        # num_hiddens / num_heads)
        output, attention_weights = self.attention(
            queries, keys, values, valid_lens, training=training)
        # Shape of output_concat: (batch_size, no. of queries, num_hiddens)
        output_concat = self.transpose_output(output)
        return self.W_o(output_concat), attention_weights
</code></pre>
<p>To allow for [<strong>parallel computation of multiple heads</strong>],
the above <code>MultiHeadAttention</code> class uses two transposition methods as defined below.
Specifically,
the <code>transpose_output</code> method reverses the operation
of the <code>transpose_qkv</code> method.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_qkv(self, X):
    """Transposition for parallel computation of multiple attention heads."""
    # Shape of input X: (batch_size, no. of queries or key-value pairs,
    # num_hiddens). Shape of output X: (batch_size, no. of queries or
    # key-value pairs, num_heads, num_hiddens / num_heads)
    X = X.reshape(X.shape[0], X.shape[1], self.num_heads, -1)
    # Shape of output X: (batch_size, num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    X = X.transpose(0, 2, 1, 3)
    # Shape of output: (batch_size * num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    return X.reshape(-1, X.shape[2], X.shape[3])

@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_output(self, X):
    """Reverse the operation of transpose_qkv."""
    X = X.reshape(-1, self.num_heads, X.shape[1], X.shape[2])
    X = X.transpose(0, 2, 1, 3)
    return X.reshape(X.shape[0], X.shape[1], -1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_qkv(self, X):
    """Transposition for parallel computation of multiple attention heads."""
    # Shape of input X: (batch_size, no. of queries or key-value pairs,
    # num_hiddens). Shape of output X: (batch_size, no. of queries or
    # key-value pairs, num_heads, num_hiddens / num_heads)
    X = X.reshape(X.shape[0], X.shape[1], self.num_heads, -1)
    # Shape of output X: (batch_size, num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    X = X.permute(0, 2, 1, 3)
    # Shape of output: (batch_size * num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    return X.reshape(-1, X.shape[2], X.shape[3])

@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_output(self, X):
    """Reverse the operation of transpose_qkv."""
    X = X.reshape(-1, self.num_heads, X.shape[1], X.shape[2])
    X = X.permute(0, 2, 1, 3)
    return X.reshape(X.shape[0], X.shape[1], -1)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_qkv(self, X):
    """Transposition for parallel computation of multiple attention heads."""
    # Shape of input X: (batch_size, no. of queries or key-value pairs,
    # num_hiddens). Shape of output X: (batch_size, no. of queries or
    # key-value pairs, num_heads, num_hiddens / num_heads)
    X = tf.reshape(X, shape=(X.shape[0], X.shape[1], self.num_heads, -1))
    # Shape of output X: (batch_size, num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    X = tf.transpose(X, perm=(0, 2, 1, 3))
    # Shape of output: (batch_size * num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    return tf.reshape(X, shape=(-1, X.shape[2], X.shape[3]))

@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_output(self, X):
    """Reverse the operation of transpose_qkv."""
    X = tf.reshape(X, shape=(-1, self.num_heads, X.shape[1], X.shape[2]))
    X = tf.transpose(X, perm=(0, 2, 1, 3))
    return tf.reshape(X, shape=(X.shape[0], X.shape[1], -1))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_qkv(self, X):
    """Transposition for parallel computation of multiple attention heads."""
    # Shape of input X: (batch_size, no. of queries or key-value pairs,
    # num_hiddens). Shape of output X: (batch_size, no. of queries or
    # key-value pairs, num_heads, num_hiddens / num_heads)
    X = X.reshape((X.shape[0], X.shape[1], self.num_heads, -1))
    # Shape of output X: (batch_size, num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    X = jnp.transpose(X, (0, 2, 1, 3))
    # Shape of output: (batch_size * num_heads, no. of queries or key-value
    # pairs, num_hiddens / num_heads)
    return X.reshape((-1, X.shape[2], X.shape[3]))

@d2l.add_to_class(MultiHeadAttention)  #@save
def transpose_output(self, X):
    """Reverse the operation of transpose_qkv."""
    X = X.reshape((-1, self.num_heads, X.shape[1], X.shape[2]))
    X = jnp.transpose(X, (0, 2, 1, 3))
    return X.reshape((X.shape[0], X.shape[1], -1))
</code></pre>
<p>Let's [<strong>test our implemented</strong>] <code>MultiHeadAttention</code> class
using a toy example where keys and values are the same.
As a result,
the shape of the multi-head attention output
is (<code>batch_size</code>, <code>num_queries</code>, <code>num_hiddens</code>).</p>
<pre><code class="language-{.python .input}">%%tab pytorch
num_hiddens, num_heads = 100, 5
attention = MultiHeadAttention(num_hiddens, num_heads, 0.5)
batch_size, num_queries, num_kvpairs = 2, 4, 6
valid_lens = d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
Y = d2l.ones((batch_size, num_kvpairs, num_hiddens))
d2l.check_shape(attention(X, Y, Y, valid_lens),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
num_hiddens, num_heads = 100, 5
attention = MultiHeadAttention(num_hiddens, num_heads, 0.5)
attention.initialize()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
num_hiddens, num_heads = 100, 5
attention = MultiHeadAttention(num_hiddens, num_heads, 0.5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
num_hiddens, num_heads = 100, 5
attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,
                               num_hiddens, num_heads, 0.5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
batch_size, num_queries, num_kvpairs = 2, 4, 6
valid_lens = d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
Y = d2l.ones((batch_size, num_kvpairs, num_hiddens))
d2l.check_shape(attention(X, Y, Y, valid_lens),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
batch_size, num_queries, num_kvpairs = 2, 4, 6
valid_lens = d2l.tensor([3, 2])
X = tf.ones((batch_size, num_queries, num_hiddens))
Y = tf.ones((batch_size, num_kvpairs, num_hiddens))
d2l.check_shape(attention(X, Y, Y, valid_lens, training=False),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
batch_size, num_queries, num_kvpairs = 2, 4, 6
valid_lens = d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
Y = d2l.ones((batch_size, num_kvpairs, num_hiddens))
d2l.check_shape(attention.init_with_output(d2l.get_key(), X, Y, Y, valid_lens,
                                           training=False)[0][0],
                (batch_size, num_queries, num_hiddens))
</code></pre>
<h2 id="summary-51"><a class="header" href="#summary-51">Summary</a></h2>
<p>Multi-head attention combines knowledge of the same attention pooling
via different representation subspaces of queries, keys, and values.
To compute multiple heads of multi-head attention in parallel,
proper tensor manipulation is needed.</p>
<h2 id="exercises-69"><a class="header" href="#exercises-69">Exercises</a></h2>
<ol>
<li>Visualize attention weights of multiple heads in this experiment.</li>
<li>Suppose that we have a trained model based on multi-head attention and we want to prune less important attention heads to increase the prediction speed. How can we design experiments to measure the importance of an attention head?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/1634">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1635">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3869">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18029">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="self-attention-and-positional-encoding"><a class="header" href="#self-attention-and-positional-encoding">Self-Attention and Positional Encoding</a></h1>
<p>:label:<code>sec_self-attention-and-positional-encoding</code></p>
<p>In deep learning, we often use CNNs or RNNs to encode sequences.
Now with attention mechanisms in mind,
imagine feeding a sequence of tokens
into an attention mechanism
such that at every step,
each token has its own query, keys, and values.
Here, when computing the value of a token's representation at the next layer,
the token can attend (via its query vector) to any other's token
(matching based on their key vectors).
Using the full set of query-key compatibility scores,
we can compute, for each token, a representation
by building the appropriate weighted sum
over the other tokens.
Because every token is attending to each other token
(unlike the case where decoder steps attend to encoder steps),
such architectures are typically described as <em>self-attention</em> models :cite:<code>Lin.Feng.Santos.ea.2017,Vaswani.Shazeer.Parmar.ea.2017</code>,
and elsewhere described as <em>intra-attention</em> model :cite:<code>Cheng.Dong.Lapata.2016,Parikh.Tackstrom.Das.ea.2016,Paulus.Xiong.Socher.2017</code>.
In this section, we will discuss sequence encoding using self-attention,
including using additional information for the sequence order.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
import math
from mxnet import autograd, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import math
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import numpy as np
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
</code></pre>
<h2 id="self-attention"><a class="header" href="#self-attention">[<strong>Self-Attention</strong>]</a></h2>
<p>Given a sequence of input tokens
$\mathbf{x}_1, \ldots, \mathbf{x}_n$ where any $\mathbf{x}_i \in \mathbb{R}^d$ ($1 \leq i \leq n$),
its self-attention outputs
a sequence of the same length
$\mathbf{y}_1, \ldots, \mathbf{y}_n$,
where</p>
<p>$$\mathbf{y}_i = f(\mathbf{x}_i, (\mathbf{x}_1, \mathbf{x}_1), \ldots, (\mathbf{x}_n, \mathbf{x}_n)) \in \mathbb{R}^d$$</p>
<p>according to the definition of attention pooling in
:eqref:<code>eq_attention_pooling</code>.
Using multi-head attention,
the following code snippet
computes the self-attention of a tensor
with shape (batch size, number of time steps or sequence length in tokens, $d$).
The output tensor has the same shape.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
num_hiddens, num_heads = 100, 5
attention = d2l.MultiHeadAttention(num_hiddens, num_heads, 0.5)
batch_size, num_queries, valid_lens = 2, 4, d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
d2l.check_shape(attention(X, X, X, valid_lens),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
num_hiddens, num_heads = 100, 5
attention = d2l.MultiHeadAttention(num_hiddens, num_heads, 0.5)
attention.initialize()
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
num_hiddens, num_heads = 100, 5
attention = d2l.MultiHeadAttention(num_hiddens, num_heads, 0.5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
num_hiddens, num_heads = 100, 5
attention = d2l.MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,
                                   num_hiddens, num_heads, 0.5)
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
batch_size, num_queries, valid_lens = 2, 4, d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
d2l.check_shape(attention(X, X, X, valid_lens),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
batch_size, num_queries, valid_lens = 2, 4, tf.constant([3, 2])
X = tf.ones((batch_size, num_queries, num_hiddens))
d2l.check_shape(attention(X, X, X, valid_lens, training=False),
                (batch_size, num_queries, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
batch_size, num_queries, valid_lens = 2, 4, d2l.tensor([3, 2])
X = d2l.ones((batch_size, num_queries, num_hiddens))
d2l.check_shape(attention.init_with_output(d2l.get_key(), X, X, X, valid_lens,
                                           training=False)[0][0],
                (batch_size, num_queries, num_hiddens))
</code></pre>
<h2 id="comparing-cnns-rnns-and-self-attention"><a class="header" href="#comparing-cnns-rnns-and-self-attention">Comparing CNNs, RNNs, and Self-Attention</a></h2>
<p>:label:<code>subsec_cnn-rnn-self-attention</code></p>
<p>Let's
compare architectures for mapping
a sequence of $n$ tokens
to another one of equal length,
where each input or output token is represented by
a $d$-dimensional vector.
Specifically,
we will consider CNNs, RNNs, and self-attention.
We will compare their
computational complexity,
sequential operations,
and maximum path lengths.
Note that sequential operations prevent parallel computation,
while a shorter path between
any combination of sequence positions
makes it easier to learn long-range dependencies
within the sequence :cite:<code>Hochreiter.Bengio.Frasconi.ea.2001</code>.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/cnn-rnn-self-attention.svg" alt="Comparing CNN (padding tokens are omitted), RNN, and self-attention architectures." />
:label:<code>fig_cnn-rnn-self-attention</code></p>
<p>Let's regard any text sequence as a "one-dimensional image". Similarly, one-dimensional CNNs can process local features such as $n$-grams in text.
Given a sequence of length $n$,
consider a convolutional layer whose kernel size is $k$,
and whose numbers of input and output channels are both $d$.
The computational complexity of the convolutional layer is $\mathcal{O}(knd^2)$.
As :numref:<code>fig_cnn-rnn-self-attention</code> shows,
CNNs are hierarchical,
so there are $\mathcal{O}(1)$ sequential operations
and the maximum path length is $\mathcal{O}(n/k)$.
For example, $\mathbf{x}_1$ and $\mathbf{x}_5$
are within the receptive field of a two-layer CNN
with kernel size 3 in :numref:<code>fig_cnn-rnn-self-attention</code>.</p>
<p>When updating the hidden state of RNNs,
multiplication of the $d \times d$ weight matrix
and the $d$-dimensional hidden state has
a computational complexity of $\mathcal{O}(d^2)$.
Since the sequence length is $n$,
the computational complexity of the recurrent layer
is $\mathcal{O}(nd^2)$.
According to :numref:<code>fig_cnn-rnn-self-attention</code>,
there are $\mathcal{O}(n)$ sequential operations
that cannot be parallelized
and the maximum path length is also $\mathcal{O}(n)$.</p>
<p>In self-attention,
the queries, keys, and values
are all $n \times d$ matrices.
Consider the scaled dot product attention in
:eqref:<code>eq_softmax_QK_V</code>,
where an $n \times d$ matrix is multiplied by
a $d \times n$ matrix,
then the output $n \times n$ matrix is multiplied
by an $n \times d$ matrix.
As a result,
the self-attention
has a $\mathcal{O}(n^2d)$ computational complexity.
As we can see from :numref:<code>fig_cnn-rnn-self-attention</code>,
each token is directly connected
to any other token via self-attention.
Therefore,
computation can be parallel with $\mathcal{O}(1)$ sequential operations
and the maximum path length is also $\mathcal{O}(1)$.</p>
<p>All in all,
both CNNs and self-attention enjoy parallel computation
and self-attention has the shortest maximum path length.
However, the quadratic computational complexity with respect to the sequence length
makes self-attention prohibitively slow for very long sequences.</p>
<h2 id="positional-encoding"><a class="header" href="#positional-encoding">[<strong>Positional Encoding</strong>]</a></h2>
<p>:label:<code>subsec_positional-encoding</code></p>
<p>Unlike RNNs, which recurrently process
tokens of a sequence one-by-one,
self-attention ditches
sequential operations in favor of
parallel computation.
Note that self-attention by itself
does not preserve the order of the sequence.
What do we do if it really matters
that the model knows in which order
the input sequence arrived?</p>
<p>The dominant approach for preserving
information about the order of tokens
is to represent this to the model
as an additional input associated
with each token.
These inputs are called <em>positional encodings</em>,
and they can either be learned or fixed <em>a priori</em>.
We now describe a simple scheme for fixed positional encodings
based on sine and cosine functions :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code>.</p>
<p>Suppose that the input representation
$\mathbf{X} \in \mathbb{R}^{n \times d}$
contains the $d$-dimensional embeddings
for $n$ tokens of a sequence.
The positional encoding outputs
$\mathbf{X} + \mathbf{P}$
using a positional embedding matrix
$\mathbf{P} \in \mathbb{R}^{n \times d}$ of the same shape,
whose element on the $i^\textrm{th}$ row
and the $(2j)^\textrm{th}$
or the $(2j + 1)^\textrm{th}$ column is</p>
<p>$$\begin{aligned} p_{i, 2j} &amp;= \sin\left(\frac{i}{10000^{2j/d}}\right),\p_{i, 2j+1} &amp;= \cos\left(\frac{i}{10000^{2j/d}}\right).\end{aligned}$$
:eqlabel:<code>eq_positional-encoding-def</code></p>
<p>At first glance,
this trigonometric function
design looks weird.
Before we give explanations of this design,
let's first implement it in the following <code>PositionalEncoding</code> class.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class PositionalEncoding(nn.Block):  #@save
    """Positional encoding."""
    def __init__(self, num_hiddens, dropout, max_len=1000):
        super().__init__()
        self.dropout = nn.Dropout(dropout)
        # Create a long enough P
        self.P = d2l.zeros((1, max_len, num_hiddens))
        X = d2l.arange(max_len).reshape(-1, 1) / np.power(
            10000, np.arange(0, num_hiddens, 2) / num_hiddens)
        self.P[:, :, 0::2] = np.sin(X)
        self.P[:, :, 1::2] = np.cos(X)

    def forward(self, X):
        X = X + self.P[:, :X.shape[1], :].as_in_ctx(X.ctx)
        return self.dropout(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class PositionalEncoding(nn.Module):  #@save
    """Positional encoding."""
    def __init__(self, num_hiddens, dropout, max_len=1000):
        super().__init__()
        self.dropout = nn.Dropout(dropout)
        # Create a long enough P
        self.P = d2l.zeros((1, max_len, num_hiddens))
        X = d2l.arange(max_len, dtype=torch.float32).reshape(
            -1, 1) / torch.pow(10000, torch.arange(
            0, num_hiddens, 2, dtype=torch.float32) / num_hiddens)
        self.P[:, :, 0::2] = torch.sin(X)
        self.P[:, :, 1::2] = torch.cos(X)

    def forward(self, X):
        X = X + self.P[:, :X.shape[1], :].to(X.device)
        return self.dropout(X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class PositionalEncoding(tf.keras.layers.Layer):  #@save
    """Positional encoding."""
    def __init__(self, num_hiddens, dropout, max_len=1000):
        super().__init__()
        self.dropout = tf.keras.layers.Dropout(dropout)
        # Create a long enough P
        self.P = np.zeros((1, max_len, num_hiddens))
        X = np.arange(max_len, dtype=np.float32).reshape(
            -1,1)/np.power(10000, np.arange(
            0, num_hiddens, 2, dtype=np.float32) / num_hiddens)
        self.P[:, :, 0::2] = np.sin(X)
        self.P[:, :, 1::2] = np.cos(X)
        
    def call(self, X, **kwargs):
        X = X + self.P[:, :X.shape[1], :]
        return self.dropout(X, **kwargs)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class PositionalEncoding(nn.Module):  #@save
    """Positional encoding."""
    num_hiddens: int
    dropout: float
    max_len: int = 1000

    def setup(self):
        # Create a long enough P
        self.P = d2l.zeros((1, self.max_len, self.num_hiddens))
        X = d2l.arange(self.max_len, dtype=jnp.float32).reshape(
            -1, 1) / jnp.power(10000, jnp.arange(
            0, self.num_hiddens, 2, dtype=jnp.float32) / self.num_hiddens)
        self.P = self.P.at[:, :, 0::2].set(jnp.sin(X))
        self.P = self.P.at[:, :, 1::2].set(jnp.cos(X))

    @nn.compact
    def __call__(self, X, training=False):
        # Flax sow API is used to capture intermediate variables
        self.sow('intermediates', 'P', self.P)
        X = X + self.P[:, :X.shape[1], :]
        return nn.Dropout(self.dropout)(X, deterministic=not training)
</code></pre>
<p>In the positional embedding matrix $\mathbf{P}$,
[<strong>rows correspond to positions within a sequence
and columns represent different positional encoding dimensions</strong>].
In the example below,
we can see that
the $6^{\textrm{th}}$ and the $7^{\textrm{th}}$
columns of the positional embedding matrix
have a higher frequency than
the $8^{\textrm{th}}$ and the $9^{\textrm{th}}$
columns.
The offset between
the $6^{\textrm{th}}$ and the $7^{\textrm{th}}$ (same for the $8^{\textrm{th}}$ and the $9^{\textrm{th}}$) columns
is due to the alternation of sine and cosine functions.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
encoding_dim, num_steps = 32, 60
pos_encoding = PositionalEncoding(encoding_dim, 0)
pos_encoding.initialize()
X = pos_encoding(np.zeros((1, num_steps, encoding_dim)))
P = pos_encoding.P[:, :X.shape[1], :]
d2l.plot(d2l.arange(num_steps), P[0, :, 6:10].T, xlabel='Row (position)',
         figsize=(6, 2.5), legend=["Col %d" % d for d in d2l.arange(6, 10)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
encoding_dim, num_steps = 32, 60
pos_encoding = PositionalEncoding(encoding_dim, 0)
X = pos_encoding(d2l.zeros((1, num_steps, encoding_dim)))
P = pos_encoding.P[:, :X.shape[1], :]
d2l.plot(d2l.arange(num_steps), P[0, :, 6:10].T, xlabel='Row (position)',
         figsize=(6, 2.5), legend=["Col %d" % d for d in d2l.arange(6, 10)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
encoding_dim, num_steps = 32, 60
pos_encoding = PositionalEncoding(encoding_dim, 0)
X = pos_encoding(tf.zeros((1, num_steps, encoding_dim)), training=False)
P = pos_encoding.P[:, :X.shape[1], :]
d2l.plot(np.arange(num_steps), P[0, :, 6:10].T, xlabel='Row (position)',
         figsize=(6, 2.5), legend=["Col %d" % d for d in np.arange(6, 10)])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
encoding_dim, num_steps = 32, 60
pos_encoding = PositionalEncoding(encoding_dim, 0)
params = pos_encoding.init(d2l.get_key(), d2l.zeros((1, num_steps, encoding_dim)))
X, inter_vars = pos_encoding.apply(params, d2l.zeros((1, num_steps, encoding_dim)),
                                   mutable='intermediates')
P = inter_vars['intermediates']['P'][0]  # retrieve intermediate value P
P = P[:, :X.shape[1], :]
d2l.plot(d2l.arange(num_steps), P[0, :, 6:10].T, xlabel='Row (position)',
         figsize=(6, 2.5), legend=["Col %d" % d for d in d2l.arange(6, 10)])
</code></pre>
<h3 id="absolute-positional-information"><a class="header" href="#absolute-positional-information">Absolute Positional Information</a></h3>
<p>To see how the monotonically decreased frequency
along the encoding dimension relates to absolute positional information,
let's print out [<strong>the binary representations</strong>] of $0, 1, \ldots, 7$.
As we can see, the lowest bit, the second-lowest bit,
and the third-lowest bit alternate on every number,
every two numbers, and every four numbers, respectively.</p>
<pre><code class="language-{.python .input}">%%tab all
for i in range(8):
    print(f'{i} in binary is {i:&gt;03b}')
</code></pre>
<p>In binary representations, a higher bit
has a lower frequency than a lower bit.
Similarly, as demonstrated in the heat map below,
[<strong>the positional encoding decreases
frequencies along the encoding dimension</strong>]
by using trigonometric functions.
Since the outputs are float numbers,
such continuous representations
are more space-efficient
than binary representations.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
P = np.expand_dims(np.expand_dims(P[0, :, :], 0), 0)
d2l.show_heatmaps(P, xlabel='Column (encoding dimension)',
                  ylabel='Row (position)', figsize=(3.5, 4), cmap='Blues')
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
P = P[0, :, :].unsqueeze(0).unsqueeze(0)
d2l.show_heatmaps(P, xlabel='Column (encoding dimension)',
                  ylabel='Row (position)', figsize=(3.5, 4), cmap='Blues')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
P = tf.expand_dims(tf.expand_dims(P[0, :, :], axis=0), axis=0)
d2l.show_heatmaps(P, xlabel='Column (encoding dimension)',
                  ylabel='Row (position)', figsize=(3.5, 4), cmap='Blues')
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
P = jnp.expand_dims(jnp.expand_dims(P[0, :, :], axis=0), axis=0)
d2l.show_heatmaps(P, xlabel='Column (encoding dimension)',
                  ylabel='Row (position)', figsize=(3.5, 4), cmap='Blues')
</code></pre>
<h3 id="relative-positional-information"><a class="header" href="#relative-positional-information">Relative Positional Information</a></h3>
<p>Besides capturing absolute positional information,
the above positional encoding
also allows
a model to easily learn to attend by relative positions.
This is because
for any fixed position offset $\delta$,
the positional encoding at position $i + \delta$
can be represented by a linear projection
of that at position $i$.</p>
<p>This projection can be explained
mathematically.
Denoting
$\omega_j = 1/10000^{2j/d}$,
any pair of $(p_{i, 2j}, p_{i, 2j+1})$
in :eqref:<code>eq_positional-encoding-def</code>
can
be linearly projected to $(p_{i+\delta, 2j}, p_{i+\delta, 2j+1})$
for any fixed offset $\delta$:</p>
<p>$$\begin{aligned}
\begin{bmatrix} \cos(\delta \omega_j) &amp; \sin(\delta \omega_j) \  -\sin(\delta \omega_j) &amp; \cos(\delta \omega_j) \ \end{bmatrix}
\begin{bmatrix} p_{i, 2j} \  p_{i, 2j+1} \ \end{bmatrix}
=&amp;\begin{bmatrix} \cos(\delta \omega_j) \sin(i \omega_j) + \sin(\delta \omega_j) \cos(i \omega_j) \  -\sin(\delta \omega_j) \sin(i \omega_j) + \cos(\delta \omega_j) \cos(i \omega_j) \ \end{bmatrix}\
=&amp;\begin{bmatrix} \sin\left((i+\delta) \omega_j\right) \  \cos\left((i+\delta) \omega_j\right) \ \end{bmatrix}\
=&amp;
\begin{bmatrix} p_{i+\delta, 2j} \  p_{i+\delta, 2j+1} \ \end{bmatrix},
\end{aligned}$$</p>
<p>where the $2\times 2$ projection matrix does not depend on any position index $i$.</p>
<h2 id="summary-52"><a class="header" href="#summary-52">Summary</a></h2>
<p>In self-attention, the queries, keys, and values all come from the same place.
Both CNNs and self-attention enjoy parallel computation
and self-attention has the shortest maximum path length.
However, the quadratic computational complexity
with respect to the sequence length
makes self-attention prohibitively slow
for very long sequences.
To use the sequence order information,
we can inject absolute or relative positional information
by adding positional encoding to the input representations.</p>
<h2 id="exercises-70"><a class="header" href="#exercises-70">Exercises</a></h2>
<ol>
<li>Suppose that we design a deep architecture to represent a sequence by stacking self-attention layers with positional encoding. What could the possible issues be?</li>
<li>Can you design a learnable positional encoding method?</li>
<li>Can we assign different learned embeddings according to different offsets between queries and keys that are compared in self-attention? Hint: you may refer to relative position embeddings :cite:<code>shaw2018self,huang2018music</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/1651">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1652">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3870">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18030">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select('mxnet', 'pytorch', 'tensorflow', 'jax')
</code></pre>
<h1 id="the-transformer-architecture"><a class="header" href="#the-transformer-architecture">The Transformer Architecture</a></h1>
<p>:label:<code>sec_transformer</code></p>
<p>We have compared CNNs, RNNs, and self-attention in
:numref:<code>subsec_cnn-rnn-self-attention</code>.
Notably, self-attention
enjoys both parallel computation and
the shortest maximum path length.
Therefore,
it is appealing to design deep architectures
by using self-attention.
Unlike earlier self-attention models
that still rely on RNNs for input representations :cite:<code>Cheng.Dong.Lapata.2016,Lin.Feng.Santos.ea.2017,Paulus.Xiong.Socher.2017</code>,
the Transformer model
is solely based on attention mechanisms
without any convolutional or recurrent layer :cite:<code>Vaswani.Shazeer.Parmar.ea.2017</code>.
Though originally proposed
for sequence-to-sequence learning on text data,
Transformers have been
pervasive in a wide range of
modern deep learning applications,
such as in areas to do with language, vision, speech, and reinforcement learning.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
from d2l import mxnet as d2l
import math
from mxnet import autograd, init, np, npx
from mxnet.gluon import nn
import pandas as pd
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import math
import pandas as pd
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
from d2l import tensorflow as d2l
import numpy as np
import pandas as pd
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
from jax import numpy as jnp
import jax
import math
import pandas as pd
</code></pre>
<h2 id="model-5"><a class="header" href="#model-5">Model</a></h2>
<p>As an instance of the encoder--decoder
architecture,
the overall architecture of
the Transformer
is presented in :numref:<code>fig_transformer</code>.
As we can see,
the Transformer is composed of an encoder and a decoder.
In contrast to
Bahdanau attention
for sequence-to-sequence learning
in :numref:<code>fig_s2s_attention_details</code>,
the input (source) and output (target)
sequence embeddings
are added with positional encoding
before being fed into
the encoder and the decoder
that stack modules based on self-attention.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/transformer.svg" alt="The Transformer architecture." />
:width:<code>320px</code>
:label:<code>fig_transformer</code></p>
<p>Now we provide an overview of the
Transformer architecture in :numref:<code>fig_transformer</code>.
At a high level,
the Transformer encoder is a stack of multiple identical layers,
where each layer
has two sublayers (either is denoted as $\textrm{sublayer}$).
The first
is a multi-head self-attention pooling
and the second is a positionwise feed-forward network.
Specifically,
in the encoder self-attention,
queries, keys, and values are all from the
outputs of the previous encoder layer.
Inspired by the ResNet design of :numref:<code>sec_resnet</code>,
a residual connection is employed
around both sublayers.
In the Transformer,
for any input $\mathbf{x} \in \mathbb{R}^d$ at any position of the sequence,
we require that $\textrm{sublayer}(\mathbf{x}) \in \mathbb{R}^d$ so that
the residual connection $\mathbf{x} + \textrm{sublayer}(\mathbf{x}) \in \mathbb{R}^d$ is feasible.
This addition from the residual connection is immediately
followed by layer normalization :cite:<code>Ba.Kiros.Hinton.2016</code>.
As a result, the Transformer encoder outputs a $d$-dimensional vector representation
for each position of the input sequence.</p>
<p>The Transformer decoder is also a stack of multiple identical layers
with residual connections and layer normalizations.
As well as the two sublayers described in
the encoder, the decoder inserts
a third sublayer, known as
the encoder--decoder attention,
between these two.
In the encoder--decoder attention,
queries are from the
outputs of the decoder's self-attention sublayer,
and the keys and values are
from the Transformer encoder outputs.
In the decoder self-attention,
queries, keys, and values are all from the
outputs of the previous decoder layer.
However, each position in the decoder is
allowed only to attend to all positions in the decoder
up to that position.
This <em>masked</em> attention
preserves the autoregressive property,
ensuring that the prediction only depends
on those output tokens that have been generated.</p>
<p>We have already described and implemented
multi-head attention based on scaled dot products
in :numref:<code>sec_multihead-attention</code>
and positional encoding in :numref:<code>subsec_positional-encoding</code>.
In the following, we will implement
the rest of the Transformer model.</p>
<h2 id="positionwise-feed-forward-networks"><a class="header" href="#positionwise-feed-forward-networks">[<strong>Positionwise Feed-Forward Networks</strong>]</a></h2>
<p>:label:<code>subsec_positionwise-ffn</code></p>
<p>The positionwise feed-forward network transforms
the representation at all the sequence positions
using the same MLP.
This is why we call it <em>positionwise</em>.
In the implementation below,
the input <code>X</code> with shape
(batch size, number of time steps or sequence length in tokens,
number of hidden units or feature dimension)
will be transformed by a two-layer MLP into
an output tensor of shape
(batch size, number of time steps, <code>ffn_num_outputs</code>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class PositionWiseFFN(nn.Block):  #@save
    """The positionwise feed-forward network."""
    def __init__(self, ffn_num_hiddens, ffn_num_outputs):
        super().__init__()
        self.dense1 = nn.Dense(ffn_num_hiddens, flatten=False,
                               activation='relu')
        self.dense2 = nn.Dense(ffn_num_outputs, flatten=False)

    def forward(self, X):
        return self.dense2(self.dense1(X))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class PositionWiseFFN(nn.Module):  #@save
    """The positionwise feed-forward network."""
    def __init__(self, ffn_num_hiddens, ffn_num_outputs):
        super().__init__()
        self.dense1 = nn.LazyLinear(ffn_num_hiddens)
        self.relu = nn.ReLU()
        self.dense2 = nn.LazyLinear(ffn_num_outputs)

    def forward(self, X):
        return self.dense2(self.relu(self.dense1(X)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class PositionWiseFFN(tf.keras.layers.Layer):  #@save
    """The positionwise feed-forward network."""
    def __init__(self, ffn_num_hiddens, ffn_num_outputs):
        super().__init__()
        self.dense1 = tf.keras.layers.Dense(ffn_num_hiddens)
        self.relu = tf.keras.layers.ReLU()
        self.dense2 = tf.keras.layers.Dense(ffn_num_outputs)

    def call(self, X):
        return self.dense2(self.relu(self.dense1(X)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class PositionWiseFFN(nn.Module):  #@save
    """The positionwise feed-forward network."""
    ffn_num_hiddens: int
    ffn_num_outputs: int

    def setup(self):
        self.dense1 = nn.Dense(self.ffn_num_hiddens)
        self.dense2 = nn.Dense(self.ffn_num_outputs)

    def __call__(self, X):
        return self.dense2(nn.relu(self.dense1(X)))
</code></pre>
<p>The following example
shows that [<strong>the innermost dimension
of a tensor changes</strong>] to
the number of outputs in
the positionwise feed-forward network.
Since the same MLP transforms
at all the positions,
when the inputs at all these positions are the same,
their outputs are also identical.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
ffn = PositionWiseFFN(4, 8)
ffn.initialize()
ffn(np.ones((2, 3, 4)))[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
ffn = PositionWiseFFN(4, 8)
ffn.eval()
ffn(d2l.ones((2, 3, 4)))[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
ffn = PositionWiseFFN(4, 8)
ffn(tf.ones((2, 3, 4)))[0]
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
ffn = PositionWiseFFN(4, 8)
ffn.init_with_output(d2l.get_key(), jnp.ones((2, 3, 4)))[0][0]
</code></pre>
<h2 id="residual-connection-and-layer-normalization"><a class="header" href="#residual-connection-and-layer-normalization">Residual Connection and Layer Normalization</a></h2>
<p>Now let's focus on the "add &amp; norm" component in :numref:<code>fig_transformer</code>.
As we described at the beginning of this section,
this is a residual connection immediately
followed by layer normalization.
Both are key to effective deep architectures.</p>
<p>In :numref:<code>sec_batch_norm</code>,
we explained how batch normalization
recenters and rescales across the examples within
a minibatch.
As discussed in :numref:<code>subsec_layer-normalization-in-bn</code>,
layer normalization is the same as batch normalization
except that the former
normalizes across the feature dimension,
thus enjoying benefits of scale independence and batch size independence.
Despite its pervasive applications
in computer vision,
batch normalization
is usually empirically
less effective than layer normalization
in natural language processing
tasks, where the inputs are often
variable-length sequences.</p>
<p>The following code snippet
[<strong>compares the normalization across different dimensions
by layer normalization and batch normalization</strong>].</p>
<pre><code class="language-{.python .input}">%%tab mxnet
ln = nn.LayerNorm()
ln.initialize()
bn = nn.BatchNorm()
bn.initialize()
X = d2l.tensor([[1, 2], [2, 3]])
# Compute mean and variance from X in the training mode
with autograd.record():
    print('layer norm:', ln(X), '\nbatch norm:', bn(X))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
ln = nn.LayerNorm(2)
bn = nn.LazyBatchNorm1d()
X = d2l.tensor([[1, 2], [2, 3]], dtype=torch.float32)
# Compute mean and variance from X in the training mode
print('layer norm:', ln(X), '\nbatch norm:', bn(X))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
ln = tf.keras.layers.LayerNormalization()
bn = tf.keras.layers.BatchNormalization()
X = tf.constant([[1, 2], [2, 3]], dtype=tf.float32)
print('layer norm:', ln(X), '\nbatch norm:', bn(X, training=True))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
ln = nn.LayerNorm()
bn = nn.BatchNorm()
X = d2l.tensor([[1, 2], [2, 3]], dtype=d2l.float32)
# Compute mean and variance from X in the training mode
print('layer norm:', ln.init_with_output(d2l.get_key(), X)[0],
      '\nbatch norm:', bn.init_with_output(d2l.get_key(), X,
                                           use_running_average=False)[0])
</code></pre>
<p>Now we can implement the <code>AddNorm</code> class
[<strong>using a residual connection followed by layer normalization</strong>].
Dropout is also applied for regularization.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class AddNorm(nn.Block):  #@save
    """The residual connection followed by layer normalization."""
    def __init__(self, dropout):
        super().__init__()
        self.dropout = nn.Dropout(dropout)
        self.ln = nn.LayerNorm()

    def forward(self, X, Y):
        return self.ln(self.dropout(Y) + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class AddNorm(nn.Module):  #@save
    """The residual connection followed by layer normalization."""
    def __init__(self, norm_shape, dropout):
        super().__init__()
        self.dropout = nn.Dropout(dropout)
        self.ln = nn.LayerNorm(norm_shape)

    def forward(self, X, Y):
        return self.ln(self.dropout(Y) + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class AddNorm(tf.keras.layers.Layer):  #@save
    """The residual connection followed by layer normalization."""
    def __init__(self, norm_shape, dropout):
        super().__init__()
        self.dropout = tf.keras.layers.Dropout(dropout)
        self.ln = tf.keras.layers.LayerNormalization(norm_shape)

    def call(self, X, Y, **kwargs):
        return self.ln(self.dropout(Y, **kwargs) + X)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class AddNorm(nn.Module):  #@save
    """The residual connection followed by layer normalization."""
    dropout: int

    @nn.compact
    def __call__(self, X, Y, training=False):
        return nn.LayerNorm()(
            nn.Dropout(self.dropout)(Y, deterministic=not training) + X)
</code></pre>
<p>The residual connection requires that
the two inputs are of the same shape
so that [<strong>the output tensor also has the same shape after the addition operation</strong>].</p>
<pre><code class="language-{.python .input}">%%tab mxnet
add_norm = AddNorm(0.5)
add_norm.initialize()
shape = (2, 3, 4)
d2l.check_shape(add_norm(d2l.ones(shape), d2l.ones(shape)), shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
add_norm = AddNorm(4, 0.5)
shape = (2, 3, 4)
d2l.check_shape(add_norm(d2l.ones(shape), d2l.ones(shape)), shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
# Normalized_shape is: [i for i in range(len(input.shape))][1:]
add_norm = AddNorm([1, 2], 0.5)
shape = (2, 3, 4)
d2l.check_shape(add_norm(tf.ones(shape), tf.ones(shape), training=False),
                shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
add_norm = AddNorm(0.5)
shape = (2, 3, 4)
output, _ = add_norm.init_with_output(d2l.get_key(), d2l.ones(shape),
                                      d2l.ones(shape))
d2l.check_shape(output, shape)
</code></pre>
<h2 id="encoder-2"><a class="header" href="#encoder-2">Encoder</a></h2>
<p>:label:<code>subsec_transformer-encoder</code></p>
<p>With all the essential components to assemble
the Transformer encoder,
let's start by
implementing [<strong>a single layer within the encoder</strong>].
The following <code>TransformerEncoderBlock</code> class
contains two sublayers: multi-head self-attention and positionwise feed-forward networks,
where a residual connection followed by layer normalization is employed
around both sublayers.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class TransformerEncoderBlock(nn.Block):  #@save
    """The Transformer encoder block."""
    def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout,
                 use_bias=False):
        super().__init__()
        self.attention = d2l.MultiHeadAttention(
            num_hiddens, num_heads, dropout, use_bias)
        self.addnorm1 = AddNorm(dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm2 = AddNorm(dropout)

    def forward(self, X, valid_lens):
        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))
        return self.addnorm2(Y, self.ffn(Y))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class TransformerEncoderBlock(nn.Module):  #@save
    """The Transformer encoder block."""
    def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout,
                 use_bias=False):
        super().__init__()
        self.attention = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                dropout, use_bias)
        self.addnorm1 = AddNorm(num_hiddens, dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm2 = AddNorm(num_hiddens, dropout)

    def forward(self, X, valid_lens):
        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))
        return self.addnorm2(Y, self.ffn(Y))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class TransformerEncoderBlock(tf.keras.layers.Layer):  #@save
    """The Transformer encoder block."""
    def __init__(self, key_size, query_size, value_size, num_hiddens,
                 norm_shape, ffn_num_hiddens, num_heads, dropout, bias=False):
        super().__init__()
        self.attention = d2l.MultiHeadAttention(
            key_size, query_size, value_size, num_hiddens, num_heads, dropout,
            bias)
        self.addnorm1 = AddNorm(norm_shape, dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm2 = AddNorm(norm_shape, dropout)

    def call(self, X, valid_lens, **kwargs):
        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens, **kwargs),
                          **kwargs)
        return self.addnorm2(Y, self.ffn(Y), **kwargs)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class TransformerEncoderBlock(nn.Module):  #@save
    """The Transformer encoder block."""
    num_hiddens: int
    ffn_num_hiddens: int
    num_heads: int
    dropout: float
    use_bias: bool = False

    def setup(self):
        self.attention = d2l.MultiHeadAttention(self.num_hiddens, self.num_heads,
                                                self.dropout, self.use_bias)
        self.addnorm1 = AddNorm(self.dropout)
        self.ffn = PositionWiseFFN(self.ffn_num_hiddens, self.num_hiddens)
        self.addnorm2 = AddNorm(self.dropout)

    def __call__(self, X, valid_lens, training=False):
        output, attention_weights = self.attention(X, X, X, valid_lens,
                                                   training=training)
        Y = self.addnorm1(X, output, training=training)
        return self.addnorm2(Y, self.ffn(Y), training=training), attention_weights
</code></pre>
<p>As we can see,
[<strong>no layer in the Transformer encoder
changes the shape of its input.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
X = d2l.ones((2, 100, 24))
valid_lens = d2l.tensor([3, 2])
encoder_blk = TransformerEncoderBlock(24, 48, 8, 0.5)
encoder_blk.initialize()
d2l.check_shape(encoder_blk(X, valid_lens), X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
X = d2l.ones((2, 100, 24))
valid_lens = d2l.tensor([3, 2])
encoder_blk = TransformerEncoderBlock(24, 48, 8, 0.5)
encoder_blk.eval()
d2l.check_shape(encoder_blk(X, valid_lens), X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
X = tf.ones((2, 100, 24))
valid_lens = tf.constant([3, 2])
norm_shape = [i for i in range(len(X.shape))][1:]
encoder_blk = TransformerEncoderBlock(24, 24, 24, 24, norm_shape, 48, 8, 0.5)
d2l.check_shape(encoder_blk(X, valid_lens, training=False), X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = jnp.ones((2, 100, 24))
valid_lens = jnp.array([3, 2])
encoder_blk = TransformerEncoderBlock(24, 48, 8, 0.5)
(output, _), _ = encoder_blk.init_with_output(d2l.get_key(), X, valid_lens,
                                              training=False)
d2l.check_shape(output, X.shape)
</code></pre>
<p>In the following [<strong>Transformer encoder</strong>] implementation,
we stack <code>num_blks</code> instances of the above <code>TransformerEncoderBlock</code> classes.
Since we use the fixed positional encoding
whose values are always between $-1$ and $1$,
we multiply values of the learnable input embeddings
by the square root of the embedding dimension
to rescale before summing up the input embedding and the positional encoding.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class TransformerEncoder(d2l.Encoder):  #@save
    """The Transformer encoder."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens,
                 num_heads, num_blks, dropout, use_bias=False):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.embedding = nn.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = nn.Sequential()
        for _ in range(num_blks):
            self.blks.add(TransformerEncoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias))
        self.initialize()

    def forward(self, X, valid_lens):
        # Since positional encoding values are between -1 and 1, the embedding
        # values are multiplied by the square root of the embedding dimension
        # to rescale before they are summed up
        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))
        self.attention_weights = [None] * len(self.blks)
        for i, blk in enumerate(self.blks):
            X = blk(X, valid_lens)
            self.attention_weights[
                i] = blk.attention.attention.attention_weights
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class TransformerEncoder(d2l.Encoder):  #@save
    """The Transformer encoder."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens,
                 num_heads, num_blks, dropout, use_bias=False):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.embedding = nn.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = nn.Sequential()
        for i in range(num_blks):
            self.blks.add_module("block"+str(i), TransformerEncoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias))

    def forward(self, X, valid_lens):
        # Since positional encoding values are between -1 and 1, the embedding
        # values are multiplied by the square root of the embedding dimension
        # to rescale before they are summed up
        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))
        self.attention_weights = [None] * len(self.blks)
        for i, blk in enumerate(self.blks):
            X = blk(X, valid_lens)
            self.attention_weights[
                i] = blk.attention.attention.attention_weights
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class TransformerEncoder(d2l.Encoder):  #@save
    """The Transformer encoder."""
    def __init__(self, vocab_size, key_size, query_size, value_size,
                 num_hiddens, norm_shape, ffn_num_hiddens, num_heads,
                 num_blks, dropout, bias=False):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.embedding = tf.keras.layers.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = [TransformerEncoderBlock(
            key_size, query_size, value_size, num_hiddens, norm_shape,
            ffn_num_hiddens, num_heads, dropout, bias) for _ in range(
            num_blks)]

    def call(self, X, valid_lens, **kwargs):
        # Since positional encoding values are between -1 and 1, the embedding
        # values are multiplied by the square root of the embedding dimension
        # to rescale before they are summed up
        X = self.pos_encoding(self.embedding(X) * tf.math.sqrt(
            tf.cast(self.num_hiddens, dtype=tf.float32)), **kwargs)
        self.attention_weights = [None] * len(self.blks)
        for i, blk in enumerate(self.blks):
            X = blk(X, valid_lens, **kwargs)
            self.attention_weights[
                i] = blk.attention.attention.attention_weights
        return X
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class TransformerEncoder(d2l.Encoder):  #@save
    """The Transformer encoder."""
    vocab_size: int
    num_hiddens:int
    ffn_num_hiddens: int
    num_heads: int
    num_blks: int
    dropout: float
    use_bias: bool = False

    def setup(self):
        self.embedding = nn.Embed(self.vocab_size, self.num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(self.num_hiddens, self.dropout)
        self.blks = [TransformerEncoderBlock(self.num_hiddens,
                                             self.ffn_num_hiddens,
                                             self.num_heads,
                                             self.dropout, self.use_bias)
                     for _ in range(self.num_blks)]

    def __call__(self, X, valid_lens, training=False):
        # Since positional encoding values are between -1 and 1, the embedding
        # values are multiplied by the square root of the embedding dimension
        # to rescale before they are summed up
        X = self.embedding(X) * math.sqrt(self.num_hiddens)
        X = self.pos_encoding(X, training=training)
        attention_weights = [None] * len(self.blks)
        for i, blk in enumerate(self.blks):
            X, attention_w = blk(X, valid_lens, training=training)
            attention_weights[i] = attention_w
        # Flax sow API is used to capture intermediate variables
        self.sow('intermediates', 'enc_attention_weights', attention_weights)
        return X
</code></pre>
<p>Below we specify hyperparameters to [<strong>create a two-layer Transformer encoder</strong>].
The shape of the Transformer encoder output
is (batch size, number of time steps, <code>num_hiddens</code>).</p>
<pre><code class="language-{.python .input}">%%tab mxnet
encoder = TransformerEncoder(200, 24, 48, 8, 2, 0.5)
d2l.check_shape(encoder(np.ones((2, 100)), valid_lens), (2, 100, 24))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
encoder = TransformerEncoder(200, 24, 48, 8, 2, 0.5)
d2l.check_shape(encoder(d2l.ones((2, 100), dtype=torch.long), valid_lens),
                (2, 100, 24))
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
encoder = TransformerEncoder(200, 24, 24, 24, 24, [1, 2], 48, 8, 2, 0.5)
d2l.check_shape(encoder(tf.ones((2, 100)), valid_lens, training=False),
                (2, 100, 24))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
encoder = TransformerEncoder(200, 24, 48, 8, 2, 0.5)
d2l.check_shape(encoder.init_with_output(d2l.get_key(),
                                         jnp.ones((2, 100), dtype=jnp.int32),
                                         valid_lens)[0],
                (2, 100, 24))
</code></pre>
<h2 id="decoder-2"><a class="header" href="#decoder-2">Decoder</a></h2>
<p>As shown in :numref:<code>fig_transformer</code>,
[<strong>the Transformer decoder
is composed of multiple identical layers</strong>].
Each layer is implemented in the following
<code>TransformerDecoderBlock</code> class,
which contains three sublayers:
decoder self-attention,
encoder--decoder attention,
and positionwise feed-forward networks.
These sublayers employ
a residual connection around them
followed by layer normalization.</p>
<p>As we described earlier in this section,
in the masked multi-head decoder self-attention
(the first sublayer),
queries, keys, and values
all come from the outputs of the previous decoder layer.
When training sequence-to-sequence models,
tokens at all the positions (time steps)
of the output sequence
are known.
However,
during prediction
the output sequence is generated token by token;
thus,
at any decoder time step
only the generated tokens
can be used in the decoder self-attention.
To preserve autoregression in the decoder,
its masked self-attention
specifies  <code>dec_valid_lens</code> so that
any query
only attends to
all positions in the decoder
up to the query position.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class TransformerDecoderBlock(nn.Block):
    # The i-th block in the Transformer decoder
    def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout, i):
        super().__init__()
        self.i = i
        self.attention1 = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                 dropout)
        self.addnorm1 = AddNorm(dropout)
        self.attention2 = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                 dropout)
        self.addnorm2 = AddNorm(dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm3 = AddNorm(dropout)

    def forward(self, X, state):
        enc_outputs, enc_valid_lens = state[0], state[1]
        # During training, all the tokens of any output sequence are processed
        # at the same time, so state[2][self.i] is None as initialized. When
        # decoding any output sequence token by token during prediction,
        # state[2][self.i] contains representations of the decoded output at
        # the i-th block up to the current time step
        if state[2][self.i] is None:
            key_values = X
        else:
            key_values = np.concatenate((state[2][self.i], X), axis=1)
        state[2][self.i] = key_values

        if autograd.is_training():
            batch_size, num_steps, _ = X.shape
            # Shape of dec_valid_lens: (batch_size, num_steps), where every
            # row is [1, 2, ..., num_steps]
            dec_valid_lens = np.tile(np.arange(1, num_steps + 1, ctx=X.ctx),
                                     (batch_size, 1))
        else:
            dec_valid_lens = None
        # Self-attention
        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)
        Y = self.addnorm1(X, X2)
        # Encoder-decoder attention. Shape of enc_outputs:
        # (batch_size, num_steps, num_hiddens)
        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)
        Z = self.addnorm2(Y, Y2)
        return self.addnorm3(Z, self.ffn(Z)), state
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class TransformerDecoderBlock(nn.Module):
    # The i-th block in the Transformer decoder
    def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout, i):
        super().__init__()
        self.i = i
        self.attention1 = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                 dropout)
        self.addnorm1 = AddNorm(num_hiddens, dropout)
        self.attention2 = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                 dropout)
        self.addnorm2 = AddNorm(num_hiddens, dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm3 = AddNorm(num_hiddens, dropout)

    def forward(self, X, state):
        enc_outputs, enc_valid_lens = state[0], state[1]
        # During training, all the tokens of any output sequence are processed
        # at the same time, so state[2][self.i] is None as initialized. When
        # decoding any output sequence token by token during prediction,
        # state[2][self.i] contains representations of the decoded output at
        # the i-th block up to the current time step
        if state[2][self.i] is None:
            key_values = X
        else:
            key_values = torch.cat((state[2][self.i], X), dim=1)
        state[2][self.i] = key_values
        if self.training:
            batch_size, num_steps, _ = X.shape
            # Shape of dec_valid_lens: (batch_size, num_steps), where every
            # row is [1, 2, ..., num_steps]
            dec_valid_lens = torch.arange(
                1, num_steps + 1, device=X.device).repeat(batch_size, 1)
        else:
            dec_valid_lens = None
        # Self-attention
        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)
        Y = self.addnorm1(X, X2)
        # Encoder-decoder attention. Shape of enc_outputs:
        # (batch_size, num_steps, num_hiddens)
        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)
        Z = self.addnorm2(Y, Y2)
        return self.addnorm3(Z, self.ffn(Z)), state
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class TransformerDecoderBlock(tf.keras.layers.Layer):
    # The i-th block in the Transformer decoder
    def __init__(self, key_size, query_size, value_size, num_hiddens,
                 norm_shape, ffn_num_hiddens, num_heads, dropout, i):
        super().__init__()
        self.i = i
        self.attention1 = d2l.MultiHeadAttention(
            key_size, query_size, value_size, num_hiddens, num_heads, dropout)
        self.addnorm1 = AddNorm(norm_shape, dropout)
        self.attention2 = d2l.MultiHeadAttention(
            key_size, query_size, value_size, num_hiddens, num_heads, dropout)
        self.addnorm2 = AddNorm(norm_shape, dropout)
        self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens)
        self.addnorm3 = AddNorm(norm_shape, dropout)

    def call(self, X, state, **kwargs):
        enc_outputs, enc_valid_lens = state[0], state[1]
        # During training, all the tokens of any output sequence are processed
        # at the same time, so state[2][self.i] is None as initialized. When
        # decoding any output sequence token by token during prediction,
        # state[2][self.i] contains representations of the decoded output at
        # the i-th block up to the current time step
        if state[2][self.i] is None:
            key_values = X
        else:
            key_values = tf.concat((state[2][self.i], X), axis=1)
        state[2][self.i] = key_values
        if kwargs["training"]:
            batch_size, num_steps, _ = X.shape
            # Shape of dec_valid_lens: (batch_size, num_steps), where every
            # row is [1, 2, ..., num_steps]
            dec_valid_lens = tf.repeat(
                tf.reshape(tf.range(1, num_steps + 1),
                           shape=(-1, num_steps)), repeats=batch_size, axis=0)
        else:
            dec_valid_lens = None
        # Self-attention
        X2 = self.attention1(X, key_values, key_values, dec_valid_lens,
                             **kwargs)
        Y = self.addnorm1(X, X2, **kwargs)
        # Encoder-decoder attention. Shape of enc_outputs:
        # (batch_size, num_steps, num_hiddens)
        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens,
                             **kwargs)
        Z = self.addnorm2(Y, Y2, **kwargs)
        return self.addnorm3(Z, self.ffn(Z), **kwargs), state
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class TransformerDecoderBlock(nn.Module):
    # The i-th block in the Transformer decoder
    num_hiddens: int
    ffn_num_hiddens: int
    num_heads: int
    dropout: float
    i: int

    def setup(self):
        self.attention1 = d2l.MultiHeadAttention(self.num_hiddens,
                                                 self.num_heads,
                                                 self.dropout)
        self.addnorm1 = AddNorm(self.dropout)
        self.attention2 = d2l.MultiHeadAttention(self.num_hiddens,
                                                 self.num_heads,
                                                 self.dropout)
        self.addnorm2 = AddNorm(self.dropout)
        self.ffn = PositionWiseFFN(self.ffn_num_hiddens, self.num_hiddens)
        self.addnorm3 = AddNorm(self.dropout)

    def __call__(self, X, state, training=False):
        enc_outputs, enc_valid_lens = state[0], state[1]
        # During training, all the tokens of any output sequence are processed
        # at the same time, so state[2][self.i] is None as initialized. When
        # decoding any output sequence token by token during prediction,
        # state[2][self.i] contains representations of the decoded output at
        # the i-th block up to the current time step
        if state[2][self.i] is None:
            key_values = X
        else:
            key_values = jnp.concatenate((state[2][self.i], X), axis=1)
        state[2][self.i] = key_values
        if training:
            batch_size, num_steps, _ = X.shape
            # Shape of dec_valid_lens: (batch_size, num_steps), where every
            # row is [1, 2, ..., num_steps]
            dec_valid_lens = jnp.tile(jnp.arange(1, num_steps + 1),
                                      (batch_size, 1))
        else:
            dec_valid_lens = None
        # Self-attention
        X2, attention_w1 = self.attention1(X, key_values, key_values,
                                           dec_valid_lens, training=training)
        Y = self.addnorm1(X, X2, training=training)
        # Encoder-decoder attention. Shape of enc_outputs:
        # (batch_size, num_steps, num_hiddens)
        Y2, attention_w2 = self.attention2(Y, enc_outputs, enc_outputs,
                                           enc_valid_lens, training=training)
        Z = self.addnorm2(Y, Y2, training=training)
        return self.addnorm3(Z, self.ffn(Z), training=training), state, attention_w1, attention_w2
</code></pre>
<p>To facilitate scaled dot product operations
in the encoder--decoder attention
and addition operations in the residual connections,
[<strong>the feature dimension (<code>num_hiddens</code>) of the decoder is
the same as that of the encoder.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab mxnet
decoder_blk = TransformerDecoderBlock(24, 48, 8, 0.5, 0)
decoder_blk.initialize()
X = np.ones((2, 100, 24))
state = [encoder_blk(X, valid_lens), valid_lens, [None]]
d2l.check_shape(decoder_blk(X, state)[0], X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
decoder_blk = TransformerDecoderBlock(24, 48, 8, 0.5, 0)
X = d2l.ones((2, 100, 24))
state = [encoder_blk(X, valid_lens), valid_lens, [None]]
d2l.check_shape(decoder_blk(X, state)[0], X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
decoder_blk = TransformerDecoderBlock(24, 24, 24, 24, [1, 2], 48, 8, 0.5, 0)
X = tf.ones((2, 100, 24))
state = [encoder_blk(X, valid_lens), valid_lens, [None]]
d2l.check_shape(decoder_blk(X, state, training=False)[0], X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
decoder_blk = TransformerDecoderBlock(24, 48, 8, 0.5, 0)
X = d2l.ones((2, 100, 24))
state = [encoder_blk.init_with_output(d2l.get_key(), X, valid_lens)[0][0],
         valid_lens, [None]]
d2l.check_shape(decoder_blk.init_with_output(d2l.get_key(), X, state)[0][0],
                X.shape)
</code></pre>
<p>Now we [<strong>construct the entire Transformer decoder</strong>]
composed of <code>num_blks</code> instances of <code>TransformerDecoderBlock</code>.
In the end,
a fully connected layer computes the prediction
for all the <code>vocab_size</code> possible output tokens.
Both of the decoder self-attention weights
and the encoder--decoder attention weights
are stored for later visualization.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
class TransformerDecoder(d2l.AttentionDecoder):
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                 num_blks, dropout):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.num_blks = num_blks
        self.embedding = nn.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = nn.Sequential()
        for i in range(num_blks):
            self.blks.add(TransformerDecoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, i))
        self.dense = nn.Dense(vocab_size, flatten=False)
        self.initialize()

    def init_state(self, enc_outputs, enc_valid_lens):
        return [enc_outputs, enc_valid_lens, [None] * self.num_blks]

    def forward(self, X, state):
        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))
        self._attention_weights = [[None] * len(self.blks) for _ in range (2)]
        for i, blk in enumerate(self.blks):
            X, state = blk(X, state)
            # Decoder self-attention weights
            self._attention_weights[0][
                i] = blk.attention1.attention.attention_weights
            # Encoder-decoder attention weights
            self._attention_weights[1][
                i] = blk.attention2.attention.attention_weights
        return self.dense(X), state

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
class TransformerDecoder(d2l.AttentionDecoder):
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                 num_blks, dropout):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.num_blks = num_blks
        self.embedding = nn.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = nn.Sequential()
        for i in range(num_blks):
            self.blks.add_module("block"+str(i), TransformerDecoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, i))
        self.dense = nn.LazyLinear(vocab_size)

    def init_state(self, enc_outputs, enc_valid_lens):
        return [enc_outputs, enc_valid_lens, [None] * self.num_blks]

    def forward(self, X, state):
        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))
        self._attention_weights = [[None] * len(self.blks) for _ in range (2)]
        for i, blk in enumerate(self.blks):
            X, state = blk(X, state)
            # Decoder self-attention weights
            self._attention_weights[0][
                i] = blk.attention1.attention.attention_weights
            # Encoder-decoder attention weights
            self._attention_weights[1][
                i] = blk.attention2.attention.attention_weights
        return self.dense(X), state

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
class TransformerDecoder(d2l.AttentionDecoder):
    def __init__(self, vocab_size, key_size, query_size, value_size,
                 num_hiddens, norm_shape, ffn_num_hiddens, num_heads,
                 num_blks, dropout):
        super().__init__()
        self.num_hiddens = num_hiddens
        self.num_blks = num_blks
        self.embedding = tf.keras.layers.Embedding(vocab_size, num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)
        self.blks = [TransformerDecoderBlock(
            key_size, query_size, value_size, num_hiddens, norm_shape,
            ffn_num_hiddens, num_heads, dropout, i)
                     for i in range(num_blks)]
        self.dense = tf.keras.layers.Dense(vocab_size)

    def init_state(self, enc_outputs, enc_valid_lens):
        return [enc_outputs, enc_valid_lens, [None] * self.num_blks]

    def call(self, X, state, **kwargs):
        X = self.pos_encoding(self.embedding(X) * tf.math.sqrt(
            tf.cast(self.num_hiddens, dtype=tf.float32)), **kwargs)
        # 2 attention layers in decoder
        self._attention_weights = [[None] * len(self.blks) for _ in range(2)]
        for i, blk in enumerate(self.blks):
            X, state = blk(X, state, **kwargs)
            # Decoder self-attention weights
            self._attention_weights[0][i] = (
                blk.attention1.attention.attention_weights)
            # Encoder-decoder attention weights
            self._attention_weights[1][i] = (
                blk.attention2.attention.attention_weights)
        return self.dense(X), state

    @property
    def attention_weights(self):
        return self._attention_weights
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class TransformerDecoder(nn.Module):
    vocab_size: int
    num_hiddens: int
    ffn_num_hiddens: int
    num_heads: int
    num_blks: int
    dropout: float

    def setup(self):
        self.embedding = nn.Embed(self.vocab_size, self.num_hiddens)
        self.pos_encoding = d2l.PositionalEncoding(self.num_hiddens,
                                                   self.dropout)
        self.blks = [TransformerDecoderBlock(self.num_hiddens,
                                             self.ffn_num_hiddens,
                                             self.num_heads, self.dropout, i)
                     for i in range(self.num_blks)]
        self.dense = nn.Dense(self.vocab_size)

    def init_state(self, enc_outputs, enc_valid_lens):
        return [enc_outputs, enc_valid_lens, [None] * self.num_blks]

    def __call__(self, X, state, training=False):
        X = self.embedding(X) * jnp.sqrt(jnp.float32(self.num_hiddens))
        X = self.pos_encoding(X, training=training)
        attention_weights = [[None] * len(self.blks) for _ in range(2)]
        for i, blk in enumerate(self.blks):
            X, state, attention_w1, attention_w2 = blk(X, state,
                                                       training=training)
            # Decoder self-attention weights
            attention_weights[0][i] = attention_w1
            # Encoder-decoder attention weights
            attention_weights[1][i] = attention_w2
        # Flax sow API is used to capture intermediate variables
        self.sow('intermediates', 'dec_attention_weights', attention_weights)
        return self.dense(X), state
</code></pre>
<h2 id="training-21"><a class="header" href="#training-21">[<strong>Training</strong>]</a></h2>
<p>Let's instantiate an encoder--decoder model
by following the Transformer architecture.
Here we specify that
both the Transformer encoder and the Transformer decoder
have two layers using 4-head attention.
As in :numref:<code>sec_seq2seq_training</code>,
we train the Transformer model
for sequence-to-sequence learning on the English--French machine translation dataset.</p>
<pre><code class="language-{.python .input}">%%tab all
data = d2l.MTFraEng(batch_size=128)
num_hiddens, num_blks, dropout = 256, 2, 0.2
ffn_num_hiddens, num_heads = 64, 4
if tab.selected('tensorflow'):
    key_size, query_size, value_size = 256, 256, 256
    norm_shape = [2]
if tab.selected('pytorch', 'mxnet', 'jax'):
    encoder = TransformerEncoder(
        len(data.src_vocab), num_hiddens, ffn_num_hiddens, num_heads,
        num_blks, dropout)
    decoder = TransformerDecoder(
        len(data.tgt_vocab), num_hiddens, ffn_num_hiddens, num_heads,
        num_blks, dropout)
if tab.selected('mxnet', 'pytorch'):
    model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                        lr=0.001)
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1)
if tab.selected('jax'):
    model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                        lr=0.001, training=True)
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1)
if tab.selected('tensorflow'):
    with d2l.try_gpu():
        encoder = TransformerEncoder(
            len(data.src_vocab), key_size, query_size, value_size, num_hiddens,
            norm_shape, ffn_num_hiddens, num_heads, num_blks, dropout)
        decoder = TransformerDecoder(
            len(data.tgt_vocab), key_size, query_size, value_size, num_hiddens,
            norm_shape, ffn_num_hiddens, num_heads, num_blks, dropout)
        model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['&lt;pad&gt;'],
                            lr=0.001)
    trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1)
trainer.fit(model, data)
</code></pre>
<p>After training,
we use the Transformer model
to [<strong>translate a few English sentences</strong>] into French and compute their BLEU scores.</p>
<pre><code class="language-{.python .input}">%%tab all
engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .']
fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .']
if tab.selected('pytorch', 'mxnet', 'tensorflow'):
    preds, _ = model.predict_step(
        data.build(engs, fras), d2l.try_gpu(), data.num_steps)
if tab.selected('jax'):
    preds, _ = model.predict_step(
        trainer.state.params, data.build(engs, fras), data.num_steps)
for en, fr, p in zip(engs, fras, preds):
    translation = []
    for token in data.tgt_vocab.to_tokens(p):
        if token == '&lt;eos&gt;':
            break
        translation.append(token)
    print(f'{en} =&gt; {translation}, bleu,'
          f'{d2l.bleu(" ".join(translation), fr, k=2):.3f}')
</code></pre>
<p>Let's [<strong>visualize the Transformer attention weights</strong>] when translating the final English sentence into French.
The shape of the encoder self-attention weights
is (number of encoder layers, number of attention heads, <code>num_steps</code> or number of queries, <code>num_steps</code> or number of key-value pairs).</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
_, dec_attention_weights = model.predict_step(
    data.build([engs[-1]], [fras[-1]]), d2l.try_gpu(), data.num_steps, True)
enc_attention_weights = d2l.concat(model.encoder.attention_weights, 0)
shape = (num_blks, num_heads, -1, data.num_steps)
enc_attention_weights = d2l.reshape(enc_attention_weights, shape)
d2l.check_shape(enc_attention_weights,
                (num_blks, num_heads, data.num_steps, data.num_steps))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
_, (dec_attention_weights, enc_attention_weights) = model.predict_step(
    trainer.state.params, data.build([engs[-1]], [fras[-1]]),
    data.num_steps, True)
enc_attention_weights = d2l.concat(enc_attention_weights, 0)
shape = (num_blks, num_heads, -1, data.num_steps)
enc_attention_weights = d2l.reshape(enc_attention_weights, shape)
d2l.check_shape(enc_attention_weights,
                (num_blks, num_heads, data.num_steps, data.num_steps))
</code></pre>
<p>In the encoder self-attention,
both queries and keys come from the same input sequence.
Since padding tokens do not carry meaning,
with specified valid length of the input sequence
no query attends to positions of padding tokens.
In the following,
two layers of multi-head attention weights
are presented row by row.
Each head independently attends
based on a separate representation subspace of queries, keys, and values.</p>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow, jax
d2l.show_heatmaps(
    enc_attention_weights, xlabel='Key positions', ylabel='Query positions',
    titles=['Head %d' % i for i in range(1, 5)], figsize=(7, 3.5))
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
d2l.show_heatmaps(
    enc_attention_weights.cpu(), xlabel='Key positions',
    ylabel='Query positions', titles=['Head %d' % i for i in range(1, 5)],
    figsize=(7, 3.5))
</code></pre>
<p>[<strong>To visualize the decoder self-attention weights and the encoder--decoder attention weights,
we need more data manipulations.</strong>]
For example,
we fill the masked attention weights with zero.
Note that
the decoder self-attention weights
and the encoder--decoder attention weights
both have the same queries:
the beginning-of-sequence token followed by
the output tokens and possibly
end-of-sequence tokens.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
dec_attention_weights_2d = [d2l.tensor(head[0]).tolist()
                            for step in dec_attention_weights
                            for attn in step for blk in attn for head in blk]
dec_attention_weights_filled = d2l.tensor(
    pd.DataFrame(dec_attention_weights_2d).fillna(0.0).values)
dec_attention_weights = d2l.reshape(dec_attention_weights_filled, (
    -1, 2, num_blks, num_heads, data.num_steps))
dec_self_attention_weights, dec_inter_attention_weights = \
    dec_attention_weights.transpose(1, 2, 3, 0, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
dec_attention_weights_2d = [head[0].tolist()
                            for step in dec_attention_weights
                            for attn in step for blk in attn for head in blk]
dec_attention_weights_filled = d2l.tensor(
    pd.DataFrame(dec_attention_weights_2d).fillna(0.0).values)
shape = (-1, 2, num_blks, num_heads, data.num_steps)
dec_attention_weights = d2l.reshape(dec_attention_weights_filled, shape)
dec_self_attention_weights, dec_inter_attention_weights = \
    dec_attention_weights.permute(1, 2, 3, 0, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
dec_attention_weights_2d = [head[0] for step in dec_attention_weights
                            for attn in step
                            for blk in attn for head in blk]
dec_attention_weights_filled = tf.convert_to_tensor(
    np.asarray(pd.DataFrame(dec_attention_weights_2d).fillna(
        0.0).values).astype(np.float32))
dec_attention_weights = tf.reshape(dec_attention_weights_filled, shape=(
    -1, 2, num_blks, num_heads, data.num_steps))
dec_self_attention_weights, dec_inter_attention_weights = tf.transpose(
    dec_attention_weights, perm=(1, 2, 3, 0, 4))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
dec_attention_weights_2d = [head[0].tolist() for step in dec_attention_weights
                            for attn in step
                            for blk in attn for head in blk]
dec_attention_weights_filled = d2l.tensor(
    pd.DataFrame(dec_attention_weights_2d).fillna(0.0).values)
dec_attention_weights = dec_attention_weights_filled.reshape(
    (-1, 2, num_blks, num_heads, data.num_steps))
dec_self_attention_weights, dec_inter_attention_weights = \
    dec_attention_weights.transpose(1, 2, 3, 0, 4)
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
d2l.check_shape(dec_self_attention_weights,
                (num_blks, num_heads, data.num_steps, data.num_steps))
d2l.check_shape(dec_inter_attention_weights,
                (num_blks, num_heads, data.num_steps, data.num_steps))
</code></pre>
<p>Because of the autoregressive property of the decoder self-attention,
no query attends to key--value pairs after the query position.</p>
<pre><code class="language-{.python .input}">%%tab all
d2l.show_heatmaps(
    dec_self_attention_weights[:, :, :, :],
    xlabel='Key positions', ylabel='Query positions',
    titles=['Head %d' % i for i in range(1, 5)], figsize=(7, 3.5))
</code></pre>
<p>Similar to the case in the encoder self-attention,
via the specified valid length of the input sequence,
[<strong>no query from the output sequence
attends to those padding tokens from the input sequence.</strong>]</p>
<pre><code class="language-{.python .input}">%%tab all
d2l.show_heatmaps(
    dec_inter_attention_weights, xlabel='Key positions',
    ylabel='Query positions', titles=['Head %d' % i for i in range(1, 5)],
    figsize=(7, 3.5))
</code></pre>
<p>Although the Transformer architecture
was originally proposed for sequence-to-sequence learning,
as we will discover later in the book,
either the Transformer encoder
or the Transformer decoder
is often individually used
for different deep learning tasks.</p>
<h2 id="summary-53"><a class="header" href="#summary-53">Summary</a></h2>
<p>The Transformer is an instance of the encoder--decoder architecture,
though either the encoder or the decoder can be used individually in practice.
In the Transformer architecture, multi-head self-attention is used
for representing the input sequence and the output sequence,
though the decoder has to preserve the autoregressive property via a masked version.
Both the residual connections and the layer normalization in the Transformer
are important for training a very deep model.
The positionwise feed-forward network in the Transformer model
transforms the representation at all the sequence positions using the same MLP.</p>
<h2 id="exercises-71"><a class="header" href="#exercises-71">Exercises</a></h2>
<ol>
<li>Train a deeper Transformer in the experiments. How does it affect the training speed and the translation performance?</li>
<li>Is it a good idea to replace scaled dot product attention with additive attention in the Transformer? Why?</li>
<li>For language modeling, should we use the Transformer encoder, decoder, or both? How would you design this method?</li>
<li>What challenges can Transformers face if input sequences are very long? Why?</li>
<li>How would you improve the computational and memory efficiency of Transformers? Hint: you may refer to the survey paper by :citet:<code>Tay.Dehghani.Bahri.ea.2020</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/348">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1066">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/3871">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18031">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['pytorch', 'jax'])
</code></pre>
<h1 id="transformers-for-vision"><a class="header" href="#transformers-for-vision">Transformers for Vision</a></h1>
<p>:label:<code>sec_vision-transformer</code></p>
<p>The Transformer architecture was initially proposed
for sequence-to-sequence learning,
with a focus on machine translation.
Subsequently, Transformers emerged as the model of choice
in various natural language processing tasks :cite:<code>Radford.Narasimhan.Salimans.ea.2018,Radford.Wu.Child.ea.2019,brown2020language,Devlin.Chang.Lee.ea.2018,raffel2020exploring</code>.
However, in the field of computer vision
the dominant architecture has remained
the CNN (:numref:<code>chap_modern_cnn</code>).
Naturally, researchers started to wonder
if it might be possible to do better
by adapting Transformer models to image data.
This question sparked immense interest
in the computer vision community.
Recently, :citet:<code>ramachandran2019stand</code> proposed
a scheme for replacing convolution with self-attention.
However, its use of specialized patterns in attention
makes it hard to scale up models on hardware accelerators.
Then, :citet:<code>cordonnier2020relationship</code> theoretically proved
that self-attention can learn to behave similarly to convolution.
Empirically, $2 \times 2$ patches were taken from images as inputs,
but the small patch size makes the model
only applicable to image data with low resolutions.</p>
<p>Without specific constraints on patch size,
<em>vision Transformers</em> (ViTs)
extract patches from images
and feed them into a Transformer encoder
to obtain a global representation,
which will finally be transformed for classification :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021</code>.
Notably, Transformers show better scalability than CNNs:
and when training larger models on larger datasets,
vision Transformers outperform ResNets by a significant margin.
Similar to the landscape of network architecture design in natural language processing,
Transformers have also become a game-changer in computer vision.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
from d2l import jax as d2l
from flax import linen as nn
import jax
from jax import numpy as jnp
</code></pre>
<h2 id="model-6"><a class="header" href="#model-6">Model</a></h2>
<p>:numref:<code>fig_vit</code> depicts
the model architecture of vision Transformers.
This architecture consists of a stem
that patchifies images,
a body based on the multilayer Transformer encoder,
and a head that transforms the global representation
into the output label.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/vit.svg" alt="The vision Transformer architecture. In this example, an image is split into nine patches. A special “&lt;cls&gt;” token and the nine flattened image patches are transformed via patch embedding and $\mathit{n}$ Transformer encoder blocks into ten representations, respectively. The “&lt;cls&gt;” representation is further transformed into the output label." />
:label:<code>fig_vit</code></p>
<p>Consider an input image with height $h$, width $w$,
and $c$ channels.
Specifying the patch height and width both as $p$,
the image is split into a sequence of $m = hw/p^2$ patches,
where each patch is flattened to a vector of length $cp^2$.
In this way, image patches can be treated similarly to tokens in text sequences by Transformer encoders.
A special “&lt;cls&gt;” (class) token and
the $m$ flattened image patches are linearly projected
into a sequence of $m+1$ vectors,
summed with learnable positional embeddings.
The multilayer Transformer encoder
transforms $m+1$ input vectors
into the same number of output vector representations of the same length.
It works exactly the same way as the original Transformer encoder in :numref:<code>fig_transformer</code>,
only differing in the position of normalization.
Since the “&lt;cls&gt;” token attends to all the image patches
via self-attention (see :numref:<code>fig_cnn-rnn-self-attention</code>),
its representation from the Transformer encoder output
will be further transformed into the output label.</p>
<h2 id="patch-embedding"><a class="header" href="#patch-embedding">Patch Embedding</a></h2>
<p>To implement a vision Transformer, let's start
with patch embedding in :numref:<code>fig_vit</code>.
Splitting an image into patches
and linearly projecting these flattened patches
can be simplified as a single convolution operation,
where both the kernel size and the stride size are set to the patch size.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class PatchEmbedding(nn.Module):
    def __init__(self, img_size=96, patch_size=16, num_hiddens=512):
        super().__init__()
        def _make_tuple(x):
            if not isinstance(x, (list, tuple)):
                return (x, x)
            return x
        img_size, patch_size = _make_tuple(img_size), _make_tuple(patch_size)
        self.num_patches = (img_size[0] // patch_size[0]) * (
            img_size[1] // patch_size[1])
        self.conv = nn.LazyConv2d(num_hiddens, kernel_size=patch_size,
                                  stride=patch_size)

    def forward(self, X):
        # Output shape: (batch size, no. of patches, no. of channels)
        return self.conv(X).flatten(2).transpose(1, 2)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class PatchEmbedding(nn.Module):
    img_size: int = 96
    patch_size: int = 16
    num_hiddens: int = 512

    def setup(self):
        def _make_tuple(x):
            if not isinstance(x, (list, tuple)):
                return (x, x)
            return x
        img_size, patch_size = _make_tuple(self.img_size), _make_tuple(self.patch_size)
        self.num_patches = (img_size[0] // patch_size[0]) * (
            img_size[1] // patch_size[1])
        self.conv = nn.Conv(self.num_hiddens, kernel_size=patch_size,
                            strides=patch_size, padding='SAME')

    def __call__(self, X):
        # Output shape: (batch size, no. of patches, no. of channels)
        X = self.conv(X)
        return X.reshape((X.shape[0], -1, X.shape[3]))
</code></pre>
<p>In the following example, taking images with height and width of <code>img_size</code> as inputs,
the patch embedding outputs <code>(img_size//patch_size)**2</code> patches
that are linearly projected to vectors of length <code>num_hiddens</code>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
img_size, patch_size, num_hiddens, batch_size = 96, 16, 512, 4
patch_emb = PatchEmbedding(img_size, patch_size, num_hiddens)
X = d2l.zeros(batch_size, 3, img_size, img_size)
d2l.check_shape(patch_emb(X),
                (batch_size, (img_size//patch_size)**2, num_hiddens))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
img_size, patch_size, num_hiddens, batch_size = 96, 16, 512, 4
patch_emb = PatchEmbedding(img_size, patch_size, num_hiddens)
X = d2l.zeros((batch_size, img_size, img_size, 3))
output, _ = patch_emb.init_with_output(d2l.get_key(), X)
d2l.check_shape(output, (batch_size, (img_size//patch_size)**2, num_hiddens))
</code></pre>
<h2 id="vision-transformer-encoder"><a class="header" href="#vision-transformer-encoder">Vision Transformer Encoder</a></h2>
<p>:label:<code>subsec_vit-encoder</code></p>
<p>The MLP of the vision Transformer encoder is slightly different
from the positionwise FFN of the original Transformer encoder
(see :numref:<code>subsec_positionwise-ffn</code>).
First, here the activation function uses the Gaussian error linear unit (GELU),
which can be considered as a smoother version of the ReLU :cite:<code>Hendrycks.Gimpel.2016</code>.
Second, dropout is applied to the output of each fully connected layer in the MLP for regularization.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class ViTMLP(nn.Module):
    def __init__(self, mlp_num_hiddens, mlp_num_outputs, dropout=0.5):
        super().__init__()
        self.dense1 = nn.LazyLinear(mlp_num_hiddens)
        self.gelu = nn.GELU()
        self.dropout1 = nn.Dropout(dropout)
        self.dense2 = nn.LazyLinear(mlp_num_outputs)
        self.dropout2 = nn.Dropout(dropout)

    def forward(self, x):
        return self.dropout2(self.dense2(self.dropout1(self.gelu(
            self.dense1(x)))))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ViTMLP(nn.Module):
    mlp_num_hiddens: int
    mlp_num_outputs: int
    dropout: float = 0.5

    @nn.compact
    def __call__(self, x, training=False):
        x = nn.Dense(self.mlp_num_hiddens)(x)
        x = nn.gelu(x)
        x = nn.Dropout(self.dropout, deterministic=not training)(x)
        x = nn.Dense(self.mlp_num_outputs)(x)
        x = nn.Dropout(self.dropout, deterministic=not training)(x)
        return x
</code></pre>
<p>The vision Transformer encoder block implementation
just follows the pre-normalization design in :numref:<code>fig_vit</code>,
where normalization is applied right <em>before</em> multi-head attention or the MLP.
In contrast to post-normalization ("add &amp; norm" in :numref:<code>fig_transformer</code>),
where normalization is placed right <em>after</em> residual connections,
pre-normalization leads to more effective or efficient training for Transformers :cite:<code>baevski2018adaptive,wang2019learning,xiong2020layer</code>.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class ViTBlock(nn.Module):
    def __init__(self, num_hiddens, norm_shape, mlp_num_hiddens,
                 num_heads, dropout, use_bias=False):
        super().__init__()
        self.ln1 = nn.LayerNorm(norm_shape)
        self.attention = d2l.MultiHeadAttention(num_hiddens, num_heads,
                                                dropout, use_bias)
        self.ln2 = nn.LayerNorm(norm_shape)
        self.mlp = ViTMLP(mlp_num_hiddens, num_hiddens, dropout)

    def forward(self, X, valid_lens=None):
        X = X + self.attention(*([self.ln1(X)] * 3), valid_lens)
        return X + self.mlp(self.ln2(X))
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ViTBlock(nn.Module):
    num_hiddens: int
    mlp_num_hiddens: int
    num_heads: int
    dropout: float
    use_bias: bool = False

    def setup(self):
        self.attention = d2l.MultiHeadAttention(self.num_hiddens, self.num_heads,
                                                self.dropout, self.use_bias)
        self.mlp = ViTMLP(self.mlp_num_hiddens, self.num_hiddens, self.dropout)

    @nn.compact
    def __call__(self, X, valid_lens=None, training=False):
        X = X + self.attention(*([nn.LayerNorm()(X)] * 3),
                               valid_lens, training=training)[0]
        return X + self.mlp(nn.LayerNorm()(X), training=training)
</code></pre>
<p>Just as in :numref:<code>subsec_transformer-encoder</code>,
no vision Transformer encoder block changes its input shape.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
X = d2l.ones((2, 100, 24))
encoder_blk = ViTBlock(24, 24, 48, 8, 0.5)
encoder_blk.eval()
d2l.check_shape(encoder_blk(X), X.shape)
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
X = d2l.ones((2, 100, 24))
encoder_blk = ViTBlock(24, 48, 8, 0.5)
d2l.check_shape(encoder_blk.init_with_output(d2l.get_key(), X)[0], X.shape)
</code></pre>
<h2 id="putting-it-all-together-1"><a class="header" href="#putting-it-all-together-1">Putting It All Together</a></h2>
<p>The forward pass of vision Transformers below is straightforward.
First, input images are fed into an <code>PatchEmbedding</code> instance,
whose output is concatenated with the “&lt;cls&gt;”  token embedding.
They are summed with learnable positional embeddings before dropout.
Then the output is fed into the Transformer encoder that stacks <code>num_blks</code> instances of the <code>ViTBlock</code> class.
Finally, the representation of the “&lt;cls&gt;”  token is projected by the network head.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
class ViT(d2l.Classifier):
    """Vision Transformer."""
    def __init__(self, img_size, patch_size, num_hiddens, mlp_num_hiddens,
                 num_heads, num_blks, emb_dropout, blk_dropout, lr=0.1,
                 use_bias=False, num_classes=10):
        super().__init__()
        self.save_hyperparameters()
        self.patch_embedding = PatchEmbedding(
            img_size, patch_size, num_hiddens)
        self.cls_token = nn.Parameter(d2l.zeros(1, 1, num_hiddens))
        num_steps = self.patch_embedding.num_patches + 1  # Add the cls token
        # Positional embeddings are learnable
        self.pos_embedding = nn.Parameter(
            torch.randn(1, num_steps, num_hiddens))
        self.dropout = nn.Dropout(emb_dropout)
        self.blks = nn.Sequential()
        for i in range(num_blks):
            self.blks.add_module(f"{i}", ViTBlock(
                num_hiddens, num_hiddens, mlp_num_hiddens,
                num_heads, blk_dropout, use_bias))
        self.head = nn.Sequential(nn.LayerNorm(num_hiddens),
                                  nn.Linear(num_hiddens, num_classes))

    def forward(self, X):
        X = self.patch_embedding(X)
        X = d2l.concat((self.cls_token.expand(X.shape[0], -1, -1), X), 1)
        X = self.dropout(X + self.pos_embedding)
        for blk in self.blks:
            X = blk(X)
        return self.head(X[:, 0])
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
class ViT(d2l.Classifier):
    """Vision Transformer."""
    img_size: int
    patch_size: int
    num_hiddens: int
    mlp_num_hiddens: int
    num_heads: int
    num_blks: int
    emb_dropout: float
    blk_dropout: float
    lr: float = 0.1
    use_bias: bool = False
    num_classes: int = 10
    training: bool = False

    def setup(self):
        self.patch_embedding = PatchEmbedding(self.img_size, self.patch_size,
                                              self.num_hiddens)
        self.cls_token = self.param('cls_token', nn.initializers.zeros,
                                    (1, 1, self.num_hiddens))
        num_steps = self.patch_embedding.num_patches + 1  # Add the cls token
        # Positional embeddings are learnable
        self.pos_embedding = self.param('pos_embed', nn.initializers.normal(),
                                        (1, num_steps, self.num_hiddens))
        self.blks = [ViTBlock(self.num_hiddens, self.mlp_num_hiddens,
                              self.num_heads, self.blk_dropout, self.use_bias)
                    for _ in range(self.num_blks)]
        self.head = nn.Sequential([nn.LayerNorm(), nn.Dense(self.num_classes)])

    @nn.compact
    def __call__(self, X):
        X = self.patch_embedding(X)
        X = d2l.concat((jnp.tile(self.cls_token, (X.shape[0], 1, 1)), X), 1)
        X = nn.Dropout(emb_dropout, deterministic=not self.training)(X + self.pos_embedding)
        for blk in self.blks:
            X = blk(X, training=self.training)
        return self.head(X[:, 0])
</code></pre>
<h2 id="training-22"><a class="header" href="#training-22">Training</a></h2>
<p>Training a vision Transformer on the Fashion-MNIST dataset is just like how CNNs were trained in :numref:<code>chap_modern_cnn</code>.</p>
<pre><code class="language-{.python .input}">%%tab all
img_size, patch_size = 96, 16
num_hiddens, mlp_num_hiddens, num_heads, num_blks = 512, 2048, 8, 2
emb_dropout, blk_dropout, lr = 0.1, 0.1, 0.1
model = ViT(img_size, patch_size, num_hiddens, mlp_num_hiddens, num_heads,
            num_blks, emb_dropout, blk_dropout, lr)
trainer = d2l.Trainer(max_epochs=10, num_gpus=1)
data = d2l.FashionMNIST(batch_size=128, resize=(img_size, img_size))
trainer.fit(model, data)
</code></pre>
<h2 id="summary-and-discussion-8"><a class="header" href="#summary-and-discussion-8">Summary and Discussion</a></h2>
<p>You may have noticed that for small datasets like Fashion-MNIST,
our implemented vision Transformer
does not outperform the ResNet in :numref:<code>sec_resnet</code>.
Similar observations can be made even on the ImageNet dataset (1.2 million images).
This is because Transformers <em>lack</em> those useful principles in convolution,
such as translation invariance and locality (:numref:<code>sec_why-conv</code>).
However, the picture changes when training larger models on larger datasets (e.g., 300 million images),
where vision Transformers outperform ResNets by a large margin in image classification, demonstrating
intrinsic superiority of Transformers in scalability :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021</code>.
The introduction of vision Transformers
has changed the landscape of network design for modeling image data.
They were soon shown to be effective on the ImageNet dataset
with data-efficient training strategies of DeiT :cite:<code>touvron2021training</code>.
However, the quadratic complexity of self-attention
(:numref:<code>sec_self-attention-and-positional-encoding</code>)
makes the Transformer architecture
less suitable for higher-resolution images.
Towards a general-purpose backbone network in computer vision,
Swin Transformers addressed the quadratic computational complexity
with respect to image size (:numref:<code>subsec_cnn-rnn-self-attention</code>)
and reinstated convolution-like priors,
extending the applicability of Transformers to a range of computer vision tasks
beyond image classification with state-of-the-art results :cite:<code>liu2021swin</code>.</p>
<h2 id="exercises-72"><a class="header" href="#exercises-72">Exercises</a></h2>
<ol>
<li>How does the value of <code>img_size</code> affect training time?</li>
<li>Instead of projecting the “&lt;cls&gt;” token representation to the output, how would you project the averaged patch representations? Implement this change and see how it affects the accuracy.</li>
<li>Can you modify hyperparameters to improve the accuracy of the vision Transformer?</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/8943">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>jax</code>
<a href="https://discuss.d2l.ai/t/18032">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-scale-pretraining-with-transformers"><a class="header" href="#large-scale-pretraining-with-transformers">Large-Scale Pretraining with Transformers</a></h1>
<p>:label:<code>sec_large-pretraining-transformers</code></p>
<p>So far in our image classification and machine translation experiments,
models have been trained on datasets with input--output examples
<em>from scratch</em> to perform specific tasks.
For example, a Transformer was trained
with English--French pairs (:numref:<code>sec_transformer</code>)
so that this model can translate input English text into French.
As a result, each model becomes a <em>specific expert</em>
that is sensitive to even a slight shift in data distribution
(:numref:<code>sec_environment-and-distribution-shift</code>).
For better generalized models, or even more competent <em>generalists</em>
that can perform multiple tasks with or without adaptation,
<em>pretraining</em> models on large data has been increasingly common.</p>
<p>Given larger data for pretraining, the Transformer architecture
performs better with an increased model size and training compute,
demonstrating superior <em>scaling</em> behavior.
Specifically, performance of Transformer-based language models
scales as a power law with the amount of model parameters,
training tokens, and training compute :cite:<code>kaplan2020scaling</code>.
The scalability of Transformers is also evidenced
by the significantly boosted performance
from larger vision Transformers trained on larger data
(discussed in :numref:<code>sec_vision-transformer</code>).
More recent success stories include Gato, a <em>generalist</em> model
that can play Atari, caption images, chat, and act as a robot :cite:<code>reed2022generalist</code>. Gato is a single  Transformer that scales well when pretrained on diverse modalities,
including text, images, joint torques, and button presses.
Notably, all such multimodal data is serialized into a flat sequence of tokens,
which can be processed akin to text tokens (:numref:<code>sec_transformer</code>)
or image patches (:numref:<code>sec_vision-transformer</code>) by Transformers.</p>
<p>Prior to the compelling success of pretraining Transformers for multimodal data,
Transformers were extensively pretrained  with a wealth of text.
Originally proposed for machine translation,
the Transformer architecture in :numref:<code>fig_transformer</code>
consists of an encoder for representing input sequences
and a decoder for generating target sequences.
Primarily, Transformers can be used in three different modes:
<em>encoder-only</em>, <em>encoder--decoder</em>, and <em>decoder-only</em>.
To conclude this chapter, we will review these three modes
and explain the scalability in pretraining Transformers.</p>
<h2 id="encoder-only"><a class="header" href="#encoder-only">Encoder-Only</a></h2>
<p>When only the Transformer encoder is used,
a sequence of input tokens is converted
into the same number of representations
that can be further projected into output
(e.g., classification). A Transformer encoder
consists of  self-attention layers,
where all input tokens attend to each other.
For example, vision Transformers depicted in :numref:<code>fig_vit</code>
are encoder-only, converting a sequence of input image patches into
the representation of a special “&lt;cls&gt;” token.
Since this representation depends on all input tokens,
it is further projected into classification labels.
This design was inspired by an earlier encoder-only Transformer
pretrained on text: BERT (Bidirectional Encoder Representations from Transformers) :cite:<code>Devlin.Chang.Lee.ea.2018</code>.</p>
<h3 id="pretraining-bert"><a class="header" href="#pretraining-bert">Pretraining BERT</a></h3>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/bert-encoder-only.svg" alt="Left: Pretraining BERT with masked language modeling. Prediction of the masked &quot;love&quot; token depends on all input tokens before and after &quot;love&quot;. Right: Attention pattern in the Transformer encoder. Each token along the vertical axis attends to all input tokens along the horizontal axis." />
:label:<code>fig_bert-encoder-only</code></p>
<p>BERT is pretrained on text sequences using <em>masked language modeling</em>:
input text with randomly masked tokens is fed
into a Transformer encoder to predict the masked tokens.
As illustrated in :numref:<code>fig_bert-encoder-only</code>,
an original text sequence "I", "love", "this", "red", "car"
is prepended with the “&lt;cls&gt;” token, and the “&lt;mask&gt;” token
randomly replaces "love"; then the cross-entropy loss between the masked token "love"
and its prediction is to be minimized during pretraining.
Note that there is no constraint in the attention pattern of Transformer encoders
(right of :numref:<code>fig_bert-encoder-only</code>)
so all tokens can attend to each other.
Thus, prediction of "love" depends on input tokens before and after it in the sequence.
This is why BERT is a "bidirectional encoder".
Without need for manual labeling, large-scale text data
from books and Wikipedia can be used for pretraining BERT.</p>
<h3 id="fine-tuning-bert"><a class="header" href="#fine-tuning-bert">Fine-Tuning BERT</a></h3>
<p>The pretrained BERT can be <em>fine-tuned</em> to downstream encoding tasks involving single text or text pairs. During fine-tuning, additional layers can be added to BERT with randomized parameters: these parameters and those pretrained BERT parameters will be <em>updated</em> to fit training data of downstream tasks.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/bert-finetune-classification.svg" alt="Fine-tuning BERT for sentiment analysis." />
:label:<code>fig_bert-finetune-classification</code></p>
<p>:numref:<code>fig_bert-finetune-classification</code> illustrates
fine-tuning of BERT for sentiment analysis.
The Transformer encoder is a pretrained BERT,
which takes a text sequence as input
and feeds the “&lt;cls&gt;” representation
(global representation of the input)
into an additional fully connected layer
to predict the sentiment.
During fine-tuning, the cross-entropy loss
between the prediction and the label
on sentiment analysis data
is minimized via gradient-based algorithms,
where the additional layer is trained from scratch
while pretrained parameters of BERT are updated.
BERT does more than sentiment analysis.
The general language representations learned
by the 350-million-parameter BERT
from 250 billion training tokens
advanced the state of the art for natural language tasks
such as single text classification,
text pair classification or regression,
text tagging, and question answering.</p>
<p>You may note that these downstream tasks include text pair understanding.
BERT pretraining has another loss for predicting
whether one sentence immediately follows the other.
However, this loss was later found to be less useful when pretraining RoBERTa,
a BERT variant of the same size, on 2000 billion tokens :cite:<code>Liu.Ott.Goyal.ea.2019</code>.
Other derivatives of BERT improved model architectures or pretraining objectives,
such as ALBERT (enforcing parameter sharing) :cite:<code>lan2019albert</code>,
SpanBERT (representing and predicting spans of text) :cite:<code>joshi2020spanbert</code>,
DistilBERT (lightweight via knowledge distillation) :cite:<code>sanh2019distilbert</code>,
and ELECTRA (replaced token detection) :cite:<code>clark2019electra</code>.
Moreover, BERT inspired Transformer pretraining in computer vision,
such as with vision Transformers :cite:<code>Dosovitskiy.Beyer.Kolesnikov.ea.2021</code>,
Swin Transformers :cite:<code>liu2021swin</code>,
and MAE (masked autoencoders) :cite:<code>he2022masked</code>.</p>
<h2 id="encoder--decoder"><a class="header" href="#encoder--decoder">Encoder--Decoder</a></h2>
<p>Since a Transformer encoder converts a sequence of input tokens
into the same number of output representations,
the encoder-only mode cannot generate a sequence of arbitrary length as in machine translation.
As originally proposed for machine translation,
the Transformer architecture can be outfitted with a decoder
that autoregressively predicts the target sequence
of arbitrary length, token by token,
conditional on both encoder output and decoder output:
(i) for conditioning on encoder output, encoder--decoder cross-attention
(multi-head attention of decoder in :numref:<code>fig_transformer</code>)
allows target tokens to attend to <em>all</em> input tokens;
(ii) conditioning on decoder output is achieved
by a so-called <em>causal</em> attention
(this name is common in the literature but is misleading
as it has little connection to the proper study of causality)
pattern (masked multi-head attention of decoder in :numref:<code>fig_transformer</code>),
where any target token can only attend to <em>past</em> and <em>present</em> tokens in the target sequence.</p>
<p>To pretrain encoder--decoder Transformers beyond human-labeled machine translation data,
BART :cite:<code>lewis2019bart</code> and T5 :cite:<code>raffel2020exploring</code>
are two concurrently proposed encoder--decoder Transformers
pretrained on large-scale text corpora.
Both attempt to reconstruct original text in their pretraining objectives,
while the former emphasizes noising input
(e.g., masking, deletion, permutation, and rotation)
and the latter highlights multitask unification
with comprehensive ablation studies.</p>
<h3 id="pretraining-t5"><a class="header" href="#pretraining-t5">Pretraining T5</a></h3>
<p>As an example of the pretrained Transformer encoder--decoder,
T5 (Text-to-Text Transfer Transformer)
unifies many tasks as the same text-to-text problem:
for any task, the input of the encoder is a task description
(e.g., "Summarize", ":") followed by task input
(e.g., a sequence of tokens from an article),
and the decoder predicts the task output
(e.g., a sequence of tokens summarizing the input article).
To perform as text-to-text, T5 is trained
to generate some target text conditional on input text.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/t5-encoder-decoder.svg" alt="Left: Pretraining T5 by predicting consecutive spans. The original sentence is &quot;I&quot;, &quot;love&quot;, &quot;this&quot;, &quot;red&quot;, &quot;car&quot;, where &quot;love&quot; is replaced by a special “&lt;X&gt;” token, and consecutive &quot;red&quot;, &quot;car&quot; are replaced by a special “&lt;Y&gt;” token. The target sequence ends with a special “&lt;Z&gt;” token. Right: Attention pattern in the Transformer encoder--decoder. In the encoder self-attention (lower square), all input tokens attend to each other; In the encoder--decoder cross-attention (upper rectangle), each target token attends to all input tokens; In the decoder self-attention (upper triangle), each target token  attends to present and past target tokens only (causal)." />
:label:<code>fig_t5-encoder-decoder</code></p>
<p>To obtain input and output from any original text,
T5 is pretrained to predict consecutive spans.
Specifically, tokens from text are randomly replaced
by special tokens where each consecutive span
is replaced by the same special token.
Consider the example in :numref:<code>fig_t5-encoder-decoder</code>,
where the original text is "I", "love", "this", "red", "car".
Tokens "love", "red", "car" are randomly replaced by special tokens.
Since "red" and "car" are a consecutive span,
they are replaced by the same special token.
As a result, the input sequence is "I", "&lt;X&gt;", "this", "&lt;Y&gt;",
and the target sequence is
"&lt;X&gt;", "love", "&lt;Y&gt;", "red", "car", "&lt;Z&gt;",
where "&lt;Z&gt;" is another special token marking the end.
As shown in :numref:<code>fig_t5-encoder-decoder</code>,
the decoder has a causal attention pattern to prevent itself
from attending to future tokens during sequence prediction.</p>
<p>In T5, predicting consecutive span is also referred to
as reconstructing corrupted text.
With this objective, T5 is pretrained
with 1000 billion tokens from the C4
(Colossal Clean Crawled Corpus) data,
which consists of clean English text
from the web :cite:<code>raffel2020exploring</code>.</p>
<h3 id="fine-tuning-t5"><a class="header" href="#fine-tuning-t5">Fine-Tuning T5</a></h3>
<p>Similar to BERT, T5 needs to be fine-tuned (updating T5 parameters)
on task-specific training data to perform this task.
Major differences from BERT fine-tuning include:
(i) T5 input includes task descriptions;
(ii) T5 can generate sequences
with arbitrary length
with its Transformer decoder;
(iii) No additional layers are required.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/t5-finetune-summarization.svg" alt="Fine-tuning T5 for text summarization. Both the task description and article tokens are fed into the Transformer encoder for predicting the summary." />
:label:<code>fig_t5-finetune-summarization</code></p>
<p>:numref:<code>fig_t5-finetune-summarization</code>
explains fine-tuning T5
using text summarization as an example.
In this downstream task,
the task description tokens "Summarize", ":"
followed by the article tokens are input to the encoder.</p>
<p>After fine-tuning, the 11-billion-parameter T5 (T5-11B)
achieved state-of-the-art results on multiple encoding (e.g., classification)
and generation (e.g., summarization) benchmarks.
Since released, T5 has been extensively used in later research.
For example, switch Transformers are designed based on T5
to activate a subset of the parameters
for better computational efficiency :cite:<code>fedus2022switch</code>.
In a text-to-image model called Imagen,
text is input to a frozen T5 encoder (T5-XXL)
with 4.6 billion parameters :cite:<code>saharia2022photorealistic</code>.
The photorealistic text-to-image examples in :numref:<code>fig_imagen</code>
suggest that the T5 encoder alone may effectively
represent text even without fine-tuning.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/imagen.png" alt="Text-to-image examples by the Imagen model, whose text encoder is from T5 (figures taken from :citet:saharia2022photorealistic)." />
:width:<code>700px</code>
:label:<code>fig_imagen</code></p>
<h2 id="decoder-only"><a class="header" href="#decoder-only">Decoder-Only</a></h2>
<p>We have reviewed encoder-only and encoder--decoder Transformers.
Alternatively, decoder-only Transformers
remove the entire encoder and the decoder sublayer
with the encoder--decoder cross-attention
from the original encoder--decoder architecture
depicted in :numref:<code>fig_transformer</code>.
Nowadays, decoder-only Transformers have been the <em>de facto</em> architecture
in large-scale language modeling (:numref:<code>sec_language-model</code>),
which leverages the world's abundant unlabeled text corpora via self-supervised learning.</p>
<h3 id="gpt-and-gpt-2"><a class="header" href="#gpt-and-gpt-2">GPT and GPT-2</a></h3>
<p>Using language modeling as the training objective,
the GPT (generative pre-training) model
chooses a Transformer decoder
as its backbone :cite:<code>Radford.Narasimhan.Salimans.ea.2018</code>.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/gpt-decoder-only.svg" alt="Left: Pretraining GPT with language modeling. The target sequence is the input sequence shifted by one token. Both “&lt;bos&gt;” and “&lt;eos&gt;” are special tokens marking the beginning and end of sequences, respectively. Right: Attention pattern in the Transformer decoder. Each token along the vertical axis attends to only its past tokens along the horizontal axis (causal)." />
:label:<code>fig_gpt-decoder-only</code></p>
<p>Following the autoregressive language model training
as described in :numref:<code>subsec_partitioning-seqs</code>,
:numref:<code>fig_gpt-decoder-only</code> illustrates
GPT pretraining with a Transformer encoder,
where the target sequence is the input sequence shifted by one token.
Note that the attention pattern in the Transformer decoder
enforces that each token can only attend to its past tokens
(future tokens cannot be attended to because they have not yet been chosen).</p>
<p>GPT has 100 million parameters and needs to be
fine-tuned for individual downstream tasks.
A much larger Transformer-decoder language model,
GPT-2, was introduced one year later :cite:<code>Radford.Wu.Child.ea.2019</code>.
Compared with the original Transformer decoder in GPT, pre-normalization
(discussed in :numref:<code>subsec_vit-encoder</code>)
and improved initialization and weight-scaling were adopted in GPT-2.
Pretrained on 40 GB of text, the 1.5-billion-parameter
GPT-2 obtained the state-of-the-art results on language modeling benchmarks
and promising results on multiple other tasks
<em>without updating the parameters or architecture</em>.</p>
<h3 id="gpt-3-and-beyond"><a class="header" href="#gpt-3-and-beyond">GPT-3 and Beyond</a></h3>
<p>GPT-2 demonstrated potential of using the same language model
for multiple tasks without updating the model.
This is more computationally efficient than fine-tuning,
which requires model updates via gradient computation.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/gpt-3-xshot.svg" alt="Zero-shot, one-shot, few-shot in-context learning with language models (Transformer decoders). No parameter update is needed." />
:label:<code>fig_gpt-3-xshot</code></p>
<p>Before explaining the more computationally efficient use
of language models without parameter update,
recall :numref:<code>sec_rnn-scratch</code> that a language model
can be trained to generate a text sequence
conditional on some prefix text sequence.
Thus, a pretrained language model may generate the task output
as a sequence <em>without parameter update</em>,
conditional on an input sequence with the task description,
task-specific input--output examples, and a prompt (task input).
This learning paradigm is called <em>in-context learning</em> :cite:<code>brown2020language</code>,
which can be further categorized
into <em>zero-shot</em>, <em>one-shot</em>, and <em>few-shot</em>,
when there is no, one, and a few task-specific input--output examples (:numref:<code>fig_gpt-3-xshot</code>).</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/gpt3-xshot-scaling.png" alt="Aggregate performance of GPT-3 for all 42 accuracy-denominated benchmarks (caption adapted and figure taken from :citet:brown2020language)." />
:width:<code>400px</code>
:label:<code>fig_gpt3-xshot-scaling</code></p>
<p>These three settings were tested in GPT-3 :cite:<code>brown2020language</code>,
whose largest version uses data and model size
about two orders of magnitude larger than those in GPT-2.
GPT-3 uses the same Transformer decoder architecture
as its direct predecessor GPT-2
except that attention patterns
(at the right in :numref:<code>fig_gpt-decoder-only</code>)
are sparser at alternating layers.
Pretrained with 300 billion tokens,
GPT-3 performs better with larger model size,
where few-shot performance increases most rapidly (:numref:<code>fig_gpt3-xshot-scaling</code>).</p>
<p>The subsequent GPT-4 model did not fully disclose technical details in its report :cite:<code>openai2023gpt4</code>.
By contrast with its predecessors, GPT-4
is a large-scale, multimodal model that
can take both text and images as input
and generate text output.</p>
<h2 id="scalability"><a class="header" href="#scalability">Scalability</a></h2>
<p>:numref:<code>fig_gpt3-xshot-scaling</code> empirically demonstrates scalability
of Transformers in the GPT-3 language model.
For language modeling, more comprehensive empirical studies
on the scalability of Transformers have led researchers to see promise
in training larger Transformers with more data and compute :cite:<code>kaplan2020scaling</code>.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/scaling-power-law.png" alt="Transformer language model performance improves smoothly as we increase the model size, dataset size, and amount of compute used for training. For optimal performance all three factors must be scaled up in tandem. Empirical performance has a power-law relationship with each individual factor when not bottlenecked by the other two (caption adapted and figure taken from :citet:kaplan2020scaling)." />
:width:<code>700px</code>
:label:<code>fig_scaling-power-law3</code></p>
<p>As shown in :numref:<code>fig_scaling-power-law3</code>,
<em>power-law scaling</em> can be observed in the performance
with respect to the model size (number of parameters, excluding embedding layers),
dataset size (number of training tokens),
and amount of training compute (PetaFLOP/s-days, excluding embedding layers).
In general, increasing all these three factors in tandem leads to better performance.
However, <em>how</em> to increase them in tandem
still remains a matter of debate :cite:<code>hoffmann2022training</code>.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/scaling-sample-conv.png" alt="Transformer language model training runs (figure taken from :citet:kaplan2020scaling)." />
:width:<code>700px</code>
:label:<code>fig_scaling-sample-conv</code></p>
<p>As well as increased performance, large models also enjoy better sample efficiency than small models. :numref:<code>fig_scaling-sample-conv</code> shows that large models need fewer training samples (tokens processed) to perform at the same level achieved by small models, and performance is scaled smoothly with compute.</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/scaling-gpt3.png" alt="GPT-3 performance (cross-entropy validation loss) follows a power-law trend with the amount of compute used for training. The power-law behavior observed in :citet:kaplan2020scaling continues for an additional two orders of magnitude with only small deviations from the predicted curve. Embedding parameters are excluded from compute and parameter counts (caption adapted and figure taken from :citet:brown2020language)." />
:width:<code>250px</code>
:label:<code>fig_scaling-gpt3</code></p>
<p>The empirical scaling behaviors in :citet:<code>kaplan2020scaling</code> have been tested in subsequent large Transformer models. For example, GPT-3 supported this hypothesis with two more orders of magnitude in :numref:<code>fig_scaling-gpt3</code>.</p>
<h2 id="large-language-models"><a class="header" href="#large-language-models">Large Language Models</a></h2>
<p>The scalability of Transformers in the GPT series has inspired subsequent large language models.
The GPT-2 Transformer decoder was used for training the 530-billion-parameter Megatron-Turing NLG :cite:<code>smith2022using</code> with 270 billion training tokens. Following the GPT-2 design, the 280-billion-parameter Gopher :cite:<code>rae2021scaling</code> pretrained with 300 billion tokens, performed competitively across diverse tasks.
Inheriting the same architecture and using the same compute budget of Gopher, Chinchilla :cite:<code>hoffmann2022training</code> is a substantially smaller (70 billion parameters) model that trains for much longer (1.4 trillion training tokens), outperforming Gopher on many tasks and with more emphasis on the number of tokens than on the number of parameters.
To continue the scaling line of language modeling,
PaLM (Pathway Language Model) :cite:<code>chowdhery2022palm</code>, a 540-billion-parameter Transformer decoder with modified designs pretrained on 780 billion tokens, outperformed average human performance on the BIG-Bench benchmark :cite:<code>srivastava2022beyond</code>. Its later version, PaLM 2 :cite:<code>anil2023palm</code>, scaled data and model roughly 1:1 and improved multilingual and reasoning capabilities.
Other large language models, such as Minerva  :cite:<code>lewkowycz2022solving</code> that further trains a generalist (PaLM) and Galactica :cite:<code>taylor2022galactica</code> that is not trained on a general corpus, have shown promising quantitative and scientific reasoning capabilities.</p>
<p>Open-sourced releases, such as OPT (Open Pretrained Transformers) :cite:<code>zhang2022opt</code>, BLOOM :cite:<code> scao2022bloom</code>, and FALCON :cite:<code>penedo2023refinedweb</code>,
democratized research and use of large language models.
Focusing on computational efficiency at inference time,
the open-sourced Llama 1 :cite:<code>touvron2023llama</code> outperformed much larger models by training on more tokens than had been typically used. The updated Llama 2 :cite:<code>touvron2023llama2</code> further increased the pretraining corpus by 40%, leading to product models that may match the performance of competitive close-sourced models.</p>
<p>:citet:<code>wei2022emergent</code> discussed emergent abilities of large language models that are present in larger models, but not in smaller models.
However, simply increasing model size does not inherently make models follow human instructions better.
:citet:<code>wei2021finetuned,sanh2021multitask</code> have found that fine-tuning large language models
on a range of datasets described via <em>instructions</em>
can improve zero-shot performance on held-out tasks.
Using <em>reinforcement learning from human feedback</em>,
:citet:<code>ouyang2022training</code> fine-tuned GPT-3
to follow a diverse set of instructions.
Following the resultant InstructGPT which
aligns language models with human intent
via fine-tuning :cite:<code>ouyang2022training</code>,
<a href="https://chat.openai.com/">ChatGPT</a>
can generate human-like responses (e.g., code debugging and creative writing)
based on conversations with humans
and can perform many natural language processing
tasks zero-shot :cite:<code>qin2023chatgpt</code>.
:citet:<code>bai2022constitutional</code> replaced human inputs (e.g., human-labeled data) with model outputs
to partially automate the instruction tuning process, which is also known as <em>reinforcement learning from AI feedback</em>.</p>
<p>Large language models offer an exciting prospect
of formulating text input to induce models to perform desired tasks via in-context learning,
which is also known as <em>prompting</em>.
Notably,
<em>chain-of-thought prompting</em> :cite:<code>wei2022chain</code>,
an in-context learning method
with few-shot "question, intermediate reasoning steps, answer" demonstrations,
elicits the complex reasoning capabilities of
large language models
in order to solve mathematical, commonsense, and symbolic reasoning tasks.
Sampling multiple reasoning paths :cite:<code>wang2023self</code>, diversifying few-shot demonstrations :cite:<code>zhang2023automatic</code>,
and reducing complex problems to sub-problems :cite:<code>zhou2023least</code>
can all improve the reasoning accuracy. In fact, with simple prompts like "Let's think step by step" just before each answer,
large language models can even perform <em>zero-shot</em>
chain-of-thought reasoning with decent accuracy :cite:<code>kojima2022large</code>.
Even for multimodal inputs consisting of both text and images,
language models can perform multimodal chain-of-thought reasoning with higher accuracy than using text input only :cite:<code>zhang2023multicot</code>.</p>
<h2 id="summary-and-discussion-9"><a class="header" href="#summary-and-discussion-9">Summary and Discussion</a></h2>
<p>Transformers have been pretrained as encoder-only (e.g., BERT), encoder--decoder (e.g., T5), and decoder-only (e.g., GPT series). Pretrained models may be adapted to perform different tasks with model update (e.g., fine-tuning) or not (e.g., few-shot). Scalability of Transformers suggests that better performance benefits from larger models, more training data, and more training compute. Since Transformers were first designed and pretrained for text data, this section leans slightly towards natural language processing. Nonetheless, those models discussed above can be often found in more recent models across multiple modalities. For example,
(i) Chinchilla :cite:<code>hoffmann2022training</code> was further extended to Flamingo :cite:<code>alayrac2022flamingo</code>, a visual language model for few-shot learning;
(ii) GPT-2 :cite:<code>Radford.Wu.Child.ea.2019</code> and the vision Transformer encode text and images in CLIP (Contrastive Language-Image Pre-training) :cite:<code>radford2021learning</code>, whose image and text embeddings were later adopted in the DALL-E 2 text-to-image system :cite:<code>ramesh2022hierarchical</code>. Although there have been no systematic studies on Transformer scalability in multimodal pretraining yet, an all-Transformer text-to-image model called Parti :cite:<code>yu2022scaling</code> shows potential of scalability across modalities:
a larger Parti is more capable of high-fidelity image generation and content-rich text understanding (:numref:<code>fig_parti</code>).</p>
<p><img src="chapter_attention-mechanisms-and-transformers/../img/parti.png" alt="Image examples generated from the same text by the Parti model of increasing sizes (350M, 750M, 3B, 20B) (examples taken from :citet:yu2022scaling)." />
:width:<code>700px</code>
:label:<code>fig_parti</code></p>
<h2 id="exercises-73"><a class="header" href="#exercises-73">Exercises</a></h2>
<ol>
<li>Is it possible to fine-tune T5 using a minibatch consisting of different tasks? Why or why not? How about for GPT-2?</li>
<li>Given a powerful language model, what applications can you think of?</li>
<li>Say that you are asked to fine-tune a language model to perform text classification by adding additional layers. Where will you add them? Why?</li>
<li>Consider sequence-to-sequence problems (e.g., machine translation) where the input sequence is always available throughout the target sequence prediction. What could be limitations of modeling with decoder-only Transformers? Why?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/9232">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimization-algorithms-1"><a class="header" href="#optimization-algorithms-1">Optimization Algorithms</a></h1>
<p>:label:<code>chap_optimization</code></p>
<p>If you read the book in sequence up to this point you already used a number of optimization algorithms to train deep learning models.
They were the tools that allowed us to continue updating model parameters and to minimize the value of the loss function, as evaluated on the training set. Indeed, anyone content with treating optimization as a black box device to minimize objective functions in a simple setting might well content oneself with the knowledge that there exists an array of incantations of such a procedure (with names such as "SGD" and "Adam").</p>
<p>To do well, however, some deeper knowledge is required.
Optimization algorithms are important for deep learning.
On the one hand, training a complex deep learning model can take hours, days, or even weeks.
The performance of the optimization algorithm directly affects the model's training efficiency.
On the other hand, understanding the principles of different optimization algorithms and the role of their hyperparameters
will enable us to tune the hyperparameters in a targeted manner to improve the performance of deep learning models.</p>
<p>In this chapter, we explore common deep learning optimization algorithms in depth.
Almost all optimization problems arising in deep learning are <em>nonconvex</em>.
Nonetheless, the design and analysis of algorithms in the context of <em>convex</em> problems have proven to be very instructive.
It is for that reason that this chapter includes a primer on convex optimization and the proof for a very simple stochastic gradient descent algorithm on a convex objective function.</p>
<pre><code class="language-toc">:maxdepth: 2

optimization-intro
convexity
gd
sgd
minibatch-sgd
momentum
adagrad
rmsprop
adadelta
adam
lr-scheduler
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimization-and-deep-learning"><a class="header" href="#optimization-and-deep-learning">Optimization and Deep Learning</a></h1>
<p>:label:<code>sec_optimization-intro</code></p>
<p>In this section, we will discuss the relationship between optimization and deep learning as well as the challenges of using optimization in deep learning.
For a deep learning problem, we will usually define a <em>loss function</em> first. Once we have the loss function, we can use an optimization algorithm in attempt to minimize the loss.
In optimization, a loss function is often referred to as the <em>objective function</em> of the optimization problem. By tradition and convention most optimization algorithms are concerned with <em>minimization</em>. If we ever need to maximize an objective there is a simple solution: just flip the sign on the objective.</p>
<h2 id="goal-of-optimization"><a class="header" href="#goal-of-optimization">Goal of Optimization</a></h2>
<p>Although optimization provides a way to minimize the loss function for deep
learning, in essence, the goals of optimization and deep learning are
fundamentally different.
The former is primarily concerned with minimizing an
objective whereas the latter is concerned with finding a suitable model, given a
finite amount of data.
In :numref:<code>sec_generalization_basics</code>,
we discussed the difference between these two goals in detail.
For instance,
training error and generalization error generally differ: since the objective
function of the optimization algorithm is usually a loss function based on the
training dataset, the goal of optimization is to reduce the training error.
However, the goal of deep learning (or more broadly, statistical inference) is to
reduce the generalization error.
To accomplish the latter we need to pay
attention to overfitting in addition to using the optimization algorithm to
reduce the training error.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mpl_toolkits import mplot3d
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import numpy as np
from mpl_toolkits import mplot3d
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import numpy as np
from mpl_toolkits import mplot3d
import tensorflow as tf
</code></pre>
<p>To illustrate the aforementioned different goals,
let's consider
the empirical risk and the risk.
As described
in :numref:<code>subsec_empirical-risk-and-risk</code>,
the empirical risk
is an average loss
on the training dataset
while the risk is the expected loss
on the entire population of data.
Below we define two functions:
the risk function <code>f</code>
and the empirical risk function <code>g</code>.
Suppose that we have only a finite amount of training data.
As a result, here <code>g</code> is less smooth than <code>f</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def f(x):
    return x * d2l.cos(np.pi * x)

def g(x):
    return f(x) + 0.2 * d2l.cos(5 * np.pi * x)
</code></pre>
<p>The graph below illustrates that the minimum of the empirical risk on a training dataset may be at a different location from the minimum of the risk (generalization error).</p>
<pre><code class="language-{.python .input}">#@tab all
def annotate(text, xy, xytext):  #@save
    d2l.plt.gca().annotate(text, xy=xy, xytext=xytext,
                           arrowprops=dict(arrowstyle='-&gt;'))

x = d2l.arange(0.5, 1.5, 0.01)
d2l.set_figsize((4.5, 2.5))
d2l.plot(x, [f(x), g(x)], 'x', 'risk')
annotate('min of\nempirical risk', (1.0, -1.2), (0.5, -1.1))
annotate('min of risk', (1.1, -1.05), (0.95, -0.5))
</code></pre>
<h2 id="optimization-challenges-in-deep-learning"><a class="header" href="#optimization-challenges-in-deep-learning">Optimization Challenges in Deep Learning</a></h2>
<p>In this chapter, we are going to focus specifically on the performance of optimization algorithms in minimizing the objective function, rather than a
model's generalization error.
In :numref:<code>sec_linear_regression</code>
we distinguished between analytical solutions and numerical solutions in
optimization problems.
In deep learning, most objective functions are
complicated and do not have analytical solutions. Instead, we must use numerical
optimization algorithms.
The optimization algorithms in this chapter
all fall into this
category.</p>
<p>There are many challenges in deep learning optimization. Some of the most vexing ones are local minima, saddle points, and vanishing gradients.
Let's have a look at them.</p>
<h3 id="local-minima"><a class="header" href="#local-minima">Local Minima</a></h3>
<p>For any objective function $f(x)$,
if the value of $f(x)$ at $x$ is smaller than the values of $f(x)$ at any other points in the vicinity of $x$, then $f(x)$ could be a local minimum.
If the value of $f(x)$ at $x$ is the minimum of the objective function over the entire domain,
then $f(x)$ is the global minimum.</p>
<p>For example, given the function</p>
<p>$$f(x) = x \cdot \textrm{cos}(\pi x) \textrm{ for } -1.0 \leq x \leq 2.0,$$</p>
<p>we can approximate the local minimum and global minimum of this function.</p>
<pre><code class="language-{.python .input}">#@tab all
x = d2l.arange(-1.0, 2.0, 0.01)
d2l.plot(x, [f(x), ], 'x', 'f(x)')
annotate('local minimum', (-0.3, -0.25), (-0.77, -1.0))
annotate('global minimum', (1.1, -0.95), (0.6, 0.8))
</code></pre>
<p>The objective function of deep learning models usually has many local optima.
When the numerical solution of an optimization problem is near the local optimum, the numerical solution obtained by the final iteration may only minimize the objective function <em>locally</em>, rather than <em>globally</em>, as the gradient of the objective function's solutions approaches or becomes zero.
Only some degree of noise might knock the parameter out of the local minimum. In fact, this is one of the beneficial properties of
minibatch stochastic gradient descent where the natural variation of gradients over minibatches is able to dislodge the parameters from local minima.</p>
<h3 id="saddle-points"><a class="header" href="#saddle-points">Saddle Points</a></h3>
<p>Besides local minima, saddle points are another reason for gradients to vanish. A <em>saddle point</em> is any location where all gradients of a function vanish but which is neither a global nor a local minimum.
Consider the function $f(x) = x^3$. Its first and second derivative vanish for $x=0$. Optimization might stall at this point, even though it is not a minimum.</p>
<pre><code class="language-{.python .input}">#@tab all
x = d2l.arange(-2.0, 2.0, 0.01)
d2l.plot(x, [x**3], 'x', 'f(x)')
annotate('saddle point', (0, -0.2), (-0.52, -5.0))
</code></pre>
<p>Saddle points in higher dimensions are even more insidious, as the example below shows. Consider the function $f(x, y) = x^2 - y^2$. It has its saddle point at $(0, 0)$. This is a maximum with respect to $y$ and a minimum with respect to $x$. Moreover, it <em>looks</em> like a saddle, which is where this mathematical property got its name.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x, y = d2l.meshgrid(
    d2l.linspace(-1.0, 1.0, 101), d2l.linspace(-1.0, 1.0, 101))
z = x**2 - y**2

ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.asnumpy(), y.asnumpy(), z.asnumpy(),
                  **{'rstride': 10, 'cstride': 10})
ax.plot([0], [0], [0], 'rx')
ticks = [-1, 0, 1]
d2l.plt.xticks(ticks)
d2l.plt.yticks(ticks)
ax.set_zticks(ticks)
d2l.plt.xlabel('x')
d2l.plt.ylabel('y');
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch, tensorflow
x, y = d2l.meshgrid(
    d2l.linspace(-1.0, 1.0, 101), d2l.linspace(-1.0, 1.0, 101))
z = x**2 - y**2

ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x, y, z, **{'rstride': 10, 'cstride': 10})
ax.plot([0], [0], [0], 'rx')
ticks = [-1, 0, 1]
d2l.plt.xticks(ticks)
d2l.plt.yticks(ticks)
ax.set_zticks(ticks)
d2l.plt.xlabel('x')
d2l.plt.ylabel('y');
</code></pre>
<p>We assume that the input of a function is a $k$-dimensional vector and its
output is a scalar, so its Hessian matrix will have $k$ eigenvalues.
The solution of the
function could be a local minimum, a local maximum, or a saddle point at a
position where the function gradient is zero:</p>
<ul>
<li>When the eigenvalues of the function's Hessian matrix at the zero-gradient position are all positive, we have a local minimum for the function.</li>
<li>When the eigenvalues of the function's Hessian matrix at the zero-gradient position are all negative, we have a local maximum for the function.</li>
<li>When the eigenvalues of the function's Hessian matrix at the zero-gradient position are negative and positive, we have a saddle point for the function.</li>
</ul>
<p>For high-dimensional problems the likelihood that at least <em>some</em> of the eigenvalues are negative is quite high. This makes saddle points more likely than local minima. We will discuss some exceptions to this situation in the next section when introducing convexity. In short, convex functions are those where the eigenvalues of the Hessian are never negative. Sadly, though, most deep learning problems do not fall into this category. Nonetheless it is a great tool to study optimization algorithms.</p>
<h3 id="vanishing-gradients-1"><a class="header" href="#vanishing-gradients-1">Vanishing Gradients</a></h3>
<p>Probably the most insidious problem to encounter is the vanishing gradient.
Recall our commonly-used activation functions and their derivatives in :numref:<code>subsec_activation-functions</code>.
For instance, assume that we want to minimize the function $f(x) = \tanh(x)$ and we happen to get started at $x = 4$. As we can see, the gradient of $f$ is close to nil.
More specifically, $f'(x) = 1 - \tanh^2(x)$ and thus $f'(4) = 0.0013$.
Consequently, optimization will get stuck for a long time before we make progress. This turns out to be one of the reasons that training deep learning models was quite tricky prior to the introduction of the ReLU activation function.</p>
<pre><code class="language-{.python .input}">#@tab all
x = d2l.arange(-2.0, 5.0, 0.01)
d2l.plot(x, [d2l.tanh(x)], 'x', 'f(x)')
annotate('vanishing gradient', (4, 1), (2, 0.0))
</code></pre>
<p>As we saw, optimization for deep learning is full of challenges. Fortunately there exists a robust range of algorithms that perform well and that are easy to use even for beginners. Furthermore, it is not really necessary to find <em>the</em> best solution. Local optima or even approximate solutions thereof are still very useful.</p>
<h2 id="summary-54"><a class="header" href="#summary-54">Summary</a></h2>
<ul>
<li>Minimizing the training error does <em>not</em> guarantee that we find the best set of parameters to minimize the generalization error.</li>
<li>The optimization problems may have many local minima.</li>
<li>The problem may have even more saddle points, as generally the problems are not convex.</li>
<li>Vanishing gradients can cause optimization to stall. Often a reparametrization of the problem helps. Good initialization of the parameters can be beneficial, too.</li>
</ul>
<h2 id="exercises-74"><a class="header" href="#exercises-74">Exercises</a></h2>
<ol>
<li>Consider a simple MLP with a single hidden layer of, say, $d$ dimensions in the hidden layer and a single output. Show that for any local minimum there are at least $d!$ equivalent solutions that behave identically.</li>
<li>Assume that we have a symmetric random matrix $\mathbf{M}$ where the entries
$M_{ij} = M_{ji}$ are each drawn from some probability distribution
$p_{ij}$. Furthermore assume that $p_{ij}(x) = p_{ij}(-x)$, i.e., that the
distribution is symmetric (see e.g., :citet:<code>Wigner.1958</code> for details).
<ol>
<li>Prove that the distribution over eigenvalues is also symmetric. That is, for any eigenvector $\mathbf{v}$ the probability that the associated eigenvalue $\lambda$ satisfies $P(\lambda &gt; 0) = P(\lambda &lt; 0)$.</li>
<li>Why does the above <em>not</em> imply $P(\lambda &gt; 0) = 0.5$?</li>
</ol>
</li>
<li>What other challenges involved in deep learning optimization can you think of?</li>
<li>Assume that you want to balance a (real) ball on a (real) saddle.
<ol>
<li>Why is this hard?</li>
<li>Can you exploit this effect also for optimization algorithms?</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/349">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/487">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/489">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convexity"><a class="header" href="#convexity">Convexity</a></h1>
<p>:label:<code>sec_convexity</code></p>
<p>Convexity plays a vital role in the design of optimization algorithms.
This is largely due to the fact that it is much easier to analyze and test algorithms in such a context.
In other words,
if the algorithm performs poorly even in the convex setting,
typically we should not hope to see great results otherwise.
Furthermore, even though the optimization problems in deep learning are generally nonconvex, they often exhibit some properties of convex ones near local minima. This can lead to exciting new optimization variants such as :cite:<code>Izmailov.Podoprikhin.Garipov.ea.2018</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mpl_toolkits import mplot3d
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import numpy as np
from mpl_toolkits import mplot3d
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import numpy as np
from mpl_toolkits import mplot3d
import tensorflow as tf
</code></pre>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Before convex analysis,
we need to define <em>convex sets</em> and <em>convex functions</em>.
They lead to mathematical tools that are commonly applied to machine learning.</p>
<h3 id="convex-sets"><a class="header" href="#convex-sets">Convex Sets</a></h3>
<p>Sets are the basis of convexity. Simply put, a set $\mathcal{X}$ in a vector space is <em>convex</em> if for any $a, b \in \mathcal{X}$ the line segment connecting $a$ and $b$ is also in $\mathcal{X}$. In mathematical terms this means that for all $\lambda \in [0, 1]$ we have</p>
<p>$$\lambda  a + (1-\lambda)  b \in \mathcal{X} \textrm{ whenever } a, b \in \mathcal{X}.$$</p>
<p>This sounds a bit abstract. Consider :numref:<code>fig_pacman</code>. The first set is not convex since there exist line segments that are not contained in it.
The other two sets suffer no such problem.</p>
<p><img src="chapter_optimization/../img/pacman.svg" alt="The first set is nonconvex and the other two are convex." />
:label:<code>fig_pacman</code></p>
<p>Definitions on their own are not particularly useful unless you can do something with them.
In this case we can look at intersections as shown in :numref:<code>fig_convex_intersect</code>.
Assume that $\mathcal{X}$ and $\mathcal{Y}$ are convex sets. Then $\mathcal{X} \cap \mathcal{Y}$ is also convex. To see this, consider any $a, b \in \mathcal{X} \cap \mathcal{Y}$. Since $\mathcal{X}$ and $\mathcal{Y}$ are convex, the line segments connecting $a$ and $b$ are contained in both $\mathcal{X}$ and $\mathcal{Y}$. Given that, they also need to be contained in $\mathcal{X} \cap \mathcal{Y}$, thus proving our theorem.</p>
<p><img src="chapter_optimization/../img/convex-intersect.svg" alt="The intersection between two convex sets is convex." />
:label:<code>fig_convex_intersect</code></p>
<p>We can strengthen this result with little effort: given convex sets $\mathcal{X}<em>i$, their intersection $\cap</em>{i} \mathcal{X}_i$ is convex.
To see that the converse is not true, consider two disjoint sets $\mathcal{X} \cap \mathcal{Y} = \emptyset$. Now pick $a \in \mathcal{X}$ and $b \in \mathcal{Y}$. The line segment in :numref:<code>fig_nonconvex</code> connecting $a$ and $b$ needs to contain some part that is neither in $\mathcal{X}$ nor in $\mathcal{Y}$, since we assumed that $\mathcal{X} \cap \mathcal{Y} = \emptyset$. Hence the line segment is not in $\mathcal{X} \cup \mathcal{Y}$ either, thus proving that in general unions of convex sets need not be convex.</p>
<p><img src="chapter_optimization/../img/nonconvex.svg" alt="The union of two convex sets need not be convex." />
:label:<code>fig_nonconvex</code></p>
<p>Typically the problems in deep learning are defined on convex sets. For instance, $\mathbb{R}^d$,
the set of $d$-dimensional vectors of real numbers,
is a convex set (after all, the line between any two points in $\mathbb{R}^d$ remains in $\mathbb{R}^d$). In some cases we work with variables of bounded length, such as balls of radius $r$ as defined by ${\mathbf{x} | \mathbf{x} \in \mathbb{R}^d \textrm{ and } |\mathbf{x}| \leq r}$.</p>
<h3 id="convex-functions"><a class="header" href="#convex-functions">Convex Functions</a></h3>
<p>Now that we have convex sets we can introduce <em>convex functions</em> $f$.
Given a convex set $\mathcal{X}$, a function $f: \mathcal{X} \to \mathbb{R}$ is <em>convex</em> if for all $x, x' \in \mathcal{X}$ and for all $\lambda \in [0, 1]$ we have</p>
<p>$$\lambda f(x) + (1-\lambda) f(x') \geq f(\lambda x + (1-\lambda) x').$$</p>
<p>To illustrate this let's plot a few functions and check which ones satisfy the requirement.
Below we define a few functions, both convex and nonconvex.</p>
<pre><code class="language-{.python .input}">#@tab all
f = lambda x: 0.5 * x**2  # Convex
g = lambda x: d2l.cos(np.pi * x)  # Nonconvex
h = lambda x: d2l.exp(0.5 * x)  # Convex

x, segment = d2l.arange(-2, 2, 0.01), d2l.tensor([-1.5, 1])
d2l.use_svg_display()
_, axes = d2l.plt.subplots(1, 3, figsize=(9, 3))
for ax, func in zip(axes, [f, g, h]):
    d2l.plot([x, segment], [func(x), func(segment)], axes=ax)
</code></pre>
<p>As expected, the cosine function is <em>nonconvex</em>, whereas the parabola and the exponential function are. Note that the requirement that $\mathcal{X}$ is a convex set is necessary for the condition to make sense. Otherwise the outcome of $f(\lambda x + (1-\lambda) x')$ might not be well defined.</p>
<h3 id="jensens-inequality"><a class="header" href="#jensens-inequality">Jensen's Inequality</a></h3>
<p>Given a convex function $f$,
one of the most useful mathematical tools
is <em>Jensen's inequality</em>.
It amounts to a generalization of the definition of convexity:</p>
<p>$$\sum_i \alpha_i f(x_i)  \geq f\left(\sum_i \alpha_i x_i\right)    \textrm{ and }    E_X[f(X)]  \geq f\left(E_X[X]\right),$$
:eqlabel:<code>eq_jensens-inequality</code></p>
<p>where $\alpha_i$ are nonnegative real numbers such that $\sum_i \alpha_i = 1$ and $X$ is a random variable.
In other words, the expectation of a convex function is no less than the convex function of an expectation, where the latter is usually a simpler expression.
To prove the first inequality we repeatedly apply the definition of convexity to one term in the sum at a time.</p>
<p>One of the common applications of Jensen's inequality is
to bound a more complicated expression by a simpler one.
For example,
its application can be
with regard to the log-likelihood of partially observed random variables. That is, we use</p>
<p>$$E_{Y \sim P(Y)}[-\log P(X \mid Y)] \geq -\log P(X),$$</p>
<p>since $\int P(Y) P(X \mid Y) dY = P(X)$.
This can be used in variational methods. Here $Y$ is typically the unobserved random variable, $P(Y)$ is the best guess of how it might be distributed, and $P(X)$ is the distribution with $Y$ integrated out. For instance, in clustering $Y$ might be the cluster labels and $P(X \mid Y)$ is the generative model when applying cluster labels.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Convex functions have many useful properties. We describe a few commonly-used ones below.</p>
<h3 id="local-minima-are-global-minima"><a class="header" href="#local-minima-are-global-minima">Local Minima Are Global Minima</a></h3>
<p>First and foremost, the local minima of convex functions are also the global minima.
We can prove it by contradiction as follows.</p>
<p>Consider a convex function $f$ defined on a convex set $\mathcal{X}$.
Suppose that $x^{\ast} \in \mathcal{X}$ is a local minimum:
there exists a small positive value $p$ so that for $x \in \mathcal{X}$ that satisfies $0 &lt; |x - x^{\ast}| \leq p$ we have $f(x^{\ast}) &lt; f(x)$.</p>
<p>Assume that the local minimum $x^{\ast}$
is not the global minimum of $f$:
there exists $x' \in \mathcal{X}$ for which $f(x') &lt; f(x^{\ast})$.
There also exists
$\lambda \in [0, 1)$ such as $\lambda = 1 - \frac{p}{|x^{\ast} - x'|}$
so that
$0 &lt; |\lambda x^{\ast} + (1-\lambda) x' - x^{\ast}| \leq p$.</p>
<p>However,
according to the definition of convex functions, we have</p>
<p>$$\begin{aligned}
f(\lambda x^{\ast} + (1-\lambda) x') &amp;\leq \lambda f(x^{\ast}) + (1-\lambda) f(x') \
&amp;&lt; \lambda f(x^{\ast}) + (1-\lambda) f(x^{\ast}) \
&amp;= f(x^{\ast}),
\end{aligned}$$</p>
<p>which contradicts with our statement that $x^{\ast}$ is a local minimum.
Therefore, there does not exist $x' \in \mathcal{X}$ for which $f(x') &lt; f(x^{\ast})$. The local minimum $x^{\ast}$ is also the global minimum.</p>
<p>For instance, the convex function $f(x) = (x-1)^2$ has a local minimum at $x=1$, which is also the global minimum.</p>
<pre><code class="language-{.python .input}">#@tab all
f = lambda x: (x - 1) ** 2
d2l.set_figsize()
d2l.plot([x, segment], [f(x), f(segment)], 'x', 'f(x)')
</code></pre>
<p>The fact that the local minima for convex functions are also the global minima is very convenient.
It means that if we minimize functions we cannot "get stuck".
Note, though, that this does not mean that there cannot be more than one global minimum or that there might even exist one. For instance, the function $f(x) = \mathrm{max}(|x|-1, 0)$ attains its minimum value over the interval $[-1, 1]$. Conversely, the function $f(x) = \exp(x)$ does not attain a minimum value on $\mathbb{R}$: for $x \to -\infty$ it asymptotes to $0$, but there is no $x$ for which $f(x) = 0$.</p>
<h3 id="below-sets-of-convex-functions-are-convex"><a class="header" href="#below-sets-of-convex-functions-are-convex">Below Sets of Convex Functions Are Convex</a></h3>
<p>We can conveniently
define convex sets
via <em>below sets</em> of convex functions.
Concretely,
given a convex function $f$ defined on a convex set $\mathcal{X}$,
any below set</p>
<p>$$\mathcal{S}_b \stackrel{\textrm{def}}{=} {x | x \in \mathcal{X} \textrm{ and } f(x) \leq b}$$</p>
<p>is convex.</p>
<p>Let's prove this quickly. Recall that for any $x, x' \in \mathcal{S}_b$ we need to show that $\lambda x + (1-\lambda) x' \in \mathcal{S}_b$ as long as $\lambda \in [0, 1]$.
Since $f(x) \leq b$ and $f(x') \leq b$,
by the definition of convexity we have</p>
<p>$$f(\lambda x + (1-\lambda) x') \leq \lambda f(x) + (1-\lambda) f(x') \leq b.$$</p>
<h3 id="convexity-and-second-derivatives"><a class="header" href="#convexity-and-second-derivatives">Convexity and Second Derivatives</a></h3>
<p>Whenever the second derivative of a function $f: \mathbb{R}^n \rightarrow \mathbb{R}$ exists it is very easy to check whether $f$ is convex.
All we need to do is check whether the Hessian of $f$ is positive semidefinite: $\nabla^2f \succeq 0$, i.e.,
denoting the Hessian matrix $\nabla^2f$ by $\mathbf{H}$,
$\mathbf{x}^\top \mathbf{H} \mathbf{x} \geq 0$
for all $\mathbf{x} \in \mathbb{R}^n$.
For instance, the function $f(\mathbf{x}) = \frac{1}{2} |\mathbf{x}|^2$ is convex since $\nabla^2 f = \mathbf{1}$, i.e., its Hessian is an identity matrix.</p>
<p>Formally, a twice-differentiable one-dimensional function $f: \mathbb{R} \rightarrow \mathbb{R}$ is convex
if and only if its second derivative $f'' \geq 0$. For any twice-differentiable multidimensional function $f: \mathbb{R}^{n} \rightarrow \mathbb{R}$,
it is convex if and only if its Hessian $\nabla^2f \succeq 0$.</p>
<p>First, we need to prove the one-dimensional case.
To see that
convexity of $f$ implies
$f'' \geq 0$  we use the fact that</p>
<p>$$\frac{1}{2} f(x + \epsilon) + \frac{1}{2} f(x - \epsilon) \geq f\left(\frac{x + \epsilon}{2} + \frac{x - \epsilon}{2}\right) = f(x).$$</p>
<p>Since the second derivative is given by the limit over finite differences it follows that</p>
<p>$$f''(x) = \lim_{\epsilon \to 0} \frac{f(x+\epsilon) + f(x - \epsilon) - 2f(x)}{\epsilon^2} \geq 0.$$</p>
<p>To see that
$f'' \geq 0$ implies that $f$ is convex
we use the fact that $f'' \geq 0$ implies that $f'$ is a monotonically nondecreasing function. Let $a &lt; x &lt; b$ be three points in $\mathbb{R}$,
where $x = (1-\lambda)a + \lambda b$ and $\lambda \in (0, 1)$.
According to the mean value theorem,
there exist $\alpha \in [a, x]$ and $\beta \in [x, b]$
such that</p>
<p>$$f'(\alpha) = \frac{f(x) - f(a)}{x-a} \textrm{ and } f'(\beta) = \frac{f(b) - f(x)}{b-x}.$$</p>
<p>By monotonicity $f'(\beta) \geq f'(\alpha)$, hence</p>
<p>$$\frac{x-a}{b-a}f(b) + \frac{b-x}{b-a}f(a) \geq f(x).$$</p>
<p>Since $x = (1-\lambda)a + \lambda b$,
we have</p>
<p>$$\lambda f(b) + (1-\lambda)f(a) \geq f((1-\lambda)a + \lambda b),$$</p>
<p>thus proving convexity.</p>
<p>Second, we need a lemma before
proving the multidimensional case:
$f: \mathbb{R}^n \rightarrow \mathbb{R}$
is convex if and only if for all $\mathbf{x}, \mathbf{y} \in \mathbb{R}^n$</p>
<p>$$g(z) \stackrel{\textrm{def}}{=} f(z \mathbf{x} + (1-z)  \mathbf{y}) \textrm{ where } z \in [0,1]$$</p>
<p>is convex.</p>
<p>To prove that convexity of $f$ implies that $g$ is convex,
we can show that for all $a, b, \lambda \in [0, 1]$ (thus
$0 \leq \lambda a + (1-\lambda) b \leq 1$)</p>
<p>$$\begin{aligned} &amp;g(\lambda a + (1-\lambda) b)\
=&amp;f\left(\left(\lambda a + (1-\lambda) b\right)\mathbf{x} + \left(1-\lambda a - (1-\lambda) b\right)\mathbf{y} \right)\
=&amp;f\left(\lambda \left(a \mathbf{x} + (1-a)  \mathbf{y}\right)  + (1-\lambda) \left(b \mathbf{x} + (1-b)  \mathbf{y}\right) \right)\
\leq&amp; \lambda f\left(a \mathbf{x} + (1-a)  \mathbf{y}\right)  + (1-\lambda) f\left(b \mathbf{x} + (1-b)  \mathbf{y}\right) \
=&amp; \lambda g(a) + (1-\lambda) g(b).
\end{aligned}$$</p>
<p>To prove the converse,
we can show that for
all $\lambda \in [0, 1]$</p>
<p>$$\begin{aligned} &amp;f(\lambda \mathbf{x} + (1-\lambda) \mathbf{y})\
=&amp;g(\lambda \cdot 1 + (1-\lambda) \cdot 0)\
\leq&amp; \lambda g(1)  + (1-\lambda) g(0) \
=&amp; \lambda f(\mathbf{x}) + (1-\lambda) f(\mathbf{y}).
\end{aligned}$$</p>
<p>Finally,
using the lemma above and the result of the one-dimensional case,
the multidimensional case
can be proven as follows.
A multidimensional function $f: \mathbb{R}^n \rightarrow \mathbb{R}$ is convex
if and only if for all $\mathbf{x}, \mathbf{y} \in \mathbb{R}^n$ $g(z) \stackrel{\textrm{def}}{=} f(z \mathbf{x} + (1-z)  \mathbf{y})$, where $z \in [0,1]$,
is convex.
According to the one-dimensional case,
this holds if and only if
$g'' = (\mathbf{x} - \mathbf{y})^\top \mathbf{H}(\mathbf{x} - \mathbf{y}) \geq 0$ ($\mathbf{H} \stackrel{\textrm{def}}{=} \nabla^2f$)
for all $\mathbf{x}, \mathbf{y} \in \mathbb{R}^n$,
which is equivalent to $\mathbf{H} \succeq 0$
per the definition of positive semidefinite matrices.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>One of the nice properties of convex optimization is that it allows us to handle constraints efficiently. That is, it allows us to solve <em>constrained optimization</em> problems of the form:</p>
<p>$$\begin{aligned} \mathop{\textrm{minimize~}}_{\mathbf{x}} &amp; f(\mathbf{x}) \
\textrm{ subject to } &amp; c_i(\mathbf{x}) \leq 0 \textrm{ for all } i \in {1, \ldots, n},
\end{aligned}$$</p>
<p>where $f$ is the objective and the functions $c_i$ are constraint functions. To see what this does consider the case where $c_1(\mathbf{x}) = |\mathbf{x}|_2 - 1$. In this case the parameters $\mathbf{x}$ are constrained to the unit ball. If a second constraint is $c_2(\mathbf{x}) = \mathbf{v}^\top \mathbf{x} + b$, then this corresponds to all $\mathbf{x}$ lying on a half-space. Satisfying both constraints simultaneously amounts to selecting a slice of a ball.</p>
<h3 id="lagrangian"><a class="header" href="#lagrangian">Lagrangian</a></h3>
<p>In general, solving a constrained optimization problem is difficult. One way of addressing it stems from physics with a rather simple intuition. Imagine a ball inside a box. The ball will roll to the place that is lowest and the forces of gravity will be balanced out with the forces that the sides of the box can impose on the ball. In short, the gradient of the objective function (i.e., gravity) will be offset by the gradient of the constraint function (the ball need to remain inside the box by virtue of the walls "pushing back").
Note that some constraints may not be active:
the walls that are not touched by the ball
will not be able to exert any force on the ball.</p>
<p>Skipping over the derivation of the <em>Lagrangian</em> $L$,
the above reasoning
can be expressed via the following saddle point optimization problem:</p>
<p>$$L(\mathbf{x}, \alpha_1, \ldots, \alpha_n) = f(\mathbf{x}) + \sum_{i=1}^n \alpha_i c_i(\mathbf{x}) \textrm{ where } \alpha_i \geq 0.$$</p>
<p>Here the variables $\alpha_i$ ($i=1,\ldots,n$) are the so-called <em>Lagrange multipliers</em> that ensure that constraints are properly enforced. They are chosen just large enough to ensure that $c_i(\mathbf{x}) \leq 0$ for all $i$. For instance, for any $\mathbf{x}$ where $c_i(\mathbf{x}) &lt; 0$ naturally, we'd end up picking $\alpha_i = 0$. Moreover, this is a saddle point optimization problem where one wants to <em>maximize</em> $L$ with respect to all $\alpha_i$ and simultaneously <em>minimize</em> it with respect to $\mathbf{x}$. There is a rich body of literature explaining how to arrive at the function $L(\mathbf{x}, \alpha_1, \ldots, \alpha_n)$. For our purposes it is sufficient to know that the saddle point of $L$ is where the original constrained optimization problem is solved optimally.</p>
<h3 id="penalties"><a class="header" href="#penalties">Penalties</a></h3>
<p>One way of satisfying constrained optimization problems at least <em>approximately</em> is to adapt the Lagrangian $L$.
Rather than satisfying $c_i(\mathbf{x}) \leq 0$ we simply add $\alpha_i c_i(\mathbf{x})$ to the objective function $f(x)$. This ensures that the constraints will not be violated too badly.</p>
<p>In fact, we have been using this trick all along. Consider weight decay in :numref:<code>sec_weight_decay</code>. In it we add $\frac{\lambda}{2} |\mathbf{w}|^2$ to the objective function to ensure that $\mathbf{w}$ does not grow too large. From the constrained optimization point of view we can see that this will ensure that $|\mathbf{w}|^2 - r^2 \leq 0$ for some radius $r$. Adjusting the value of $\lambda$ allows us to vary the size of $\mathbf{w}$.</p>
<p>In general, adding penalties is a good way of ensuring approximate constraint satisfaction. In practice this turns out to be much more robust than exact satisfaction. Furthermore, for nonconvex problems many of the properties that make the exact approach so appealing in the convex case (e.g., optimality) no longer hold.</p>
<h3 id="projections"><a class="header" href="#projections">Projections</a></h3>
<p>An alternative strategy for satisfying constraints is projections. Again, we encountered them before, e.g., when dealing with gradient clipping in :numref:<code>sec_rnn-scratch</code>. There we ensured that a gradient has length bounded by $\theta$ via</p>
<p>$$\mathbf{g} \leftarrow \mathbf{g} \cdot \mathrm{min}(1, \theta/|\mathbf{g}|).$$</p>
<p>This turns out to be a <em>projection</em> of $\mathbf{g}$ onto the ball of radius $\theta$. More generally, a projection on a convex set $\mathcal{X}$ is defined as</p>
<p>$$\textrm{Proj}<em>\mathcal{X}(\mathbf{x}) = \mathop{\mathrm{argmin}}</em>{\mathbf{x}' \in \mathcal{X}} |\mathbf{x} - \mathbf{x}'|,$$</p>
<p>which is the closest point in $\mathcal{X}$ to $\mathbf{x}$.</p>
<p><img src="chapter_optimization/../img/projections.svg" alt="Convex Projections." />
:label:<code>fig_projections</code></p>
<p>The mathematical definition of projections may sound a bit abstract. :numref:<code>fig_projections</code> explains it somewhat more clearly. In it we have two convex sets, a circle and a diamond.
Points inside both sets (yellow) remain unchanged during projections.
Points outside both sets (black) are projected to
the points inside the sets (red) that are closet to the original points (black).
While for $\ell_2$ balls this leaves the direction unchanged, this need not be the case in general, as can be seen in the case of the diamond.</p>
<p>One of the uses for convex projections is to compute sparse weight vectors. In this case we project weight vectors onto an $\ell_1$ ball,
which is a generalized version of the diamond case in :numref:<code>fig_projections</code>.</p>
<h2 id="summary-55"><a class="header" href="#summary-55">Summary</a></h2>
<p>In the context of deep learning the main purpose of convex functions is to motivate optimization algorithms and help us understand them in detail. In the following we will see how gradient descent and stochastic gradient descent can be derived accordingly.</p>
<ul>
<li>Intersections of convex sets are convex. Unions are not.</li>
<li>The expectation of a convex function is no less than the convex function of an expectation (Jensen's inequality).</li>
<li>A twice-differentiable function is convex if and only if its Hessian (a matrix of second derivatives) is positive semidefinite.</li>
<li>Convex constraints can be added via the Lagrangian. In practice we may simply add them with a penalty to the objective function.</li>
<li>Projections map to points in the convex set closest to the original points.</li>
</ul>
<h2 id="exercises-75"><a class="header" href="#exercises-75">Exercises</a></h2>
<ol>
<li>Assume that we want to verify convexity of a set by drawing all lines between points within the set and checking whether the lines are contained.
<ol>
<li>Prove that it is sufficient to check only the points on the boundary.</li>
<li>Prove that it is sufficient to check only the vertices of the set.</li>
</ol>
</li>
<li>Denote by $\mathcal{B}_p[r] \stackrel{\textrm{def}}{=} {\mathbf{x} | \mathbf{x} \in \mathbb{R}^d \textrm{ and } |\mathbf{x}|_p \leq r}$ the ball of radius $r$ using the $p$-norm. Prove that $\mathcal{B}_p[r]$ is convex for all $p \geq 1$.</li>
<li>Given convex functions $f$ and $g$, show that $\mathrm{max}(f, g)$ is convex, too. Prove that $\mathrm{min}(f, g)$ is not convex.</li>
<li>Prove that the normalization of the softmax function is convex. More specifically prove the convexity of
$f(x) = \log \sum_i \exp(x_i)$.</li>
<li>Prove that linear subspaces, i.e., $\mathcal{X} = {\mathbf{x} | \mathbf{W} \mathbf{x} = \mathbf{b}}$, are convex sets.</li>
<li>Prove that in the case of linear subspaces with $\mathbf{b} = \mathbf{0}$ the projection $\textrm{Proj}_\mathcal{X}$ can be written as $\mathbf{M} \mathbf{x}$ for some matrix $\mathbf{M}$.</li>
<li>Show that for  twice-differentiable convex functions $f$ we can write $f(x + \epsilon) = f(x) + \epsilon f'(x) + \frac{1}{2} \epsilon^2 f''(x + \xi)$ for some $\xi \in [0, \epsilon]$.</li>
<li>Given a convex set $\mathcal{X}$ and two vectors $\mathbf{x}$ and $\mathbf{y}$, prove that projections never increase distances, i.e., $|\mathbf{x} - \mathbf{y}| \geq |\textrm{Proj}<em>\mathcal{X}(\mathbf{x}) - \textrm{Proj}</em>\mathcal{X}(\mathbf{y})|$.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/350">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h1>
<p>:label:<code>sec_gd</code></p>
<p>In this section we are going to introduce the basic concepts underlying <em>gradient descent</em>.
Although it is rarely used directly in deep learning, an understanding of gradient descent is key to understanding stochastic gradient descent algorithms.
For instance, the optimization problem might diverge due to an overly large learning rate. This phenomenon can already be seen in gradient descent. Likewise, preconditioning is a common technique in gradient descent and carries over to more advanced algorithms.
Let's start with a simple special case.</p>
<h2 id="one-dimensional-gradient-descent"><a class="header" href="#one-dimensional-gradient-descent">One-Dimensional Gradient Descent</a></h2>
<p>Gradient descent in one dimension is an excellent example to explain why the gradient descent algorithm may reduce the value of the objective function. Consider some continuously differentiable real-valued function $f: \mathbb{R} \rightarrow \mathbb{R}$. Using a Taylor expansion we obtain</p>
<p>$$f(x + \epsilon) = f(x) + \epsilon f'(x) + \mathcal{O}(\epsilon^2).$$
:eqlabel:<code>gd-taylor</code></p>
<p>That is, in first-order approximation $f(x+\epsilon)$ is given by the function value $f(x)$ and the first derivative $f'(x)$ at $x$. It is not unreasonable to assume that for small $\epsilon$ moving in the direction of the negative gradient will decrease $f$. To keep things simple we pick a fixed step size $\eta &gt; 0$ and choose $\epsilon = -\eta f'(x)$. Plugging this into the Taylor expansion above we get</p>
<p>$$f(x - \eta f'(x)) = f(x) - \eta f'^2(x) + \mathcal{O}(\eta^2 f'^2(x)).$$
:eqlabel:<code>gd-taylor-2</code></p>
<p>If the derivative $f'(x) \neq 0$ does not vanish we make progress since $\eta f'^2(x)&gt;0$. Moreover, we can always choose $\eta$ small enough for the higher-order terms to become irrelevant. Hence we arrive at</p>
<p>$$f(x - \eta f'(x)) \lessapprox f(x).$$</p>
<p>This means that, if we use</p>
<p>$$x \leftarrow x - \eta f'(x)$$</p>
<p>to iterate $x$, the value of function $f(x)$ might decline. Therefore, in gradient descent we first choose an initial value $x$ and a constant $\eta &gt; 0$ and then use them to continuously iterate $x$ until the stop condition is reached, for example, when the magnitude of the gradient $|f'(x)|$ is small enough or the number of iterations has reached a certain value.</p>
<p>For simplicity we choose the objective function $f(x)=x^2$ to illustrate how to implement gradient descent. Although we know that $x=0$ is the solution to minimize $f(x)$, we still use this simple function to observe how $x$ changes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import numpy as np
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import numpy as np
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
def f(x):  # Objective function
    return x ** 2

def f_grad(x):  # Gradient (derivative) of the objective function
    return 2 * x
</code></pre>
<p>Next, we use $x=10$ as the initial value and assume $\eta=0.2$. Using gradient descent to iterate $x$ for 10 times we can see that, eventually, the value of $x$ approaches the optimal solution.</p>
<pre><code class="language-{.python .input}">#@tab all
def gd(eta, f_grad):
    x = 10.0
    results = [x]
    for i in range(10):
        x -= eta * f_grad(x)
        results.append(float(x))
    print(f'epoch 10, x: {x:f}')
    return results

results = gd(0.2, f_grad)
</code></pre>
<p>The progress of optimizing over $x$ can be plotted as follows.</p>
<pre><code class="language-{.python .input}">#@tab all
def show_trace(results, f):
    n = max(abs(min(results)), abs(max(results)))
    f_line = d2l.arange(-n, n, 0.01)
    d2l.set_figsize()
    d2l.plot([f_line, results], [[f(x) for x in f_line], [
        f(x) for x in results]], 'x', 'f(x)', fmts=['-', '-o'])

show_trace(results, f)
</code></pre>
<h3 id="learning-rate"><a class="header" href="#learning-rate">Learning Rate</a></h3>
<p>:label:<code>subsec_gd-learningrate</code></p>
<p>The learning rate $\eta$ can be set by the algorithm designer. If we use a learning rate that is too small, it will cause $x$ to update very slowly, requiring more iterations to get a better solution. To show what happens in such a case, consider the progress in the same optimization problem for $\eta = 0.05$. As we can see, even after 10 steps we are still very far from the optimal solution.</p>
<pre><code class="language-{.python .input}">#@tab all
show_trace(gd(0.05, f_grad), f)
</code></pre>
<p>Conversely, if we use an excessively high learning rate, $\left|\eta f'(x)\right|$ might be too large for the first-order Taylor expansion formula. That is, the term $\mathcal{O}(\eta^2 f'^2(x))$ in :eqref:<code>gd-taylor-2</code> might become significant. In this case, we cannot guarantee that the iteration of $x$ will be able to lower the value of $f(x)$. For example, when we set the learning rate to $\eta=1.1$, $x$ overshoots the optimal solution $x=0$ and gradually diverges.</p>
<pre><code class="language-{.python .input}">#@tab all
show_trace(gd(1.1, f_grad), f)
</code></pre>
<h3 id="local-minima-1"><a class="header" href="#local-minima-1">Local Minima</a></h3>
<p>To illustrate what happens for nonconvex functions consider the case of $f(x) = x \cdot \cos(cx)$ for some constant $c$. This function has infinitely many local minima. Depending on our choice of the learning rate and depending on how well conditioned the problem is, we may end up with one of many solutions. The example below illustrates how an (unrealistically) high learning rate will lead to a poor local minimum.</p>
<pre><code class="language-{.python .input}">#@tab all
c = d2l.tensor(0.15 * np.pi)

def f(x):  # Objective function
    return x * d2l.cos(c * x)

def f_grad(x):  # Gradient of the objective function
    return d2l.cos(c * x) - c * x * d2l.sin(c * x)

show_trace(gd(2, f_grad), f)
</code></pre>
<h2 id="multivariate-gradient-descent"><a class="header" href="#multivariate-gradient-descent">Multivariate Gradient Descent</a></h2>
<p>Now that we have a better intuition of the univariate case, let's consider the situation where $\mathbf{x} = [x_1, x_2, \ldots, x_d]^\top$. That is, the objective function $f: \mathbb{R}^d \to \mathbb{R}$ maps vectors into scalars. Correspondingly its gradient is multivariate, too. It is a vector consisting of $d$ partial derivatives:</p>
<p>$$\nabla f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_d}\bigg]^\top.$$</p>
<p>Each partial derivative element $\partial f(\mathbf{x})/\partial x_i$ in the gradient indicates the rate of change of $f$ at $\mathbf{x}$ with respect to the input $x_i$. As before in the univariate case we can use the corresponding Taylor approximation for multivariate functions to get some idea of what we should do. In particular, we have that</p>
<p>$$f(\mathbf{x} + \boldsymbol{\epsilon}) = f(\mathbf{x}) + \mathbf{\boldsymbol{\epsilon}}^\top \nabla f(\mathbf{x}) + \mathcal{O}(|\boldsymbol{\epsilon}|^2).$$
:eqlabel:<code>gd-multi-taylor</code></p>
<p>In other words, up to second-order terms in $\boldsymbol{\epsilon}$ the direction of steepest descent is given by the negative gradient $-\nabla f(\mathbf{x})$. Choosing a suitable learning rate $\eta &gt; 0$ yields the prototypical gradient descent algorithm:</p>
<p>$$\mathbf{x} \leftarrow \mathbf{x} - \eta \nabla f(\mathbf{x}).$$</p>
<p>To see how the algorithm behaves in practice let's construct an objective function $f(\mathbf{x})=x_1^2+2x_2^2$ with a two-dimensional vector $\mathbf{x} = [x_1, x_2]^\top$ as input and a scalar as output. The gradient is given by $\nabla f(\mathbf{x}) = [2x_1, 4x_2]^\top$. We will observe the trajectory of $\mathbf{x}$ by gradient descent from the initial position $[-5, -2]$.</p>
<p>To begin with, we need two more helper functions. The first uses an update function and applies it 20 times to the initial value. The second helper visualizes the trajectory of $\mathbf{x}$.</p>
<pre><code class="language-{.python .input}">#@tab all
def train_2d(trainer, steps=20, f_grad=None):  #@save
    """Optimize a 2D objective function with a customized trainer."""
    # `s1` and `s2` are internal state variables that will be used in Momentum, adagrad, RMSProp
    x1, x2, s1, s2 = -5, -2, 0, 0
    results = [(x1, x2)]
    for i in range(steps):
        if f_grad:
            x1, x2, s1, s2 = trainer(x1, x2, s1, s2, f_grad)
        else:
            x1, x2, s1, s2 = trainer(x1, x2, s1, s2)
        results.append((x1, x2))
    print(f'epoch {i + 1}, x1: {float(x1):f}, x2: {float(x2):f}')
    return results
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
def show_trace_2d(f, results):  #@save
    """Show the trace of 2D variables during optimization."""
    d2l.set_figsize()
    d2l.plt.plot(*zip(*results), '-o', color='#ff7f0e')
    x1, x2 = d2l.meshgrid(d2l.arange(-55, 1, 1),
                          d2l.arange(-30, 1, 1))
    x1, x2 = x1.asnumpy()*0.1, x2.asnumpy()*0.1
    d2l.plt.contour(x1, x2, f(x1, x2), colors='#1f77b4')
    d2l.plt.xlabel('x1')
    d2l.plt.ylabel('x2')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def show_trace_2d(f, results):  #@save
    """Show the trace of 2D variables during optimization."""
    d2l.set_figsize()
    d2l.plt.plot(*zip(*results), '-o', color='#ff7f0e')
    x1, x2 = d2l.meshgrid(d2l.arange(-5.5, 1.0, 0.1),
                          d2l.arange(-3.0, 1.0, 0.1))
    d2l.plt.contour(x1, x2, f(x1, x2), colors='#1f77b4')
    d2l.plt.xlabel('x1')
    d2l.plt.ylabel('x2')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def show_trace_2d(f, results):  #@save
    """Show the trace of 2D variables during optimization."""
    d2l.set_figsize()
    d2l.plt.plot(*zip(*results), '-o', color='#ff7f0e')
    x1, x2 = d2l.meshgrid(d2l.arange(-5.5, 1.0, 0.1),
                          d2l.arange(-3.0, 1.0, 0.1), indexing='ij')
    d2l.plt.contour(x1, x2, f(x1, x2), colors='#1f77b4')
    d2l.plt.xlabel('x1')
    d2l.plt.ylabel('x2')
</code></pre>
<p>Next, we observe the trajectory of the optimization variable $\mathbf{x}$ for learning rate $\eta = 0.1$. We can see that after 20 steps the value of $\mathbf{x}$ approaches its minimum at $[0, 0]$. Progress is fairly well-behaved albeit rather slow.</p>
<pre><code class="language-{.python .input}">#@tab all
def f_2d(x1, x2):  # Objective function
    return x1 ** 2 + 2 * x2 ** 2

def f_2d_grad(x1, x2):  # Gradient of the objective function
    return (2 * x1, 4 * x2)

def gd_2d(x1, x2, s1, s2, f_grad):
    g1, g2 = f_grad(x1, x2)
    return (x1 - eta * g1, x2 - eta * g2, 0, 0)

eta = 0.1
show_trace_2d(f_2d, train_2d(gd_2d, f_grad=f_2d_grad))
</code></pre>
<h2 id="adaptive-methods"><a class="header" href="#adaptive-methods">Adaptive Methods</a></h2>
<p>As we could see in :numref:<code>subsec_gd-learningrate</code>, getting the learning rate $\eta$ "just right" is tricky. If we pick it too small, we make little progress. If we pick it too large, the solution oscillates and in the worst case it might even diverge. What if we could determine $\eta$ automatically or get rid of having to select a learning rate at all?
Second-order methods that look not only at the value and gradient of the objective function
but also at its <em>curvature</em> can help in this case. While these methods cannot be applied to deep learning directly due to the computational cost, they provide useful intuition into how to design advanced optimization algorithms that mimic many of the desirable properties of the algorithms outlined below.</p>
<h3 id="newtons-method"><a class="header" href="#newtons-method">Newton's Method</a></h3>
<p>Reviewing the Taylor expansion of some function $f: \mathbb{R}^d \rightarrow \mathbb{R}$ there is no need to stop after the first term. In fact, we can write it as</p>
<p>$$f(\mathbf{x} + \boldsymbol{\epsilon}) = f(\mathbf{x}) + \boldsymbol{\epsilon}^\top \nabla f(\mathbf{x}) + \frac{1}{2} \boldsymbol{\epsilon}^\top \nabla^2 f(\mathbf{x}) \boldsymbol{\epsilon} + \mathcal{O}(|\boldsymbol{\epsilon}|^3).$$
:eqlabel:<code>gd-hot-taylor</code></p>
<p>To avoid cumbersome notation we define $\mathbf{H} \stackrel{\textrm{def}}{=} \nabla^2 f(\mathbf{x})$ to be the Hessian of $f$, which is a $d \times d$ matrix. For small $d$ and simple problems $\mathbf{H}$ is easy to compute. For deep neural networks, on the other hand, $\mathbf{H}$ may be prohibitively large, due to the cost of storing $\mathcal{O}(d^2)$ entries. Furthermore it may be too expensive to compute via backpropagation. For now let's ignore such considerations and look at what algorithm we would get.</p>
<p>After all, the minimum of $f$ satisfies $\nabla f = 0$.
Following calculus rules in :numref:<code>subsec_calculus-grad</code>,
by taking derivatives of :eqref:<code>gd-hot-taylor</code> with regard to $\boldsymbol{\epsilon}$ and ignoring higher-order terms we arrive at</p>
<p>$$\nabla f(\mathbf{x}) + \mathbf{H} \boldsymbol{\epsilon} = 0 \textrm{ and hence }
\boldsymbol{\epsilon} = -\mathbf{H}^{-1} \nabla f(\mathbf{x}).$$</p>
<p>That is, we need to invert the Hessian $\mathbf{H}$ as part of the optimization problem.</p>
<p>As a simple example, for $f(x) = \frac{1}{2} x^2$ we have $\nabla f(x) = x$ and $\mathbf{H} = 1$. Hence for any $x$ we obtain $\epsilon = -x$. In other words, a <em>single</em> step is sufficient to converge perfectly without the need for any adjustment! Alas, we got a bit lucky here: the Taylor expansion was exact since $f(x+\epsilon)= \frac{1}{2} x^2 + \epsilon x + \frac{1}{2} \epsilon^2$.</p>
<p>Let's see what happens in other problems.
Given a convex hyperbolic cosine function $f(x) = \cosh(cx)$ for some constant $c$, we can see that
the global minimum at $x=0$ is reached
after a few iterations.</p>
<pre><code class="language-{.python .input}">#@tab all
c = d2l.tensor(0.5)

def f(x):  # Objective function
    return d2l.cosh(c * x)

def f_grad(x):  # Gradient of the objective function
    return c * d2l.sinh(c * x)

def f_hess(x):  # Hessian of the objective function
    return c**2 * d2l.cosh(c * x)

def newton(eta=1):
    x = 10.0
    results = [x]
    for i in range(10):
        x -= eta * f_grad(x) / f_hess(x)
        results.append(float(x))
    print('epoch 10, x:', x)
    return results

show_trace(newton(), f)
</code></pre>
<p>Now let's consider a <em>nonconvex</em> function, such as $f(x) = x \cos(c x)$ for some constant $c$. After all, note that in Newton's method we end up dividing by the Hessian. This means that if the second derivative is <em>negative</em> we may walk into the direction of <em>increasing</em> the value of $f$.
That is a fatal flaw of the algorithm.
Let's see what happens in practice.</p>
<pre><code class="language-{.python .input}">#@tab all
c = d2l.tensor(0.15 * np.pi)

def f(x):  # Objective function
    return x * d2l.cos(c * x)

def f_grad(x):  # Gradient of the objective function
    return d2l.cos(c * x) - c * x * d2l.sin(c * x)

def f_hess(x):  # Hessian of the objective function
    return - 2 * c * d2l.sin(c * x) - x * c**2 * d2l.cos(c * x)

show_trace(newton(), f)
</code></pre>
<p>This went spectacularly wrong. How can we fix it? One way would be to "fix" the Hessian by taking its absolute value instead. Another strategy is to bring back the learning rate. This seems to defeat the purpose, but not quite. Having second-order information allows us to be cautious whenever the curvature is large and to take longer steps whenever the objective function is flatter.
Let's see how this works with a slightly smaller learning rate, say $\eta = 0.5$. As we can see, we have quite an efficient algorithm.</p>
<pre><code class="language-{.python .input}">#@tab all
show_trace(newton(0.5), f)
</code></pre>
<h3 id="convergence-analysis"><a class="header" href="#convergence-analysis">Convergence Analysis</a></h3>
<p>We only analyze the convergence rate of Newton's method for some convex and three times differentiable objective function $f$, where the second derivative is nonzero, i.e., $f'' &gt; 0$. The multivariate proof is a straightforward extension of the one-dimensional argument below and omitted since it does not help us much in terms of intuition.</p>
<p>Denote by $x^{(k)}$ the value of $x$ at the $k^\textrm{th}$ iteration and let $e^{(k)} \stackrel{\textrm{def}}{=} x^{(k)} - x^<em>$ be the distance from optimality at the $k^\textrm{th}$ iteration. By Taylor  expansion we have that the condition $f'(x^</em>) = 0$ can be written as</p>
<p>$$0 = f'(x^{(k)} - e^{(k)}) = f'(x^{(k)}) - e^{(k)} f''(x^{(k)}) + \frac{1}{2} (e^{(k)})^2 f'''(\xi^{(k)}),$$</p>
<p>which holds for some $\xi^{(k)} \in [x^{(k)} - e^{(k)}, x^{(k)}]$. Dividing the above expansion by $f''(x^{(k)})$ yields</p>
<p>$$e^{(k)} - \frac{f'(x^{(k)})}{f''(x^{(k)})} = \frac{1}{2} (e^{(k)})^2 \frac{f'''(\xi^{(k)})}{f''(x^{(k)})}.$$</p>
<p>Recall that we have the update $x^{(k+1)} = x^{(k)} - f'(x^{(k)}) / f''(x^{(k)})$.
Plugging in this update equation and taking the absolute value of both sides, we have</p>
<p>$$\left|e^{(k+1)}\right| = \frac{1}{2}(e^{(k)})^2 \frac{\left|f'''(\xi^{(k)})\right|}{f''(x^{(k)})}.$$</p>
<p>Consequently, whenever we are in a region of bounded $\left|f'''(\xi^{(k)})\right| / (2f''(x^{(k)})) \leq c$, we have a quadratically decreasing error</p>
<p>$$\left|e^{(k+1)}\right| \leq c (e^{(k)})^2.$$</p>
<p>As an aside, optimization researchers call this <em>linear</em> convergence, whereas a condition such as $\left|e^{(k+1)}\right| \leq \alpha \left|e^{(k)}\right|$ would be called a <em>constant</em> rate of convergence.
Note that this analysis comes with a number of caveats.
First, we do not really have much of a guarantee when we will reach the region of rapid convergence. Instead, we only know that once we reach it, convergence will be very quick. Second, this analysis requires that $f$ is well-behaved up to higher-order derivatives. It comes down to ensuring that $f$ does not have any "surprising" properties in terms of how it might change its values.</p>
<h3 id="preconditioning"><a class="header" href="#preconditioning">Preconditioning</a></h3>
<p>Quite unsurprisingly computing and storing the full Hessian is very expensive. It is thus desirable to find alternatives. One way to improve matters is <em>preconditioning</em>. It avoids computing the Hessian in its entirety but only computes the <em>diagonal</em> entries. This leads to update algorithms of the form</p>
<p>$$\mathbf{x} \leftarrow \mathbf{x} - \eta \textrm{diag}(\mathbf{H})^{-1} \nabla f(\mathbf{x}).$$</p>
<p>While this is not quite as good as the full Newton's method, it is still much better than not using it.
To see why this might be a good idea consider a situation where one variable denotes height in millimeters and the other one denotes height in kilometers. Assuming that for both the natural scale is in meters, we have a terrible mismatch in parametrizations. Fortunately, using preconditioning removes this. Effectively preconditioning with gradient descent amounts to selecting a different learning rate for each variable (coordinate of vector $\mathbf{x}$).
As we will see later, preconditioning drives some of the innovation in stochastic gradient descent optimization algorithms.</p>
<h3 id="gradient-descent-with-line-search"><a class="header" href="#gradient-descent-with-line-search">Gradient Descent with Line Search</a></h3>
<p>One of the key problems in gradient descent is that we might overshoot the goal or make insufficient progress. A simple fix for the problem is to use line search in conjunction with gradient descent. That is, we use the direction given by $\nabla f(\mathbf{x})$ and then perform binary search as to which learning rate $\eta$ minimizes $f(\mathbf{x} - \eta \nabla f(\mathbf{x}))$.</p>
<p>This algorithm converges rapidly (for an analysis and proof see e.g., :citet:<code>Boyd.Vandenberghe.2004</code>). However, for the purpose of deep learning this is not quite so feasible, since each step of the line search would require us to evaluate the objective function on the entire dataset. This is way too costly to accomplish.</p>
<h2 id="summary-56"><a class="header" href="#summary-56">Summary</a></h2>
<ul>
<li>Learning rates matter. Too large and we diverge, too small and we do not make progress.</li>
<li>Gradient descent can get stuck in local minima.</li>
<li>In high dimensions adjusting the learning rate is complicated.</li>
<li>Preconditioning can help with scale adjustment.</li>
<li>Newton's method is a lot faster once it has started working properly in convex problems.</li>
<li>Beware of using Newton's method without any adjustments for nonconvex problems.</li>
</ul>
<h2 id="exercises-76"><a class="header" href="#exercises-76">Exercises</a></h2>
<ol>
<li>Experiment with different learning rates and objective functions for gradient descent.</li>
<li>Implement line search to minimize a convex function in the interval $[a, b]$.
<ol>
<li>Do you need derivatives for binary search, i.e., to decide whether to pick $[a, (a+b)/2]$ or $[(a+b)/2, b]$.</li>
<li>How rapid is the rate of convergence for the algorithm?</li>
<li>Implement the algorithm and apply it to minimizing $\log (\exp(x) + \exp(-2x -3))$.</li>
</ol>
</li>
<li>Design an objective function defined on $\mathbb{R}^2$ where gradient descent is exceedingly slow. Hint: scale different coordinates differently.</li>
<li>Implement the lightweight version of Newton's method using preconditioning:
<ol>
<li>Use diagonal Hessian as preconditioner.</li>
<li>Use the absolute values of that rather than the actual (possibly signed) values.</li>
<li>Apply this to the problem above.</li>
</ol>
</li>
<li>Apply the algorithm above to a number of objective functions (convex or not). What happens if you rotate coordinates by $45$ degrees?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/351">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stochastic-gradient-descent"><a class="header" href="#stochastic-gradient-descent">Stochastic Gradient Descent</a></h1>
<p>:label:<code>sec_sgd</code></p>
<p>In earlier chapters we kept using stochastic gradient descent in our training procedure, however, without explaining why it works.
To shed some light on it,
we just described the basic principles of gradient descent
in :numref:<code>sec_gd</code>.
In this section, we go on to discuss
<em>stochastic gradient descent</em> in greater detail.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import math
import tensorflow as tf
</code></pre>
<h2 id="stochastic-gradient-updates"><a class="header" href="#stochastic-gradient-updates">Stochastic Gradient Updates</a></h2>
<p>In deep learning, the objective function is usually the average of the loss functions for each example in the training dataset.
Given a training dataset of $n$ examples,
we assume that $f_i(\mathbf{x})$ is the loss function
with respect to the training example of index $i$,
where $\mathbf{x}$ is the parameter vector.
Then we arrive at the objective function</p>
<p>$$f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n f_i(\mathbf{x}).$$</p>
<p>The gradient of the objective function at $\mathbf{x}$ is computed as</p>
<p>$$\nabla f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\mathbf{x}).$$</p>
<p>If gradient descent is used, the computational cost for each independent variable iteration is $\mathcal{O}(n)$, which grows linearly with $n$. Therefore, when the  training dataset is larger, the cost of gradient descent for each iteration will be higher.</p>
<p>Stochastic gradient descent (SGD) reduces computational cost at each iteration. At each iteration of stochastic gradient descent, we uniformly sample an index $i\in{1,\ldots, n}$ for data examples at random, and compute the gradient $\nabla f_i(\mathbf{x})$ to update $\mathbf{x}$:</p>
<p>$$\mathbf{x} \leftarrow \mathbf{x} - \eta \nabla f_i(\mathbf{x}),$$</p>
<p>where $\eta$ is the learning rate. We can see that the computational cost for each iteration drops from $\mathcal{O}(n)$ of the gradient descent to the constant $\mathcal{O}(1)$. Moreover, we want to emphasize that the stochastic gradient $\nabla f_i(\mathbf{x})$ is an unbiased estimate of the full gradient $\nabla f(\mathbf{x})$ because</p>
<p>$$\mathbb{E}<em>i \nabla f_i(\mathbf{x}) = \frac{1}{n} \sum</em>{i = 1}^n \nabla f_i(\mathbf{x}) = \nabla f(\mathbf{x}).$$</p>
<p>This means that, on average, the stochastic gradient is a good estimate of the gradient.</p>
<p>Now, we will compare it with gradient descent by adding random noise with a mean of 0 and a variance of 1 to the gradient to simulate a stochastic gradient descent.</p>
<pre><code class="language-{.python .input}">#@tab all
def f(x1, x2):  # Objective function
    return x1 ** 2 + 2 * x2 ** 2

def f_grad(x1, x2):  # Gradient of the objective function
    return 2 * x1, 4 * x2
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
def sgd(x1, x2, s1, s2, f_grad):
    g1, g2 = f_grad(x1, x2)
    # Simulate noisy gradient
    g1 += d2l.normal(0.0, 1, (1,))
    g2 += d2l.normal(0.0, 1, (1,))
    eta_t = eta * lr()
    return (x1 - eta_t * g1, x2 - eta_t * g2, 0, 0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def sgd(x1, x2, s1, s2, f_grad):
    g1, g2 = f_grad(x1, x2)
    # Simulate noisy gradient
    g1 += torch.normal(0.0, 1, (1,)).item()
    g2 += torch.normal(0.0, 1, (1,)).item()
    eta_t = eta * lr()
    return (x1 - eta_t * g1, x2 - eta_t * g2, 0, 0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def sgd(x1, x2, s1, s2, f_grad):
    g1, g2 = f_grad(x1, x2)
    # Simulate noisy gradient
    g1 += d2l.normal([1], 0.0, 1)
    g2 += d2l.normal([1], 0.0, 1)
    eta_t = eta * lr()
    return (x1 - eta_t * g1, x2 - eta_t * g2, 0, 0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
def constant_lr():
    return 1

eta = 0.1
lr = constant_lr  # Constant learning rate
d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=50, f_grad=f_grad))
</code></pre>
<p>As we can see, the trajectory of the variables in the stochastic gradient descent is much more noisy than the one we observed in gradient descent in :numref:<code>sec_gd</code>. This is due to the stochastic nature of the gradient. That is, even when we arrive near the minimum, we are still subject to the uncertainty injected by the instantaneous gradient via $\eta \nabla f_i(\mathbf{x})$. Even after 50 steps the quality is still not so good. Even worse, it will not improve after additional steps (we encourage you to experiment with a larger number of steps to confirm this). This leaves us with the only alternative: change the learning rate $\eta$. However, if we pick this too small, we will not make any meaningful progress initially. On the other hand, if we pick it too large, we will not get a good solution, as seen above. The only way to resolve these conflicting goals is to reduce the learning rate <em>dynamically</em> as optimization progresses.</p>
<p>This is also the reason for adding a learning rate function <code>lr</code> into the <code>sgd</code> step function. In the example above any functionality for learning rate scheduling lies dormant as we set the associated <code>lr</code> function to be constant.</p>
<h2 id="dynamic-learning-rate"><a class="header" href="#dynamic-learning-rate">Dynamic Learning Rate</a></h2>
<p>Replacing $\eta$ with a time-dependent learning rate $\eta(t)$ adds to the complexity of controlling convergence of an optimization algorithm. In particular, we need to figure out how rapidly $\eta$ should decay. If it is too quick, we will stop optimizing prematurely. If we decrease it too slowly, we waste too much time on optimization. The following are a few basic strategies that are used in adjusting $\eta$ over time (we will discuss more advanced strategies later):</p>
<p>$$
\begin{aligned}
\eta(t) &amp; = \eta_i \textrm{ if } t_i \leq t \leq t_{i+1}  &amp;&amp; \textrm{piecewise constant} \
\eta(t) &amp; = \eta_0 \cdot e^{-\lambda t} &amp;&amp; \textrm{exponential decay} \
\eta(t) &amp; = \eta_0 \cdot (\beta t + 1)^{-\alpha} &amp;&amp; \textrm{polynomial decay}
\end{aligned}
$$</p>
<p>In the first <em>piecewise constant</em> scenario we decrease the learning rate, e.g., whenever progress in optimization stalls. This is a common strategy for training deep networks. Alternatively we could decrease it much more aggressively by an <em>exponential decay</em>. Unfortunately this often leads to premature stopping before the algorithm has converged. A popular choice is <em>polynomial decay</em> with $\alpha = 0.5$. In the case of convex optimization there are a number of proofs that show that this rate is well behaved.</p>
<p>Let's see what the exponential decay looks like in practice.</p>
<pre><code class="language-{.python .input}">#@tab all
def exponential_lr():
    # Global variable that is defined outside this function and updated inside
    global t
    t += 1
    return math.exp(-0.1 * t)

t = 1
lr = exponential_lr
d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=1000, f_grad=f_grad))
</code></pre>
<p>As expected, the variance in the parameters is significantly reduced. However, this comes at the expense of failing to converge to the optimal solution $\mathbf{x} = (0, 0)$. Even after 1000 iteration steps are we are still very far away from the optimal solution. Indeed, the algorithm fails to converge at all. On the other hand, if we use a polynomial decay where the learning rate decays with the inverse square root of the number of steps, convergence gets better after only 50 steps.</p>
<pre><code class="language-{.python .input}">#@tab all
def polynomial_lr():
    # Global variable that is defined outside this function and updated inside
    global t
    t += 1
    return (1 + 0.1 * t) ** (-0.5)

t = 1
lr = polynomial_lr
d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=50, f_grad=f_grad))
</code></pre>
<p>There exist many more choices for how to set the learning rate. For instance, we could start with a small rate, then rapidly ramp up and then decrease it again, albeit more slowly. We could even alternate between smaller and larger learning rates. There exists a large variety of such schedules. For now let's focus on learning rate schedules for which a comprehensive theoretical analysis is possible, i.e., on learning rates in a convex setting. For general nonconvex problems it is very difficult to obtain meaningful convergence guarantees, since in general minimizing nonlinear nonconvex problems is NP hard. For a survey see e.g., the excellent <a href="https://www.stat.cmu.edu/%7Eryantibs/convexopt-F15/lectures/26-nonconvex.pdf">lecture notes</a> of Tibshirani 2015.</p>
<h2 id="convergence-analysis-for-convex-objectives"><a class="header" href="#convergence-analysis-for-convex-objectives">Convergence Analysis for Convex Objectives</a></h2>
<p>The following convergence analysis of stochastic gradient descent for convex objective functions
is optional and primarily serves to convey more intuition about the problem.
We limit ourselves to one of the simplest proofs :cite:<code>Nesterov.Vial.2000</code>.
Significantly more advanced proof techniques exist, e.g., whenever the objective function is particularly well behaved.</p>
<p>Suppose that the objective function $f(\boldsymbol{\xi}, \mathbf{x})$ is convex in $\mathbf{x}$
for all $\boldsymbol{\xi}$.
More concretely,
we consider the stochastic gradient descent update:</p>
<p>$$\mathbf{x}<em>{t+1} = \mathbf{x}</em>{t} - \eta_t \partial_\mathbf{x} f(\boldsymbol{\xi}_t, \mathbf{x}),$$</p>
<p>where $f(\boldsymbol{\xi}_t, \mathbf{x})$
is the objective function
with respect to the training example $\boldsymbol{\xi}_t$
drawn from some distribution
at step $t$ and $\mathbf{x}$ is the model parameter.
Denote by</p>
<p>$$R(\mathbf{x}) = E_{\boldsymbol{\xi}}[f(\boldsymbol{\xi}, \mathbf{x})]$$</p>
<p>the expected risk and by $R^<em>$ its minimum with regard to $\mathbf{x}$. Last let $\mathbf{x}^</em>$ be the minimizer (we assume that it exists within the domain where $\mathbf{x}$ is defined). In this case we can track the distance between the current parameter $\mathbf{x}_t$ at time $t$ and the risk minimizer $\mathbf{x}^*$ and see whether it improves over time:</p>
<p>$$\begin{aligned}    &amp;|\mathbf{x}<em>{t+1} - \mathbf{x}^*|^2 \ =&amp; |\mathbf{x}</em>{t} - \eta_t \partial_\mathbf{x} f(\boldsymbol{\xi}<em>t, \mathbf{x}) - \mathbf{x}^*|^2 \    =&amp; |\mathbf{x}</em>{t} - \mathbf{x}^<em>|^2 + \eta_t^2 |\partial_\mathbf{x} f(\boldsymbol{\xi}_t, \mathbf{x})|^2 - 2 \eta_t    \left\langle \mathbf{x}_t - \mathbf{x}^</em>, \partial_\mathbf{x} f(\boldsymbol{\xi}_t, \mathbf{x})\right\rangle.   \end{aligned}$$
:eqlabel:<code>eq_sgd-xt+1-xstar</code></p>
<p>We assume that the $\ell_2$ norm of stochastic gradient $\partial_\mathbf{x} f(\boldsymbol{\xi}_t, \mathbf{x})$ is bounded  by some  constant $L$, hence we have that</p>
<p>$$\eta_t^2 |\partial_\mathbf{x} f(\boldsymbol{\xi}_t, \mathbf{x})|^2 \leq \eta_t^2 L^2.$$
:eqlabel:<code>eq_sgd-L</code></p>
<p>We are mostly interested in how the distance between $\mathbf{x}_t$ and $\mathbf{x}^*$ changes <em>in expectation</em>. In fact, for any specific sequence of steps the distance might well increase, depending on whichever $\boldsymbol{\xi}_t$ we encounter. Hence we need to bound the dot product.
Since for any convex function $f$ it holds that
$f(\mathbf{y}) \geq f(\mathbf{x}) + \langle f'(\mathbf{x}), \mathbf{y} - \mathbf{x} \rangle$
for all $\mathbf{x}$ and $\mathbf{y}$,
by convexity we have</p>
<p>$$f(\boldsymbol{\xi}_t, \mathbf{x}^<em>) \geq f(\boldsymbol{\xi}_t, \mathbf{x}_t) + \left\langle \mathbf{x}^</em> - \mathbf{x}<em>t, \partial</em>{\mathbf{x}} f(\boldsymbol{\xi}_t, \mathbf{x}_t) \right\rangle.$$
:eqlabel:<code>eq_sgd-f-xi-xstar</code></p>
<p>Plugging both inequalities :eqref:<code>eq_sgd-L</code> and :eqref:<code>eq_sgd-f-xi-xstar</code> into :eqref:<code>eq_sgd-xt+1-xstar</code> we obtain a bound on the distance between parameters at time $t+1$ as follows:</p>
<p>$$|\mathbf{x}<em>{t} - \mathbf{x}^*|^2 - |\mathbf{x}</em>{t+1} - \mathbf{x}^<em>|^2 \geq 2 \eta_t (f(\boldsymbol{\xi}_t, \mathbf{x}_t) - f(\boldsymbol{\xi}_t, \mathbf{x}^</em>)) - \eta_t^2 L^2.$$
:eqlabel:<code>eqref_sgd-xt-diff</code></p>
<p>This means that we make progress as long as the  difference between current loss and the optimal loss outweighs $\eta_t L^2/2$. Since this difference is bound to converge to zero it follows that the learning rate $\eta_t$ also needs to <em>vanish</em>.</p>
<p>Next we take expectations over :eqref:<code>eqref_sgd-xt-diff</code>. This yields</p>
<p>$$E\left[|\mathbf{x}<em>{t} - \mathbf{x}^*|^2\right] - E\left[|\mathbf{x}</em>{t+1} - \mathbf{x}^<em>|^2\right] \geq 2 \eta_t [E[R(\mathbf{x}_t)] - R^</em>] -  \eta_t^2 L^2.$$</p>
<p>The last step involves summing over the inequalities for $t \in {1, \ldots, T}$. Since the sum telescopes and by dropping the lower term we obtain</p>
<p>$$|\mathbf{x}<em>1 - \mathbf{x}^*|^2 \geq 2 \left (\sum</em>{t=1}^T   \eta_t \right) [E[R(\mathbf{x}<em>t)] - R^*] - L^2 \sum</em>{t=1}^T \eta_t^2.$$
:eqlabel:<code>eq_sgd-x1-xstar</code></p>
<p>Note that we exploited that $\mathbf{x}_1$ is given and thus the expectation can be dropped. Last define</p>
<p>$$\bar{\mathbf{x}} \stackrel{\textrm{def}}{=} \frac{\sum_{t=1}^T \eta_t \mathbf{x}<em>t}{\sum</em>{t=1}^T \eta_t}.$$</p>
<p>Since</p>
<p>$$E\left(\frac{\sum_{t=1}^T \eta_t R(\mathbf{x}<em>t)}{\sum</em>{t=1}^T \eta_t}\right) = \frac{\sum_{t=1}^T \eta_t E[R(\mathbf{x}<em>t)]}{\sum</em>{t=1}^T \eta_t} = E[R(\mathbf{x}_t)],$$</p>
<p>by Jensen's inequality (setting $i=t$, $\alpha_i = \eta_t/\sum_{t=1}^T \eta_t$ in :eqref:<code>eq_jensens-inequality</code>) and convexity of $R$ it follows that $E[R(\mathbf{x}_t)] \geq E[R(\bar{\mathbf{x}})]$, thus</p>
<p>$$\sum_{t=1}^T \eta_t E[R(\mathbf{x}<em>t)] \geq \sum</em>{t=1}^T \eta_t  E\left[R(\bar{\mathbf{x}})\right].$$</p>
<p>Plugging this into the inequality :eqref:<code>eq_sgd-x1-xstar</code> yields the bound</p>
<p>$$
\left[E[\bar{\mathbf{x}}]\right] - R^* \leq \frac{r^2 + L^2 \sum_{t=1}^T \eta_t^2}{2 \sum_{t=1}^T \eta_t},
$$</p>
<p>where $r^2 \stackrel{\textrm{def}}{=} |\mathbf{x}_1 - \mathbf{x}^*|^2$ is a bound on the distance between the initial choice of parameters and the final outcome. In short, the speed of convergence depends on how
the norm of stochastic gradient is bounded ($L$) and how far away from optimality the initial parameter value is ($r$). Note that the bound is in terms of $\bar{\mathbf{x}}$ rather than $\mathbf{x}_T$. This is the case since $\bar{\mathbf{x}}$ is a smoothed version of the optimization path.
Whenever $r, L$, and $T$ are known we can pick the learning rate $\eta = r/(L \sqrt{T})$. This yields as upper bound $rL/\sqrt{T}$. That is, we converge with rate $\mathcal{O}(1/\sqrt{T})$ to the optimal solution.</p>
<h2 id="stochastic-gradients-and-finite-samples"><a class="header" href="#stochastic-gradients-and-finite-samples">Stochastic Gradients and Finite Samples</a></h2>
<p>So far we have played a bit fast and loose when it comes to talking about stochastic gradient descent. We posited that we draw instances $x_i$, typically with labels $y_i$ from some distribution $p(x, y)$ and that we use this to update the model parameters in some manner. In particular, for a finite sample size we simply argued that the discrete distribution $p(x, y) = \frac{1}{n} \sum_{i=1}^n \delta_{x_i}(x) \delta_{y_i}(y)$
for some functions $\delta_{x_i}$ and $\delta_{y_i}$
allows us to perform stochastic gradient descent over it.</p>
<p>However, this is not really what we did. In the toy examples in the current section we simply added noise to an otherwise non-stochastic gradient, i.e., we pretended to have pairs $(x_i, y_i)$. It turns out that this is justified here (see the exercises for a detailed discussion). More troubling is that in all previous discussions we clearly did not do this. Instead we iterated over all instances <em>exactly once</em>. To see why this is preferable consider the converse, namely that we are sampling $n$ observations from the discrete distribution <em>with replacement</em>. The probability of choosing an element $i$ at random is $1/n$. Thus to choose it <em>at least</em> once is</p>
<p>$$P(\textrm{choose~} i) = 1 - P(\textrm{omit~} i) = 1 - (1-1/n)^n \approx 1-e^{-1} \approx 0.63.$$</p>
<p>A similar reasoning shows that the probability of picking some sample (i.e., training example) <em>exactly once</em> is given by</p>
<p>$${n \choose 1} \frac{1}{n} \left(1-\frac{1}{n}\right)^{n-1} = \frac{n}{n-1} \left(1-\frac{1}{n}\right)^{n} \approx e^{-1} \approx 0.37.$$</p>
<p>Sampling with replacement leads to an increased variance and decreased data efficiency relative to sampling <em>without replacement</em>. Hence, in practice we perform the latter (and this is the default choice throughout this book). Last note that repeated passes through the training dataset traverse it in a <em>different</em> random order.</p>
<h2 id="summary-57"><a class="header" href="#summary-57">Summary</a></h2>
<ul>
<li>For convex problems we can prove that for a wide choice of learning rates stochastic gradient descent will converge to the optimal solution.</li>
<li>For deep learning this is generally not the case. However, the analysis of convex problems gives us useful insight into how to approach optimization, namely to reduce the learning rate progressively, albeit not too quickly.</li>
<li>Problems occur when the learning rate is too small or too large. In practice  a suitable learning rate is often found only after multiple experiments.</li>
<li>When there are more examples in the training dataset, it costs more to compute each iteration for gradient descent, so stochastic gradient descent is preferred in these cases.</li>
<li>Optimality guarantees for stochastic gradient descent are in general not available in nonconvex cases since the number of local minima that require checking might well be exponential.</li>
</ul>
<h2 id="exercises-77"><a class="header" href="#exercises-77">Exercises</a></h2>
<ol>
<li>Experiment with different learning rate schedules for stochastic gradient descent and with different numbers of iterations. In particular, plot the distance from the optimal solution $(0, 0)$ as a function of the number of iterations.</li>
<li>Prove that for the function $f(x_1, x_2) = x_1^2 + 2 x_2^2$ adding normal noise to the gradient is equivalent to minimizing a loss function $f(\mathbf{x}, \mathbf{w}) = (x_1 - w_1)^2 + 2 (x_2 - w_2)^2$ where $\mathbf{x}$ is drawn from a normal distribution.</li>
<li>Compare convergence of stochastic gradient descent when you sample from ${(x_1, y_1), \ldots, (x_n, y_n)}$ with replacement and when you sample without replacement.</li>
<li>How would you change the stochastic gradient descent solver if some gradient (or rather some coordinate associated with it) was consistently larger than all the other gradients?</li>
<li>Assume that $f(x) = x^2 (1 + \sin x)$. How many local minima does $f$ have? Can you change $f$ in such a way that to minimize it one needs to evaluate all the local minima?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/352">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/497">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1067">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minibatch-stochastic-gradient-descent-1"><a class="header" href="#minibatch-stochastic-gradient-descent-1">Minibatch Stochastic Gradient Descent</a></h1>
<p>:label:<code>sec_minibatch_sgd</code></p>
<p>So far we encountered two extremes in the approach to gradient-based learning: :numref:<code>sec_gd</code> uses the full dataset to compute gradients and to update parameters, one pass at a time. Conversely :numref:<code>sec_sgd</code> processes one training example at a time to make progress.
Either of them has its own drawbacks.
Gradient descent is not particularly <em>data efficient</em> whenever data is very similar.
Stochastic gradient descent is not particularly <em>computationally efficient</em> since CPUs and GPUs cannot exploit the full power of vectorization.
This suggests that there might be something in between,
and in fact, that is what we have been using so far in the examples we discussed.</p>
<h2 id="vectorization-and-caches"><a class="header" href="#vectorization-and-caches">Vectorization and Caches</a></h2>
<p>At the heart of the decision to use minibatches is computational efficiency. This is most easily understood when considering parallelization to multiple GPUs and multiple servers. In this case we need to send at least one image to each GPU. With 8 GPUs per server and 16 servers we already arrive at a minibatch size no smaller than 128.</p>
<p>Things are a bit more subtle when it comes to single GPUs or even CPUs. These devices have multiple types of memory, often multiple types of computational units and different bandwidth constraints between them.
For instance, a CPU has a small number of registers and then the L1, L2, and in some cases even L3 cache (which is shared among different processor cores).
These caches are of increasing size and latency (and at the same time they are of decreasing bandwidth).
Suffice to say, the processor is capable of performing many more operations than what the main memory interface is able to provide.</p>
<p>First, a 2GHz CPU with 16 cores and AVX-512 vectorization can process up to $2 \cdot 10^9 \cdot 16 \cdot 32 = 10^{12}$ bytes per second. The capability of GPUs easily exceeds this number by a factor of 100. On the other hand, a midrange server processor might not have much more than 100 GB/s bandwidth, i.e., less than one tenth of what would be required to keep the processor fed. To make matters worse, not all memory access is created equal: memory interfaces are typically 64 bit wide or wider (e.g., on GPUs up to 384 bit), hence reading a single byte incurs the cost of a much wider access.</p>
<p>Second, there is significant overhead for the first access whereas sequential access is relatively cheap (this is often called a burst read). There are many more things to keep in mind, such as caching when we have multiple sockets, chiplets, and other structures.
See this <a href="https://en.wikipedia.org/wiki/Cache_hierarchy">Wikipedia article</a>
for a more in-depth discussion.</p>
<p>The way to alleviate these constraints is to use a hierarchy of CPU caches that are actually fast enough to supply the processor with data. This is <em>the</em> driving force behind batching in deep learning. To keep matters simple, consider matrix-matrix multiplication, say $\mathbf{A} = \mathbf{B}\mathbf{C}$. We have a number of options for calculating $\mathbf{A}$. For instance, we could try the following:</p>
<ol>
<li>We could compute $\mathbf{A}<em>{ij} = \mathbf{B}</em>{i,:} \mathbf{C}_{:,j}$, i.e., we could compute it elementwise by means of dot products.</li>
<li>We could compute $\mathbf{A}<em>{:,j} = \mathbf{B} \mathbf{C}</em>{:,j}$, i.e., we could compute it one column at a time. Likewise we could compute $\mathbf{A}$ one row $\mathbf{A}_{i,:}$ at a time.</li>
<li>We could simply compute $\mathbf{A} = \mathbf{B} \mathbf{C}$.</li>
<li>We could break $\mathbf{B}$ and $\mathbf{C}$ into smaller block matrices and compute $\mathbf{A}$ one block at a time.</li>
</ol>
<p>If we follow the first option, we will need to copy one row and one column vector into the CPU each time we want to compute an element $\mathbf{A}<em>{ij}$. Even worse, due to the fact that matrix elements are aligned sequentially we are thus required to access many disjoint locations for one of the two vectors as we read them from memory. The second option is much more favorable. In it, we are able to keep the column vector $\mathbf{C}</em>{:,j}$ in the CPU cache while we keep on traversing through $\mathbf{B}$. This halves the memory bandwidth requirement with correspondingly faster access. Of course, option 3 is most desirable. Unfortunately, most matrices might not entirely fit into cache (this is what we are discussing after all). However, option 4 offers a practically useful alternative: we can move blocks of the matrix into cache and multiply them locally. Optimized libraries take care of this for us. Let's have a look at how efficient these operations are in practice.</p>
<p>Beyond computational efficiency, the overhead introduced by Python and by the deep learning framework itself is considerable. Recall that each time we execute a command the Python interpreter sends a command to the MXNet engine which needs to insert it into the computational graph and deal with it during scheduling. Such overhead can be quite detrimental. In short, it is highly advisable to use vectorization (and matrices) whenever possible.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
import time
npx.set_np()

A = np.zeros((256, 256))
B = np.random.normal(0, 1, (256, 256))
C = np.random.normal(0, 1, (256, 256))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import numpy as np
import time
import torch
from torch import nn

A = torch.zeros(256, 256)
B = torch.randn(256, 256)
C = torch.randn(256, 256)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import numpy as np
import tensorflow as tf
import time

A = tf.Variable(d2l.zeros((256, 256)))
B = tf.Variable(d2l.normal([256, 256], 0, 1))
C = tf.Variable(d2l.normal([256, 256], 0, 1))
</code></pre>
<p>Since we will benchmark the running time frequently in the rest of the book, let's define a timer.</p>
<pre><code class="language-{.python .input}">#@tab all
class Timer:  #@save
    """Record multiple running times."""
    def __init__(self):
        self.times = []
        self.start()

    def start(self):
        """Start the timer."""
        self.tik = time.time()

    def stop(self):
        """Stop the timer and record the time in a list."""
        self.times.append(time.time() - self.tik)
        return self.times[-1]

    def avg(self):
        """Return the average time."""
        return sum(self.times) / len(self.times)

    def sum(self):
        """Return the sum of time."""
        return sum(self.times)

    def cumsum(self):
        """Return the accumulated time."""
        return np.array(self.times).cumsum().tolist()

timer = Timer()
</code></pre>
<p>Element-wise assignment simply iterates over all rows and columns of $\mathbf{B}$ and $\mathbf{C}$ respectively to assign the value to $\mathbf{A}$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute A = BC one element at a time
timer.start()
for i in range(256):
    for j in range(256):
        A[i, j] = np.dot(B[i, :], C[:, j])
A.wait_to_read()
timer.stop()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute A = BC one element at a time
timer.start()
for i in range(256):
    for j in range(256):
        A[i, j] = torch.dot(B[i, :], C[:, j])
timer.stop()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute A = BC one element at a time
timer.start()
for i in range(256):
    for j in range(256):
        A[i, j].assign(tf.tensordot(B[i, :], C[:, j], axes=1))
timer.stop()
</code></pre>
<p>A faster strategy is to perform column-wise assignment.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute A = BC one column at a time
timer.start()
for j in range(256):
    A[:, j] = np.dot(B, C[:, j])
A.wait_to_read()
timer.stop()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute A = BC one column at a time
timer.start()
for j in range(256):
    A[:, j] = torch.mv(B, C[:, j])
timer.stop()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
timer.start()
for j in range(256):
    A[:, j].assign(tf.tensordot(B, C[:, j], axes=1))
timer.stop()
</code></pre>
<p>Last, the most effective manner is to perform the entire operation in one block.
Note that multiplying any two matrices $\mathbf{B} \in \mathbb{R}^{m \times n}$ and $\mathbf{C} \in \mathbb{R}^{n \times p}$ takes approximately $2mnp$ floating point operations,
when scalar multiplication and addition are counted as separate operations (fused in practice).
Thus, multiplying two $256 \times 256$ matrices
takes $0.03$ billion floating point operations.
Let's see what the respective speed of the operations is.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute A = BC in one go
timer.start()
A = np.dot(B, C)
A.wait_to_read()
timer.stop()

gigaflops = [0.03 / i for i in timer.times]
print(f'performance in Gigaflops: element {gigaflops[0]:.3f}, '
      f'column {gigaflops[1]:.3f}, full {gigaflops[2]:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute A = BC in one go
timer.start()
A = torch.mm(B, C)
timer.stop()

gigaflops = [0.03 / i for i in timer.times]
print(f'performance in Gigaflops: element {gigaflops[0]:.3f}, '
      f'column {gigaflops[1]:.3f}, full {gigaflops[2]:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
timer.start()
A.assign(tf.tensordot(B, C, axes=1))
timer.stop()

gigaflops = [0.03 / i for i in timer.times]
print(f'performance in Gigaflops: element {gigaflops[0]:.3f}, '
      f'column {gigaflops[1]:.3f}, full {gigaflops[2]:.3f}')
</code></pre>
<h2 id="minibatches"><a class="header" href="#minibatches">Minibatches</a></h2>
<p>:label:<code>sec_minibatches</code></p>
<p>In the past we took it for granted that we would read <em>minibatches</em> of data rather than single observations to update parameters. We now give a brief justification for it. Processing single observations requires us to perform many single matrix-vector (or even vector-vector) multiplications, which is quite expensive and which incurs a significant overhead on behalf of the underlying deep learning framework. This applies both to evaluating a network when applied to data (often referred to as inference) and when computing gradients to update parameters. That is, this applies whenever we perform $\mathbf{w} \leftarrow \mathbf{w} - \eta_t \mathbf{g}_t$ where</p>
<p>$$\mathbf{g}<em>t = \partial</em>{\mathbf{w}} f(\mathbf{x}_{t}, \mathbf{w})$$</p>
<p>We can increase the <em>computational</em> efficiency of this operation by applying it to a minibatch of observations at a time. That is, we replace the gradient $\mathbf{g}_t$ over a single observation by one over a small batch</p>
<p>$$\mathbf{g}<em>t = \partial</em>{\mathbf{w}} \frac{1}{|\mathcal{B}<em>t|} \sum</em>{i \in \mathcal{B}<em>t} f(\mathbf{x}</em>{i}, \mathbf{w})$$</p>
<p>Let's see what this does to the statistical properties of $\mathbf{g}_t$: since both $\mathbf{x}_t$ and also all elements of the minibatch $\mathcal{B}_t$ are drawn uniformly at random from the training set, the expectation of the gradient remains unchanged. The variance, on the other hand, is reduced significantly. Since the minibatch gradient is composed of $b \stackrel{\textrm{def}}{=} |\mathcal{B}_t|$ independent gradients which are being averaged, its standard deviation is reduced by a factor of $b^{-\frac{1}{2}}$. This, by itself, is a good thing, since it means that the updates are more reliably aligned with the full gradient.</p>
<p>Naively this would indicate that choosing a large minibatch $\mathcal{B}_t$ would be universally desirable. Alas, after some point, the additional reduction in standard deviation is minimal when compared to the linear increase in computational cost. In practice we pick a minibatch that is large enough to offer good computational efficiency while still fitting into the memory of a GPU. To illustrate the savings let's have a look at some code. In it we perform the same matrix-matrix multiplication, but this time broken up into "minibatches" of 64 columns at a time.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
timer.start()
for j in range(0, 256, 64):
    A[:, j:j+64] = np.dot(B, C[:, j:j+64])
timer.stop()
print(f'performance in Gigaflops: block {0.03 / timer.times[3]:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
timer.start()
for j in range(0, 256, 64):
    A[:, j:j+64] = torch.mm(B, C[:, j:j+64])
timer.stop()
print(f'performance in Gigaflops: block {0.03 / timer.times[3]:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
timer.start()
for j in range(0, 256, 64):
    A[:, j:j+64].assign(tf.tensordot(B, C[:, j:j+64], axes=1))
timer.stop()
print(f'performance in Gigaflops: block {0.03 / timer.times[3]:.3f}')
</code></pre>
<p>As we can see, the computation on the minibatch is essentially as efficient as on the full matrix. A word of caution is in order. In :numref:<code>sec_batch_norm</code> we used a type of regularization that was heavily dependent on the amount of variance in a minibatch. As we increase the latter, the variance decreases and with it the benefit of the noise-injection due to batch normalization. See e.g., :citet:<code>Ioffe.2017</code> for details on how to rescale and compute the appropriate terms.</p>
<h2 id="reading-the-dataset-4"><a class="header" href="#reading-the-dataset-4">Reading the Dataset</a></h2>
<p>Let's have a look at how minibatches are efficiently generated from data. In the following we use a dataset developed by NASA to test the wing <a href="https://archive.ics.uci.edu/dataset/291/airfoil+self+noise">noise from different aircraft</a> to compare these optimization algorithms. For convenience we only use the first $1,500$ examples. The data is whitened for preprocessing, i.e., we remove the mean and rescale the variance to $1$ per coordinate.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
d2l.DATA_HUB['airfoil'] = (d2l.DATA_URL + 'airfoil_self_noise.dat',
                           '76e5be1548fd8222e5074cf0faae75edff8cf93f')

#@save
def get_data_ch11(batch_size=10, n=1500):
    data = np.genfromtxt(d2l.download('airfoil'),
                         dtype=np.float32, delimiter='\t')
    data = (data - data.mean(axis=0)) / data.std(axis=0)
    data_iter = d2l.load_array(
        (data[:n, :-1], data[:n, -1]), batch_size, is_train=True)
    return data_iter, data.shape[1]-1
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
d2l.DATA_HUB['airfoil'] = (d2l.DATA_URL + 'airfoil_self_noise.dat',
                           '76e5be1548fd8222e5074cf0faae75edff8cf93f')

#@save
def get_data_ch11(batch_size=10, n=1500):
    data = np.genfromtxt(d2l.download('airfoil'),
                         dtype=np.float32, delimiter='\t')
    data = torch.from_numpy((data - data.mean(axis=0)) / data.std(axis=0))
    data_iter = d2l.load_array((data[:n, :-1], data[:n, -1]),
                               batch_size, is_train=True)
    return data_iter, data.shape[1]-1
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
d2l.DATA_HUB['airfoil'] = (d2l.DATA_URL + 'airfoil_self_noise.dat',
                           '76e5be1548fd8222e5074cf0faae75edff8cf93f')

#@save
def get_data_ch11(batch_size=10, n=1500):
    data = np.genfromtxt(d2l.download('airfoil'),
                         dtype=np.float32, delimiter='\t')
    data = (data - data.mean(axis=0)) / data.std(axis=0)
    data_iter = d2l.load_array((data[:n, :-1], data[:n, -1]),
                               batch_size, is_train=True)
    return data_iter, data.shape[1]-1
</code></pre>
<h2 id="implementation-from-scratch-8"><a class="header" href="#implementation-from-scratch-8">Implementation from Scratch</a></h2>
<p>Recall the minibatch stochastic gradient descent implementation from :numref:<code>sec_linear_scratch</code>. In the following we provide a slightly more general implementation. For convenience it has the same call signature as the other optimization algorithms introduced later in this chapter. Specifically, we add the status
input <code>states</code> and place the hyperparameter in dictionary <code>hyperparams</code>. In
addition, we will average the loss of each minibatch example in the training
function, so the gradient in the optimization algorithm does not need to be
divided by the batch size.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def sgd(params, states, hyperparams):
    for p in params:
        p[:] -= hyperparams['lr'] * p.grad
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def sgd(params, states, hyperparams):
    for p in params:
        p.data.sub_(hyperparams['lr'] * p.grad)
        p.grad.data.zero_()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def sgd(params, grads, states, hyperparams):
    for param, grad in zip(params, grads):
        param.assign_sub(hyperparams['lr']*grad)
</code></pre>
<p>Next, we implement a generic training function to facilitate the use of the other optimization algorithms introduced later in this chapter. It initializes a linear regression model and can be used to train the model with minibatch stochastic gradient descent and other algorithms introduced subsequently.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def train_ch11(trainer_fn, states, hyperparams, data_iter,
               feature_dim, num_epochs=2):
    # Initialization
    w = np.random.normal(scale=0.01, size=(feature_dim, 1))
    b = np.zeros(1)
    w.attach_grad()
    b.attach_grad()
    net, loss = lambda X: d2l.linreg(X, w, b), d2l.squared_loss
    # Train
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()
    for _ in range(num_epochs):
        for X, y in data_iter:
            with autograd.record():
                l = loss(net(X), y).mean()
            l.backward()
            trainer_fn([w, b], states, hyperparams)
            n += X.shape[0]
            if n % 200 == 0:
                timer.stop()
                animator.add(n/X.shape[0]/len(data_iter),
                             (d2l.evaluate_loss(net, data_iter, loss),))
                timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
    return timer.cumsum(), animator.Y[0]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def train_ch11(trainer_fn, states, hyperparams, data_iter,
               feature_dim, num_epochs=2):
    # Initialization
    w = torch.normal(mean=0.0, std=0.01, size=(feature_dim, 1),
                     requires_grad=True)
    b = torch.zeros((1), requires_grad=True)
    net, loss = lambda X: d2l.linreg(X, w, b), d2l.squared_loss
    # Train
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()
    for _ in range(num_epochs):
        for X, y in data_iter:
            l = loss(net(X), y).mean()
            l.backward()
            trainer_fn([w, b], states, hyperparams)
            n += X.shape[0]
            if n % 200 == 0:
                timer.stop()
                animator.add(n/X.shape[0]/len(data_iter),
                             (d2l.evaluate_loss(net, data_iter, loss),))
                timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
    return timer.cumsum(), animator.Y[0]
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
def train_ch11(trainer_fn, states, hyperparams, data_iter,
               feature_dim, num_epochs=2):
    # Initialization
    w = tf.Variable(tf.random.normal(shape=(feature_dim, 1),
                                   mean=0, stddev=0.01),trainable=True)
    b = tf.Variable(tf.zeros(1), trainable=True)

    # Train
    net, loss = lambda X: d2l.linreg(X, w, b), d2l.squared_loss
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()

    for _ in range(num_epochs):
        for X, y in data_iter:
          with tf.GradientTape() as g:
            l = tf.math.reduce_mean(loss(net(X), y))

          dw, db = g.gradient(l, [w, b])
          trainer_fn([w, b], [dw, db], states, hyperparams)
          n += X.shape[0]
          if n % 200 == 0:
              timer.stop()
              p = n/X.shape[0]
              q = p/tf.data.experimental.cardinality(data_iter).numpy()
              r = (d2l.evaluate_loss(net, data_iter, loss),)
              animator.add(q, r)
              timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
    return timer.cumsum(), animator.Y[0]
</code></pre>
<p>Let's see how optimization proceeds for batch gradient descent. This can be achieved by setting the minibatch size to 1500 (i.e., to the total number of examples). As a result the model parameters are updated only once per epoch. There is little progress. In fact, after 6 steps progress stalls.</p>
<pre><code class="language-{.python .input}">#@tab all
def train_sgd(lr, batch_size, num_epochs=2):
    data_iter, feature_dim = get_data_ch11(batch_size)
    return train_ch11(
        sgd, None, {'lr': lr}, data_iter, feature_dim, num_epochs)

gd_res = train_sgd(1, 1500, 10)
</code></pre>
<p>When the batch size equals 1, we use stochastic gradient descent for optimization. For simplicity of implementation we picked a constant (albeit small) learning rate. In stochastic gradient descent, the model parameters are updated whenever an example is processed. In our case this amounts to 1500 updates per epoch. As we can see, the decline in the value of the objective function slows down after one epoch. Although both the procedures processed 1500 examples within one epoch, stochastic gradient descent consumes more time than gradient descent in our experiment. This is because stochastic gradient descent updated the parameters more frequently and since it is less efficient to process single observations one at a time.</p>
<pre><code class="language-{.python .input}">#@tab all
sgd_res = train_sgd(0.005, 1)
</code></pre>
<p>Finally, when the batch size equals 100, we use minibatch stochastic gradient descent for optimization. The time required per epoch is shorter than the time needed for stochastic gradient descent and the time for batch gradient descent.</p>
<pre><code class="language-{.python .input}">#@tab all
mini1_res = train_sgd(.4, 100)
</code></pre>
<p>Reducing the batch size to 10, the time for each epoch increases because the workload for each batch is less efficient to execute.</p>
<pre><code class="language-{.python .input}">#@tab all
mini2_res = train_sgd(.05, 10)
</code></pre>
<p>Now we can compare the time vs. loss for the previous four experiments. As can be seen, although stochastic gradient descent converges faster than GD in terms of number of examples processed, it uses more time to reach the same loss than GD because computing the gradient example by example is not as efficient. Minibatch stochastic gradient descent is able to trade-off convergence speed and computation efficiency. A minibatch size of 10 is more efficient than stochastic gradient descent; a minibatch size of 100 even outperforms GD in terms of runtime.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.set_figsize([6, 3])
d2l.plot(*list(map(list, zip(gd_res, sgd_res, mini1_res, mini2_res))),
         'time (sec)', 'loss', xlim=[1e-2, 10],
         legend=['gd', 'sgd', 'batch size=100', 'batch size=10'])
d2l.plt.gca().set_xscale('log')
</code></pre>
<h2 id="concise-implementation-8"><a class="header" href="#concise-implementation-8">Concise Implementation</a></h2>
<p>In Gluon, we can use the <code>Trainer</code> class to call optimization algorithms. This is used to implement a generic training function. We will use this throughout the current chapter.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def train_concise_ch11(tr_name, hyperparams, data_iter, num_epochs=2):
    # Initialization
    net = nn.Sequential()
    net.add(nn.Dense(1))
    net.initialize(init.Normal(sigma=0.01))
    trainer = gluon.Trainer(net.collect_params(), tr_name, hyperparams)
    loss = gluon.loss.L2Loss()
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()
    for _ in range(num_epochs):
        for X, y in data_iter:
            with autograd.record():
                l = loss(net(X), y)
            l.backward()
            trainer.step(X.shape[0])
            n += X.shape[0]
            if n % 200 == 0:
                timer.stop()
                animator.add(n/X.shape[0]/len(data_iter),
                             (d2l.evaluate_loss(net, data_iter, loss),))
                timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def train_concise_ch11(trainer_fn, hyperparams, data_iter, num_epochs=4):
    # Initialization
    net = nn.Sequential(nn.Linear(5, 1))
    def init_weights(module):
        if type(module) == nn.Linear:
            torch.nn.init.normal_(module.weight, std=0.01)
    net.apply(init_weights)

    optimizer = trainer_fn(net.parameters(), **hyperparams)
    loss = nn.MSELoss(reduction='none')
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()
    for _ in range(num_epochs):
        for X, y in data_iter:
            optimizer.zero_grad()
            out = net(X)
            y = y.reshape(out.shape)
            l = loss(out, y)
            l.mean().backward()
            optimizer.step()
            n += X.shape[0]
            if n % 200 == 0:
                timer.stop()
                # `MSELoss` computes squared error without the 1/2 factor
                animator.add(n/X.shape[0]/len(data_iter),
                             (d2l.evaluate_loss(net, data_iter, loss) / 2,))
                timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
def train_concise_ch11(trainer_fn, hyperparams, data_iter, num_epochs=2):
    # Initialization
    net = tf.keras.Sequential()
    net.add(tf.keras.layers.Dense(1,
            kernel_initializer=tf.random_normal_initializer(stddev=0.01)))
    optimizer = trainer_fn(**hyperparams)
    loss = tf.keras.losses.MeanSquaredError()
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[0, num_epochs], ylim=[0.22, 0.35])
    n, timer = 0, d2l.Timer()
    for _ in range(num_epochs):
        for X, y in data_iter:
            with tf.GradientTape() as g:
                out = net(X)
                l = loss(y, out)
                params = net.trainable_variables
                grads = g.gradient(l, params)
            optimizer.apply_gradients(zip(grads, params))
            n += X.shape[0]
            if n % 200 == 0:
                timer.stop()
                p = n/X.shape[0]
                q = p/tf.data.experimental.cardinality(data_iter).numpy()
                # `MeanSquaredError` computes squared error without the 1/2
                # factor
                r = (d2l.evaluate_loss(net, data_iter, loss) / 2,)
                animator.add(q, r)
                timer.start()
    print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/epoch')
</code></pre>
<p>Using Gluon to repeat the last experiment shows identical behavior.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
data_iter, _ = get_data_ch11(10)
train_concise_ch11('sgd', {'learning_rate': 0.05}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
data_iter, _ = get_data_ch11(10)
trainer = torch.optim.SGD
train_concise_ch11(trainer, {'lr': 0.01}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
data_iter, _ = get_data_ch11(10)
trainer = tf.keras.optimizers.SGD
train_concise_ch11(trainer, {'learning_rate': 0.05}, data_iter)
</code></pre>
<h2 id="summary-58"><a class="header" href="#summary-58">Summary</a></h2>
<ul>
<li>Vectorization makes code more efficient due to reduced overhead arising from the deep learning framework and due to better memory locality and caching on CPUs and GPUs.</li>
<li>There is a trade-off between statistical efficiency arising from stochastic gradient descent and computational efficiency arising from processing large batches of data at a time.</li>
<li>Minibatch stochastic gradient descent offers the best of both worlds: computational and statistical efficiency.</li>
<li>In minibatch stochastic gradient descent we process batches of data obtained by a random permutation of the training data (i.e., each observation is processed only once per epoch, albeit in random order).</li>
<li>It is advisable to decay the learning rates during training.</li>
<li>In general, minibatch stochastic gradient descent is faster than stochastic gradient descent and gradient descent for convergence to a smaller risk, when measured in terms of clock time.</li>
</ul>
<h2 id="exercises-78"><a class="header" href="#exercises-78">Exercises</a></h2>
<ol>
<li>Modify the batch size and learning rate and observe the rate of decline for the value of the objective function and the time consumed in each epoch.</li>
<li>Read the MXNet documentation and use the <code>Trainer</code> class <code>set_learning_rate</code> function to reduce the learning rate of the minibatch stochastic gradient descent to 1/10 of its previous value after each epoch.</li>
<li>Compare minibatch stochastic gradient descent with a variant that actually <em>samples with replacement</em> from the training set. What happens?</li>
<li>An evil genie replicates your dataset without telling you (i.e., each observation occurs twice and your dataset grows to twice its original size, but nobody told you). How does the behavior of stochastic gradient descent, minibatch stochastic gradient descent and that of gradient descent change?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/353">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1068">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1069">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="momentum"><a class="header" href="#momentum">Momentum</a></h1>
<p>:label:<code>sec_momentum</code></p>
<p>In :numref:<code>sec_sgd</code> we reviewed what happens when performing stochastic gradient descent, i.e., when performing optimization where only a noisy variant of the gradient is available. In particular, we noticed that for noisy gradients we need to be extra cautious when it comes to choosing the learning rate in the face of noise. If we decrease it too rapidly, convergence stalls. If we are too lenient, we fail to converge to a good enough solution since noise keeps on driving us away from optimality.</p>
<h2 id="basics-1"><a class="header" href="#basics-1">Basics</a></h2>
<p>In this section, we will explore more effective optimization algorithms, especially for certain types of optimization problems that are common in practice.</p>
<h3 id="leaky-averages"><a class="header" href="#leaky-averages">Leaky Averages</a></h3>
<p>The previous section saw us discussing minibatch SGD as a means for accelerating computation. It also had the nice side-effect that averaging gradients reduced the amount of variance. The minibatch stochastic gradient descent can be calculated by:</p>
<p>$$\mathbf{g}<em>{t, t-1} = \partial</em>{\mathbf{w}} \frac{1}{|\mathcal{B}<em>t|} \sum</em>{i \in \mathcal{B}<em>t} f(\mathbf{x}</em>{i}, \mathbf{w}_{t-1}) = \frac{1}{|\mathcal{B}<em>t|} \sum</em>{i \in \mathcal{B}<em>t} \mathbf{h}</em>{i, t-1}.
$$</p>
<p>To keep the notation simple, here we used $\mathbf{h}<em>{i, t-1} = \partial</em>{\mathbf{w}} f(\mathbf{x}<em>i, \mathbf{w}</em>{t-1})$ as the stochastic gradient descent for sample $i$ using the weights updated at time $t-1$.
It would be nice if we could benefit from the effect of variance reduction even beyond averaging gradients on a minibatch. One option to accomplish this task is to replace the gradient computation by a "leaky average":</p>
<p>$$\mathbf{v}<em>t = \beta \mathbf{v}</em>{t-1} + \mathbf{g}_{t, t-1}$$</p>
<p>for some $\beta \in (0, 1)$. This effectively replaces the instantaneous gradient by one that is been averaged over multiple <em>past</em> gradients. $\mathbf{v}$ is called <em>velocity</em>. It accumulates past gradients similar to how a heavy ball rolling down the objective function landscape integrates over past forces. To see what is happening in more detail let's expand $\mathbf{v}_t$ recursively into</p>
<p>$$\begin{aligned}
\mathbf{v}<em>t = \beta^2 \mathbf{v}</em>{t-2} + \beta \mathbf{g}<em>{t-1, t-2} + \mathbf{g}</em>{t, t-1}
= \ldots, = \sum_{\tau = 0}^{t-1} \beta^{\tau} \mathbf{g}_{t-\tau, t-\tau-1}.
\end{aligned}$$</p>
<p>Large $\beta$ amounts to a long-range average, whereas small $\beta$ amounts to only a slight correction relative to a gradient method. The new gradient replacement no longer points into the direction of steepest descent on a particular instance any longer but rather in the direction of a weighted average of past gradients. This allows us to realize most of the benefits of averaging over a batch without the cost of actually computing the gradients on it. We will revisit this averaging procedure in more detail later.</p>
<p>The above reasoning formed the basis for what is now known as <em>accelerated</em> gradient methods, such as gradients with momentum. They enjoy the additional benefit of being much more effective in cases where the optimization problem is ill-conditioned (i.e., where there are some directions where progress is much slower than in others, resembling a narrow canyon). Furthermore, they allow us to average over subsequent gradients to obtain more stable directions of descent. Indeed, the aspect of acceleration even for noise-free convex problems is one of the key reasons why momentum works and why it works so well.</p>
<p>As one would expect, due to its efficacy momentum is a well-studied subject in optimization for deep learning and beyond. See e.g., the beautiful <a href="https://distill.pub/2017/momentum/">expository article</a> by :citet:<code>Goh.2017</code> for an in-depth analysis and interactive animation. It was proposed by :citet:<code>Polyak.1964</code>. :citet:<code>Nesterov.2018</code> has a detailed theoretical discussion in the context of convex optimization. Momentum in deep learning has been known to be beneficial for a long time. See e.g., the discussion by :citet:<code>Sutskever.Martens.Dahl.ea.2013</code> for details.</p>
<h3 id="an-ill-conditioned-problem"><a class="header" href="#an-ill-conditioned-problem">An Ill-conditioned Problem</a></h3>
<p>To get a better understanding of the geometric properties of the momentum method we revisit gradient descent, albeit with a significantly less pleasant objective function. Recall that in :numref:<code>sec_gd</code> we used $f(\mathbf{x}) = x_1^2 + 2 x_2^2$, i.e., a moderately distorted ellipsoid objective. We distort this function further by stretching it out in the $x_1$ direction via</p>
<p>$$f(\mathbf{x}) = 0.1 x_1^2 + 2 x_2^2.$$</p>
<p>As before $f$ has its minimum at $(0, 0)$. This function is <em>very</em> flat in the direction of $x_1$. Let's see what happens when we perform gradient descent as before on this new function. We pick a learning rate of $0.4$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()

eta = 0.4
def f_2d(x1, x2):
    return 0.1 * x1 ** 2 + 2 * x2 ** 2
def gd_2d(x1, x2, s1, s2):
    return (x1 - eta * 0.2 * x1, x2 - eta * 4 * x2, 0, 0)

d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

eta = 0.4
def f_2d(x1, x2):
    return 0.1 * x1 ** 2 + 2 * x2 ** 2
def gd_2d(x1, x2, s1, s2):
    return (x1 - eta * 0.2 * x1, x2 - eta * 4 * x2, 0, 0)

d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf

eta = 0.4
def f_2d(x1, x2):
    return 0.1 * x1 ** 2 + 2 * x2 ** 2
def gd_2d(x1, x2, s1, s2):
    return (x1 - eta * 0.2 * x1, x2 - eta * 4 * x2, 0, 0)

d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
</code></pre>
<p>By construction, the gradient in the $x_2$ direction is <em>much</em> higher and changes much more rapidly than in the horizontal $x_1$ direction. Thus we are stuck between two undesirable choices: if we pick a small learning rate we ensure that the solution does not diverge in the $x_2$ direction but we are saddled with slow convergence in the $x_1$ direction. Conversely, with a large learning rate we progress rapidly in the $x_1$ direction but diverge in $x_2$. The example below illustrates what happens even after a slight increase in learning rate from $0.4$ to $0.6$. Convergence in the $x_1$ direction improves but the overall solution quality is much worse.</p>
<pre><code class="language-{.python .input}">#@tab all
eta = 0.6
d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
</code></pre>
<h3 id="the-momentum-method"><a class="header" href="#the-momentum-method">The Momentum Method</a></h3>
<p>The momentum method allows us to solve the gradient descent problem described
above. Looking at the optimization trace above we might intuit that averaging gradients over the past would work well. After all, in the $x_1$ direction this will aggregate well-aligned gradients, thus increasing the distance we cover with every step. Conversely, in the $x_2$ direction where gradients oscillate, an aggregate gradient will reduce step size due to oscillations that cancel each other out.
Using $\mathbf{v}_t$ instead of the gradient $\mathbf{g}_t$ yields the following update equations:</p>
<p>$$
\begin{aligned}
\mathbf{v}<em>t &amp;\leftarrow \beta \mathbf{v}</em>{t-1} + \mathbf{g}_{t, t-1}, \
\mathbf{x}<em>t &amp;\leftarrow \mathbf{x}</em>{t-1} - \eta_t \mathbf{v}_t.
\end{aligned}
$$</p>
<p>Note that for $\beta = 0$ we recover regular gradient descent. Before delving deeper into the mathematical properties let's have a quick look at how the algorithm behaves in practice.</p>
<pre><code class="language-{.python .input}">#@tab all
def momentum_2d(x1, x2, v1, v2):
    v1 = beta * v1 + 0.2 * x1
    v2 = beta * v2 + 4 * x2
    return x1 - eta * v1, x2 - eta * v2, v1, v2

eta, beta = 0.6, 0.5
d2l.show_trace_2d(f_2d, d2l.train_2d(momentum_2d))
</code></pre>
<p>As we can see, even with the same learning rate that we used before, momentum still converges well. Let's see what happens when we decrease the momentum parameter. Halving it to $\beta = 0.25$ leads to a trajectory that barely converges at all. Nonetheless, it is a lot better than without momentum (when the solution diverges).</p>
<pre><code class="language-{.python .input}">#@tab all
eta, beta = 0.6, 0.25
d2l.show_trace_2d(f_2d, d2l.train_2d(momentum_2d))
</code></pre>
<p>Note that we can combine momentum with stochastic gradient descent and in particular, minibatch stochastic gradient descent. The only change is that in that case we replace the gradients $\mathbf{g}_{t, t-1}$ with $\mathbf{g}_t$. Last, for convenience we initialize $\mathbf{v}_0 = 0$ at time $t=0$. Let's look at what leaky averaging actually does to the updates.</p>
<h3 id="effective-sample-weight"><a class="header" href="#effective-sample-weight">Effective Sample Weight</a></h3>
<p>Recall that $\mathbf{v}<em>t = \sum</em>{\tau = 0}^{t-1} \beta^{\tau} \mathbf{g}<em>{t-\tau, t-\tau-1}$. In the limit the terms add up to $\sum</em>{\tau=0}^\infty \beta^\tau = \frac{1}{1-\beta}$. In other words, rather than taking a step of size $\eta$ in gradient descent or stochastic gradient descent we take a step of size $\frac{\eta}{1-\beta}$ while at the same time, dealing with a potentially much better behaved descent direction. These are two benefits in one. To illustrate how weighting behaves for different choices of $\beta$ consider the diagram below.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.set_figsize()
betas = [0.95, 0.9, 0.6, 0]
for beta in betas:
    x = d2l.numpy(d2l.arange(40))
    d2l.plt.plot(x, beta ** x, label=f'beta = {beta:.2f}')
d2l.plt.xlabel('time')
d2l.plt.legend();
</code></pre>
<h2 id="practical-experiments"><a class="header" href="#practical-experiments">Practical Experiments</a></h2>
<p>Let's see how momentum works in practice, i.e., when used within the context of a proper optimizer. For this we need a somewhat more scalable implementation.</p>
<h3 id="implementation-from-scratch-9"><a class="header" href="#implementation-from-scratch-9">Implementation from Scratch</a></h3>
<p>Compared with (minibatch) stochastic gradient descent the momentum method needs to maintain a set of  auxiliary variables, i.e., velocity. It has the same shape as the gradients (and variables of the optimization problem). In the implementation below we call these variables <code>states</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet,pytorch
def init_momentum_states(feature_dim):
    v_w = d2l.zeros((feature_dim, 1))
    v_b = d2l.zeros(1)
    return (v_w, v_b)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def init_momentum_states(features_dim):
    v_w = tf.Variable(d2l.zeros((features_dim, 1)))
    v_b = tf.Variable(d2l.zeros(1))
    return (v_w, v_b)
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
def sgd_momentum(params, states, hyperparams):
    for p, v in zip(params, states):
        v[:] = hyperparams['momentum'] * v + p.grad
        p[:] -= hyperparams['lr'] * v
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def sgd_momentum(params, states, hyperparams):
    for p, v in zip(params, states):
        with torch.no_grad():
            v[:] = hyperparams['momentum'] * v + p.grad
            p[:] -= hyperparams['lr'] * v
        p.grad.data.zero_()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def sgd_momentum(params, grads, states, hyperparams):
    for p, v, g in zip(params, states, grads):
            v[:].assign(hyperparams['momentum'] * v + g)
            p[:].assign(p - hyperparams['lr'] * v)
</code></pre>
<p>Let's see how this works in practice.</p>
<pre><code class="language-{.python .input}">#@tab all
def train_momentum(lr, momentum, num_epochs=2):
    d2l.train_ch11(sgd_momentum, init_momentum_states(feature_dim),
                   {'lr': lr, 'momentum': momentum}, data_iter,
                   feature_dim, num_epochs)

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
train_momentum(0.02, 0.5)
</code></pre>
<p>When we increase the momentum hyperparameter <code>momentum</code> to 0.9, it amounts to a significantly larger effective sample size of $\frac{1}{1 - 0.9} = 10$. We reduce the learning rate slightly to $0.01$ to keep matters under control.</p>
<pre><code class="language-{.python .input}">#@tab all
train_momentum(0.01, 0.9)
</code></pre>
<p>Reducing the learning rate further addresses any issue of non-smooth optimization problems. Setting it to $0.005$ yields good convergence properties.</p>
<pre><code class="language-{.python .input}">#@tab all
train_momentum(0.005, 0.9)
</code></pre>
<h3 id="concise-implementation-9"><a class="header" href="#concise-implementation-9">Concise Implementation</a></h3>
<p>There is very little to do in Gluon since the standard <code>sgd</code> solver already had momentum built in. Setting matching parameters yields a very similar trajectory.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.train_concise_ch11('sgd', {'learning_rate': 0.005, 'momentum': 0.9},
                       data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
trainer = torch.optim.SGD
d2l.train_concise_ch11(trainer, {'lr': 0.005, 'momentum': 0.9}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
trainer = tf.keras.optimizers.SGD
d2l.train_concise_ch11(trainer, {'learning_rate': 0.005, 'momentum': 0.9},
                       data_iter)
</code></pre>
<h2 id="theoretical-analysis"><a class="header" href="#theoretical-analysis">Theoretical Analysis</a></h2>
<p>So far the 2D example of $f(x) = 0.1 x_1^2 + 2 x_2^2$ seemed rather contrived. We will now see that this is actually quite representative of the types of problem one might encounter, at least in the case of minimizing convex quadratic objective functions.</p>
<h3 id="quadratic-convex-functions"><a class="header" href="#quadratic-convex-functions">Quadratic Convex Functions</a></h3>
<p>Consider the function</p>
<p>$$h(\mathbf{x}) = \frac{1}{2} \mathbf{x}^\top \mathbf{Q} \mathbf{x} + \mathbf{x}^\top \mathbf{c} + b.$$</p>
<p>This is a general quadratic function. For positive definite matrices $\mathbf{Q} \succ 0$, i.e., for matrices with positive eigenvalues this has a minimizer at $\mathbf{x}^* = -\mathbf{Q}^{-1} \mathbf{c}$ with minimum value $b - \frac{1}{2} \mathbf{c}^\top \mathbf{Q}^{-1} \mathbf{c}$. Hence we can rewrite $h$ as</p>
<p>$$h(\mathbf{x}) = \frac{1}{2} (\mathbf{x} - \mathbf{Q}^{-1} \mathbf{c})^\top \mathbf{Q} (\mathbf{x} - \mathbf{Q}^{-1} \mathbf{c}) + b - \frac{1}{2} \mathbf{c}^\top \mathbf{Q}^{-1} \mathbf{c}.$$</p>
<p>The gradient is given by $\partial_{\mathbf{x}} h(\mathbf{x}) = \mathbf{Q} (\mathbf{x} - \mathbf{Q}^{-1} \mathbf{c})$. That is, it is given by the distance between $\mathbf{x}$ and the minimizer, multiplied by $\mathbf{Q}$. Consequently also the velocity  is a linear combination of terms $\mathbf{Q} (\mathbf{x}_t - \mathbf{Q}^{-1} \mathbf{c})$.</p>
<p>Since $\mathbf{Q}$ is positive definite it can be decomposed into its eigensystem via $\mathbf{Q} = \mathbf{O}^\top \boldsymbol{\Lambda} \mathbf{O}$ for an orthogonal (rotation) matrix $\mathbf{O}$ and a diagonal matrix $\boldsymbol{\Lambda}$ of positive eigenvalues. This allows us to perform a change of variables from $\mathbf{x}$ to $\mathbf{z} \stackrel{\textrm{def}}{=} \mathbf{O} (\mathbf{x} - \mathbf{Q}^{-1} \mathbf{c})$ to obtain a much simplified expression:</p>
<p>$$h(\mathbf{z}) = \frac{1}{2} \mathbf{z}^\top \boldsymbol{\Lambda} \mathbf{z} + b'.$$</p>
<p>Here $b' = b - \frac{1}{2} \mathbf{c}^\top \mathbf{Q}^{-1} \mathbf{c}$. Since $\mathbf{O}$ is only an orthogonal matrix this does not perturb the gradients in a meaningful way. Expressed in terms of $\mathbf{z}$ gradient descent becomes</p>
<p>$$\mathbf{z}<em>t = \mathbf{z}</em>{t-1} - \boldsymbol{\Lambda} \mathbf{z}<em>{t-1} = (\mathbf{I} - \boldsymbol{\Lambda}) \mathbf{z}</em>{t-1}.$$</p>
<p>The important fact in this expression is that gradient descent <em>does not mix</em> between different eigenspaces. That is, when expressed in terms of the eigensystem of $\mathbf{Q}$ the optimization problem proceeds in a coordinate-wise manner. This also holds for</p>
<p>$$\begin{aligned}
\mathbf{v}<em>t &amp; = \beta \mathbf{v}</em>{t-1} + \boldsymbol{\Lambda} \mathbf{z}<em>{t-1} \
\mathbf{z}<em>t &amp; = \mathbf{z}</em>{t-1} - \eta \left(\beta \mathbf{v}</em>{t-1} + \boldsymbol{\Lambda} \mathbf{z}<em>{t-1}\right) \
&amp; = (\mathbf{I} - \eta \boldsymbol{\Lambda}) \mathbf{z}</em>{t-1} - \eta \beta \mathbf{v}_{t-1}.
\end{aligned}$$</p>
<p>In doing this we just proved the following theorem: gradient descent with and without momentum for a convex quadratic function decomposes into coordinate-wise optimization in the direction of the eigenvectors of the quadratic matrix.</p>
<h3 id="scalar-functions"><a class="header" href="#scalar-functions">Scalar Functions</a></h3>
<p>Given the above result let's see what happens when we minimize the function $f(x) = \frac{\lambda}{2} x^2$. For gradient descent we have</p>
<p>$$x_{t+1} = x_t - \eta \lambda x_t = (1 - \eta \lambda) x_t.$$</p>
<p>Whenever $|1 - \eta \lambda| &lt; 1$ this optimization converges at an exponential rate since after $t$ steps we have $x_t = (1 - \eta \lambda)^t x_0$. This shows how the rate of convergence improves initially as we increase the learning rate $\eta$ until $\eta \lambda = 1$. Beyond that things diverge and for $\eta \lambda &gt; 2$ the optimization problem diverges.</p>
<pre><code class="language-{.python .input}">#@tab all
lambdas = [0.1, 1, 10, 19]
eta = 0.1
d2l.set_figsize((6, 4))
for lam in lambdas:
    t = d2l.numpy(d2l.arange(20))
    d2l.plt.plot(t, (1 - eta * lam) ** t, label=f'lambda = {lam:.2f}')
d2l.plt.xlabel('time')
d2l.plt.legend();
</code></pre>
<p>To analyze convergence in the case of momentum we begin by rewriting the update equations in terms of two scalars: one for $x$ and one for velocity $v$. This yields:</p>
<p>$$
\begin{bmatrix} v_{t+1} \ x_{t+1} \end{bmatrix} =
\begin{bmatrix} \beta &amp; \lambda \ -\eta \beta &amp; (1 - \eta \lambda) \end{bmatrix}
\begin{bmatrix} v_{t} \ x_{t} \end{bmatrix} = \mathbf{R}(\beta, \eta, \lambda) \begin{bmatrix} v_{t} \ x_{t} \end{bmatrix}.
$$</p>
<p>We used $\mathbf{R}$ to denote the $2 \times 2$ governing convergence behavior. After $t$ steps the initial choice $[v_0, x_0]$ becomes $\mathbf{R}(\beta, \eta, \lambda)^t [v_0, x_0]$. Hence, it is up to the eigenvalues of $\mathbf{R}$ to determine the speed of convergence. See the <a href="https://distill.pub/2017/momentum/">Distill post</a> of :citet:<code>Goh.2017</code> for a great animation and :citet:<code>Flammarion.Bach.2015</code> for a detailed analysis. One can show that $0 &lt; \eta \lambda &lt; 2 + 2 \beta$ velocity converges. This is a larger range of feasible parameters when compared to $0 &lt; \eta \lambda &lt; 2$ for gradient descent. It also suggests that in general large values of $\beta$ are desirable. Further details require a fair amount of technical detail and we suggest that the interested reader consult the original publications.</p>
<h2 id="summary-59"><a class="header" href="#summary-59">Summary</a></h2>
<ul>
<li>Momentum replaces gradients with a leaky average over past gradients. This accelerates convergence significantly.</li>
<li>It is desirable for both noise-free gradient descent and (noisy) stochastic gradient descent.</li>
<li>Momentum prevents stalling of the optimization process that is much more likely to occur for stochastic gradient descent.</li>
<li>The effective number of gradients is given by $\frac{1}{1-\beta}$ due to exponentiated downweighting of past data.</li>
<li>In the case of convex quadratic problems this can be analyzed explicitly in detail.</li>
<li>Implementation is quite straightforward but it requires us to store an additional state vector (velocity $\mathbf{v}$).</li>
</ul>
<h2 id="exercises-79"><a class="header" href="#exercises-79">Exercises</a></h2>
<ol>
<li>Use other combinations of momentum hyperparameters and learning rates and observe and analyze the different experimental results.</li>
<li>Try out gradient descent and momentum for a quadratic problem where you have multiple eigenvalues, i.e., $f(x) = \frac{1}{2} \sum_i \lambda_i x_i^2$, e.g., $\lambda_i = 2^{-i}$. Plot how the values of $x$ decrease for the initialization $x_i = 1$.</li>
<li>Derive minimum value and minimizer for $h(\mathbf{x}) = \frac{1}{2} \mathbf{x}^\top \mathbf{Q} \mathbf{x} + \mathbf{x}^\top \mathbf{c} + b$.</li>
<li>What changes when we perform stochastic gradient descent with momentum? What happens when we use minibatch stochastic gradient descent with momentum? Experiment with the parameters?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/354">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1070">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1071">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adagrad"><a class="header" href="#adagrad">Adagrad</a></h1>
<p>:label:<code>sec_adagrad</code></p>
<p>Let's begin by considering learning problems with features that occur infrequently.</p>
<h2 id="sparse-features-and-learning-rates"><a class="header" href="#sparse-features-and-learning-rates">Sparse Features and Learning Rates</a></h2>
<p>Imagine that we are training a language model. To get good accuracy we typically want to decrease the learning rate as we keep on training, usually at a rate of $\mathcal{O}(t^{-\frac{1}{2}})$ or slower. Now consider a model training on sparse features, i.e., features that occur only infrequently. This is common for natural language, e.g., it is a lot less likely that we will see the word <em>preconditioning</em> than <em>learning</em>. However, it is also common in other areas such as computational advertising and personalized collaborative filtering. After all, there are many things that are of interest only for a small number of people.</p>
<p>Parameters associated with infrequent features only receive meaningful updates whenever these features occur. Given a decreasing learning rate we might end up in a situation where the parameters for common features converge rather quickly to their optimal values, whereas for infrequent features we are still short of observing them sufficiently frequently before their optimal values can be determined. In other words, the learning rate either decreases too slowly for frequent features or too quickly for infrequent ones.</p>
<p>A possible hack to redress this issue would be to count the number of times we see a particular feature and to use this as a clock for adjusting learning rates. That is, rather than choosing a learning rate of the form $\eta = \frac{\eta_0}{\sqrt{t + c}}$ we could use $\eta_i = \frac{\eta_0}{\sqrt{s(i, t) + c}}$. Here $s(i, t)$ counts the number of nonzeros for feature $i$ that we have observed up to time $t$. This is actually quite easy to implement at no meaningful overhead. However, it fails whenever we do not quite have sparsity but rather just data where the gradients are often very small and only rarely large. After all, it is unclear where one would draw the line between something that qualifies as an observed feature or not.</p>
<p>Adagrad by :citet:<code>Duchi.Hazan.Singer.2011</code> addresses this by replacing the rather crude counter $s(i, t)$ by an aggregate of the squares of previously observed gradients. In particular, it uses $s(i, t+1) = s(i, t) + \left(\partial_i f(\mathbf{x})\right)^2$ as a means to adjust the learning rate. This has two benefits: first, we no longer need to decide just when a gradient is large enough. Second, it scales automatically with the magnitude of the gradients. Coordinates that routinely correspond to large gradients are scaled down significantly, whereas others with small gradients receive a much more gentle treatment. In practice this leads to a very effective optimization procedure for computational advertising and related problems. But this hides some of the additional benefits inherent in Adagrad that are best understood in the context of preconditioning.</p>
<h2 id="preconditioning-1"><a class="header" href="#preconditioning-1">Preconditioning</a></h2>
<p>Convex optimization problems are good for analyzing the characteristics of algorithms. After all, for most nonconvex problems it is difficult to derive meaningful theoretical guarantees, but <em>intuition</em> and <em>insight</em> often carry over.  Let's look at the problem of minimizing $f(\mathbf{x}) = \frac{1}{2} \mathbf{x}^\top \mathbf{Q} \mathbf{x} + \mathbf{c}^\top \mathbf{x} + b$.</p>
<p>As we saw in :numref:<code>sec_momentum</code>, it is possible to rewrite this problem in terms of its eigendecomposition $\mathbf{Q} = \mathbf{U}^\top \boldsymbol{\Lambda} \mathbf{U}$ to arrive at a much simplified problem where each coordinate can be solved individually:</p>
<p>$$f(\mathbf{x}) = \bar{f}(\bar{\mathbf{x}}) = \frac{1}{2} \bar{\mathbf{x}}^\top \boldsymbol{\Lambda} \bar{\mathbf{x}} + \bar{\mathbf{c}}^\top \bar{\mathbf{x}} + b.$$</p>
<p>Here we used $\bar{\mathbf{x}} = \mathbf{U} \mathbf{x}$ and consequently $\bar{\mathbf{c}} = \mathbf{U} \mathbf{c}$. The modified problem has as its minimizer $\bar{\mathbf{x}} = -\boldsymbol{\Lambda}^{-1} \bar{\mathbf{c}}$ and minimum value $-\frac{1}{2} \bar{\mathbf{c}}^\top \boldsymbol{\Lambda}^{-1} \bar{\mathbf{c}} + b$. This is much easier to compute since $\boldsymbol{\Lambda}$ is a diagonal matrix containing the eigenvalues of $\mathbf{Q}$.</p>
<p>If we perturb $\mathbf{c}$ slightly we would hope to find only slight changes in the minimizer of $f$. Unfortunately this is not the case. While slight changes in $\mathbf{c}$ lead to equally slight changes in $\bar{\mathbf{c}}$, this is not the case for the minimizer of $f$ (and of $\bar{f}$ respectively). Whenever the eigenvalues $\boldsymbol{\Lambda}_i$ are large we will see only small changes in $\bar{x}_i$ and in the minimum of $\bar{f}$. Conversely, for small $\boldsymbol{\Lambda}_i$ changes in $\bar{x}_i$ can be dramatic. The ratio between the largest and the smallest eigenvalue is called the condition number of an optimization problem.</p>
<p>$$\kappa = \frac{\boldsymbol{\Lambda}_1}{\boldsymbol{\Lambda}_d}.$$</p>
<p>If the condition number $\kappa$ is large, it is difficult to solve the optimization problem accurately. We need to ensure that we are careful in getting a large dynamic range of values right. Our analysis leads to an obvious, albeit somewhat naive question: couldn't we simply "fix" the problem by distorting the space such that all eigenvalues are $1$. In theory this is quite easy: we only need the eigenvalues and eigenvectors of $\mathbf{Q}$ to rescale the problem from $\mathbf{x}$ to one in $\mathbf{z} \stackrel{\textrm{def}}{=} \boldsymbol{\Lambda}^{\frac{1}{2}} \mathbf{U} \mathbf{x}$. In the new coordinate system $\mathbf{x}^\top \mathbf{Q} \mathbf{x}$ could be simplified to $|\mathbf{z}|^2$. Alas, this is a rather impractical suggestion. Computing eigenvalues and eigenvectors is in general <em>much more</em> expensive than solving the actual  problem.</p>
<p>While computing eigenvalues exactly might be expensive, guessing them and computing them even somewhat approximately may already be a lot better than not doing anything at all. In particular, we could use the diagonal entries of $\mathbf{Q}$ and rescale it accordingly. This is <em>much</em> cheaper than computing eigenvalues.</p>
<p>$$\tilde{\mathbf{Q}} = \textrm{diag}^{-\frac{1}{2}}(\mathbf{Q}) \mathbf{Q} \textrm{diag}^{-\frac{1}{2}}(\mathbf{Q}).$$</p>
<p>In this case we have $\tilde{\mathbf{Q}}<em>{ij} = \mathbf{Q}</em>{ij} / \sqrt{\mathbf{Q}<em>{ii} \mathbf{Q}</em>{jj}}$ and specifically $\tilde{\mathbf{Q}}_{ii} = 1$ for all $i$. In most cases this simplifies the condition number considerably. For instance, the cases we discussed previously, this would entirely eliminate the problem at hand since the problem is axis aligned.</p>
<p>Unfortunately we face yet another problem: in deep learning we typically do not even have access to the second derivative of the objective function: for $\mathbf{x} \in \mathbb{R}^d$ the second derivative even on a minibatch may require $\mathcal{O}(d^2)$ space and work to compute, thus making it practically infeasible. The ingenious idea of Adagrad is to use a proxy for that elusive diagonal of the Hessian that is both relatively cheap to compute and effective---the magnitude of the gradient itself.</p>
<p>In order to see why this works, let's look at $\bar{f}(\bar{\mathbf{x}})$. We have that</p>
<p>$$\partial_{\bar{\mathbf{x}}} \bar{f}(\bar{\mathbf{x}}) = \boldsymbol{\Lambda} \bar{\mathbf{x}} + \bar{\mathbf{c}} = \boldsymbol{\Lambda} \left(\bar{\mathbf{x}} - \bar{\mathbf{x}}_0\right),$$</p>
<p>where $\bar{\mathbf{x}}_0$ is the minimizer of $\bar{f}$. Hence the magnitude of the gradient depends both on $\boldsymbol{\Lambda}$ and the distance from optimality. If $\bar{\mathbf{x}} - \bar{\mathbf{x}}<em>0$ did not change, this would be all that is needed. After all, in this case the magnitude of the gradient $\partial</em>{\bar{\mathbf{x}}} \bar{f}(\bar{\mathbf{x}})$ suffices. Since AdaGrad is a stochastic gradient descent algorithm, we will see gradients with nonzero variance even at optimality. As a result we can safely use the variance of the gradients as a cheap proxy for the scale of the Hessian. A thorough analysis is beyond the scope of this section (it would be several pages). We refer the reader to :cite:<code>Duchi.Hazan.Singer.2011</code> for details.</p>
<h2 id="the-algorithm"><a class="header" href="#the-algorithm">The Algorithm</a></h2>
<p>Let's formalize the discussion from above. We use the variable $\mathbf{s}_t$ to accumulate past gradient variance as follows.</p>
<p>$$\begin{aligned}
\mathbf{g}<em>t &amp; = \partial</em>{\mathbf{w}} l(y_t, f(\mathbf{x}_t, \mathbf{w})), \
\mathbf{s}<em>t &amp; = \mathbf{s}</em>{t-1} + \mathbf{g}_t^2, \
\mathbf{w}<em>t &amp; = \mathbf{w}</em>{t-1} - \frac{\eta}{\sqrt{\mathbf{s}_t + \epsilon}} \cdot \mathbf{g}_t.
\end{aligned}$$</p>
<p>Here the operation are applied coordinate wise. That is, $\mathbf{v}^2$ has entries $v_i^2$. Likewise $\frac{1}{\sqrt{v}}$ has entries $\frac{1}{\sqrt{v_i}}$ and $\mathbf{u} \cdot \mathbf{v}$ has entries $u_i v_i$. As before $\eta$ is the learning rate and $\epsilon$ is an additive constant that ensures that we do not divide by $0$. Last, we initialize $\mathbf{s}_0 = \mathbf{0}$.</p>
<p>Just like in the case of momentum we need to keep track of an auxiliary variable, in this case to allow for an individual learning rate per coordinate. This does not increase the cost of Adagrad significantly relative to SGD, simply since the main cost is typically to compute $l(y_t, f(\mathbf{x}_t, \mathbf{w}))$ and its derivative.</p>
<p>Note that accumulating squared gradients in $\mathbf{s}_t$ means that $\mathbf{s}_t$ grows essentially at linear rate (somewhat slower than linearly in practice, since the gradients initially diminish). This leads to an $\mathcal{O}(t^{-\frac{1}{2}})$ learning rate, albeit adjusted on a per coordinate basis. For convex problems this is perfectly adequate. In deep learning, though, we might want to decrease the learning rate rather more slowly. This led to a number of Adagrad variants that we will discuss in the subsequent chapters. For now let's see how it behaves in a quadratic convex problem. We use the same problem as before:</p>
<p>$$f(\mathbf{x}) = 0.1 x_1^2 + 2 x_2^2.$$</p>
<p>We are going to implement Adagrad using the same learning rate previously, i.e., $\eta = 0.4$. As we can see, the iterative trajectory of the independent variable is smoother. However, due to the cumulative effect of $\boldsymbol{s}_t$, the learning rate continuously decays, so the independent variable does not move as much during later stages of iteration.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import math
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
def adagrad_2d(x1, x2, s1, s2):
    eps = 1e-6
    g1, g2 = 0.2 * x1, 4 * x2
    s1 += g1 ** 2
    s2 += g2 ** 2
    x1 -= eta / math.sqrt(s1 + eps) * g1
    x2 -= eta / math.sqrt(s2 + eps) * g2
    return x1, x2, s1, s2

def f_2d(x1, x2):
    return 0.1 * x1 ** 2 + 2 * x2 ** 2

eta = 0.4
d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))
</code></pre>
<p>As we increase the learning rate to $2$ we see much better behavior. This already indicates that the decrease in learning rate might be rather aggressive, even in the noise-free case and we need to ensure that parameters converge appropriately.</p>
<pre><code class="language-{.python .input}">#@tab all
eta = 2
d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))
</code></pre>
<h2 id="implementation-from-scratch-10"><a class="header" href="#implementation-from-scratch-10">Implementation from Scratch</a></h2>
<p>Just like the momentum method, Adagrad needs to maintain a state variable of the same shape as the parameters.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def init_adagrad_states(feature_dim):
    s_w = d2l.zeros((feature_dim, 1))
    s_b = d2l.zeros(1)
    return (s_w, s_b)

def adagrad(params, states, hyperparams):
    eps = 1e-6
    for p, s in zip(params, states):
        s[:] += np.square(p.grad)
        p[:] -= hyperparams['lr'] * p.grad / np.sqrt(s + eps)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def init_adagrad_states(feature_dim):
    s_w = d2l.zeros((feature_dim, 1))
    s_b = d2l.zeros(1)
    return (s_w, s_b)

def adagrad(params, states, hyperparams):
    eps = 1e-6
    for p, s in zip(params, states):
        with torch.no_grad():
            s[:] += torch.square(p.grad)
            p[:] -= hyperparams['lr'] * p.grad / torch.sqrt(s + eps)
        p.grad.data.zero_()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def init_adagrad_states(feature_dim):
    s_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    s_b = tf.Variable(d2l.zeros(1))
    return (s_w, s_b)

def adagrad(params, grads, states, hyperparams):
    eps = 1e-6
    for p, s, g in zip(params, states, grads):
        s[:].assign(s + tf.math.square(g))
        p[:].assign(p - hyperparams['lr'] * g / tf.math.sqrt(s + eps))
</code></pre>
<p>Compared to the experiment in :numref:<code>sec_minibatch_sgd</code> we use a
larger learning rate to train the model.</p>
<pre><code class="language-{.python .input}">#@tab all
data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(adagrad, init_adagrad_states(feature_dim),
               {'lr': 0.1}, data_iter, feature_dim);
</code></pre>
<h2 id="concise-implementation-10"><a class="header" href="#concise-implementation-10">Concise Implementation</a></h2>
<p>Using the <code>Trainer</code> instance of the algorithm <code>adagrad</code>, we can invoke the Adagrad algorithm in Gluon.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.train_concise_ch11('adagrad', {'learning_rate': 0.1}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
trainer = torch.optim.Adagrad
d2l.train_concise_ch11(trainer, {'lr': 0.1}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
trainer = tf.keras.optimizers.Adagrad
d2l.train_concise_ch11(trainer, {'learning_rate' : 0.1}, data_iter)
</code></pre>
<h2 id="summary-60"><a class="header" href="#summary-60">Summary</a></h2>
<ul>
<li>Adagrad decreases the learning rate dynamically on a per-coordinate basis.</li>
<li>It uses the magnitude of the gradient as a means of adjusting how quickly progress is achieved - coordinates with large gradients are compensated with a smaller learning rate.</li>
<li>Computing the exact second derivative is typically infeasible in deep learning problems due to memory and computational constraints. The gradient can be a useful proxy.</li>
<li>If the optimization problem has a rather uneven structure Adagrad can help mitigate the distortion.</li>
<li>Adagrad is particularly effective for sparse features where the learning rate needs to decrease more slowly for infrequently occurring terms.</li>
<li>On deep learning problems Adagrad can sometimes be too aggressive in reducing learning rates. We will discuss strategies for mitigating this in the context of :numref:<code>sec_adam</code>.</li>
</ul>
<h2 id="exercises-80"><a class="header" href="#exercises-80">Exercises</a></h2>
<ol>
<li>Prove that for an orthogonal matrix $\mathbf{U}$ and a vector $\mathbf{c}$ the following holds: $|\mathbf{c} - \mathbf{\delta}|_2 = |\mathbf{U} \mathbf{c} - \mathbf{U} \mathbf{\delta}|_2$. Why does this mean that the magnitude of perturbations does not change after an orthogonal change of variables?</li>
<li>Try out Adagrad for $f(\mathbf{x}) = 0.1 x_1^2 + 2 x_2^2$ and also for the objective function was rotated by 45 degrees, i.e., $f(\mathbf{x}) = 0.1 (x_1 + x_2)^2 + 2 (x_1 - x_2)^2$. Does it behave differently?</li>
<li>Prove <a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gerschgorin's circle theorem</a> which states that eigenvalues $\lambda_i$ of a matrix $\mathbf{M}$ satisfy $|\lambda_i - \mathbf{M}<em>{jj}| \leq \sum</em>{k \neq j} |\mathbf{M}_{jk}|$ for at least one choice of $j$.</li>
<li>What does Gerschgorin's theorem tell us about the eigenvalues of the diagonally preconditioned matrix $\textrm{diag}^{-\frac{1}{2}}(\mathbf{M}) \mathbf{M} \textrm{diag}^{-\frac{1}{2}}(\mathbf{M})$?</li>
<li>Try out Adagrad for a proper deep network, such as :numref:<code>sec_lenet</code> when applied to Fashion-MNIST.</li>
<li>How would you need to modify Adagrad to achieve a less aggressive decay in learning rate?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/355">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1072">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1073">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rmsprop"><a class="header" href="#rmsprop">RMSProp</a></h1>
<p>:label:<code>sec_rmsprop</code></p>
<p>One of the key issues in :numref:<code>sec_adagrad</code> is that the learning rate decreases at a predefined schedule of effectively $\mathcal{O}(t^{-\frac{1}{2}})$. While this is generally appropriate for convex problems, it might not be ideal for nonconvex ones, such as those encountered in deep learning. Yet, the coordinate-wise adaptivity of Adagrad is highly desirable as a preconditioner.</p>
<p>:citet:<code>Tieleman.Hinton.2012</code> proposed the RMSProp algorithm as a simple fix to decouple rate scheduling from coordinate-adaptive learning rates. The issue is that Adagrad accumulates the squares of the gradient $\mathbf{g}_t$ into a state vector $\mathbf{s}<em>t = \mathbf{s}</em>{t-1} + \mathbf{g}_t^2$. As a result $\mathbf{s}_t$ keeps on growing without bound due to the lack of normalization, essentially linearly as the algorithm converges.</p>
<p>One way of fixing this problem would be to use $\mathbf{s}_t / t$. For reasonable distributions of $\mathbf{g}_t$ this will converge. Unfortunately it might take a very long time until the limit behavior starts to matter since the procedure remembers the full trajectory of values. An alternative is to use a leaky average in the same way we used in the momentum method, i.e., $\mathbf{s}<em>t \leftarrow \gamma \mathbf{s}</em>{t-1} + (1-\gamma) \mathbf{g}_t^2$ for some parameter $\gamma &gt; 0$. Keeping all other parts unchanged yields RMSProp.</p>
<h2 id="the-algorithm-1"><a class="header" href="#the-algorithm-1">The Algorithm</a></h2>
<p>Let's write out the equations in detail.</p>
<p>$$\begin{aligned}
\mathbf{s}<em>t &amp; \leftarrow \gamma \mathbf{s}</em>{t-1} + (1 - \gamma) \mathbf{g}_t^2, \
\mathbf{x}<em>t &amp; \leftarrow \mathbf{x}</em>{t-1} - \frac{\eta}{\sqrt{\mathbf{s}_t + \epsilon}} \odot \mathbf{g}_t.
\end{aligned}$$</p>
<p>The constant $\epsilon &gt; 0$ is typically set to $10^{-6}$ to ensure that we do not suffer from division by zero or overly large step sizes. Given this expansion we are now free to control the learning rate $\eta$ independently of the scaling that is applied on a per-coordinate basis. In terms of leaky averages we can apply the same reasoning as previously applied in the case of the momentum method. Expanding the definition of $\mathbf{s}_t$ yields</p>
<p>$$
\begin{aligned}
\mathbf{s}<em>t &amp; = (1 - \gamma) \mathbf{g}<em>t^2 + \gamma \mathbf{s}</em>{t-1} \
&amp; = (1 - \gamma) \left(\mathbf{g}<em>t^2 + \gamma \mathbf{g}</em>{t-1}^2 + \gamma^2 \mathbf{g}</em>{t-2} + \ldots, \right).
\end{aligned}
$$</p>
<p>As before in :numref:<code>sec_momentum</code> we use $1 + \gamma + \gamma^2 + \ldots, = \frac{1}{1-\gamma}$. Hence the sum of weights is normalized to $1$ with a half-life time of an observation of $\gamma^{-1}$. Let's visualize the weights for the past 40 time steps for various choices of $\gamma$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import np, npx

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
import math
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
import math
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
d2l.set_figsize()
gammas = [0.95, 0.9, 0.8, 0.7]
for gamma in gammas:
    x = d2l.numpy(d2l.arange(40))
    d2l.plt.plot(x, (1-gamma) * gamma ** x, label=f'gamma = {gamma:.2f}')
d2l.plt.xlabel('time');
</code></pre>
<h2 id="implementation-from-scratch-11"><a class="header" href="#implementation-from-scratch-11">Implementation from Scratch</a></h2>
<p>As before we use the quadratic function $f(\mathbf{x})=0.1x_1^2+2x_2^2$ to observe the trajectory of RMSProp. Recall that in :numref:<code>sec_adagrad</code>, when we used Adagrad with a learning rate of 0.4, the variables moved only very slowly in the later stages of the algorithm since the learning rate decreased too quickly. Since $\eta$ is controlled separately this does not happen with RMSProp.</p>
<pre><code class="language-{.python .input}">#@tab all
def rmsprop_2d(x1, x2, s1, s2):
    g1, g2, eps = 0.2 * x1, 4 * x2, 1e-6
    s1 = gamma * s1 + (1 - gamma) * g1 ** 2
    s2 = gamma * s2 + (1 - gamma) * g2 ** 2
    x1 -= eta / math.sqrt(s1 + eps) * g1
    x2 -= eta / math.sqrt(s2 + eps) * g2
    return x1, x2, s1, s2

def f_2d(x1, x2):
    return 0.1 * x1 ** 2 + 2 * x2 ** 2

eta, gamma = 0.4, 0.9
d2l.show_trace_2d(f_2d, d2l.train_2d(rmsprop_2d))
</code></pre>
<p>Next, we implement RMSProp to be used in a deep network. This is equally straightforward.</p>
<pre><code class="language-{.python .input}">#@tab mxnet,pytorch
def init_rmsprop_states(feature_dim):
    s_w = d2l.zeros((feature_dim, 1))
    s_b = d2l.zeros(1)
    return (s_w, s_b)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def init_rmsprop_states(feature_dim):
    s_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    s_b = tf.Variable(d2l.zeros(1))
    return (s_w, s_b)
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
def rmsprop(params, states, hyperparams):
    gamma, eps = hyperparams['gamma'], 1e-6
    for p, s in zip(params, states):
        s[:] = gamma * s + (1 - gamma) * np.square(p.grad)
        p[:] -= hyperparams['lr'] * p.grad / np.sqrt(s + eps)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def rmsprop(params, states, hyperparams):
    gamma, eps = hyperparams['gamma'], 1e-6
    for p, s in zip(params, states):
        with torch.no_grad():
            s[:] = gamma * s + (1 - gamma) * torch.square(p.grad)
            p[:] -= hyperparams['lr'] * p.grad / torch.sqrt(s + eps)
        p.grad.data.zero_()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def rmsprop(params, grads, states, hyperparams):
    gamma, eps = hyperparams['gamma'], 1e-6
    for p, s, g in zip(params, states, grads):
        s[:].assign(gamma * s + (1 - gamma) * tf.math.square(g))
        p[:].assign(p - hyperparams['lr'] * g / tf.math.sqrt(s + eps))
</code></pre>
<p>We set the initial learning rate to 0.01 and the weighting term $\gamma$ to 0.9. That is, $\mathbf{s}$ aggregates on average over the past $1/(1-\gamma) = 10$ observations of the square gradient.</p>
<pre><code class="language-{.python .input}">#@tab all
data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(rmsprop, init_rmsprop_states(feature_dim),
               {'lr': 0.01, 'gamma': 0.9}, data_iter, feature_dim);
</code></pre>
<h2 id="concise-implementation-11"><a class="header" href="#concise-implementation-11">Concise Implementation</a></h2>
<p>Since RMSProp is a rather popular algorithm it is also available in the <code>Trainer</code> instance. All we need to do is instantiate it using an algorithm named <code>rmsprop</code>, assigning $\gamma$ to the parameter <code>gamma1</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.train_concise_ch11('rmsprop', {'learning_rate': 0.01, 'gamma1': 0.9},
                       data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
trainer = torch.optim.RMSprop
d2l.train_concise_ch11(trainer, {'lr': 0.01, 'alpha': 0.9},
                       data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
trainer = tf.keras.optimizers.RMSprop
d2l.train_concise_ch11(trainer, {'learning_rate': 0.01, 'rho': 0.9},
                       data_iter)
</code></pre>
<h2 id="summary-61"><a class="header" href="#summary-61">Summary</a></h2>
<ul>
<li>RMSProp is very similar to Adagrad insofar as both use the square of the gradient to scale coefficients.</li>
<li>RMSProp shares with momentum the leaky averaging. However, RMSProp uses the technique to adjust the coefficient-wise preconditioner.</li>
<li>The learning rate needs to be scheduled by the experimenter in practice.</li>
<li>The coefficient $\gamma$ determines how long the history is when adjusting the per-coordinate scale.</li>
</ul>
<h2 id="exercises-81"><a class="header" href="#exercises-81">Exercises</a></h2>
<ol>
<li>What happens experimentally if we set $\gamma = 1$? Why?</li>
<li>Rotate the optimization problem to minimize $f(\mathbf{x}) = 0.1 (x_1 + x_2)^2 + 2 (x_1 - x_2)^2$. What happens to the convergence?</li>
<li>Try out what happens to RMSProp on a real machine learning problem, such as training on Fashion-MNIST. Experiment with different choices for adjusting the learning rate.</li>
<li>Would you want to adjust $\gamma$ as optimization progresses? How sensitive is RMSProp to this?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/356">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1074">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1075">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adadelta"><a class="header" href="#adadelta">Adadelta</a></h1>
<p>:label:<code>sec_adadelta</code></p>
<p>Adadelta is yet another variant of AdaGrad (:numref:<code>sec_adagrad</code>). The main difference lies in the fact that it decreases the amount by which the learning rate is adaptive to coordinates. Moreover, traditionally it referred to as not having a learning rate since it uses the amount of change itself as calibration for future change. The algorithm was proposed in :citet:<code>Zeiler.2012</code>. It is fairly straightforward, given the discussion of previous algorithms so far.</p>
<h2 id="the-algorithm-2"><a class="header" href="#the-algorithm-2">The Algorithm</a></h2>
<p>In a nutshell, Adadelta uses two state variables, $\mathbf{s}_t$ to store a leaky average of the second moment of the gradient and $\Delta\mathbf{x}_t$ to store a leaky average of the second moment of the change of parameters in the model itself. Note that we use the original notation and naming of the authors for compatibility with other publications and implementations (there is no other real reason why one should use different Greek variables to indicate a parameter serving the same purpose in momentum, Adagrad, RMSProp, and Adadelta).</p>
<p>Here are the technical details of Adadelta. Given the parameter du jour is $\rho$, we obtain the following leaky updates similarly to :numref:<code>sec_rmsprop</code>:</p>
<p>$$\begin{aligned}
\mathbf{s}<em>t &amp; = \rho \mathbf{s}</em>{t-1} + (1 - \rho) \mathbf{g}_t^2.
\end{aligned}$$</p>
<p>The difference to :numref:<code>sec_rmsprop</code> is that we perform updates with the rescaled gradient $\mathbf{g}_t'$, i.e.,</p>
<p>$$\begin{aligned}
\mathbf{x}<em>t  &amp; = \mathbf{x}</em>{t-1} - \mathbf{g}_t'. \
\end{aligned}$$</p>
<p>So what is the rescaled gradient $\mathbf{g}_t'$? We can calculate it as follows:</p>
<p>$$\begin{aligned}
\mathbf{g}<em>t' &amp; = \frac{\sqrt{\Delta\mathbf{x}</em>{t-1} + \epsilon}}{\sqrt{{\mathbf{s}_t + \epsilon}}} \odot \mathbf{g}_t, \
\end{aligned}$$</p>
<p>where $\Delta \mathbf{x}_{t-1}$ is the leaky average of the squared rescaled gradients $\mathbf{g}<em>t'$. We initialize $\Delta \mathbf{x}</em>{0}$ to be $0$ and update it at each step with $\mathbf{g}_t'$, i.e.,</p>
<p>$$\begin{aligned}
\Delta \mathbf{x}<em>t &amp; = \rho \Delta\mathbf{x}</em>{t-1} + (1 - \rho) {\mathbf{g}_t'}^2,
\end{aligned}$$</p>
<p>and $\epsilon$ (a small value such as $10^{-5}$) is added to maintain numerical stability.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>Adadelta needs to maintain two state variables for each variable, $\mathbf{s}_t$ and $\Delta\mathbf{x}_t$. This yields the following implementation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()

def init_adadelta_states(feature_dim):
    s_w, s_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    delta_w, delta_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    return ((s_w, delta_w), (s_b, delta_b))

def adadelta(params, states, hyperparams):
    rho, eps = hyperparams['rho'], 1e-5
    for p, (s, delta) in zip(params, states):
        # In-place updates via [:]
        s[:] = rho * s + (1 - rho) * np.square(p.grad)
        g = (np.sqrt(delta + eps) / np.sqrt(s + eps)) * p.grad
        p[:] -= g
        delta[:] = rho * delta + (1 - rho) * g * g
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

def init_adadelta_states(feature_dim):
    s_w, s_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    delta_w, delta_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    return ((s_w, delta_w), (s_b, delta_b))

def adadelta(params, states, hyperparams):
    rho, eps = hyperparams['rho'], 1e-5
    for p, (s, delta) in zip(params, states):
        with torch.no_grad():
            # In-place updates via [:]
            s[:] = rho * s + (1 - rho) * torch.square(p.grad)
            g = (torch.sqrt(delta + eps) / torch.sqrt(s + eps)) * p.grad
            p[:] -= g
            delta[:] = rho * delta + (1 - rho) * g * g
        p.grad.data.zero_()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf

def init_adadelta_states(feature_dim):
    s_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    s_b = tf.Variable(d2l.zeros(1))
    delta_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    delta_b = tf.Variable(d2l.zeros(1))
    return ((s_w, delta_w), (s_b, delta_b))

def adadelta(params, grads, states, hyperparams):
    rho, eps = hyperparams['rho'], 1e-5
    for p, (s, delta), grad in zip(params, states, grads):
        s[:].assign(rho * s + (1 - rho) * tf.math.square(grad))
        g = (tf.math.sqrt(delta + eps) / tf.math.sqrt(s + eps)) * grad
        p[:].assign(p - g)
        delta[:].assign(rho * delta + (1 - rho) * g * g)
</code></pre>
<p>Choosing $\rho = 0.9$ amounts to a half-life time of 10 for each parameter update. This tends to work quite well. We get the following behavior.</p>
<pre><code class="language-{.python .input}">#@tab all
data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(adadelta, init_adadelta_states(feature_dim),
               {'rho': 0.9}, data_iter, feature_dim);
</code></pre>
<p>For a concise implementation we simply use the Adadelta algorithm from high-level APIs. This yields the following one-liner for a much more compact invocation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.train_concise_ch11('adadelta', {'rho': 0.9}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
trainer = torch.optim.Adadelta
d2l.train_concise_ch11(trainer, {'rho': 0.9}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# adadelta is not converging at default learning rate
# but it is converging at lr = 5.0
trainer = tf.keras.optimizers.Adadelta
d2l.train_concise_ch11(trainer, {'learning_rate':5.0, 'rho': 0.9}, data_iter)
</code></pre>
<h2 id="summary-62"><a class="header" href="#summary-62">Summary</a></h2>
<ul>
<li>Adadelta has no learning rate parameter. Instead, it uses the rate of change in the parameters itself to adapt the learning rate.</li>
<li>Adadelta requires two state variables to store the second moments of gradient and the change in parameters.</li>
<li>Adadelta uses leaky averages to keep a running estimate of the appropriate statistics.</li>
</ul>
<h2 id="exercises-82"><a class="header" href="#exercises-82">Exercises</a></h2>
<ol>
<li>Adjust the value of $\rho$. What happens?</li>
<li>Show how to implement the algorithm without the use of $\mathbf{g}_t'$. Why might this be a good idea?</li>
<li>Is Adadelta really learning rate free? Could you find optimization problems that break Adadelta?</li>
<li>Compare Adadelta to Adagrad and RMS prop to discuss their convergence behavior.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/357">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1076">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1077">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adam"><a class="header" href="#adam">Adam</a></h1>
<p>:label:<code>sec_adam</code></p>
<p>In the discussions leading up to this section we encountered a number of techniques for efficient optimization. Let's recap them in detail here:</p>
<ul>
<li>We saw that :numref:<code>sec_sgd</code> is more effective than Gradient Descent when solving optimization problems, e.g., due to its inherent resilience to redundant data.</li>
<li>We saw that :numref:<code>sec_minibatch_sgd</code> affords significant additional efficiency arising from vectorization, using larger sets of observations in one minibatch. This is the key to efficient multi-machine, multi-GPU and overall parallel processing.</li>
<li>:numref:<code>sec_momentum</code> added a mechanism for aggregating a history of past gradients to accelerate convergence.</li>
<li>:numref:<code>sec_adagrad</code> used per-coordinate scaling to allow for a computationally efficient preconditioner.</li>
<li>:numref:<code>sec_rmsprop</code> decoupled per-coordinate scaling from a learning rate adjustment.</li>
</ul>
<p>Adam :cite:<code>Kingma.Ba.2014</code> combines all these techniques into one efficient learning algorithm. As expected, this is an algorithm that has become rather popular as one of the more robust and effective optimization algorithms to use in deep learning. It is not without issues, though. In particular, :cite:<code>Reddi.Kale.Kumar.2019</code> show that there are situations where Adam can diverge due to poor variance control. In a follow-up work :citet:<code>Zaheer.Reddi.Sachan.ea.2018</code> proposed a hotfix to Adam, called Yogi which addresses these issues. More on this later. For now let's review the Adam algorithm.</p>
<h2 id="the-algorithm-3"><a class="header" href="#the-algorithm-3">The Algorithm</a></h2>
<p>One of the key components of Adam is that it uses exponential weighted moving averages (also known as leaky averaging) to obtain an estimate of both the momentum and also the second moment of the gradient. That is, it uses the state variables</p>
<p>$$\begin{aligned}
\mathbf{v}<em>t &amp; \leftarrow \beta_1 \mathbf{v}</em>{t-1} + (1 - \beta_1) \mathbf{g}_t, \
\mathbf{s}<em>t &amp; \leftarrow \beta_2 \mathbf{s}</em>{t-1} + (1 - \beta_2) \mathbf{g}_t^2.
\end{aligned}$$</p>
<p>Here $\beta_1$ and $\beta_2$ are nonnegative weighting parameters. Common choices for them are $\beta_1 = 0.9$ and $\beta_2 = 0.999$. That is, the variance estimate moves <em>much more slowly</em> than the momentum term. Note that if we initialize $\mathbf{v}_0 = \mathbf{s}<em>0 = 0$ we have a significant amount of bias initially towards smaller values. This can be addressed by using the fact that $\sum</em>{i=0}^{t-1} \beta^i = \frac{1 - \beta^t}{1 - \beta}$ to re-normalize terms. Correspondingly the normalized state variables are given by</p>
<p>$$\hat{\mathbf{v}}_t = \frac{\mathbf{v}_t}{1 - \beta_1^t} \textrm{ and } \hat{\mathbf{s}}_t = \frac{\mathbf{s}_t}{1 - \beta_2^t}.$$</p>
<p>Armed with the proper estimates we can now write out the update equations. First, we rescale the gradient in a manner very much akin to that of RMSProp to obtain</p>
<p>$$\mathbf{g}_t' = \frac{\eta \hat{\mathbf{v}}_t}{\sqrt{\hat{\mathbf{s}}_t} + \epsilon}.$$</p>
<p>Unlike RMSProp our update uses the momentum $\hat{\mathbf{v}}_t$ rather than the gradient itself. Moreover, there is a slight cosmetic difference as the rescaling happens using $\frac{1}{\sqrt{\hat{\mathbf{s}}_t} + \epsilon}$ instead of $\frac{1}{\sqrt{\hat{\mathbf{s}}_t + \epsilon}}$. The former works arguably slightly better in practice, hence the deviation from RMSProp. Typically we pick $\epsilon = 10^{-6}$ for a good trade-off between numerical stability and fidelity.</p>
<p>Now we have all the pieces in place to compute updates. This is slightly anticlimactic and we have a simple update of the form</p>
<p>$$\mathbf{x}<em>t \leftarrow \mathbf{x}</em>{t-1} - \mathbf{g}_t'.$$</p>
<p>Reviewing the design of Adam its inspiration is clear. Momentum and scale are clearly visible in the state variables. Their rather peculiar definition forces us to debias terms (this could be fixed by a slightly different initialization and update condition). Second, the combination of both terms is pretty straightforward, given RMSProp. Last, the explicit learning rate $\eta$ allows us to control the step length to address issues of convergence.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>Implementing Adam from scratch is not very daunting. For convenience we store the time step counter $t$ in the <code>hyperparams</code> dictionary. Beyond that all is straightforward.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()

def init_adam_states(feature_dim):
    v_w, v_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    s_w, s_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    return ((v_w, s_w), (v_b, s_b))

def adam(params, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-6
    for p, (v, s) in zip(params, states):
        v[:] = beta1 * v + (1 - beta1) * p.grad
        s[:] = beta2 * s + (1 - beta2) * np.square(p.grad)
        v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
        s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
        p[:] -= hyperparams['lr'] * v_bias_corr / (np.sqrt(s_bias_corr) + eps)
    hyperparams['t'] += 1
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

def init_adam_states(feature_dim):
    v_w, v_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    s_w, s_b = d2l.zeros((feature_dim, 1)), d2l.zeros(1)
    return ((v_w, s_w), (v_b, s_b))

def adam(params, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-6
    for p, (v, s) in zip(params, states):
        with torch.no_grad():
            v[:] = beta1 * v + (1 - beta1) * p.grad
            s[:] = beta2 * s + (1 - beta2) * torch.square(p.grad)
            v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
            s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
            p[:] -= hyperparams['lr'] * v_bias_corr / (torch.sqrt(s_bias_corr)
                                                       + eps)
        p.grad.data.zero_()
    hyperparams['t'] += 1
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf

def init_adam_states(feature_dim):
    v_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    v_b = tf.Variable(d2l.zeros(1))
    s_w = tf.Variable(d2l.zeros((feature_dim, 1)))
    s_b = tf.Variable(d2l.zeros(1))
    return ((v_w, s_w), (v_b, s_b))

def adam(params, grads, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-6
    for p, (v, s), grad in zip(params, states, grads):
        v[:].assign(beta1 * v  + (1 - beta1) * grad)
        s[:].assign(beta2 * s + (1 - beta2) * tf.math.square(grad))
        v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
        s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
        p[:].assign(p - hyperparams['lr'] * v_bias_corr  
                    / tf.math.sqrt(s_bias_corr) + eps)
</code></pre>
<p>We are ready to use Adam to train the model. We use a learning rate of $\eta = 0.01$.</p>
<pre><code class="language-{.python .input}">#@tab all
data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(adam, init_adam_states(feature_dim),
               {'lr': 0.01, 't': 1}, data_iter, feature_dim);
</code></pre>
<p>A more concise implementation is straightforward since <code>adam</code> is one of the algorithms provided as part of the Gluon <code>trainer</code> optimization library. Hence we only need to pass configuration parameters for an implementation in Gluon.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.train_concise_ch11('adam', {'learning_rate': 0.01}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
trainer = torch.optim.Adam
d2l.train_concise_ch11(trainer, {'lr': 0.01}, data_iter)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
trainer = tf.keras.optimizers.Adam
d2l.train_concise_ch11(trainer, {'learning_rate': 0.01}, data_iter)
</code></pre>
<h2 id="yogi"><a class="header" href="#yogi">Yogi</a></h2>
<p>One of the problems of Adam is that it can fail to converge even in convex settings when the second moment estimate in $\mathbf{s}_t$ blows up. As a fix :citet:<code>Zaheer.Reddi.Sachan.ea.2018</code> proposed a refined update (and initialization) for $\mathbf{s}_t$. To understand what's going on, let's rewrite the Adam update as follows:</p>
<p>$$\mathbf{s}<em>t \leftarrow \mathbf{s}</em>{t-1} + (1 - \beta_2) \left(\mathbf{g}<em>t^2 - \mathbf{s}</em>{t-1}\right).$$</p>
<p>Whenever $\mathbf{g}_t^2$ has high variance or updates are sparse, $\mathbf{s}_t$ might forget past values too quickly. A possible fix for this is to replace $\mathbf{g}<em>t^2 - \mathbf{s}</em>{t-1}$ by $\mathbf{g}_t^2 \odot \mathop{\textrm{sgn}}(\mathbf{g}<em>t^2 - \mathbf{s}</em>{t-1})$. Now the magnitude of the update no longer depends on the amount of deviation. This yields the Yogi updates</p>
<p>$$\mathbf{s}<em>t \leftarrow \mathbf{s}</em>{t-1} + (1 - \beta_2) \mathbf{g}_t^2 \odot \mathop{\textrm{sgn}}(\mathbf{g}<em>t^2 - \mathbf{s}</em>{t-1}).$$</p>
<p>The authors furthermore advise to initialize the momentum on a larger initial batch rather than just initial pointwise estimate. We omit the details since they are not material to the discussion and since even without this convergence remains pretty good.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def yogi(params, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-3
    for p, (v, s) in zip(params, states):
        v[:] = beta1 * v + (1 - beta1) * p.grad
        s[:] = s + (1 - beta2) * np.sign(
            np.square(p.grad) - s) * np.square(p.grad)
        v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
        s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
        p[:] -= hyperparams['lr'] * v_bias_corr / (np.sqrt(s_bias_corr) + eps)
    hyperparams['t'] += 1

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(yogi, init_adam_states(feature_dim),
               {'lr': 0.01, 't': 1}, data_iter, feature_dim);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def yogi(params, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-3
    for p, (v, s) in zip(params, states):
        with torch.no_grad():
            v[:] = beta1 * v + (1 - beta1) * p.grad
            s[:] = s + (1 - beta2) * torch.sign(
                torch.square(p.grad) - s) * torch.square(p.grad)
            v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
            s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
            p[:] -= hyperparams['lr'] * v_bias_corr / (torch.sqrt(s_bias_corr)
                                                       + eps)
        p.grad.data.zero_()
    hyperparams['t'] += 1

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(yogi, init_adam_states(feature_dim),
               {'lr': 0.01, 't': 1}, data_iter, feature_dim);
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def yogi(params, grads, states, hyperparams):
    beta1, beta2, eps = 0.9, 0.999, 1e-6
    for p, (v, s), grad in zip(params, states, grads):
        v[:].assign(beta1 * v  + (1 - beta1) * grad)
        s[:].assign(s + (1 - beta2) * tf.math.sign(
                   tf.math.square(grad) - s) * tf.math.square(grad))
        v_bias_corr = v / (1 - beta1 ** hyperparams['t'])
        s_bias_corr = s / (1 - beta2 ** hyperparams['t'])
        p[:].assign(p - hyperparams['lr'] * v_bias_corr  
                    / tf.math.sqrt(s_bias_corr) + eps)
    hyperparams['t'] += 1

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10)
d2l.train_ch11(yogi, init_adam_states(feature_dim),
               {'lr': 0.01, 't': 1}, data_iter, feature_dim);
</code></pre>
<h2 id="summary-63"><a class="header" href="#summary-63">Summary</a></h2>
<ul>
<li>Adam combines features of many optimization algorithms into a fairly robust update rule.</li>
<li>Created on the basis of RMSProp, Adam also uses EWMA on the minibatch stochastic gradient.</li>
<li>Adam uses bias correction to adjust for a slow startup when estimating momentum and a second moment.</li>
<li>For gradients with significant variance we may encounter issues with convergence. They can be amended by using larger minibatches or by switching to an improved estimate for $\mathbf{s}_t$. Yogi offers such an alternative.</li>
</ul>
<h2 id="exercises-83"><a class="header" href="#exercises-83">Exercises</a></h2>
<ol>
<li>Adjust the learning rate and observe and analyze the experimental results.</li>
<li>Can you rewrite momentum and second moment updates such that it does not require bias correction?</li>
<li>Why do you need to reduce the learning rate $\eta$ as we converge?</li>
<li>Try to construct a case for which Adam diverges and Yogi converges?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/358">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1078">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1079">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-rate-scheduling"><a class="header" href="#learning-rate-scheduling">Learning Rate Scheduling</a></h1>
<p>:label:<code>sec_scheduler</code></p>
<p>So far we primarily focused on optimization <em>algorithms</em> for how to update the weight vectors rather than on the <em>rate</em> at which they are being updated. Nonetheless, adjusting the learning rate is often just as important as the actual algorithm. There are a number of aspects to consider:</p>
<ul>
<li>Most obviously the <em>magnitude</em> of the learning rate matters. If it is too large, optimization diverges, if it is too small, it takes too long to train or we end up with a suboptimal result. We saw previously that the condition number of the problem matters (see e.g., :numref:<code>sec_momentum</code> for details). Intuitively it is the ratio of the amount of change in the least sensitive direction vs. the most sensitive one.</li>
<li>Secondly, the rate of decay is just as important. If the learning rate remains large we may simply end up bouncing around the minimum and thus not reach optimality. :numref:<code>sec_minibatch_sgd</code> discussed this in some detail and we analyzed performance guarantees in :numref:<code>sec_sgd</code>. In short, we want the rate to decay, but probably more slowly than $\mathcal{O}(t^{-\frac{1}{2}})$ which would be a good choice for convex problems.</li>
<li>Another aspect that is equally important is <em>initialization</em>. This pertains both to how the parameters are set initially (review :numref:<code>sec_numerical_stability</code> for details) and also how they evolve initially. This goes under the moniker of <em>warmup</em>, i.e., how rapidly we start moving towards the solution initially. Large steps in the beginning might not be beneficial, in particular since the initial set of parameters is random. The initial update directions might be quite meaningless, too.</li>
<li>Lastly, there are a number of optimization variants that perform cyclical learning rate adjustment. This is beyond the scope of the current chapter. We recommend the reader to review details in :citet:<code>Izmailov.Podoprikhin.Garipov.ea.2018</code>, e.g., how to obtain better solutions by averaging over an entire <em>path</em> of parameters.</li>
</ul>
<p>Given the fact that there is a lot of detail needed to manage learning rates, most deep learning frameworks have tools to deal with this automatically. In the current chapter we will review the effects that different schedules have on accuracy and also show how this can be managed efficiently via a <em>learning rate scheduler</em>.</p>
<h2 id="toy-problem"><a class="header" href="#toy-problem">Toy Problem</a></h2>
<p>We begin with a toy problem that is cheap enough to compute easily, yet sufficiently nontrivial to illustrate some of the key aspects. For that we pick a slightly modernized version of LeNet (<code>relu</code> instead of <code>sigmoid</code> activation, MaxPooling rather than AveragePooling), as applied to Fashion-MNIST. Moreover, we hybridize the network for performance. Since most of the code is standard we just introduce the basics without further detailed discussion. See :numref:<code>chap_cnn</code> for a refresher as needed.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, lr_scheduler, np, npx
from mxnet.gluon import nn
npx.set_np()

net = nn.HybridSequential()
net.add(nn.Conv2D(channels=6, kernel_size=5, padding=2, activation='relu'),
        nn.MaxPool2D(pool_size=2, strides=2),
        nn.Conv2D(channels=16, kernel_size=5, activation='relu'),
        nn.MaxPool2D(pool_size=2, strides=2),
        nn.Dense(120, activation='relu'),
        nn.Dense(84, activation='relu'),
        nn.Dense(10))
net.hybridize()
loss = gluon.loss.SoftmaxCrossEntropyLoss()
device = d2l.try_gpu()

batch_size = 256
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)

# The code is almost identical to `d2l.train_ch6` defined in the
# lenet section of chapter convolutional neural networks
def train(net, train_iter, test_iter, num_epochs, loss, trainer, device):
    net.initialize(force_reinit=True, ctx=device, init=init.Xavier())
    animator = d2l.Animator(xlabel='epoch', xlim=[0, num_epochs],
                            legend=['train loss', 'train acc', 'test acc'])
    for epoch in range(num_epochs):
        metric = d2l.Accumulator(3)  # train_loss, train_acc, num_examples
        for i, (X, y) in enumerate(train_iter):
            X, y = X.as_in_ctx(device), y.as_in_ctx(device)
            with autograd.record():
                y_hat = net(X)
                l = loss(y_hat, y)
            l.backward()
            trainer.step(X.shape[0])
            metric.add(l.sum(), d2l.accuracy(y_hat, y), X.shape[0])
            train_loss = metric[0] / metric[2]
            train_acc = metric[1] / metric[2]
            if (i + 1) % 50 == 0:
                animator.add(epoch + i / len(train_iter),
                             (train_loss, train_acc, None))
        test_acc = d2l.evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'train loss {train_loss:.3f}, train acc {train_acc:.3f}, '
          f'test acc {test_acc:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
from torch import nn
from torch.optim import lr_scheduler

def net_fn():
    model = nn.Sequential(
        nn.Conv2d(1, 6, kernel_size=5, padding=2), nn.ReLU(),
        nn.MaxPool2d(kernel_size=2, stride=2),
        nn.Conv2d(6, 16, kernel_size=5), nn.ReLU(),
        nn.MaxPool2d(kernel_size=2, stride=2),
        nn.Flatten(),
        nn.Linear(16 * 5 * 5, 120), nn.ReLU(),
        nn.Linear(120, 84), nn.ReLU(),
        nn.Linear(84, 10))

    return model

loss = nn.CrossEntropyLoss()
device = d2l.try_gpu()

batch_size = 256
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)

# The code is almost identical to `d2l.train_ch6` defined in the
# lenet section of chapter convolutional neural networks
def train(net, train_iter, test_iter, num_epochs, loss, trainer, device,
          scheduler=None):
    net.to(device)
    animator = d2l.Animator(xlabel='epoch', xlim=[0, num_epochs],
                            legend=['train loss', 'train acc', 'test acc'])

    for epoch in range(num_epochs):
        metric = d2l.Accumulator(3)  # train_loss, train_acc, num_examples
        for i, (X, y) in enumerate(train_iter):
            net.train()
            trainer.zero_grad()
            X, y = X.to(device), y.to(device)
            y_hat = net(X)
            l = loss(y_hat, y)
            l.backward()
            trainer.step()
            with torch.no_grad():
                metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0])
            train_loss = metric[0] / metric[2]
            train_acc = metric[1] / metric[2]
            if (i + 1) % 50 == 0:
                animator.add(epoch + i / len(train_iter),
                             (train_loss, train_acc, None))

        test_acc = d2l.evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch+1, (None, None, test_acc))

        if scheduler:
            if scheduler.__module__ == lr_scheduler.__name__:
                # Using PyTorch In-Built scheduler
                scheduler.step()
            else:
                # Using custom defined scheduler
                for param_group in trainer.param_groups:
                    param_group['lr'] = scheduler(epoch)

    print(f'train loss {train_loss:.3f}, train acc {train_acc:.3f}, '
          f'test acc {test_acc:.3f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
import math
from tensorflow.keras.callbacks import LearningRateScheduler

def net():
    return tf.keras.models.Sequential([
        tf.keras.layers.Conv2D(filters=6, kernel_size=5, activation='relu',
                               padding='same'),
        tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
        tf.keras.layers.Conv2D(filters=16, kernel_size=5,
                               activation='relu'),
        tf.keras.layers.AvgPool2D(pool_size=2, strides=2),
        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(120, activation='relu'),
        tf.keras.layers.Dense(84, activation='sigmoid'),
        tf.keras.layers.Dense(10)])


batch_size = 256
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)

# The code is almost identical to `d2l.train_ch6` defined in the
# lenet section of chapter convolutional neural networks
def train(net_fn, train_iter, test_iter, num_epochs, lr,
              device=d2l.try_gpu(), custom_callback = False):
    device_name = device._device_name
    strategy = tf.distribute.OneDeviceStrategy(device_name)
    with strategy.scope():
        optimizer = tf.keras.optimizers.SGD(learning_rate=lr)
        loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)
        net = net_fn()
        net.compile(optimizer=optimizer, loss=loss, metrics=['accuracy'])
    callback = d2l.TrainCallback(net, train_iter, test_iter, num_epochs,
                             device_name)
    if custom_callback is False:
        net.fit(train_iter, epochs=num_epochs, verbose=0,
                callbacks=[callback])
    else:
         net.fit(train_iter, epochs=num_epochs, verbose=0,
                 callbacks=[callback, custom_callback])
    return net
</code></pre>
<p>Let's have a look at what happens if we invoke this algorithm with default settings, such as a learning rate of $0.3$ and train for $30$ iterations. Note how the training accuracy keeps on increasing while progress in terms of test accuracy stalls beyond a point. The gap between both curves indicates overfitting.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lr, num_epochs = 0.3, 30
net.initialize(force_reinit=True, ctx=device, init=init.Xavier())
trainer = gluon.Trainer(net.collect_params(), 'sgd', {'learning_rate': lr})
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr, num_epochs = 0.3, 30
net = net_fn()
trainer = torch.optim.SGD(net.parameters(), lr=lr)
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
lr, num_epochs = 0.3, 30
train(net, train_iter, test_iter, num_epochs, lr)
</code></pre>
<h2 id="schedulers"><a class="header" href="#schedulers">Schedulers</a></h2>
<p>One way of adjusting the learning rate is to set it explicitly at each step. This is conveniently achieved by the <code>set_learning_rate</code> method. We could adjust it downward after every epoch (or even after every minibatch), e.g., in a dynamic manner in response to how optimization is progressing.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
trainer.set_learning_rate(0.1)
print(f'learning rate is now {trainer.learning_rate:.2f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr = 0.1
trainer.param_groups[0]["lr"] = lr
print(f'learning rate is now {trainer.param_groups[0]["lr"]:.2f}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
lr = 0.1
dummy_model = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])
dummy_model.compile(tf.keras.optimizers.SGD(learning_rate=lr), loss='mse')
print(f'learning rate is now ,', dummy_model.optimizer.lr.numpy())
</code></pre>
<p>More generally we want to define a scheduler. When invoked with the number of updates it returns the appropriate value of the learning rate. Let's define a simple one that sets the learning rate to $\eta = \eta_0 (t + 1)^{-\frac{1}{2}}$.</p>
<pre><code class="language-{.python .input}">#@tab all
class SquareRootScheduler:
    def __init__(self, lr=0.1):
        self.lr = lr

    def __call__(self, num_update):
        return self.lr * pow(num_update + 1.0, -0.5)
</code></pre>
<p>Let's plot its behavior over a range of values.</p>
<pre><code class="language-{.python .input}">#@tab all
scheduler = SquareRootScheduler(lr=0.1)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<p>Now let's see how this plays out for training on Fashion-MNIST. We simply provide the scheduler as an additional argument to the training algorithm.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'lr_scheduler': scheduler})
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = net_fn()
trainer = torch.optim.SGD(net.parameters(), lr)
train(net, train_iter, test_iter, num_epochs, loss, trainer, device,
      scheduler)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
train(net, train_iter, test_iter, num_epochs, lr,
      custom_callback=LearningRateScheduler(scheduler))
</code></pre>
<p>This worked quite a bit better than previously. Two things stand out: the curve was rather more smooth than previously. Secondly, there was less overfitting. Unfortunately it is not a well-resolved question as to why certain strategies lead to less overfitting in <em>theory</em>. There is some argument that a smaller stepsize will lead to parameters that are closer to zero and thus simpler. However, this does not explain the phenomenon entirely since we do not really stop early but simply reduce the learning rate gently.</p>
<h2 id="policies"><a class="header" href="#policies">Policies</a></h2>
<p>While we cannot possibly cover the entire variety of learning rate schedulers, we attempt to give a brief overview of popular policies below. Common choices are polynomial decay and piecewise constant schedules. Beyond that, cosine learning rate schedules have been found to work well empirically on some problems. Lastly, on some problems it is beneficial to warm up the optimizer prior to using large learning rates.</p>
<h3 id="factor-scheduler"><a class="header" href="#factor-scheduler">Factor Scheduler</a></h3>
<p>One alternative to a polynomial decay would be a multiplicative one, that is $\eta_{t+1} \leftarrow \eta_t \cdot \alpha$ for $\alpha \in (0, 1)$. To prevent the learning rate from decaying beyond a reasonable lower bound the update equation is often modified to $\eta_{t+1} \leftarrow \mathop{\mathrm{max}}(\eta_{\mathrm{min}}, \eta_t \cdot \alpha)$.</p>
<pre><code class="language-{.python .input}">#@tab all
class FactorScheduler:
    def __init__(self, factor=1, stop_factor_lr=1e-7, base_lr=0.1):
        self.factor = factor
        self.stop_factor_lr = stop_factor_lr
        self.base_lr = base_lr

    def __call__(self, num_update):
        self.base_lr = max(self.stop_factor_lr, self.base_lr * self.factor)
        return self.base_lr

scheduler = FactorScheduler(factor=0.9, stop_factor_lr=1e-2, base_lr=2.0)
d2l.plot(d2l.arange(50), [scheduler(t) for t in range(50)])
</code></pre>
<p>This can also be accomplished by a built-in scheduler in MXNet via the <code>lr_scheduler.FactorScheduler</code> object. It takes a few more parameters, such as warmup period, warmup mode (linear or constant), the maximum number of desired updates, etc.; Going forward we will use the built-in schedulers as appropriate and only explain their functionality here. As illustrated, it is fairly straightforward to build your own scheduler if needed.</p>
<h3 id="multi-factor-scheduler"><a class="header" href="#multi-factor-scheduler">Multi Factor Scheduler</a></h3>
<p>A common strategy for training deep networks is to keep the learning rate piecewise constant and to decrease it by a given amount every so often. That is, given a set of times when to decrease the rate, such as $s = {5, 10, 20}$ decrease $\eta_{t+1} \leftarrow \eta_t \cdot \alpha$ whenever $t \in s$. Assuming that the values are halved at each step we can implement this as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
scheduler = lr_scheduler.MultiFactorScheduler(step=[15, 30], factor=0.5,
                                              base_lr=0.5)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = net_fn()
trainer = torch.optim.SGD(net.parameters(), lr=0.5)
scheduler = lr_scheduler.MultiStepLR(trainer, milestones=[15, 30], gamma=0.5)

def get_lr(trainer, scheduler):
    lr = scheduler.get_last_lr()[0]
    trainer.step()
    scheduler.step()
    return lr

d2l.plot(d2l.arange(num_epochs), [get_lr(trainer, scheduler)
                                  for t in range(num_epochs)])
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
class MultiFactorScheduler:
    def __init__(self, step, factor, base_lr):
        self.step = step
        self.factor = factor
        self.base_lr = base_lr

    def __call__(self, epoch):
        if epoch in self.step:
            self.base_lr = self.base_lr * self.factor
            return self.base_lr
        else:
            return self.base_lr

scheduler = MultiFactorScheduler(step=[15, 30], factor=0.5, base_lr=0.5)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<p>The intuition behind this piecewise constant learning rate schedule is that one lets optimization proceed until a stationary point has been reached in terms of the distribution of weight vectors. Then (and only then) do we decrease the rate such as to obtain a higher quality proxy to a good local minimum. The example below shows how this can produce ever slightly better solutions.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'lr_scheduler': scheduler})
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train(net, train_iter, test_iter, num_epochs, loss, trainer, device,
      scheduler)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
train(net, train_iter, test_iter, num_epochs, lr,
      custom_callback=LearningRateScheduler(scheduler))
</code></pre>
<h3 id="cosine-scheduler"><a class="header" href="#cosine-scheduler">Cosine Scheduler</a></h3>
<p>A rather perplexing heuristic was proposed by :citet:<code>Loshchilov.Hutter.2016</code>. It relies on the observation that we might not want to decrease the learning rate too drastically in the beginning and moreover, that we might want to "refine" the solution in the end using a very small learning rate. This results in a cosine-like schedule with the following functional form for learning rates in the range $t \in [0, T]$.</p>
<p>$$\eta_t = \eta_T + \frac{\eta_0 - \eta_T}{2} \left(1 + \cos(\pi t/T)\right)$$</p>
<p>Here $\eta_0$ is the initial learning rate, $\eta_T$ is the target rate at time $T$. Furthermore, for $t &gt; T$ we simply pin the value to $\eta_T$ without increasing it again. In the following example, we set the max update step $T = 20$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
scheduler = lr_scheduler.CosineScheduler(max_update=20, base_lr=0.3,
                                         final_lr=0.01)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch, tensorflow
class CosineScheduler:
    def __init__(self, max_update, base_lr=0.01, final_lr=0,
               warmup_steps=0, warmup_begin_lr=0):
        self.base_lr_orig = base_lr
        self.max_update = max_update
        self.final_lr = final_lr
        self.warmup_steps = warmup_steps
        self.warmup_begin_lr = warmup_begin_lr
        self.max_steps = self.max_update - self.warmup_steps

    def get_warmup_lr(self, epoch):
        increase = (self.base_lr_orig - self.warmup_begin_lr) \
                       * float(epoch) / float(self.warmup_steps)
        return self.warmup_begin_lr + increase

    def __call__(self, epoch):
        if epoch &lt; self.warmup_steps:
            return self.get_warmup_lr(epoch)
        if epoch &lt;= self.max_update:
            self.base_lr = self.final_lr + (
                self.base_lr_orig - self.final_lr) * (1 + math.cos(
                math.pi * (epoch - self.warmup_steps) / self.max_steps)) / 2
        return self.base_lr

scheduler = CosineScheduler(max_update=20, base_lr=0.3, final_lr=0.01)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<p>In the context of computer vision this schedule <em>can</em> lead to improved results. Note, though, that such improvements are not guaranteed (as can be seen below).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'lr_scheduler': scheduler})
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = net_fn()
trainer = torch.optim.SGD(net.parameters(), lr=0.3)
train(net, train_iter, test_iter, num_epochs, loss, trainer, device,
      scheduler)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
train(net, train_iter, test_iter, num_epochs, lr,
      custom_callback=LearningRateScheduler(scheduler))
</code></pre>
<h3 id="warmup"><a class="header" href="#warmup">Warmup</a></h3>
<p>In some cases initializing the parameters is not sufficient to guarantee a good solution. This is particularly a problem for some advanced network designs that may lead to unstable optimization problems. We could address this by choosing a sufficiently small learning rate to prevent divergence in the beginning. Unfortunately this means that progress is slow. Conversely, a large learning rate initially leads to divergence.</p>
<p>A rather simple fix for this dilemma is to use a warmup period during which the learning rate <em>increases</em> to its initial maximum and to cool down the rate until the end of the optimization process. For simplicity one typically uses a linear increase for this purpose. This leads to a schedule of the form indicated below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
scheduler = lr_scheduler.CosineScheduler(20, warmup_steps=5, base_lr=0.3,
                                         final_lr=0.01)
d2l.plot(np.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch, tensorflow
scheduler = CosineScheduler(20, warmup_steps=5, base_lr=0.3, final_lr=0.01)
d2l.plot(d2l.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
</code></pre>
<p>Note that the network converges better initially (in particular observe the performance during the first 5 epochs).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'lr_scheduler': scheduler})
train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = net_fn()
trainer = torch.optim.SGD(net.parameters(), lr=0.3)
train(net, train_iter, test_iter, num_epochs, loss, trainer, device,
      scheduler)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
train(net, train_iter, test_iter, num_epochs, lr,
      custom_callback=LearningRateScheduler(scheduler))
</code></pre>
<p>Warmup can be applied to any scheduler (not just cosine). For a more detailed discussion of learning rate schedules and many more experiments see also :cite:<code>Gotmare.Keskar.Xiong.ea.2018</code>. In particular they find that a warmup phase limits the amount of divergence of parameters in very deep networks. This makes intuitively sense since we would expect significant divergence due to random initialization in those parts of the network that take the most time to make progress in the beginning.</p>
<h2 id="summary-64"><a class="header" href="#summary-64">Summary</a></h2>
<ul>
<li>Decreasing the learning rate during training can lead to improved accuracy and (most perplexingly) reduced overfitting of the model.</li>
<li>A piecewise decrease of the learning rate whenever progress has plateaued is effective in practice. Essentially this ensures that we converge efficiently to a suitable solution and only then reduce the inherent variance of the parameters by reducing the learning rate.</li>
<li>Cosine schedulers are popular for some computer vision problems. See e.g., <a href="http://gluon-cv.mxnet.io">GluonCV</a> for details of such a scheduler.</li>
<li>A warmup period before optimization can prevent divergence.</li>
<li>Optimization serves multiple purposes in deep learning. Besides minimizing the training objective, different choices of optimization algorithms and learning rate scheduling can lead to rather different amounts of generalization and overfitting on the test set (for the same amount of training error).</li>
</ul>
<h2 id="exercises-84"><a class="header" href="#exercises-84">Exercises</a></h2>
<ol>
<li>Experiment with the optimization behavior for a given fixed learning rate. What is the best model you can obtain this way?</li>
<li>How does convergence change if you change the exponent of the decrease in the learning rate? Use <code>PolyScheduler</code> for your convenience in the experiments.</li>
<li>Apply the cosine scheduler to large computer vision problems, e.g., training ImageNet. How does it affect performance relative to other schedulers?</li>
<li>How long should warmup last?</li>
<li>Can you connect optimization and sampling? Start by using results from :citet:<code>Welling.Teh.2011</code> on Stochastic Gradient Langevin Dynamics.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/359">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1080">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1081">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computational-performance"><a class="header" href="#computational-performance">Computational Performance</a></h1>
<p>:label:<code>chap_performance</code></p>
<p>In deep learning,
datasets and models are usually large,
which involves heavy computation.
Therefore, computational performance matters a lot.
This chapter will focus on the major factors that affect computational performance:
imperative programming, symbolic programming, asynchronous computing, automatic parallelism, and multi-GPU computation.
By studying this chapter, you may further improve computational performance of those models implemented in the previous chapters,
for example, by reducing training time without affecting accuracy.</p>
<pre><code class="language-toc">:maxdepth: 2

hybridize
async-computation
auto-parallelism
hardware
multiple-gpus
multiple-gpus-concise
parameterserver
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilers-and-interpreters"><a class="header" href="#compilers-and-interpreters">Compilers and Interpreters</a></h1>
<p>:label:<code>sec_hybridize</code></p>
<p>So far, this book has focused on imperative programming, which makes use of statements such as <code>print</code>, <code>+</code>, and <code>if</code> to change a program's state. Consider the following example of a simple imperative program.</p>
<pre><code class="language-{.python .input}">#@tab all
def add(a, b):
    return a + b

def fancy_func(a, b, c, d):
    e = add(a, b)
    f = add(c, d)
    g = add(e, f)
    return g

print(fancy_func(1, 2, 3, 4))
</code></pre>
<p>Python is an <em>interpreted language</em>. When evaluating the above <code>fancy_func</code> function it performs the operations making up the function's body <em>in sequence</em>. That is, it will evaluate <code>e = add(a, b)</code> and store the results as variable <code>e</code>, thereby changing the program's state. The next two statements <code>f = add(c, d)</code> and <code>g = add(e, f)</code> will be executed similarly, performing additions and storing the results as variables. :numref:<code>fig_compute_graph</code> illustrates the flow of data.</p>
<p><img src="chapter_computational-performance/../img/computegraph.svg" alt="Data flow in an imperative program." />
:label:<code>fig_compute_graph</code></p>
<p>Although imperative programming is convenient, it may be inefficient. On the one hand, even if the <code>add</code> function is repeatedly called throughout <code>fancy_func</code>, Python will execute the three function calls individually. If these are executed, say, on a GPU (or even on multiple GPUs), the overhead arising from the Python interpreter can become overwhelming. Moreover, it will need to save the variable values of <code>e</code> and <code>f</code> until all the statements in <code>fancy_func</code> have been executed. This is because we do not know whether the variables <code>e</code> and <code>f</code> will be used by other parts of the program after the statements <code>e = add(a, b)</code> and <code>f = add(c, d)</code> are executed.</p>
<h2 id="symbolic-programming"><a class="header" href="#symbolic-programming">Symbolic Programming</a></h2>
<p>Consider the alternative, <em>symbolic programming</em>, where computation is usually performed only once the process has been fully defined. This strategy is used by multiple deep learning frameworks, including Theano and TensorFlow (the latter has acquired imperative extensions). It usually involves the following steps:</p>
<ol>
<li>Define the operations to be executed.</li>
<li>Compile the operations into an executable program.</li>
<li>Provide the required inputs and call the compiled program for execution.</li>
</ol>
<p>This allows for a significant amount of optimization. First, we can skip the Python interpreter in many cases, thus removing a performance bottleneck that can become significant on multiple fast GPUs paired with a single Python thread on a CPU.
Second, a compiler might optimize and rewrite the above code into <code>print((1 + 2) + (3 + 4))</code> or even <code>print(10)</code>. This is possible since a compiler gets to see the full code before turning it into machine instructions. For instance, it can release memory (or never allocate it) whenever a variable is no longer needed. Or it can transform the code entirely into an equivalent piece.
To get a better idea, consider the following simulation of imperative programming (it is Python after all) below.</p>
<pre><code class="language-{.python .input}">#@tab all
def add_():
    return '''
def add(a, b):
    return a + b
'''

def fancy_func_():
    return '''
def fancy_func(a, b, c, d):
    e = add(a, b)
    f = add(c, d)
    g = add(e, f)
    return g
'''

def evoke_():
    return add_() + fancy_func_() + 'print(fancy_func(1, 2, 3, 4))'

prog = evoke_()
print(prog)
y = compile(prog, '', 'exec')
exec(y)
</code></pre>
<p>The differences between imperative (interpreted) programming and symbolic programming are as follows:</p>
<ul>
<li>Imperative programming is easier. When imperative programming is used in Python, the majority of the code is straightforward and easy to write. It is also easier to debug imperative programming code. This is because it is easier to obtain and print all relevant intermediate variable values, or use Python's built-in debugging tools.</li>
<li>Symbolic programming is more efficient and easier to port. Symbolic programming makes it easier to optimize the code during compilation, while also having the ability to port the program into a format independent of Python. This allows the program to be run in a non-Python environment, thus avoiding any potential performance issues related to the Python interpreter.</li>
</ul>
<h2 id="hybrid-programming"><a class="header" href="#hybrid-programming">Hybrid Programming</a></h2>
<p>Historically most deep learning frameworks choose between an imperative or a symbolic approach. For example, Theano, TensorFlow (inspired by the former), Keras, and CNTK formulate models symbolically. Conversely, Chainer and PyTorch take an imperative approach. An imperative mode was added to TensorFlow 2.0 and Keras in later revisions.</p>
<p>:begin_tab:<code>mxnet</code>
When designing Gluon, developers considered whether it would be possible to combine the benefits of both programming paradigms. This led to a hybrid model that lets users develop and debug with pure imperative programming, while having the ability to convert most programs into symbolic programs to be run when product-level computing performance and deployment are required.</p>
<p>In practice this means that we build models using the <code>HybridBlock</code> or <code>HybridSequential</code> class. By default, either of them is executed in the same way the <code>Block</code> or <code>Sequential</code> class is executed in imperative programming.
The <code>HybridSequential</code> class is a subclass of <code>HybridBlock</code> (just like <code>Sequential</code> subclasses <code>Block</code>). When the <code>hybridize</code> function is called, Gluon compiles the model into the form used in symbolic programming. This allows one to optimize the computation-intensive components without sacrifices in the way a model is implemented. We will illustrate the benefits below, focusing on sequential models and blocks.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
As mentioned above, PyTorch is based on imperative programming and uses dynamic computation graphs. In an effort to leverage the portability and efficiency of symbolic programming, developers considered whether it would be possible to combine the benefits of both programming paradigms. This led to a torchscript that lets users develop and debug using pure imperative programming, while having the ability to convert most programs into symbolic programs to be run when product-level computing performance and deployment are required.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
The imperative programming paradigm is now the default in Tensorflow 2, a welcoming change for those new to the language. However, the same symbolic programming techniques and subsequent computational graphs still exist in TensorFlow, and can be accessed by the easy-to-use <code>tf.function</code> decorator. This brought the imperative programming paradigm to TensorFlow, allowed users to define more intuitive functions, then wrap them and compile them into computational graphs automatically using a feature the TensorFlow team refers to as <a href="https://www.tensorflow.org/api_docs/python/tf/autograph">autograph</a>.
:end_tab:</p>
<h2 id="hybridizing-the-sequential-class"><a class="header" href="#hybridizing-the-sequential-class">Hybridizing the <code>Sequential</code> Class</a></h2>
<p>The easiest way to get a feel for how hybridization works is to consider deep networks with multiple layers. Conventionally the Python interpreter will need to execute the code for all layers to generate an instruction that can then be forwarded to a CPU or a GPU. For a single (fast) computing device this does not cause any major issues. On the other hand, if we use an advanced 8-GPU server such as an AWS P3dn.24xlarge instance Python will struggle to keep all GPUs busy. The single-threaded Python interpreter becomes the bottleneck here. Let's see how we can address this for significant parts of the code by replacing <code>Sequential</code> with <code>HybridSequential</code>. We begin by defining a simple MLP.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
from mxnet.gluon import nn
npx.set_np()

# Factory for networks
def get_net():
    net = nn.HybridSequential()  
    net.add(nn.Dense(256, activation='relu'),
            nn.Dense(128, activation='relu'),
            nn.Dense(2))
    net.initialize()
    return net

x = np.random.normal(size=(1, 512))
net = get_net()
net(x)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn

# Factory for networks
def get_net():
    net = nn.Sequential(nn.Linear(512, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 2))
    return net

x = torch.randn(size=(1, 512))
net = get_net()
net(x)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
from tensorflow.keras.layers import Dense

# Factory for networks
def get_net():
    net = tf.keras.Sequential()
    net.add(Dense(256, input_shape = (512,), activation = "relu"))
    net.add(Dense(128, activation = "relu"))
    net.add(Dense(2, activation = "linear"))
    return net

x = tf.random.normal([1,512])
net = get_net()
net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
By calling the <code>hybridize</code> function, we are able to compile and optimize the computation in the MLP. The model's computation result remains unchanged.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
By converting the model using <code>torch.jit.script</code> function, we are able to compile and optimize the computation in the MLP. The model's computation result remains unchanged.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Formerly, all functions built in TensorFlow were built as a computational graph, and therefore JIT compiled by default. However, with the release of TensorFlow 2.X and EagerTensor, this is no longer the default behavor.
We cen re-enable this functionality with tf.function. tf.function is more commonly used as a function decorator, however it is possible to call it direcly as a normal python function, shown below. The model's computation result remains unchanged.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net.hybridize()
net(x)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = torch.jit.script(net)
net(x)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
net = tf.function(net)
net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
This seems almost too good to be true: simply designate a block to be <code>HybridSequential</code>, write the same code as before and invoke <code>hybridize</code>. Once this happens the network is optimized (we will benchmark the performance below). Unfortunately this does not work magically for every layer. That said, a layer will not be optimized if it inherits from the <code>Block</code> class instead of the <code>HybridBlock</code> class.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
This seems almost too good to be true: write the same code as before and simply convert the model using <code>torch.jit.script</code>. Once this happens the network is optimized (we will benchmark the performance below).
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
This seems almost too good to be true: write the same code as before and simply convert the model using <code>tf.function</code>. Once this happens the network is built as a computational graph in TensorFlow's MLIR intermediate representation and is heavily optimized at the compiler level for rapid execution (we will benchmark the performance below).
Explicitly adding the <code>jit_compile = True</code> flag to the <code>tf.function()</code> call enables XLA (Accelerated Linear Algebra) functionality in TensorFlow. XLA can further optimize JIT compiled code in certain instances. Graph-mode execution is enabled without this explicit definition, however XLA can make certain large linear algebra operations (in the vein of those we see in deep learning applications) much faster, particularly in a GPU environment.
:end_tab:</p>
<h3 id="acceleration-by-hybridization"><a class="header" href="#acceleration-by-hybridization">Acceleration by Hybridization</a></h3>
<p>To demonstrate the performance improvement gained by compilation we compare the time needed to evaluate <code>net(x)</code> before and after hybridization. Let's define a class to measure this time first. It will come handy throughout the chapter as we set out to measure (and improve) performance.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
class Benchmark:
    """For measuring running time."""
    def __init__(self, description='Done'):
        self.description = description

    def __enter__(self):
        self.timer = d2l.Timer()
        return self

    def __exit__(self, *args):
        print(f'{self.description}: {self.timer.stop():.4f} sec')
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Now we can invoke the network twice, once with and once without hybridization.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Now we can invoke the network twice, once with and once without torchscript.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Now we can invoke the network three times, once executed eagerly, once with graph-mode execution, and again using JIT compiled XLA.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = get_net()
with Benchmark('Without hybridization'):
    for i in range(1000): net(x)
    npx.waitall()

net.hybridize()
with Benchmark('With hybridization'):
    for i in range(1000): net(x)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = get_net()
with Benchmark('Without torchscript'):
    for i in range(1000): net(x)

net = torch.jit.script(net)
with Benchmark('With torchscript'):
    for i in range(1000): net(x)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
net = get_net()
with Benchmark('Eager Mode'):
    for i in range(1000): net(x)

net = tf.function(net)
with Benchmark('Graph Mode'):
    for i in range(1000): net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
As is observed in the above results, after a <code>HybridSequential</code> instance calls the <code>hybridize</code> function, computing performance is improved through the use of symbolic programming.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
As is observed in the above results, after an <code>nn.Sequential</code> instance is scripted using the <code>torch.jit.script</code> function, computing performance is improved through the use of symbolic programming.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
As is observed in the above results, after a <code>tf.keras.Sequential</code> instance is scripted using the <code>tf.function</code> function, computing performance is improved through the use of symbolic programming via graph-mode execution in tensorflow.
:end_tab:</p>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<p>:begin_tab:<code>mxnet</code>
One of the benefits of compiling the models is that we can serialize (save) the model and its parameters to disk. This allows us to store a model in a manner that is independent of the front-end language of choice. This allows us to deploy trained models to other devices and easily use other front-end programming languages. At the same time the code is often faster than what can be achieved in imperative programming. Let's see the <code>export</code> function in action.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
One of the benefits of compiling the models is that we can serialize (save) the model and its parameters to disk. This allows us to store a model in a manner that is independent of the front-end language of choice. This allows us to deploy trained models to other devices and easily use other front-end programming languages. At the same time the code is often faster than what can be achieved in imperative programming. Let's see the <code>save</code> function in action.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
One of the benefits of compiling the models is that we can serialize (save) the model and its parameters to disk. This allows us to store a model in a manner that is independent of the front-end language of choice. This allows us to deploy trained models to other devices and easily use other front-end programming languages or execute a trained model on a server. At the same time the code is often faster than what can be achieved in imperative programming.
The low-level API that allows us to save in tensorflow is <code>tf.saved_model</code>.
Let's see the <code>saved_model</code> instance in action.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net.export('my_mlp')
!ls -lh my_mlp*
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net.save('my_mlp')
!ls -lh my_mlp*
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
net = get_net()
tf.saved_model.save(net, 'my_mlp')
!ls -lh my_mlp*
</code></pre>
<p>:begin_tab:<code>mxnet</code>
The model is decomposed into a (large binary) parameter file and a JSON description of the program required to execute the model computation. The files can be read by other front-end languages supported by Python or MXNet, such as C++, R, Scala, and Perl. Let's have a look at the first few lines in the model description.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
!head my_mlp-symbol.json
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Earlier, we demonstrated that, after calling the <code>hybridize</code> function, the model is able to achieve superior computing performance and portability. Note, though that hybridization can affect model flexibility, in particular in terms of control flow.</p>
<p>Besides, contrary to the <code>Block</code> instance, which needs to use the <code>forward</code> function, for a <code>HybridBlock</code> instance we need to use the <code>hybrid_forward</code> function.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class HybridNet(nn.HybridBlock):
    def __init__(self, **kwargs):
        super(HybridNet, self).__init__(**kwargs)
        self.hidden = nn.Dense(4)
        self.output = nn.Dense(2)

    def hybrid_forward(self, F, x):
        print('module F: ', F)
        print('value  x: ', x)
        x = F.npx.relu(self.hidden(x))
        print('result  : ', x)
        return self.output(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
The code above implements a simple network with 4 hidden units and 2 outputs. The <code>hybrid_forward</code> function takes an additional argument <code>F</code>. This is needed since, depending on whether the code has been hybridized or not, it will use a slightly different library (<code>ndarray</code> or <code>symbol</code>) for processing. Both classes perform very similar functions and MXNet automatically determines the argument. To understand what is going on we print the arguments as part of the function invocation.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = HybridNet()
net.initialize()
x = np.random.normal(size=(1, 3))
net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Repeating the forward computation will lead to the same output (we omit details). Now let's see what happens if we invoke the <code>hybridize</code> function.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net.hybridize()
net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Instead of using <code>ndarray</code> we now use the <code>symbol</code> module for <code>F</code>. Moreover, even though the input is of <code>ndarray</code> type, the data flowing through the network is now converted to <code>symbol</code> type as part of the compilation process. Repeating the function call leads to a surprising outcome:
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net(x)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
This is quite different from what we saw previously. All print statements, as defined in <code>hybrid_forward</code>, are omitted. Indeed, after hybridization the execution of <code>net(x)</code> does not involve the Python interpreter any longer. This means that any spurious Python code is omitted (such as print statements) in favor of a much more streamlined execution and better performance. Instead, MXNet directly calls the C++ backend. Also note that some functions are not supported in the <code>symbol</code> module (e.g.,  <code>asnumpy</code>) and operations in-place such as <code>a += b</code> and <code>a[:] = a + b</code> must be rewritten as <code>a = a + b</code>. Nonetheless, compilation of models is worth the effort whenever speed matters. The benefit can range from small percentage points to more than twice the speed, depending on the complexity of the model, the speed of the CPU, and the speed and number of GPUs.
:end_tab:</p>
<h2 id="summary-65"><a class="header" href="#summary-65">Summary</a></h2>
<ul>
<li>Imperative programming makes it easy to design new models since it is possible to write code with control flow and the ability to use a large amount of the Python software ecosystem.</li>
<li>Symbolic programming requires that we specify the program and compile it before executing it. The benefit is improved performance.</li>
</ul>
<p>:begin_tab:<code>mxnet</code></p>
<ul>
<li>MXNet is able to combine the advantages of both approaches as needed.</li>
<li>Models constructed by the <code>HybridSequential</code> and <code>HybridBlock</code> classes are able to convert imperative programs into symbolic programs by calling the <code>hybridize</code> function.
:end_tab:</li>
</ul>
<h2 id="exercises-85"><a class="header" href="#exercises-85">Exercises</a></h2>
<p>:begin_tab:<code>mxnet</code></p>
<ol>
<li>Add <code>x.asnumpy()</code> to the first line of the <code>hybrid_forward</code> function of the <code>HybridNet</code> class in this section. Execute the code and observe the errors you encounter. Why do they happen?</li>
<li>What happens if we add control flow, i.e., the Python statements <code>if</code> and <code>for</code> in the <code>hybrid_forward</code> function?</li>
<li>Review the models that interest you in the previous chapters. Can you improve their computational performance by reimplementing them?
:end_tab:</li>
</ol>
<p>:begin_tab:<code>pytorch,tensorflow</code></p>
<ol>
<li>Review the models that interest you in the previous chapters. Can you improve their computational performance by reimplementing them?
:end_tab:</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/360">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/2490">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/2492">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-computation"><a class="header" href="#asynchronous-computation">Asynchronous Computation</a></h1>
<p>:label:<code>sec_async</code></p>
<p>Today's computers are highly parallel systems, consisting of multiple CPU cores (often multiple threads per core), multiple processing elements per GPU, and often multiple GPUs per device. In short, we can process many different things at the same time, often on different devices. Unfortunately Python is not a great way of writing parallel and asynchronous code, at least not without some extra help. After all, Python is single-threaded and this is unlikely to change in the future. Deep learning frameworks such as MXNet and TensorFlow adopt an <em>asynchronous programming</em> model to improve performance,
while PyTorch uses Python's own scheduler leading to a different performance trade-off.
For PyTorch, by default, GPU operations are asynchronous. When you call a function that uses the GPU, the operations are enqueued to the particular device, but not necessarily executed until later. This allows us to execute more computations in parallel, including operations on the CPU or other GPUs.</p>
<p>Hence, understanding how asynchronous programming works helps us to develop more efficient programs, by proactively reducing computational requirements and mutual dependencies. This allows us to reduce memory overhead and increase processor utilization.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
import numpy, os, subprocess
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import numpy, os, subprocess
import torch
from torch import nn
</code></pre>
<h2 id="asynchrony-via-backend"><a class="header" href="#asynchrony-via-backend">Asynchrony via Backend</a></h2>
<p>:begin_tab:<code>mxnet</code>
For a warmup consider the following toy problem: we want to generate a random matrix and multiply it. Let's do that both in NumPy and in <code>mxnet.np</code> to see the difference.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
For a warmup consider the following toy problem: we want to generate a random matrix and multiply it. Let's do that both in NumPy and in PyTorch tensor to see the difference.
Note that PyTorch <code>tensor</code> is defined on a GPU.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('numpy'):
    for _ in range(10):
        a = numpy.random.normal(size=(1000, 1000))
        b = numpy.dot(a, a)

with d2l.Benchmark('mxnet.np'):
    for _ in range(10):
        a = np.random.normal(size=(1000, 1000))
        b = np.dot(a, a)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Warmup for GPU computation
device = d2l.try_gpu()
a = torch.randn(size=(1000, 1000), device=device)
b = torch.mm(a, a)

with d2l.Benchmark('numpy'):
    for _ in range(10):
        a = numpy.random.normal(size=(1000, 1000))
        b = numpy.dot(a, a)

with d2l.Benchmark('torch'):
    for _ in range(10):
        a = torch.randn(size=(1000, 1000), device=device)
        b = torch.mm(a, a)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
The benchmark output via MXNet is orders of magnitude faster. Since both are executed on the same processor something else must be going on.
Forcing MXNet to finish all the backend computation prior to returning shows what happened previously: computation is executed by the backend while the frontend returns control to Python.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
The benchmark output via PyTorch is orders of magnitude faster.
NumPy dot product is executed on the CPU processor while
PyTorch matrix multiplication is executed on GPU and hence the latter
is expected to be much faster. But the huge time difference suggests something
else must be going on.
By default, GPU operations are asynchronous in PyTorch.
Forcing PyTorch to finish all computation prior to returning shows
what happened previously: computation is being executed by the backend
while the frontend returns control to Python.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark():
    for _ in range(10):
        a = np.random.normal(size=(1000, 1000))
        b = np.dot(a, a)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
with d2l.Benchmark():
    for _ in range(10):
        a = torch.randn(size=(1000, 1000), device=device)
        b = torch.mm(a, a)
    torch.cuda.synchronize(device)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Broadly speaking, MXNet has a frontend for direct interactions with users, e.g., via Python, as well as a backend used by the system to perform the computation.
As shown in :numref:<code>fig_frontends</code>, users can write MXNet programs in various frontend languages, such as Python, R, Scala, and C++. Regardless of the frontend programming language used, the execution of MXNet programs occurs primarily in the backend of C++ implementations. Operations issued by the frontend language are passed on to the backend for execution.
The backend manages its own threads that continuously collect and execute queued tasks. Note that for this to work the backend must be able to keep track of the dependencies between various steps in the computational graph. Hence, it is not possible to parallelize operations that depend on each other.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Broadly speaking, PyTorch has a frontend for direct interaction with the users, e.g., via Python, as well as a backend used by the system to perform the computation.
As shown in :numref:<code>fig_frontends</code>, users can write PyTorch programs in various frontend languages, such as Python and C++. Regardless of the frontend programming language used, the execution of PyTorch programs occurs primarily in the backend of C++ implementations. Operations issued by the frontend language are passed on to the backend for execution.
The backend manages its own threads that continuously collect and execute queued tasks.
Note that for this to work the backend must be able to keep track of the
dependencies between various steps in the computational graph.
Hence, it is not possible to parallelize operations that depend on each other.
:end_tab:</p>
<p><img src="chapter_computational-performance/../img/frontends.png" alt="Programming language frontends and deep learning framework backends." />
:width:<code>300px</code>
:label:<code>fig_frontends</code></p>
<p>Let's look at another toy example to understand the dependency graph a bit better.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.ones((1, 2))
y = np.ones((1, 2))
z = x * y + 2
z
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.ones((1, 2), device=device)
y = torch.ones((1, 2), device=device)
z = x * y + 2
z
</code></pre>
<p><img src="chapter_computational-performance/../img/asyncgraph.svg" alt="The backend tracks dependencies between various steps in the computational graph." />
:label:<code>fig_asyncgraph</code></p>
<p>The code snippet above is also illustrated in :numref:<code>fig_asyncgraph</code>.
Whenever the Python frontend thread executes one of the first three statements, it simply returns the task to the backend queue. When the last statement's results need to be <em>printed</em>, the Python frontend thread will wait for the C++ backend thread to finish computing the result of the variable <code>z</code>. One benefit of this design is that the Python frontend thread does not need to perform actual computations. Thus, there is little impact on the program's overall performance, regardless of Python's performance. :numref:<code>fig_threading</code> illustrates how frontend and backend interact.</p>
<p><img src="chapter_computational-performance/../img/threading.svg" alt="Interactions of the frontend and backend." />
:label:<code>fig_threading</code></p>
<h2 id="barriers-and-blockers"><a class="header" href="#barriers-and-blockers">Barriers and Blockers</a></h2>
<p>:begin_tab:<code>mxnet</code>
There are a number of operations that will force Python to wait for completion:</p>
<ul>
<li>Most obviously <code>npx.waitall()</code> waits until all computation has completed, regardless of when the compute instructions were issued. In practice it is a bad idea to use this operator unless absolutely necessary since it can lead to poor performance.</li>
<li>If we just want to wait until a specific variable is available we can call <code>z.wait_to_read()</code>. In this case MXNet blocks return to Python until the variable <code>z</code> has been computed. Other computation may well continue afterwards.</li>
</ul>
<p>Let's see how this works in practice.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('waitall'):
    b = np.dot(a, a)
    npx.waitall()

with d2l.Benchmark('wait_to_read'):
    b = np.dot(a, a)
    b.wait_to_read()
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Both operations take approximately the same time to complete. Besides the obvious blocking operations we recommend that you are aware of <em>implicit</em> blockers. Printing a variable clearly requires the variable to be available and is thus a blocker. Last, conversions to NumPy via <code>z.asnumpy()</code> and conversions to scalars via <code>z.item()</code> are blocking, since NumPy has no notion of asynchrony. It needs access to the values just like the <code>print</code> function.</p>
<p>Copying small amounts of data frequently from MXNet's scope to NumPy and back can destroy performance of an otherwise efficient code, since each such operation requires the computational graph to evaluate all intermediate results needed to get the relevant term <em>before</em> anything else can be done.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('numpy conversion'):
    b = np.dot(a, a)
    b.asnumpy()

with d2l.Benchmark('scalar conversion'):
    b = np.dot(a, a)
    b.sum().item()
</code></pre>
<h2 id="improving-computation"><a class="header" href="#improving-computation">Improving Computation</a></h2>
<p>:begin_tab:<code>mxnet</code>
On a heavily multithreaded system (even regular laptops have 4 threads or more and on multi-socket servers this number can exceed 256) the overhead of scheduling operations can become significant. This is why it is highly desirable to have computation and scheduling occur asynchronously and in parallel. To illustrate the benefit of doing so let's see what happens if we increment a variable by 1 multiple times, both in sequence or asynchronously. We simulate synchronous execution by inserting a <code>wait_to_read</code> barrier in between each addition.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('synchronous'):
    for _ in range(10000):
        y = x + 1
        y.wait_to_read()

with d2l.Benchmark('asynchronous'):
    for _ in range(10000):
        y = x + 1
    npx.waitall()
</code></pre>
<p>:begin_tab:<code>mxnet</code>
A slightly simplified interaction between the Python frontend thread and the C++ backend thread can be summarized as follows:</p>
<ol>
<li>The frontend orders the backend to insert the computation task <code>y = x + 1</code> into the queue.</li>
<li>The backend then receives the computation tasks from the queue and performs the actual computations.</li>
<li>The backend then returns the computation results to the frontend.
Assume that the durations of these three stages are $t_1, t_2$ and $t_3$, respectively. If we do not use asynchronous programming, the total time taken to perform 10000 computations is approximately $10000 (t_1+ t_2 + t_3)$. If asynchronous programming is used, the total time taken to perform 10000 computations can be reduced to $t_1 + 10000 t_2 + t_3$ (assuming $10000 t_2 &gt; 9999t_1$), since the frontend does not have to wait for the backend to return computation results for each loop.
:end_tab:</li>
</ol>
<h2 id="summary-66"><a class="header" href="#summary-66">Summary</a></h2>
<ul>
<li>Deep learning frameworks may decouple the Python frontend from an execution backend. This allows for fast asynchronous insertion of commands into the backend and associated parallelism.</li>
<li>Asynchrony leads to a rather responsive frontend. However, use caution not to overfill the task queue since it may lead to excessive memory consumption. It is recommended to synchronize for each minibatch to keep frontend and backend approximately synchronized.</li>
<li>Chip vendors offer sophisticated performance analysis tools to obtain a much more fine-grained insight into the efficiency of deep learning.</li>
</ul>
<p>:begin_tab:<code>mxnet</code></p>
<ul>
<li>Be aware of the fact that conversions from MXNet's memory management to Python will force the backend to wait until  the specific variable is ready. Functions such as <code>print</code>, <code>asnumpy</code> and <code>item</code> all have this effect. This can be desirable but a careless use of synchronization can ruin performance.
:end_tab:</li>
</ul>
<h2 id="exercises-86"><a class="header" href="#exercises-86">Exercises</a></h2>
<p>:begin_tab:<code>mxnet</code></p>
<ol>
<li>We mentioned above that using asynchronous computation can reduce the total amount of time needed to perform 10000 computations to $t_1 + 10000 t_2 + t_3$. Why do we have to assume $10000 t_2 &gt; 9999 t_1$ here?</li>
<li>Measure the difference between <code>waitall</code> and <code>wait_to_read</code>. Hint: perform a number of instructions and synchronize for an intermediate result.
:end_tab:</li>
</ol>
<p>:begin_tab:<code>pytorch</code></p>
<ol>
<li>On the CPU, benchmark the same matrix multiplication operations in this section. Can you still observe asynchrony via the backend?
:end_tab:</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/361">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/2564">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-parallelism"><a class="header" href="#automatic-parallelism">Automatic Parallelism</a></h1>
<p>:label:<code>sec_auto_para</code></p>
<p>Deep learning frameworks (e.g., MXNet and PyTorch) automatically construct computational graphs at the backend. Using a
computational graph, the system is aware of all the dependencies,
and can selectively execute multiple non-interdependent tasks in parallel to
improve speed. For instance, :numref:<code>fig_asyncgraph</code> in :numref:<code>sec_async</code> initializes two variables independently. Consequently the system can choose to execute them in parallel.</p>
<p>Typically, a single operator will use all the computational resources on all CPUs or on a single GPU. For example, the <code>dot</code> operator will use all cores (and threads) on all CPUs, even if there are multiple CPU processors on a single machine. The same applies to a single GPU. Hence parallelization is not quite so useful for single-device computers. With multiple devices things matter more. While parallelization is typically most relevant between multiple GPUs, adding the local CPU will increase performance slightly. For example, see :citet:<code>Hadjis.Zhang.Mitliagkas.ea.2016</code> that focuses on training computer vision models combining a GPU and a CPU. With the convenience of an automatically parallelizing framework we can accomplish the same goal in a few lines of Python code. More broadly, our discussion of automatic parallel computation focuses on parallel computation using both CPUs and GPUs, as well as the parallelization of computation and communication.</p>
<p>Note that we need at least two GPUs to run the experiments in this section.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
</code></pre>
<h2 id="parallel-computation-on-gpus"><a class="header" href="#parallel-computation-on-gpus">Parallel Computation on GPUs</a></h2>
<p>Let's start by defining a reference workload to test: the <code>run</code> function below performs 10 matrix-matrix multiplications on the device of our choice using data allocated into two variables: <code>x_gpu1</code> and <code>x_gpu2</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
devices = d2l.try_all_gpus()
def run(x):
    return [x.dot(x) for _ in range(50)]

x_gpu1 = np.random.uniform(size=(4000, 4000), ctx=devices[0])
x_gpu2 = np.random.uniform(size=(4000, 4000), ctx=devices[1])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
devices = d2l.try_all_gpus()
def run(x):
    return [x.mm(x) for _ in range(50)]

x_gpu1 = torch.rand(size=(4000, 4000), device=devices[0])
x_gpu2 = torch.rand(size=(4000, 4000), device=devices[1])
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Now we apply the function to the data. To ensure that caching does not play a role in the results we warm up the devices by performing a single pass on either of them prior to measuring.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Now we apply the function to the data. To ensure that caching does not play a role in the results we warm up the devices by performing a single pass on either of them prior to measuring. <code>torch.cuda.synchronize()</code> waits for all kernels in all streams on a CUDA device to complete. It takes in a <code>device</code> argument, the device for which we need to synchronize. It uses the current device, given by <code>current_device()</code>, if the device argument is <code>None</code> (default).
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
run(x_gpu1)  # Warm-up both devices
run(x_gpu2)
npx.waitall()

with d2l.Benchmark('GPU1 time'):
    run(x_gpu1)
    npx.waitall()

with d2l.Benchmark('GPU2 time'):
    run(x_gpu2)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
run(x_gpu1)
run(x_gpu2)  # Warm-up all devices
torch.cuda.synchronize(devices[0])
torch.cuda.synchronize(devices[1])

with d2l.Benchmark('GPU1 time'):
    run(x_gpu1)
    torch.cuda.synchronize(devices[0])

with d2l.Benchmark('GPU2 time'):
    run(x_gpu2)
    torch.cuda.synchronize(devices[1])
</code></pre>
<p>:begin_tab:<code>mxnet</code>
If we remove the <code>waitall</code> statement between both tasks the system is free to parallelize computation on both devices automatically.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
If we remove the <code>synchronize</code> statement between both tasks the system is free to parallelize computation on both devices automatically.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('GPU1 &amp; GPU2'):
    run(x_gpu1)
    run(x_gpu2)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
with d2l.Benchmark('GPU1 &amp; GPU2'):
    run(x_gpu1)
    run(x_gpu2)
    torch.cuda.synchronize()
</code></pre>
<p>In the above case the total execution time is less than the sum of its parts, since the deep learning framework automatically schedules computation on both GPU devices without the need for sophisticated code on behalf of the user.</p>
<h2 id="parallel-computation-and-communication"><a class="header" href="#parallel-computation-and-communication">Parallel Computation and Communication</a></h2>
<p>In many cases we need to move data between different devices, say between the CPU and GPU, or between different GPUs.
For instance,
this occurs when we want to perform distributed optimization where we need to aggregate the gradients over multiple accelerator cards. Let's simulate this by computing on the GPU and then copying the results back to the CPU.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def copy_to_cpu(x):
    return [y.copyto(npx.cpu()) for y in x]

with d2l.Benchmark('Run on GPU1'):
    y = run(x_gpu1)
    npx.waitall()

with d2l.Benchmark('Copy to CPU'):
    y_cpu = copy_to_cpu(y)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def copy_to_cpu(x, non_blocking=False):
    return [y.to('cpu', non_blocking=non_blocking) for y in x]

with d2l.Benchmark('Run on GPU1'):
    y = run(x_gpu1)
    torch.cuda.synchronize()

with d2l.Benchmark('Copy to CPU'):
    y_cpu = copy_to_cpu(y)
    torch.cuda.synchronize()
</code></pre>
<p>:begin_tab:<code>mxnet</code>
This is somewhat inefficient. Note that we could already start copying parts of <code>y</code> to the CPU while the remainder of the list is still being computed. This situation occurs, e.g., when we compute the gradient on a minibatch. The gradients of some of the parameters will be available earlier than that of others. Hence it works to our advantage to start using PCI-Express bus bandwidth while the GPU is still running. Removing <code>waitall</code> between both parts allows us to simulate this scenario.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
This is somewhat inefficient. Note that we could already start copying parts of <code>y</code> to the CPU while the remainder of the list is still being computed. This situation occurs, e.g., when we compute the (backprop) gradient on a minibatch. The gradients of some of the parameters will be available earlier than that of others. Hence it works to our advantage to start using PCI-Express bus bandwidth while the GPU is still running. In PyTorch, several functions such as <code>to()</code> and <code>copy_()</code> admit an explicit <code>non_blocking</code> argument, which lets the caller bypass synchronization when it is unnecessary. Setting <code>non_blocking=True</code> allows us to simulate this scenario.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
with d2l.Benchmark('Run on GPU1 and copy to CPU'):
    y = run(x_gpu1)
    y_cpu = copy_to_cpu(y)
    npx.waitall()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
with d2l.Benchmark('Run on GPU1 and copy to CPU'):
    y = run(x_gpu1)
    y_cpu = copy_to_cpu(y, True)
    torch.cuda.synchronize()
</code></pre>
<p>The total time required for both operations is (as expected) less than the sum of their parts.
Note that this task is different from parallel computation as it uses a different resource: the bus between the CPU and GPUs. In fact, we could compute on both devices and communicate, all at the same time. As noted above, there is a dependency between computation and communication: <code>y[i]</code> must be computed before it can be copied to the CPU. Fortunately, the system can copy <code>y[i-1]</code> while computing <code>y[i]</code> to reduce the total running time.</p>
<p>We conclude with an illustration of the computational graph and its dependencies for a simple two-layer MLP when training on a CPU and two GPUs, as depicted in :numref:<code>fig_twogpu</code>. It would be quite painful to schedule the parallel program resulting from this manually. This is where it is advantageous to have a graph-based computing backend for optimization.</p>
<p><img src="chapter_computational-performance/../img/twogpu.svg" alt="The computational graph and its dependencies of a two-layer MLP on a CPU and two GPUs." />
:label:<code>fig_twogpu</code></p>
<h2 id="summary-67"><a class="header" href="#summary-67">Summary</a></h2>
<ul>
<li>Modern systems have a variety of devices, such as multiple GPUs and CPUs. They can be used in parallel, asynchronously.</li>
<li>Modern systems also have a variety of resources for communication, such as PCI Express, storage (typically solid-state drives or via networks), and network bandwidth. They can be used in parallel for peak efficiency.</li>
<li>The backend can improve performance through automatic parallel computation and communication.</li>
</ul>
<h2 id="exercises-87"><a class="header" href="#exercises-87">Exercises</a></h2>
<ol>
<li>Eight operations were performed in the <code>run</code> function defined in this section. There are no dependencies between them. Design an experiment to see if the deep learning framework will automatically execute them in parallel.</li>
<li>When the workload of an individual operator is sufficiently small, parallelization can help even on a single CPU or GPU. Design an experiment to verify this.</li>
<li>Design an experiment that uses parallel computation on CPUs, GPUs, and communication between both devices.</li>
<li>Use a debugger such as NVIDIA's <a href="https://developer.nvidia.com/nsight-compute-2019_5">Nsight</a> to verify that your code is efficient.</li>
<li>Designing computation tasks that include more complex data dependencies, and run experiments to see if you can obtain the correct results while improving performance.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/362">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1681">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware"><a class="header" href="#hardware">Hardware</a></h1>
<p>:label:<code>sec_hardware</code></p>
<p>Building systems with great performance requires a good understanding of the algorithms and models to capture the statistical aspects of the problem. At the same time it is also indispensable to have at least a modicum of knowledge of the underlying hardware. The current section is no substitute for a proper course on hardware and system design. Instead, it might serve as a starting point for understanding why some algorithms are more efficient than others and how to achieve good throughput. A good design can easily make a difference of an order of magnitude and, in turn, this can make the difference between being able to train a network (e.g., in a week) and not at all (in 3 months, thus missing the deadline).
We will start by looking at computers. Then we will zoom in to look more carefully at CPUs and GPUs. Lastly we zoom out to review how multiple computers are connected in a server center or in the cloud.</p>
<p><img src="chapter_computational-performance/../img/latencynumbers.png" alt="Latency Numbers that every programmer should know." />
:label:<code>fig_latencynumbers</code></p>
<p>Impatient readers may be able to get by with :numref:<code>fig_latencynumbers</code>. It is taken from Colin Scott's <a href="https://people.eecs.berkeley.edu/%7Ercs/research/interactive_latency.html">interactive post</a> that gives a good overview of the progress over the past decade. The original numbers are due to Jeff Dean's <a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/Stanford-DL-Nov-2010.pdf">Stanford talk from 2010</a>.
The discussion below explains some of the rationale for these numbers and how they can guide us in designing algorithms. The discussion below is very high level and cursory. It is clearly <em>no substitute</em> for a proper course but rather just meant to provide enough information for a statistical modeler to make suitable design decisions. For an in-depth overview of computer architecture we refer the reader to :cite:<code>Hennessy.Patterson.2011</code> or a recent course on the subject, such as the one by <a href="http://inst.eecs.berkeley.edu/%7Ecs152/sp19/">Arste Asanovic</a>.</p>
<h2 id="computers"><a class="header" href="#computers">Computers</a></h2>
<p>Most deep learning researchers and practitioners have access to a computer with a fair amount of memory, computation, some form of an accelerator such as a GPU, or multiples thereof. A computer consists of the following key components:</p>
<ul>
<li>A processor (also referred to as a CPU) that is able to execute the programs we give it (in addition to running an operating system and many other things), typically consisting of 8 or more cores.</li>
<li>Memory (RAM) to store and retrieve the results from computation, such as weight vectors and activations, and training data.</li>
<li>An Ethernet network connection (sometimes multiple) with speeds ranging from 1 GB/s to 100 GB/s. On high end servers more advanced interconnects can be found.</li>
<li>A high speed expansion bus (PCIe) to connect the system to one or more GPUs. Servers have up to 8 accelerators, often connected in an advanced topology, while desktop systems have 1 or 2, depending on the budget of the user and the size of the power supply.</li>
<li>Durable storage, such as a magnetic hard disk drive, a solid state drive, in many cases connected using the PCIe bus. It provides efficient transfer of training data to the system and storage of intermediate checkpoints as needed.</li>
</ul>
<p><img src="chapter_computational-performance/../img/mobo-symbol.svg" alt="Connectivity of components of a computer." />
:label:<code>fig_mobo-symbol</code></p>
<p>As :numref:<code>fig_mobo-symbol</code> indicates, most components (network, GPU, and storage) are connected to the CPU across the PCIe bus. It consists of multiple lanes that are directly attached to the CPU. For instance AMD's Threadripper 3 has 64 PCIe 4.0 lanes, each of which is capable 16 Gbit/s data transfer in both directions. The memory is directly attached to the CPU with a total bandwidth of up to 100 GB/s.</p>
<p>When we run code on a computer we need to shuffle data to the processors (CPUs or GPUs), perform computation, and then move the results off the processor back to RAM and durable storage. Hence, in order to get good performance we need to make sure that this works seamlessly without any one of the systems becoming a major bottleneck. For instance, if we cannot load images quickly enough the processor will not have any work to do. Likewise, if we cannot move matrices quickly enough to the CPU (or GPU), its processing elements will starve. Finally, if we want to synchronize multiple computers across the network, the latter should not slow down computation. One option is to interleave communication and computation. Let's have a look at the various components in more detail.</p>
<h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<p>At its most basic memory is used to store data that needs to be readily accessible. At present CPU RAM is typically of the <a href="https://en.wikipedia.org/wiki/DDR4_SDRAM">DDR4</a> variety, offering 20--25 GB/s bandwidth per module. Each module has a 64-bit-wide bus. Typically pairs of memory modules are used to allow for multiple channels. CPUs have between 2 and 4 memory channels, i.e., they have between 4 0GB/s and 100 GB/s peak memory bandwidth. Often there are two banks per channel. For instance AMD's Zen 3 Threadripper has 8 slots.</p>
<p>While these numbers are impressive, indeed, they only tell part of the story. When we want to read a portion from memory we first need to tell the memory module where the information can be found. That is, we first need to send the <em>address</em> to RAM. Once this is accomplished we can choose to read just a single 64 bit record or a long sequence of records. The latter is called <em>burst read</em>. In a nutshell, sending an address to memory and setting up the transfer takes approximately 100 ns (details depend on the specific timing coefficients of the memory chips used), every subsequent transfer takes only 0.2 ns. In short, the first read is 500 times as expensive as subsequent ones! Note that we could perform up to 10,000,000 random reads per second. This suggests that we avoid random memory access as far as possible and use burst reads (and writes) instead.</p>
<p>Matters are a bit more complex when we take into account that we have multiple <em>banks</em>. Each bank can read memory largely independently. This means two things.
On the one hand, the effective number of random reads is up to 4 times higher, provided that they are spread evenly across memory. It also means that it is still a bad idea to perform random reads since burst reads are 4 times faster, too. On the other hand, due to memory alignment to 64 bit boundaries it is a good idea to align any data structures with the same boundaries. Compilers do this pretty much <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">automatically</a> when the appropriate flags are set. Curious readers are encouraged to review a lecture on DRAMs such as the one by <a href="http://web.cecs.pdx.edu/%7Ezeshan/ece585_lec5.pdf">Zeshan Chishti</a>.</p>
<p>GPU memory is subject to even higher bandwidth requirements since they have many more processing elements than CPUs. By and large there are two options to address them. The first is to make the memory bus significantly wider. For instance, NVIDIA's RTX 2080 Ti has a 352-bit-wide bus. This allows for much more information to be transferred at the same time. Second, GPUs use specific high-performance memory. Consumer-grade devices, such as NVIDIA's RTX and Titan series typically use <a href="https://en.wikipedia.org/wiki/GDDR6_SDRAM">GDDR6</a> chips with over 500 GB/s aggregate bandwidth. An alternative is to use HBM (high bandwidth memory) modules. They use a very different interface and connect directly with GPUs on a dedicated silicon wafer. This makes them very expensive and their use is typically limited to high-end server chips, such as the NVIDIA Volta V100 series of accelerators. Quite unsurprisingly, GPU memory is generally <em>much</em> smaller than CPU memory due to the higher cost of the former. For our purposes, by and large their performance characteristics are similar, just a lot faster. We can safely ignore the details for the purpose of this book. They only matter when tuning GPU kernels for high throughput.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>We saw that some of the key characteristics of RAM are <em>bandwidth</em> and <em>latency</em>. The same is true for storage devices, just that the differences can be even more extreme.</p>
<h3 id="hard-disk-drives"><a class="header" href="#hard-disk-drives">Hard Disk Drives</a></h3>
<p><em>Hard disk drives</em> (HDDs) have been in use for over half a century. In a nutshell they contain a number of spinning platters with heads that can be positioned to read or write at any given track. High-end disks hold up to 16 TB on 9 platters. One of the key benefits of HDDs is that they are relatively inexpensive. One of their many downsides are their typically catastrophic failure modes and their relatively high read latency.</p>
<p>To understand the latter, consider the fact that HDDs spin at around 7,200 RPM (revolutions per minute). If they were much faster they would shatter due to the centrifugal force exerted on the platters. This has a major downside when it comes to accessing a specific sector on the disk: we need to wait until the platter has rotated in position (we can move the heads but not accelerate the actual disks). Hence it can take over 8 ms until the requested data is available. A common way this is expressed is to say that HDDs can operate at approximately 100 IOPs (input/output operations per second). This number has essentially remained unchanged for the past two decades. Worse still, it is equally difficult to increase bandwidth (it is in the order of 100--200 MB/s). After all, each head reads a track of bits, hence the bit rate only scales with the square root of the information density. As a result, HDDs are quickly becoming relegated to archival storage and low-grade storage for very large datasets.</p>
<h3 id="solid-state-drives"><a class="header" href="#solid-state-drives">Solid State Drives</a></h3>
<p>Solid state drives (SSDs) use flash memory to store information persistently. This allows for <em>much faster</em> access to stored records. Modern SSDs can operate at 100,000 to 500,000 IOPs, i.e., up to 3 orders of magnitude faster than HDDs. Furthermore, their bandwidth can reach 1--3GB/s, i.e., one order of magnitude faster than HDDs. These improvements sound almost too good to be true. Indeed, they come with the following caveats, due to the way SSDs are designed.</p>
<ul>
<li>SSDs store information in blocks (256 KB or larger). They can only be written as a whole, which takes significant time. Consequently bit-wise random writes on SSD have very poor performance. Likewise, writing data in general takes significant time since the block has to be read, erased and then rewritten with new information. By now SSD controllers and firmware have developed algorithms to mitigate this. Nonetheless, writes can be much slower, in particular for QLC (quad level cell) SSDs. The key for improved performance is to maintain a <em>queue</em> of operations, to prefer reads and to write in large blocks if possible.</li>
<li>The memory cells in SSDs wear out relatively quickly (often already after a few thousand writes). Wear-level protection algorithms are able to spread the degradation over many cells. That said, it is not recommended to use SSDs for swapping files or for large aggregations of log-files.</li>
<li>Lastly, the massive increase in bandwidth has forced computer designers to attach SSDs directly to the PCIe bus. The drives capable of handling this, referred to as NVMe (Non Volatile Memory enhanced), can use up to 4 PCIe lanes. This amounts to up to 8GB/s on PCIe 4.0.</li>
</ul>
<h3 id="cloud-storage"><a class="header" href="#cloud-storage">Cloud Storage</a></h3>
<p>Cloud storage provides a configurable range of performance. That is, the assignment of storage to virtual machines is dynamic, both in terms of quantity and in terms of speed, as chosen by users. We recommend that users increase the provisioned number of IOPs whenever latency is too high, e.g., during training with many small records.</p>
<h2 id="cpus"><a class="header" href="#cpus">CPUs</a></h2>
<p>Central processing units (CPUs) are the centerpiece of any computer. They consist of a number of key components: <em>processor cores</em> that are able to execute machine code, a <em>bus</em> connecting them (the specific topology differs significantly between processor models, generations, and vendors), and <em>caches</em> to allow for higher bandwidth and lower latency memory access than what is possible by reads from main memory. Lastly, almost all modern CPUs contain <em>vector processing units</em> to aid with high performance linear algebra and convolutions, as they are common in media processing and machine learning.</p>
<p><img src="chapter_computational-performance/../img/skylake.svg" alt="Intel Skylake consumer quad-core CPU." />
:label:<code>fig_skylake</code></p>
<p>:numref:<code>fig_skylake</code> depicts an Intel Skylake consumer-grade quad-core CPU. It has an integrated GPU, caches, and a ringbus connecting the four cores. Peripherals, such as Ethernet, WiFi, Bluetooth, SSD controller, and USB, are either part of the chipset or directly attached (PCIe) to the CPU.</p>
<h3 id="microarchitecture"><a class="header" href="#microarchitecture">Microarchitecture</a></h3>
<p>Each of the processor cores consists of a rather sophisticated set of components. While details differ between generations and vendors, the basic functionality is pretty much standard. The front-end loads instructions and tries to predict which path will be taken (e.g., for control flow). Instructions are then decoded from assembly code to microinstructions. Assembly code is often not the lowest level code that a processor executes. Instead, complex instructions may be decoded into a set of more lower level operations. These are then processed by the actual execution core. Often the latter is capable of performing many operations simultaneously. For instance, the ARM Cortex A77 core of :numref:<code>fig_cortexa77</code> is able to perform up to 8 operations simultaneously.</p>
<p><img src="chapter_computational-performance/../img/a77.svg" alt="ARM Cortex A77 Microarchitecture." />
:label:<code>fig_cortexa77</code></p>
<p>This means that efficient programs might be able to perform more than one instruction per clock cycle, provided that they can be carried out independently. Not all units are created equal. Some specialize in integer instructions whereas others are optimized for floating point performance. To increase throughput, the processor might also follow  multiple code paths simultaneously in a branching instruction and then discard the results of the branches not taken. This is why branch prediction units matter (on the front-end) such that only the most promising paths are pursued.</p>
<h3 id="vectorization-1"><a class="header" href="#vectorization-1">Vectorization</a></h3>
<p>Deep learning is extremely compute-hungry. Hence, to make CPUs suitable for machine learning, one needs to perform many operations in one clock cycle. This is achieved via vector units. They have different names: on ARM they are called NEON, on x86 they (a recent generation) are referred to as <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX2</a> units. A common aspect is that they are able to perform SIMD (single instruction multiple data) operations. :numref:<code>fig_neon128</code> shows how 8 short integers can be added in one clock cycle on ARM.</p>
<p><img src="chapter_computational-performance/../img/neon128.svg" alt="128 bit NEON vectorization." />
:label:<code>fig_neon128</code></p>
<p>Depending on architecture choices, such registers are up to 512 bits long, allowing for the combination of up to 64 pairs of numbers. For instance, we might be multiplying two numbers and adding them to a third, which is also known as a fused multiply-add. Intel's <a href="https://01.org/openvinotoolkit">OpenVino</a> uses these to achieve respectable throughput for deep learning on server-grade CPUs. Note, though, that this number is entirely dwarfed by what GPUs are capable of achieving. For instance, NVIDIA's RTX 2080 Ti has 4,352 CUDA cores, each of which is capable of processing such an operation at any time.</p>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<p>Consider the following situation: we have a modest CPU core with 4 cores as depicted in :numref:<code>fig_skylake</code> above, running at 2 GHz frequency.
Moreover, let's assume that we have an IPC (instructions per clock) count of 1 and that the units have AVX2 with 256-bit width enabled. Let's furthermore assume that at least one of the registers used for AVX2 operations needs to be retrieved from memory. This means that the CPU consumes $4 \times 256 \textrm{ bit} = 128 \textrm{ bytes}$ of data per clock cycle. Unless we are able to transfer $2 \times 10^9 \times 128 = 256 \times 10^9$ bytes to the processor per second the processing elements are going to starve. Unfortunately the memory interface of such a chip only supports 20--40 GB/s data transfer, i.e., one order of magnitude less. The fix is to avoid loading <em>new</em> data from memory as far as possible and rather to cache it locally on the CPU. This is where caches come in handy. Commonly the following names or concepts are used:</p>
<ul>
<li><strong>Registers</strong> are strictly speaking not part of the cache. They help stage instructions. That said, CPU registers are memory locations that a CPU can access at clock speed without any delay penalty. CPUs have tens of registers. It is up to the compiler (or programmer) to use registers efficiently. For instance the C programming language has a <code>register</code> keyword.</li>
<li><strong>L1 caches</strong> are the first line of defense against high memory bandwidth requirements. L1 caches are tiny (typical sizes might be 32--64 KB) and often split into data and instructions caches. When data is found in the L1 cache, access is very fast. If they cannot be found there, the search progresses down the cache hierarchy.</li>
<li><strong>L2 caches</strong> are the next stop. Depending on architecture design and processor size they might be exclusive. They might be accessible only by a given core or shared among multiple cores. L2 caches are larger (typically 256--512 KB per core) and slower than L1. Furthermore, to access something in L2 we first need to check to realize that the data is not in L1, which adds a small amount of extra latency.</li>
<li><strong>L3 caches</strong> are shared among multiple cores and can be quite large. AMD's Epyc 3 server CPUs have a whopping 256 MB of cache spread across multiple chiplets. More typical numbers are in the 4--8 MB range.</li>
</ul>
<p>Predicting which memory elements will be needed next is one of the key optimization parameters in chip design. For instance, it is advisable to traverse memory in a <em>forward</em> direction since most caching algorithms will try to <em>read ahead</em> rather than backwards. Likewise, keeping memory access patterns local is a good way of improving performance.</p>
<p>Adding caches is a double-edge sword. On the one hand they ensure that the processor cores do not starve of data. At the same time they increase chip size, using up area that otherwise could have been spent on increasing processing power. Moreover, <em>cache misses</em> can be expensive. Consider the worst case scenario, <em>false sharing</em>, as depicted in :numref:<code>fig_falsesharing</code>. A memory location is cached on processor 0 when a thread on processor 1 requests the data. To obtain it, processor 0 needs to stop what it is doing, write the information back to main memory and then let processor 1 read it from memory. During this operation both processors wait. Quite potentially such code runs <em>more slowly</em> on multiple processors when compared with an efficient single-processor implementation. This is one more reason for why there is a practical limit to cache sizes (besides their physical size).</p>
<p><img src="chapter_computational-performance/../img/falsesharing.svg" alt="False sharing (image courtesy of Intel)." />
:label:<code>fig_falsesharing</code></p>
<h2 id="gpus-and-other-accelerators"><a class="header" href="#gpus-and-other-accelerators">GPUs and other Accelerators</a></h2>
<p>It is not an exaggeration to claim that deep learning would not have been successful without GPUs. By the same token, it is quite reasonable to argue that GPU manufacturers' fortunes have increased significantly due to deep learning. This co-evolution of hardware and algorithms has led to a situation where for better or worse deep learning is the preferable statistical modeling paradigm. Hence it pays to understand the specific benefits that GPUs and related accelerators such as the TPU :cite:<code>Jouppi.Young.Patil.ea.2017</code>.</p>
<p>Of note is a distinction that is often made in practice: accelerators are optimized either for training or inference. For the latter we only need to compute the forward propagation in a network. No storage of intermediate data is needed for backpropagation. Moreover, we may not need very precise computation (FP16 or INT8 typically suffice). On the other hand, during training all intermediate results need storage to compute gradients. Moreover, accumulating gradients requires higher precision to avoid numerical underflow (or overflow). This means that FP16 (or mixed precision with FP32) is the minimum requirement. All of this necessitates faster and larger memory (HBM2 vs. GDDR6) and more processing power. For instance, NVIDIA's <a href="https://devblogs.nvidia.com/nvidia-turing-architecture-in-depth/">Turing</a> T4 GPUs are optimized for inference whereas the V100 GPUs are preferable for training.</p>
<p>Recall vectorization as illustrated in :numref:<code>fig_neon128</code>. Adding vector units to a processor core allowed us to increase throughput significantly. For example, in the example in :numref:<code>fig_neon128</code> we were able to perform 16 operations simultaneously.
First,
what if we added operations that optimized not just operations between vectors but also between matrices? This strategy led to tensor cores (to be covered shortly).
Second, what if we added many more cores? In a nutshell, these two strategies summarize the design decisions in GPUs. :numref:<code>fig_turing_processing_block</code> gives an overview of a basic processing block. It contains 16 integer and 16 floating point units. In addition to that, two tensor cores accelerate a narrow subset of additional operations relevant for deep learning. Each streaming multiprocessor consists of four such blocks.</p>
<p><img src="chapter_computational-performance/../img/turing-processing-block.png" alt="NVIDIA Turing processing block (image courtesy of NVIDIA)." />
:width:<code>150px</code>
:label:<code>fig_turing_processing_block</code></p>
<p>Next, 12 streaming multiprocessors are grouped into graphics processing clusters which make up the high-end TU102 processors. Ample memory channels and an L2 cache complement the setup. :numref:<code>fig_turing</code> has the relevant details. One of the reasons for designing such a device is that individual blocks can be added or removed as needed to allow for more compact chips and to deal with yield issues (faulty modules might not be activated). Fortunately programming such devices is well hidden from the casual deep learning researcher beneath layers of CUDA and framework code. In particular, more than one of the programs might well be executed simultaneously on the GPU, provided that there are available resources. Nonetheless it pays to be aware of the limitations of the devices to avoid picking models that do not fit into device memory.</p>
<p><img src="chapter_computational-performance/../img/turing.png" alt="NVIDIA Turing architecture (image courtesy of NVIDIA)" />
:width:<code>350px</code>
:label:<code>fig_turing</code></p>
<p>A last aspect that is worth mentioning in more detail are <em>tensor cores</em>. They are an example of a recent trend of adding more optimized circuits that are specifically effective for deep learning. For instance, the TPU added a systolic array :cite:<code>Kung.1988</code> for fast matrix multiplication. There the design was to support a very small number (one for the first generation of TPUs) of large operations. Tensor cores are at the other end. They are optimized for small operations involving between $4 \times 4$ and $16 \times 16$ matrices, depending on their numerical precision. :numref:<code>fig_tensorcore</code> gives an overview of the optimizations.</p>
<p><img src="chapter_computational-performance/../img/tensorcore.jpg" alt="NVIDIA tensor cores in Turing (image courtesy of NVIDIA)." />
:width:<code>400px</code>
:label:<code>fig_tensorcore</code></p>
<p>Obviously when optimizing for computation we end up making certain compromises. One of them is that GPUs are not very good at handling interrupts and sparse data. While there are notable exceptions, such as <a href="https://github.com/gunrock/gunrock">Gunrock</a> :cite:<code>Wang.Davidson.Pan.ea.2016</code>, the access pattern of sparse matrices and vectors do not go well with the high bandwidth burst read operations where GPUs excel. Matching both goals is an area of active research. See e.g., <a href="http://dgl.ai">DGL</a>, a library tuned for deep learning on graphs.</p>
<h2 id="networks-and-buses"><a class="header" href="#networks-and-buses">Networks and Buses</a></h2>
<p>Whenever a single device is insufficient for optimization we need to transfer data to and from it to synchronize processing. This is where networks and buses come in handy. We have a number of design parameters: bandwidth, cost, distance, and flexibility.
On one end we have WiFi that has a pretty good range, is very easy to use (no wires, after all), cheap but it offers comparatively mediocre bandwidth and latency. No machine learning researcher within their right mind would use it to build a cluster of servers. In what follows we focus on interconnects that are suitable for deep learning.</p>
<ul>
<li><strong>PCIe</strong> is a dedicated bus for very high bandwidth point-to-point connections (up to 32 GB/s on PCIe 4.0 in a 16-lane slot) per lane. Latency is in the order of single-digit microseconds (5 μs). PCIe links are precious. Processors only have a limited number of them: AMD's EPYC 3 has 128 lanes, Intel's Xeon has up to 48 lanes per chip; on desktop-grade CPUs the numbers are 20 (Ryzen 9) and 16 (Core i9) respectively. Since GPUs have typically 16 lanes, this limits the number of GPUs that can connect to the CPU at full bandwidth. After all, they need to share the links with other high bandwidth peripherals such as storage and Ethernet. Just like with RAM access, large bulk transfers are preferable due to reduced packet overhead.</li>
<li><strong>Ethernet</strong> is the most commonly used way of connecting computers. While it is significantly slower than PCIe, it is very cheap and resilient to install and covers much longer distances. Typical bandwidth for low-grade servers is 1 GBit/s. Higher-end devices (e.g., <a href="https://aws.amazon.com/ec2/instance-types/c5/">C5 instances</a> in the cloud) offer between 10 and 100 GBit/s bandwidth. As in all previous cases data transmission has significant overheads. Note that we almost never use raw Ethernet directly but rather a protocol that is executed on top of the physical interconnect (such as UDP or TCP/IP). This adds further overhead. Like PCIe, Ethernet is designed to connect two devices, e.g., a computer and a switch.</li>
<li><strong>Switches</strong> allow us to connect multiple devices in a manner where any pair of them can carry out a (typically full bandwidth) point-to-point connection simultaneously. For instance, Ethernet switches might connect 40 servers at high cross-sectional bandwidth. Note that switches are not unique to traditional computer networks. Even PCIe lanes can be <a href="https://www.broadcom.com/products/pcie-switches-bridges/pcie-switches">switched</a>. This occurs, e.g., to connect a large number of GPUs to a host processor, as is the case for the <a href="https://aws.amazon.com/ec2/instance-types/p2/">P2 instances</a>.</li>
<li><strong>NVLink</strong> is an alternative to PCIe when it comes to very high bandwidth interconnects. It offers up to 300 Gbit/s data transfer rate per link. Server GPUs (Volta V100) have six links whereas consumer-grade GPUs (RTX 2080 Ti) have only one link, operating at a reduced 100 Gbit/s rate. We recommend to use <a href="https://github.com/NVIDIA/nccl">NCCL</a> to achieve high data transfer between GPUs.</li>
</ul>
<h2 id="more-latency-numbers"><a class="header" href="#more-latency-numbers">More Latency Numbers</a></h2>
<p>The summary in :numref:<code>table_latency_numbers</code> and :numref:<code>table_latency_numbers_tesla</code> are from <a href="https://gist.github.com/eshelman">Eliot Eshelman</a> who maintains an updated version of the numbers as a <a href="https://gist.github.com/eshelman/343a1c46cb3fba142c1afdcdeec17646">GitHub gist</a>.</p>
<p>:Common Latency Numbers.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Action</th><th style="text-align: right">Time</th><th style="text-align: left">Notes</th></tr></thead><tbody>
<tr><td style="text-align: left">L1 cache reference/hit</td><td style="text-align: right">1.5 ns</td><td style="text-align: left">4 cycles</td></tr>
<tr><td style="text-align: left">Floating-point add/mult/FMA</td><td style="text-align: right">1.5 ns</td><td style="text-align: left">4 cycles</td></tr>
<tr><td style="text-align: left">L2 cache reference/hit</td><td style="text-align: right">5 ns</td><td style="text-align: left">12 ~ 17 cycles</td></tr>
<tr><td style="text-align: left">Branch mispredict</td><td style="text-align: right">6 ns</td><td style="text-align: left">15 ~ 20 cycles</td></tr>
<tr><td style="text-align: left">L3 cache hit (unshared cache)</td><td style="text-align: right">16 ns</td><td style="text-align: left">42 cycles</td></tr>
<tr><td style="text-align: left">L3 cache hit (shared in another core)</td><td style="text-align: right">25 ns</td><td style="text-align: left">65 cycles</td></tr>
<tr><td style="text-align: left">Mutex lock/unlock</td><td style="text-align: right">25 ns</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">L3 cache hit (modified in another core)</td><td style="text-align: right">29 ns</td><td style="text-align: left">75 cycles</td></tr>
<tr><td style="text-align: left">L3 cache hit (on a remote CPU socket)</td><td style="text-align: right">40 ns</td><td style="text-align: left">100 ~ 300 cycles (40 ~ 116 ns)</td></tr>
<tr><td style="text-align: left">QPI hop to a another CPU (per hop)</td><td style="text-align: right">40 ns</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">64MB memory ref. (local CPU)</td><td style="text-align: right">46 ns</td><td style="text-align: left">TinyMemBench on Broadwell E5-2690v4</td></tr>
<tr><td style="text-align: left">64MB memory ref. (remote CPU)</td><td style="text-align: right">70 ns</td><td style="text-align: left">TinyMemBench on Broadwell E5-2690v4</td></tr>
<tr><td style="text-align: left">256MB memory ref. (local CPU)</td><td style="text-align: right">75 ns</td><td style="text-align: left">TinyMemBench on Broadwell E5-2690v4</td></tr>
<tr><td style="text-align: left">Intel Optane random write</td><td style="text-align: right">94 ns</td><td style="text-align: left">UCSD Non-Volatile Systems Lab</td></tr>
<tr><td style="text-align: left">256MB memory ref. (remote CPU)</td><td style="text-align: right">120 ns</td><td style="text-align: left">TinyMemBench on Broadwell E5-2690v4</td></tr>
<tr><td style="text-align: left">Intel Optane random read</td><td style="text-align: right">305 ns</td><td style="text-align: left">UCSD Non-Volatile Systems Lab</td></tr>
<tr><td style="text-align: left">Send 4KB over 100 Gbps HPC fabric</td><td style="text-align: right">1 μs</td><td style="text-align: left">MVAPICH2 over Intel Omni-Path</td></tr>
<tr><td style="text-align: left">Compress 1KB with Google Snappy</td><td style="text-align: right">3 μs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Send 4KB over 10 Gbps ethernet</td><td style="text-align: right">10 μs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Write 4KB randomly to NVMe SSD</td><td style="text-align: right">30 μs</td><td style="text-align: left">DC P3608 NVMe SSD (QOS 99% is 500μs)</td></tr>
<tr><td style="text-align: left">Transfer 1MB to/from NVLink GPU</td><td style="text-align: right">30 μs</td><td style="text-align: left">~33GB/s on NVIDIA 40GB NVLink</td></tr>
<tr><td style="text-align: left">Transfer 1MB to/from PCI-E GPU</td><td style="text-align: right">80 μs</td><td style="text-align: left">~12GB/s on PCIe 3.0 x16 link</td></tr>
<tr><td style="text-align: left">Read 4KB randomly from NVMe SSD</td><td style="text-align: right">120 μs</td><td style="text-align: left">DC P3608 NVMe SSD (QOS 99%)</td></tr>
<tr><td style="text-align: left">Read 1MB sequentially from NVMe SSD</td><td style="text-align: right">208 μs</td><td style="text-align: left">~4.8GB/s DC P3608 NVMe SSD</td></tr>
<tr><td style="text-align: left">Write 4KB randomly to SATA SSD</td><td style="text-align: right">500 μs</td><td style="text-align: left">DC S3510 SATA SSD (QOS 99.9%)</td></tr>
<tr><td style="text-align: left">Read 4KB randomly from SATA SSD</td><td style="text-align: right">500 μs</td><td style="text-align: left">DC S3510 SATA SSD (QOS 99.9%)</td></tr>
<tr><td style="text-align: left">Round trip within same data center</td><td style="text-align: right">500 μs</td><td style="text-align: left">One-way ping is ~250μs</td></tr>
<tr><td style="text-align: left">Read 1MB sequentially from SATA SSD</td><td style="text-align: right">2 ms</td><td style="text-align: left">~550MB/s DC S3510 SATA SSD</td></tr>
<tr><td style="text-align: left">Read 1MB sequentially from disk</td><td style="text-align: right">5 ms</td><td style="text-align: left">~200MB/s server HDD</td></tr>
<tr><td style="text-align: left">Random Disk Access (seek+rotation)</td><td style="text-align: right">10 ms</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Send packet CA-&gt;Netherlands-&gt;CA</td><td style="text-align: right">150 ms</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">:label:<code>table_latency_numbers</code></td><td style="text-align: right"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>:Latency Numbers for NVIDIA Tesla GPUs.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Action</th><th style="text-align: right">Time</th><th style="text-align: left">Notes</th></tr></thead><tbody>
<tr><td style="text-align: left">GPU Shared Memory access</td><td style="text-align: right">30 ns</td><td style="text-align: left">30~90 cycles (bank conflicts add latency)</td></tr>
<tr><td style="text-align: left">GPU Global Memory access</td><td style="text-align: right">200 ns</td><td style="text-align: left">200~800 cycles</td></tr>
<tr><td style="text-align: left">Launch CUDA kernel on GPU</td><td style="text-align: right">10 μs</td><td style="text-align: left">Host CPU instructs GPU to start kernel</td></tr>
<tr><td style="text-align: left">Transfer 1MB to/from NVLink GPU</td><td style="text-align: right">30 μs</td><td style="text-align: left">~33GB/s on NVIDIA 40GB NVLink</td></tr>
<tr><td style="text-align: left">Transfer 1MB to/from PCI-E GPU</td><td style="text-align: right">80 μs</td><td style="text-align: left">~12GB/s on PCI-Express x16 link</td></tr>
<tr><td style="text-align: left">:label:<code>table_latency_numbers_tesla</code></td><td style="text-align: right"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h2 id="summary-68"><a class="header" href="#summary-68">Summary</a></h2>
<ul>
<li>Devices have overheads for operations. Hence it is important to aim for a small number of large transfers rather than many small ones. This applies to RAM, SSDs, networks and GPUs.</li>
<li>Vectorization is key for performance. Make sure you are aware of the specific abilities of your accelerator. E.g., some Intel Xeon CPUs are particularly good for INT8 operations, NVIDIA Volta GPUs excel at FP16 matrix-matrix operations and NVIDIA Turing shines at FP16, INT8, and INT4 operations.</li>
<li>Numerical overflow due to small data types can be a problem during training (and to a lesser extent during inference).</li>
<li>Aliasing can significantly degrade performance. For instance, memory alignment on 64 bit CPUs should be done with respect to 64 bit boundaries. On GPUs it is a good idea to keep convolution sizes aligned, e.g., to tensor cores.</li>
<li>Match your algorithms to the hardware (e.g., memory footprint, and bandwidth). Great speedup (orders of magnitude) can be achieved when fitting the parameters into caches.</li>
<li>We recommend that you sketch out the performance of a novel algorithm on paper before verifying the experimental results. Discrepancies of an order-of-magnitude or more are reasons for concern.</li>
<li>Use profilers to debug performance bottlenecks.</li>
<li>Training and inference hardware have different sweet spots in terms of price and performance.</li>
</ul>
<h2 id="exercises-88"><a class="header" href="#exercises-88">Exercises</a></h2>
<ol>
<li>Write C code to test whether there is any difference in speed between accessing memory aligned or misaligned relative to the external memory interface. Hint: be careful of caching effects.</li>
<li>Test the difference in speed between accessing memory in sequence or with a given stride.</li>
<li>How could you measure the cache sizes on a CPU?</li>
<li>How would you lay out data across multiple memory channels for maximum bandwidth? How would you lay it out if you had many small threads?</li>
<li>An enterprise-class HDD is spinning at 10,000 rpm. What is the absolutely minimum time an HDD needs to spend worst case before it can read data (you can assume that heads move almost instantaneously)? Why are 2.5" HDDs becoming popular for commercial servers (relative to 3.5" and 5.25" drives)?</li>
<li>Assume that an HDD manufacturer increases the storage density from 1 Tbit per square inch to 5 Tbit per square inch. How much information can you store on a ring on a 2.5" HDD? Is there a difference between the inner and outer tracks?</li>
<li>Going from 8 bit to 16 bit data types increases the amount of silicon approximately by four times. Why? Why might NVIDIA have added INT4 operations to their Turing GPUs?</li>
<li>How much faster is it to read forward through memory vs. reading backwards? Does this number differ between different computers and CPU vendors? Why? Write C code and experiment with it.</li>
<li>Can you measure the cache size of your disk? What is it for a typical HDD? Do SSDs need a cache?</li>
<li>Measure the packet overhead when sending messages across the Ethernet. Look up the difference between UDP and TCP/IP connections.</li>
<li>Direct memory access allows devices other than the CPU to write (and read) directly to (from) memory. Why is this a good idea?</li>
<li>Look at the performance numbers for the Turing T4 GPU. Why does the performance "only" double as you go from FP16 to INT8 and INT4?</li>
<li>What is the shortest time it should take for a packet on a round trip between San Francisco and Amsterdam? Hint: you can assume that the distance is 10,000 km.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/363">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="training-on-multiple-gpus"><a class="header" href="#training-on-multiple-gpus">Training on Multiple GPUs</a></h1>
<p>:label:<code>sec_multi_gpu</code></p>
<p>So far we discussed how to train models efficiently on CPUs and GPUs. We even showed how deep learning frameworks allow one to parallelize computation and communication automatically between them in :numref:<code>sec_auto_para</code>. We also showed in :numref:<code>sec_use_gpu</code> how to list all the available GPUs on a computer using the <code>nvidia-smi</code> command.
What we did <em>not</em> discuss is how to actually parallelize deep learning training.
Instead, we implied in passing that one would somehow split the data across multiple devices and make it work. The present section fills in the details and shows how to train a network in parallel when starting from scratch. Details on how to take advantage of functionality in high-level APIs is relegated to :numref:<code>sec_multi_gpu_concise</code>.
We assume that you are familiar with minibatch stochastic gradient descent algorithms such as the ones described in :numref:<code>sec_minibatch_sgd</code>.</p>
<h2 id="splitting-the-problem"><a class="header" href="#splitting-the-problem">Splitting the Problem</a></h2>
<p>Let's start with a simple computer vision problem and a slightly archaic network, e.g., with multiple layers of convolutions, pooling, and possibly a few fully connected layers in the end.
That is, let's start with a network that looks quite similar to LeNet :cite:<code>LeCun.Bottou.Bengio.ea.1998</code> or AlexNet :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>.
Given multiple GPUs (2 if it is a desktop server, 4 on an AWS g4dn.12xlarge instance, 8 on a p3.16xlarge, or 16 on a p2.16xlarge), we want to partition training in a manner as to achieve good speedup while simultaneously benefitting from simple and reproducible design choices. Multiple GPUs, after all, increase both <em>memory</em> and <em>computation</em> ability. In a nutshell, we have the following choices, given a minibatch of training data that we want to classify.</p>
<p>First, we could partition the network across multiple GPUs. That is, each GPU takes as input the data flowing into a particular layer, processes data across a number of subsequent layers and then sends the data to the next GPU.
This allows us to process data with larger networks when compared with what a single GPU could handle.
Besides,
memory footprint per GPU can be well controlled (it is a fraction of the total network footprint).</p>
<p>However, the interface between layers (and thus GPUs) requires tight synchronization. This can be tricky, in particular if the computational workloads are not properly matched between layers. The problem is exacerbated for large numbers of GPUs.
The interface between layers also
requires large amounts of data transfer,
such as activations and gradients.
This may overwhelm the bandwidth of the GPU buses.
Moreover, compute-intensive, yet sequential operations are nontrivial to partition. See e.g., :citet:<code>Mirhoseini.Pham.Le.ea.2017</code> for a best effort in this regard. It remains a difficult problem and it is unclear whether it is possible to achieve good (linear) scaling on nontrivial problems. We do not recommend it unless there is excellent framework or operating system support for chaining together multiple GPUs.</p>
<p>Second, we could split the work layerwise. For instance, rather than computing 64 channels on a single GPU we could split up the problem across 4 GPUs, each of which generates data for 16 channels.
Likewise, for a fully connected layer we could split the number of output units. :numref:<code>fig_alexnet_original</code> (taken from :citet:<code>Krizhevsky.Sutskever.Hinton.2012</code>)
illustrates this design, where this strategy was used to deal with GPUs that had a very small memory footprint (2 GB at the time).
This allows for good scaling in terms of computation, provided that the number of channels (or units) is not too small.
Besides,
multiple GPUs can process increasingly larger networks since the available memory scales linearly.</p>
<p><img src="chapter_computational-performance/../img/alexnet-original.svg" alt="Model parallelism in the original AlexNet design due to limited GPU memory." />
:label:<code>fig_alexnet_original</code></p>
<p>However,
we need a <em>very large</em> number of synchronization or barrier operations since each layer depends on the results from all the other layers.
Moreover, the amount of data that needs to be transferred is potentially even larger than when distributing layers across GPUs. Thus, we do not recommend this approach due to its bandwidth cost and complexity.</p>
<p>Last, we could partition data across multiple GPUs. This way all GPUs perform the same type of work, albeit on different observations. Gradients are aggregated across GPUs after each minibatch of training data.
This is the simplest approach and it can be applied in any situation.
We only need to synchronize after each minibatch. That said, it is highly desirable to start exchanging gradients parameters already while others are still being computed.
Moreover, larger numbers of GPUs lead to larger minibatch sizes, thus increasing training efficiency.
However, adding more GPUs does not allow us to train larger models.</p>
<p><img src="chapter_computational-performance/../img/splitting.svg" alt="Parallelization on multiple GPUs. From left to right: original problem, network partitioning, layerwise partitioning, data parallelism." />
:label:<code>fig_splitting</code></p>
<p>A comparison of different ways of parallelization on multiple GPUs is depicted in :numref:<code>fig_splitting</code>.
By and large, data parallelism is the most convenient way to proceed, provided that we have access to GPUs with sufficiently large memory. See also :cite:<code>Li.Andersen.Park.ea.2014</code> for a detailed description of partitioning for distributed training. GPU memory used to be a problem in the early days of deep learning. By now this issue has been resolved for all but the most unusual cases. We focus on data parallelism in what follows.</p>
<h2 id="data-parallelism"><a class="header" href="#data-parallelism">Data Parallelism</a></h2>
<p>Assume that there are $k$ GPUs on a machine. Given the model to be trained, each GPU will maintain a complete set of model parameters independently though parameter values across the GPUs are identical and synchronized.
As an example,
:numref:<code>fig_data_parallel</code> illustrates
training with
data parallelism when $k=2$.</p>
<p><img src="chapter_computational-performance/../img/data-parallel.svg" alt="Calculation of minibatch stochastic gradient descent using data parallelism on two GPUs." />
:label:<code>fig_data_parallel</code></p>
<p>In general, the training proceeds as follows:</p>
<ul>
<li>In any iteration of training, given a random minibatch, we split the examples in the batch into $k$ portions and distribute them evenly across the GPUs.</li>
<li>Each GPU calculates loss and gradient of the model parameters based on the minibatch subset it was assigned.</li>
<li>The local gradients of each of the $k$ GPUs are aggregated to obtain the current minibatch stochastic gradient.</li>
<li>The aggregate gradient is re-distributed to each GPU.</li>
<li>Each GPU uses this minibatch stochastic gradient to update the complete set of model parameters that it maintains.</li>
</ul>
<p>Note that in practice we <em>increase</em> the minibatch size $k$-fold when training on $k$ GPUs such that each GPU has the same amount of work to do as if we were training on a single GPU only. On a 16-GPU server this can increase the minibatch size considerably and we may have to increase the learning rate accordingly.
Also note that batch normalization in :numref:<code>sec_batch_norm</code> needs to be adjusted, e.g., by keeping a separate batch normalization coefficient per GPU.
In what follows we will use a toy network to illustrate multi-GPU training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, np, npx
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<h2 id="a-toy-network"><a class="header" href="#a-toy-network">[<strong>A Toy Network</strong>]</a></h2>
<p>We use LeNet as introduced in :numref:<code>sec_lenet</code> (with slight modifications). We define it from scratch to illustrate parameter exchange and synchronization in detail.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Initialize model parameters
scale = 0.01
W1 = np.random.normal(scale=scale, size=(20, 1, 3, 3))
b1 = np.zeros(20)
W2 = np.random.normal(scale=scale, size=(50, 20, 5, 5))
b2 = np.zeros(50)
W3 = np.random.normal(scale=scale, size=(800, 128))
b3 = np.zeros(128)
W4 = np.random.normal(scale=scale, size=(128, 10))
b4 = np.zeros(10)
params = [W1, b1, W2, b2, W3, b3, W4, b4]

# Define the model
def lenet(X, params):
    h1_conv = npx.convolution(data=X, weight=params[0], bias=params[1],
                              kernel=(3, 3), num_filter=20)
    h1_activation = npx.relu(h1_conv)
    h1 = npx.pooling(data=h1_activation, pool_type='avg', kernel=(2, 2),
                     stride=(2, 2))
    h2_conv = npx.convolution(data=h1, weight=params[2], bias=params[3],
                              kernel=(5, 5), num_filter=50)
    h2_activation = npx.relu(h2_conv)
    h2 = npx.pooling(data=h2_activation, pool_type='avg', kernel=(2, 2),
                     stride=(2, 2))
    h2 = h2.reshape(h2.shape[0], -1)
    h3_linear = np.dot(h2, params[4]) + params[5]
    h3 = npx.relu(h3_linear)
    y_hat = np.dot(h3, params[6]) + params[7]
    return y_hat

# Cross-entropy loss function
loss = gluon.loss.SoftmaxCrossEntropyLoss()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Initialize model parameters
scale = 0.01
W1 = torch.randn(size=(20, 1, 3, 3)) * scale
b1 = torch.zeros(20)
W2 = torch.randn(size=(50, 20, 5, 5)) * scale
b2 = torch.zeros(50)
W3 = torch.randn(size=(800, 128)) * scale
b3 = torch.zeros(128)
W4 = torch.randn(size=(128, 10)) * scale
b4 = torch.zeros(10)
params = [W1, b1, W2, b2, W3, b3, W4, b4]

# Define the model
def lenet(X, params):
    h1_conv = F.conv2d(input=X, weight=params[0], bias=params[1])
    h1_activation = F.relu(h1_conv)
    h1 = F.avg_pool2d(input=h1_activation, kernel_size=(2, 2), stride=(2, 2))
    h2_conv = F.conv2d(input=h1, weight=params[2], bias=params[3])
    h2_activation = F.relu(h2_conv)
    h2 = F.avg_pool2d(input=h2_activation, kernel_size=(2, 2), stride=(2, 2))
    h2 = h2.reshape(h2.shape[0], -1)
    h3_linear = torch.mm(h2, params[4]) + params[5]
    h3 = F.relu(h3_linear)
    y_hat = torch.mm(h3, params[6]) + params[7]
    return y_hat

# Cross-entropy loss function
loss = nn.CrossEntropyLoss(reduction='none')
</code></pre>
<h2 id="data-synchronization"><a class="header" href="#data-synchronization">Data Synchronization</a></h2>
<p>For efficient multi-GPU training we need two basic operations.
First we need to have the ability to [<strong>distribute a list of parameters to multiple devices</strong>] and to attach gradients (<code>get_params</code>). Without parameters it is impossible to evaluate the network on a GPU.
Second, we need the ability to sum parameters across multiple devices, i.e., we need an <code>allreduce</code> function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_params(params, device):
    new_params = [p.copyto(device) for p in params]
    for p in new_params:
        p.attach_grad()
    return new_params
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_params(params, device):
    new_params = [p.to(device) for p in params]
    for p in new_params:
        p.requires_grad_()
    return new_params
</code></pre>
<p>Let's try it out by copying the model parameters to one GPU.</p>
<pre><code class="language-{.python .input}">#@tab all
new_params = get_params(params, d2l.try_gpu(0))
print('b1 weight:', new_params[1])
print('b1 grad:', new_params[1].grad)
</code></pre>
<p>Since we did not perform any computation yet, the gradient with regard to the bias parameter is still zero.
Now let's assume that we have a vector distributed across multiple GPUs. The following [<strong><code>allreduce</code> function adds up all vectors and broadcasts the result back to all GPUs</strong>]. Note that for this to work we need to copy the data to the device accumulating the results.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def allreduce(data):
    for i in range(1, len(data)):
        data[0][:] += data[i].copyto(data[0].ctx)
    for i in range(1, len(data)):
        data[0].copyto(data[i])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def allreduce(data):
    for i in range(1, len(data)):
        data[0][:] += data[i].to(data[0].device)
    for i in range(1, len(data)):
        data[i][:] = data[0].to(data[i].device)
</code></pre>
<p>Let's test this by creating vectors with different values on different devices and aggregate them.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
data = [np.ones((1, 2), ctx=d2l.try_gpu(i)) * (i + 1) for i in range(2)]
print('before allreduce:\n', data[0], '\n', data[1])
allreduce(data)
print('after allreduce:\n', data[0], '\n', data[1])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
data = [torch.ones((1, 2), device=d2l.try_gpu(i)) * (i + 1) for i in range(2)]
print('before allreduce:\n', data[0], '\n', data[1])
allreduce(data)
print('after allreduce:\n', data[0], '\n', data[1])
</code></pre>
<h2 id="distributing-data"><a class="header" href="#distributing-data">Distributing Data</a></h2>
<p>We need a simple utility function to [<strong>distribute a minibatch evenly across multiple GPUs</strong>]. For instance, on two GPUs we would like to have half of the data to be copied to either of the GPUs.
Since it is more convenient and more concise, we use the built-in function from the deep learning framework to try it out on a $4 \times 5$ matrix.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
data = np.arange(20).reshape(4, 5)
devices = [npx.gpu(0), npx.gpu(1)]
split = gluon.utils.split_and_load(data, devices)
print('input :', data)
print('load into', devices)
print('output:', split)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
data = torch.arange(20).reshape(4, 5)
devices = [torch.device('cuda:0'), torch.device('cuda:1')]
split = nn.parallel.scatter(data, devices)
print('input :', data)
print('load into', devices)
print('output:', split)
</code></pre>
<p>For later reuse we define a <code>split_batch</code> function that splits both data and labels.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def split_batch(X, y, devices):
    """Split `X` and `y` into multiple devices."""
    assert X.shape[0] == y.shape[0]
    return (gluon.utils.split_and_load(X, devices),
            gluon.utils.split_and_load(y, devices))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def split_batch(X, y, devices):
    """Split `X` and `y` into multiple devices."""
    assert X.shape[0] == y.shape[0]
    return (nn.parallel.scatter(X, devices),
            nn.parallel.scatter(y, devices))
</code></pre>
<h2 id="training-23"><a class="header" href="#training-23">Training</a></h2>
<p>Now we can implement [<strong>multi-GPU training on a single minibatch</strong>]. Its implementation is primarily based on the data parallelism approach described in this section. We will use the auxiliary functions we just discussed, <code>allreduce</code> and <code>split_and_load</code>, to synchronize the data among multiple GPUs. Note that we do not need to write any specific code to achieve parallelism. Since the computational graph does not have any dependencies across devices within a minibatch, it is executed in parallel <em>automatically</em>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train_batch(X, y, device_params, devices, lr):
    X_shards, y_shards = split_batch(X, y, devices)
    with autograd.record():  # Loss is calculated separately on each GPU
        ls = [loss(lenet(X_shard, device_W), y_shard)
              for X_shard, y_shard, device_W in zip(
                  X_shards, y_shards, device_params)]
    for l in ls:  # Backpropagation is performed separately on each GPU
        l.backward()
    # Sum all gradients from each GPU and broadcast them to all GPUs
    for i in range(len(device_params[0])):
        allreduce([device_params[c][i].grad for c in range(len(devices))])
    # The model parameters are updated separately on each GPU
    for param in device_params:
        d2l.sgd(param, lr, X.shape[0])  # Here, we use a full-size batch
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train_batch(X, y, device_params, devices, lr):
    X_shards, y_shards = split_batch(X, y, devices)
    # Loss is calculated separately on each GPU
    ls = [loss(lenet(X_shard, device_W), y_shard).sum()
          for X_shard, y_shard, device_W in zip(
              X_shards, y_shards, device_params)]
    for l in ls:  # Backpropagation is performed separately on each GPU
        l.backward()
    # Sum all gradients from each GPU and broadcast them to all GPUs
    with torch.no_grad():
        for i in range(len(device_params[0])):
            allreduce([device_params[c][i].grad for c in range(len(devices))])
    # The model parameters are updated separately on each GPU
    for param in device_params:
        d2l.sgd(param, lr, X.shape[0]) # Here, we use a full-size batch
</code></pre>
<p>Now, we can define [<strong>the training function</strong>]. It is slightly different from the ones used in the previous chapters: we need to allocate the GPUs and copy all the model parameters to all the devices.
Obviously each batch is processed using the <code>train_batch</code> function to deal with multiple GPUs. For convenience (and conciseness of code) we compute the accuracy on a single GPU, though this is <em>inefficient</em> since the other GPUs are idle.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(num_gpus, batch_size, lr):
    train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
    devices = [d2l.try_gpu(i) for i in range(num_gpus)]
    # Copy model parameters to `num_gpus` GPUs
    device_params = [get_params(params, d) for d in devices]
    num_epochs = 10
    animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs])
    timer = d2l.Timer()
    for epoch in range(num_epochs):
        timer.start()
        for X, y in train_iter:
            # Perform multi-GPU training for a single minibatch
            train_batch(X, y, device_params, devices, lr)
            npx.waitall()
        timer.stop()
        # Evaluate the model on GPU 0
        animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu(
            lambda x: lenet(x, device_params[0]), test_iter, devices[0]),))
    print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch '
          f'on {str(devices)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(num_gpus, batch_size, lr):
    train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
    devices = [d2l.try_gpu(i) for i in range(num_gpus)]
    # Copy model parameters to `num_gpus` GPUs
    device_params = [get_params(params, d) for d in devices]
    num_epochs = 10
    animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs])
    timer = d2l.Timer()
    for epoch in range(num_epochs):
        timer.start()
        for X, y in train_iter:
            # Perform multi-GPU training for a single minibatch
            train_batch(X, y, device_params, devices, lr)
            torch.cuda.synchronize()
        timer.stop()
        # Evaluate the model on GPU 0
        animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu(
            lambda x: lenet(x, device_params[0]), test_iter, devices[0]),))
    print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch '
          f'on {str(devices)}')
</code></pre>
<p>Let's see how well this works [<strong>on a single GPU</strong>].
We first use a batch size of 256 and a learning rate of 0.2.</p>
<pre><code class="language-{.python .input}">#@tab all
train(num_gpus=1, batch_size=256, lr=0.2)
</code></pre>
<p>By keeping the batch size and learning rate unchanged and [<strong>increasing the number of GPUs to 2</strong>], we can see that the test accuracy roughly stays the same compared with
the previous experiment.
In terms of the optimization algorithms, they are identical. Unfortunately there is no meaningful speedup to be gained here: the model is simply too small; moreover we only have a small dataset, where our slightly unsophisticated approach to implementing multi-GPU training suffered from significant Python overhead. We will encounter more complex models and more sophisticated ways of parallelization going forward.
Let's see what happens nonetheless for Fashion-MNIST.</p>
<pre><code class="language-{.python .input}">#@tab all
train(num_gpus=2, batch_size=256, lr=0.2)
</code></pre>
<h2 id="summary-69"><a class="header" href="#summary-69">Summary</a></h2>
<ul>
<li>There are multiple ways to split deep network training over multiple GPUs. We could split them between layers, across layers, or across data. The former two require tightly choreographed data transfers. Data parallelism is the simplest strategy.</li>
<li>Data parallel training is straightforward. However, it increases the effective minibatch size to be efficient.</li>
<li>In data parallelism, data is split across multiple GPUs, where each GPU executes its own forward and backward operation and subsequently gradients are aggregated and results are broadcast back to the GPUs.</li>
<li>We may use slightly increased learning rates for larger minibatches.</li>
</ul>
<h2 id="exercises-89"><a class="header" href="#exercises-89">Exercises</a></h2>
<ol>
<li>When training on $k$ GPUs, change the minibatch size from $b$ to $k \cdot b$, i.e., scale it up by the number of GPUs.</li>
<li>Compare accuracy for different learning rates. How does it scale with the number of GPUs?</li>
<li>Implement a more efficient <code>allreduce</code> function that aggregates different parameters on different GPUs? Why is it more efficient?</li>
<li>Implement multi-GPU test accuracy computation.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/364">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1669">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-implementation-for-multiple-gpus"><a class="header" href="#concise-implementation-for-multiple-gpus">Concise Implementation for Multiple GPUs</a></h1>
<p>:label:<code>sec_multi_gpu_concise</code></p>
<p>Implementing parallelism from scratch for every new model is no fun. Moreover, there is significant benefit in optimizing synchronization tools for high performance. In the following we will show how to do this using high-level APIs of deep learning frameworks.
The mathematics and the algorithms are the same as in :numref:<code>sec_multi_gpu</code>.
Quite unsurprisingly you will need at least two GPUs to run code of this section.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<h2 id="a-toy-network-1"><a class="header" href="#a-toy-network-1">[<strong>A Toy Network</strong>]</a></h2>
<p>Let's use a slightly more meaningful network than LeNet from :numref:<code>sec_multi_gpu</code> that is still sufficiently easy and quick to train.
We pick a ResNet-18 variant :cite:<code>He.Zhang.Ren.ea.2016</code>. Since the input images are tiny we modify it slightly. In particular, the difference from :numref:<code>sec_resnet</code> is that we use a smaller convolution kernel, stride, and padding at the beginning.
Moreover, we remove the max-pooling layer.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def resnet18(num_classes):
    """A slightly modified ResNet-18 model."""
    def resnet_block(num_channels, num_residuals, first_block=False):
        blk = nn.Sequential()
        for i in range(num_residuals):
            if i == 0 and not first_block:
                blk.add(d2l.Residual(
                    num_channels, use_1x1conv=True, strides=2))
            else:
                blk.add(d2l.Residual(num_channels))
        return blk

    net = nn.Sequential()
    # This model uses a smaller convolution kernel, stride, and padding and
    # removes the max-pooling layer
    net.add(nn.Conv2D(64, kernel_size=3, strides=1, padding=1),
            nn.BatchNorm(), nn.Activation('relu'))
    net.add(resnet_block(64, 2, first_block=True),
            resnet_block(128, 2),
            resnet_block(256, 2),
            resnet_block(512, 2))
    net.add(nn.GlobalAvgPool2D(), nn.Dense(num_classes))
    return net
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def resnet18(num_classes, in_channels=1):
    """A slightly modified ResNet-18 model."""
    def resnet_block(in_channels, out_channels, num_residuals,
                     first_block=False):
        blk = []
        for i in range(num_residuals):
            if i == 0 and not first_block:
                blk.append(d2l.Residual(out_channels, use_1x1conv=True, 
                                        strides=2))
            else:
                blk.append(d2l.Residual(out_channels))
        return nn.Sequential(*blk)

    # This model uses a smaller convolution kernel, stride, and padding and
    # removes the max-pooling layer
    net = nn.Sequential(
        nn.Conv2d(in_channels, 64, kernel_size=3, stride=1, padding=1),
        nn.BatchNorm2d(64),
        nn.ReLU())
    net.add_module("resnet_block1", resnet_block(64, 64, 2, first_block=True))
    net.add_module("resnet_block2", resnet_block(64, 128, 2))
    net.add_module("resnet_block3", resnet_block(128, 256, 2))
    net.add_module("resnet_block4", resnet_block(256, 512, 2))
    net.add_module("global_avg_pool", nn.AdaptiveAvgPool2d((1,1)))
    net.add_module("fc", nn.Sequential(nn.Flatten(),
                                       nn.Linear(512, num_classes)))
    return net
</code></pre>
<h2 id="network-initialization"><a class="header" href="#network-initialization">Network Initialization</a></h2>
<p>:begin_tab:<code>mxnet</code>
The <code>initialize</code> function allows us to initialize parameters on a device of our choice.
For a refresher on initialization methods see :numref:<code>sec_numerical_stability</code>. What is particularly convenient is that it also allows us to initialize the network on <em>multiple</em> devices simultaneously. Let's try how this works in practice.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
We will initialize the network inside the training loop.
For a refresher on initialization methods see :numref:<code>sec_numerical_stability</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = resnet18(10)
# Get a list of GPUs
devices = d2l.try_all_gpus()
# Initialize all the parameters of the network
net.initialize(init=init.Normal(sigma=0.01), ctx=devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = resnet18(10)
# Get a list of GPUs
devices = d2l.try_all_gpus()
# We will initialize the network inside the training loop
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Using the <code>split_and_load</code> function introduced in :numref:<code>sec_multi_gpu</code> we can divide a minibatch of data and copy portions to the list of devices provided by the <code>devices</code> variable. The network instance <em>automatically</em> uses the appropriate GPU to compute the value of the forward propagation. Here we generate 4 observations and split them over the GPUs.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.random.uniform(size=(4, 1, 28, 28))
x_shards = gluon.utils.split_and_load(x, devices)
net(x_shards[0]), net(x_shards[1])
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Once data passes through the network, the corresponding parameters are initialized <em>on the device the data passed through</em>.
This means that initialization happens on a per-device basis. Since we picked GPU 0 and GPU 1 for initialization, the network is initialized only there, and not on the CPU. In fact, the parameters do not even exist on the CPU. We can verify this by printing out the parameters and observing any errors that might arise.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
weight = net[0].params.get('weight')

try:
    weight.data()
except RuntimeError:
    print('not initialized on cpu')
weight.data(devices[0])[0], weight.data(devices[1])[0]
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Next, let's replace the code to [<strong>evaluate the accuracy</strong>] by one that works (<strong>in parallel across multiple devices</strong>). This serves as a replacement of the <code>evaluate_accuracy_gpu</code> function from :numref:<code>sec_lenet</code>. The main difference is that we split a minibatch before invoking the network. All else is essentially identical.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def evaluate_accuracy_gpus(net, data_iter, split_f=d2l.split_batch):
    """Compute the accuracy for a model on a dataset using multiple GPUs."""
    # Query the list of devices
    devices = list(net.collect_params().values())[0].list_ctx()
    # No. of correct predictions, no. of predictions
    metric = d2l.Accumulator(2)
    for features, labels in data_iter:
        X_shards, y_shards = split_f(features, labels, devices)
        # Run in parallel
        pred_shards = [net(X_shard) for X_shard in X_shards]
        metric.add(sum(float(d2l.accuracy(pred_shard, y_shard)) for
                       pred_shard, y_shard in zip(
                           pred_shards, y_shards)), labels.size)
    return metric[0] / metric[1]
</code></pre>
<h2 id="training-24"><a class="header" href="#training-24">[<strong>Training</strong>]</a></h2>
<p>As before, the training code needs to perform several basic functions for efficient parallelism:</p>
<ul>
<li>Network parameters need to be initialized across all devices.</li>
<li>While iterating over the dataset minibatches are to be divided across all devices.</li>
<li>We compute the loss and its gradient in parallel across devices.</li>
<li>Gradients are aggregated and parameters are updated accordingly.</li>
</ul>
<p>In the end we compute the accuracy (again in parallel) to report the final performance of the network. The training routine is quite similar to implementations in previous chapters, except that we need to split and aggregate data.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(num_gpus, batch_size, lr):
    train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
    ctx = [d2l.try_gpu(i) for i in range(num_gpus)]
    net.initialize(init=init.Normal(sigma=0.01), ctx=ctx, force_reinit=True)
    trainer = gluon.Trainer(net.collect_params(), 'sgd',
                            {'learning_rate': lr})
    loss = gluon.loss.SoftmaxCrossEntropyLoss()
    timer, num_epochs = d2l.Timer(), 10
    animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs])
    for epoch in range(num_epochs):
        timer.start()
        for features, labels in train_iter:
            X_shards, y_shards = d2l.split_batch(features, labels, ctx)
            with autograd.record():
                ls = [loss(net(X_shard), y_shard) for X_shard, y_shard
                      in zip(X_shards, y_shards)]
            for l in ls:
                l.backward()
            trainer.step(batch_size)
        npx.waitall()
        timer.stop()
        animator.add(epoch + 1, (evaluate_accuracy_gpus(net, test_iter),))
    print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch '
          f'on {str(ctx)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net, num_gpus, batch_size, lr):
    train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
    devices = [d2l.try_gpu(i) for i in range(num_gpus)]
    def init_weights(module):
        if type(module) in [nn.Linear, nn.Conv2d]:
            nn.init.normal_(module.weight, std=0.01)
    net.apply(init_weights)
    # Set the model on multiple GPUs
    net = nn.DataParallel(net, device_ids=devices)
    trainer = torch.optim.SGD(net.parameters(), lr)
    loss = nn.CrossEntropyLoss()
    timer, num_epochs = d2l.Timer(), 10
    animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs])
    for epoch in range(num_epochs):
        net.train()
        timer.start()
        for X, y in train_iter:
            trainer.zero_grad()
            X, y = X.to(devices[0]), y.to(devices[0])
            l = loss(net(X), y)
            l.backward()
            trainer.step()
        timer.stop()
        animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu(net, test_iter),))
    print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch '
          f'on {str(devices)}')
</code></pre>
<p>Let's see how this works in practice. As a warm-up we [<strong>train the network on a single GPU.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train(num_gpus=1, batch_size=256, lr=0.1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train(net, num_gpus=1, batch_size=256, lr=0.1)
</code></pre>
<p>Next we [<strong>use 2 GPUs for training</strong>]. Compared with LeNet
evaluated in :numref:<code>sec_multi_gpu</code>,
the model for ResNet-18 is considerably more complex. This is where parallelization shows its advantage. The time for computation is meaningfully larger than the time for synchronizing parameters. This improves scalability since the overhead for parallelization is less relevant.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train(num_gpus=2, batch_size=512, lr=0.2)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train(net, num_gpus=2, batch_size=512, lr=0.2)
</code></pre>
<h2 id="summary-70"><a class="header" href="#summary-70">Summary</a></h2>
<p>:begin_tab:<code>mxnet</code></p>
<ul>
<li>Gluon provides primitives for model initialization across multiple devices by providing a context list.
:end_tab:</li>
<li>Data is automatically evaluated on the devices where the data can be found.</li>
<li>Take care to initialize the networks on each device before trying to access the parameters on that device. Otherwise you will encounter an error.</li>
<li>The optimization algorithms automatically aggregate over multiple GPUs.</li>
</ul>
<h2 id="exercises-90"><a class="header" href="#exercises-90">Exercises</a></h2>
<p>:begin_tab:<code>mxnet</code></p>
<ol>
<li>This section uses ResNet-18. Try different epochs, batch sizes, and learning rates. Use more GPUs for computation. What happens if you try this with 16 GPUs (e.g., on an AWS p2.16xlarge instance)?</li>
<li>Sometimes, different devices provide different computing power. We could use the GPUs and the CPU at the same time. How should we divide the work? Is it worth the effort? Why? Why not?</li>
<li>What happens if we drop <code>npx.waitall()</code>? How would you modify training such that you have an overlap of up to two steps for parallelism?
:end_tab:</li>
</ol>
<p>:begin_tab:<code>pytorch</code></p>
<ol>
<li>This section uses ResNet-18. Try different epochs, batch sizes, and learning rates. Use more GPUs for computation. What happens if you try this with 16 GPUs (e.g., on an AWS p2.16xlarge instance)?</li>
<li>Sometimes, different devices provide different computing power. We could use the GPUs and the CPU at the same time. How should we divide the work? Is it worth the effort? Why? Why not?
:end_tab:</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/365">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1403">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameter-servers"><a class="header" href="#parameter-servers">Parameter Servers</a></h1>
<p>:label:<code>sec_parameterserver</code></p>
<p>As we move from a single GPU to multiple GPUs and then to multiple servers containing multiple GPUs, possibly all spread out across multiple racks and network switches,
our algorithms for distributed and parallel training need to become much more sophisticated. Details matter since different interconnects have very different bandwidth (e.g., NVLink can offer up to 100 GB/s across 6 links in an appropriate setting, PCIe 4.0 (16-lane) offers 32 GB/s, while even high speed 100GbE Ethernet only amounts to 10 GB/s). At the same time it is unreasonable to expect that a statistical modeler be an expert in networking and systems.</p>
<p>The core idea of the parameter server was introduced in :citet:<code>Smola.Narayanamurthy.2010</code> in the context of distributed latent variable models. A description of the push and pull semantics then followed in :citet:<code>Ahmed.Aly.Gonzalez.ea.2012</code> and a description of the system and an open source library followed in :citet:<code>Li.Andersen.Park.ea.2014</code>. In the following we will motivate the components needed for efficiency.</p>
<h2 id="data-parallel-training"><a class="header" href="#data-parallel-training">Data-Parallel Training</a></h2>
<p>Let's review the data parallel training approach to distributed training. We will use this to the exclusion of all others in this section since it is significantly simpler to implement in practice. There are virtually no use cases (besides deep learning on graphs) where any other strategy for parallelism is preferred since GPUs have plenty of memory nowadays. :numref:<code>fig_parameterserver</code> describes the variant of data parallelism that we implemented in :numref:<code>sec_multi_gpu</code>. The key aspect in it is that the aggregation of gradients occurs on one single GPU (GPU 0) before the updated parameters are rebroadcast to all GPUs.</p>
<p><img src="chapter_computational-performance/../img/ps.svg" alt="Left: single GPU training. Right: a variant of multi-GPU training: (1) we compute loss and gradient, (2) all gradients are aggregated on one GPU, (3) parameter update happens and the parameters are re-distributed to all GPUs." />
:label:<code>fig_parameterserver</code></p>
<p>In retrospect, the decision to aggregate on GPU 0 seems rather ad-hoc. After all, we might just as well aggregate on the CPU. In fact, we could even decide to aggregate some of the parameters on one GPU and some others on another. Provided that the optimization algorithm supports this, there is no real reason for why we could not. For instance, if we have four parameter vectors with associated gradients $\mathbf{g}_1, \ldots, \mathbf{g}_4$ we could aggregate the gradients on one GPU for each $\mathbf{g}_i$ ($i = 1, \ldots, 4$).</p>
<p>This reasoning seems arbitrary and frivolous. After all, the mathematics is the same throughout. However, we are dealing with real physical hardware where different buses have different bandwidth as discussed in :numref:<code>sec_hardware</code>.
Consider a real 4-way GPU server as described in :numref:<code>fig_bw_hierarchy</code>. If it is particularly well connected, it might have a 100 GbE network card. More typical numbers are in the 1--10 GbE range with an effective bandwidth of 100 MB/s to 1 GB/s.
Since the CPUs have too few PCIe lanes to connect to all GPUs directly (e.g., consumer-grade Intel CPUs have 24 lanes) we need a <a href="https://www.broadcom.com/products/pcie-switches-bridges/pcie-switches">multiplexer</a>. The bandwidth from the CPU on a 16x Gen3 link is 16 GB/s. This is also the speed at which <em>each</em> of the GPUs is connected to the switch. This means that it is more effective to communicate between the devices.</p>
<p><img src="chapter_computational-performance/../img/bw-hierarchy.svg" alt="A 4-way GPU server." />
:label:<code>fig_bw_hierarchy</code></p>
<p>For the sake of the argument let's assume that the gradients are of 160 MB. In this case it takes 30 ms to send the gradients from all 3 remaining GPUs to the fourth one (each transfer takes 10 ms = 160 MB / 16 GB/s). Adding another 30 ms to transmit the weight vectors back we arrive at a total of 60 ms.
If we send all data to the CPU we incur a penalty of 40 ms since <em>each</em> of the four GPUs needs to send the data to the CPU, yielding a total of 80 ms. Lastly assume that we are able to split the gradients into 4 parts of 40 MB each. Now we can aggregate each of the parts on a different GPU <em>simultaneously</em> since the PCIe switch offers a full-bandwidth operation between all links. Instead of 30 ms this takes 7.5 ms, yielding a total of 15 ms for a synchronization operation. In short, depending on how we synchronize parameters the same operation can take anywhere from 15 ms to 80 ms. :numref:<code>fig_ps_distributed</code> depicts the different strategies for exchanging parameters.</p>
<p><img src="chapter_computational-performance/../img/ps-distributed.svg" alt="Parameter synchronization strategies." />
:label:<code>fig_ps_distributed</code></p>
<p>Note that we have yet another tool at our disposal when it comes to improving performance: in a deep network it takes some time to compute all gradients from the top to the bottom. We can begin synchronizing gradients for some parameter groups even while we are still busy computing them for others. See e.g., :citet:<code>Sergeev.Del-Balso.2018</code> for details on how to do this in <a href="https://github.com/horovod/horovod">Horovod</a>.</p>
<h2 id="ring-synchronization"><a class="header" href="#ring-synchronization">Ring Synchronization</a></h2>
<p>When it comes to synchronization on modern deep learning hardware we often encounter significantly bespoke network connectivity. For instance, the AWS p3.16xlarge and NVIDIA DGX-2 instances share the connectivity structure of :numref:<code>fig_nvlink</code>. Each GPU connects to a host CPU via a PCIe link which operates at best at 16 GB/s. Additionally each GPU also has 6 NVLink connections, each of which is capable of transferring 300 Gbit/s bidirectionally. This amounts to around 18 GB/s per link per direction. In short, the aggregate NVLink bandwidth is significantly higher than the PCIe bandwidth. The question is how to use it most efficiently.</p>
<p><img src="chapter_computational-performance/../img/nvlink.svg" alt="NVLink connectivity on 8  V100 GPU servers (image courtesy of NVIDIA)." />
:label:<code>fig_nvlink</code></p>
<p>It turns out that the optimal synchronization strategy is to decompose the network into two rings and to use them to synchronize data directly :cite:<code>Wang.Li.Liberty.ea.2018</code>. :numref:<code>fig_nvlink_twoloop</code> illustrates that the network can be decomposed into one ring (1-2-3-4-5-6-7-8-1) with double NVLink bandwidth and into one (1-4-6-3-5-8-2-7-1) with regular bandwidth. Designing an efficient synchronization protocol in this case is nontrivial.</p>
<p><img src="chapter_computational-performance/../img/nvlink-twoloop.svg" alt="Decomposition of the NVLink network into two rings." />
:label:<code>fig_nvlink_twoloop</code></p>
<p>Consider the following thought experiment: given a ring of $n$ computing nodes (or GPUs) we can send gradients from the first to the second node. There it is added to the local gradient and sent on to the third node, and so on. After $n-1$ steps the aggregate gradient can be found in the last-visited node. That is, the time to aggregate gradients grows linearly with the number of nodes. But if we do this the algorithm is quite inefficient. After all, at any time there is only one of the nodes communicating. What if we broke the gradients into $n$ chunks and started synchronizing chunk $i$ starting at node $i$?
Since each chunk is of size $1/n$ the total time is now $(n-1)/n \approx 1$. In other words, the time spent to aggregate gradients <em>does not grow</em> as we increase the size of the ring. This is quite an astonishing result. :numref:<code>fig_ringsync</code> illustrates the sequence of steps on $n=4$ nodes.</p>
<p><img src="chapter_computational-performance/../img/ringsync.svg" alt="Ring synchronization across 4 nodes. Each node starts transmitting parts of gradients to its left neighbor until the assembled gradient can be found in its right neighbor." />
:label:<code>fig_ringsync</code></p>
<p>If we use the same example of synchronizing 160 MB across 8 V100 GPUs we arrive at approximately $2 \cdot 160 \textrm{MB} / (3 \cdot 18 \textrm{GB/s}) \approx 6 \textrm{ms}$. This is better than using the PCIe bus, even though we are now using 8 GPUs. Note that in practice these numbers are a bit worse, since deep learning frameworks often fail to assemble communication into large burst transfers.</p>
<p>Note that there is a common misconception that ring synchronization is fundamentally different from other synchronization algorithms. The only difference is that the synchronization path is somewhat more elaborate when compared with a simple tree.</p>
<h2 id="multi-machine-training"><a class="header" href="#multi-machine-training">Multi-Machine Training</a></h2>
<p>Distributed training on multiple machines adds a further challenge: we need to communicate with servers that are only connected across a comparatively lower bandwidth fabric that can be over an order of magnitude slower in some cases.
Synchronization across devices is tricky. After all, different machines running training code will have subtly different speed. Hence we need to <em>synchronize</em> them if we want to use synchronous distributed optimization. :numref:<code>fig_ps_multimachine</code> illustrates how distributed parallel training occurs.</p>
<ol>
<li>A (different) batch of data is read on each machine, split across multiple GPUs and transferred to GPU memory. There predictions and gradients are computed on each GPU batch separately.</li>
<li>The gradients from all local GPUs are aggregated on one GPU (or parts of it are aggregated over different GPUs).</li>
<li>The gradients are sent to the CPUs.</li>
<li>The CPUs send the gradients to a central parameter server which aggregates all the gradients.</li>
<li>The aggregate gradients are then used to update the parameters and the updated parameters are broadcast back to the individual CPUs.</li>
<li>The information is sent to one (or multiple) GPUs.</li>
<li>The updated parameters are spread across all GPUs.</li>
</ol>
<p><img src="chapter_computational-performance/../img/ps-multimachine.svg" alt="Multi-machine multi-GPU distributed parallel training." />
:label:<code>fig_ps_multimachine</code></p>
<p>Each of these operations seems rather straightforward. And, indeed, they can be carried out efficiently <em>within</em> a single machine. Once we look at multiple machines, though, we can see that the central parameter server becomes the bottleneck. After all, the bandwidth per server is limited, hence for $m$ workers the time it takes to send all gradients to the server is $\mathcal{O}(m)$. We can break through this barrier by increasing the number of servers to $n$. At this point each server only needs to store $\mathcal{O}(1/n)$ of the parameters, hence the total time for updates and optimization becomes $\mathcal{O}(m/n)$.
Matching both numbers yields constant scaling regardless of how many workers we are dealing with. In practice we use the <em>same</em> machines both as workers and as servers. :numref:<code>fig_ps_multips</code> illustrates the design (see also :cite:<code>Li.Andersen.Park.ea.2014</code> for details).
In particular, ensuring that multiple machines work without unreasonable delays is nontrivial.</p>
<p><img src="chapter_computational-performance/../img/ps-multips.svg" alt="Top: a single parameter server is a bottleneck since its bandwidth is finite. Bottom: multiple parameter servers store parts of the parameters with aggregate bandwidth." />
:label:<code>fig_ps_multips</code></p>
<h2 id="key--value-stores"><a class="header" href="#key--value-stores">Key--Value Stores</a></h2>
<p>Implementing the steps required for distributed multi-GPU training in practice is nontrivial.
This is why it pays to use a common abstraction, namely that of a <em>key--value store</em> with redefined update semantics.</p>
<p>Across many workers and many GPUs the computation for gradient $i$ can be defined as</p>
<p>$$\mathbf{g}<em>{i} = \sum</em>{k \in \textrm{workers}} \sum_{j \in \textrm{GPUs}} \mathbf{g}_{ijk},$$</p>
<p>where $\mathbf{g}_{ijk}$ is part of gradient $i$ split on GPU $j$ of worker $k$.
The key aspect in this operation is that it is a <em>commutative reduction</em>, that is, it turns many vectors into one and the order in which the operation is applied does not matter. This is great for our purposes since we do not (need to) have fine grained control over when which gradient is received. Besides, note that this operation is independent among different $i$.</p>
<p>This allows us to define the following two operations: <em>push</em>, which accumulates gradients, and <em>pull</em>, which retrieves aggregate gradients. Since we have many different sets of gradients (after all, we have many layers), we need to index the gradients with a key $i$. This similarity to key--value stores, such as the one introduced in Dynamo
:cite:<code>DeCandia.Hastorun.Jampani.ea.2007</code> is not by coincidence. They, too, satisfy many similar characteristics, in particular when it comes to distributing the parameters across multiple servers.</p>
<p>The push and pull operations for key-value stores are described as follows:</p>
<ul>
<li><strong>push(key, value)</strong> sends a particular gradient (the value) from a worker to a common storage. There the value is aggregated, e.g., by summing it up.</li>
<li><strong>pull(key, value)</strong> retrieves an aggregate value from common storage, e.g., after combining the gradients from all workers.</li>
</ul>
<p>By hiding all the complexity about synchronization behind a simple push and pull operation we can decouple the concerns of statistical modelers who want to be able to express optimization in simple terms and the system engineers who need to deal with the complexity inherent in distributed synchronization.</p>
<h2 id="summary-71"><a class="header" href="#summary-71">Summary</a></h2>
<ul>
<li>Synchronization needs to be highly adaptive to specific network infrastructure and connectivity within a server. This can make a significant difference to the time it takes to synchronize.</li>
<li>Ring-synchronization can be optimal for p3 and DGX-2 servers. For others possibly not so much.</li>
<li>A hierarchical synchronization strategy works well when adding multiple parameter servers for increased bandwidth.</li>
</ul>
<h2 id="exercises-91"><a class="header" href="#exercises-91">Exercises</a></h2>
<ol>
<li>Can you increase the ring synchronization even further? Hint: you can send messages in both directions.</li>
<li>Is it possible to allow asynchronous communication (while computation is still ongoing)? How does it affect performance?</li>
<li>What if we lost a server during a long-running computation? How can we design a <em>fault tolerance</em> mechanism to avoid restarting the computation fully?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/366">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-vision"><a class="header" href="#computer-vision">Computer Vision</a></h1>
<p>:label:<code>chap_cv</code></p>
<p>Whether it is medical diagnosis, self-driving vehicles, camera monitoring, or smart filters, many applications in the field of computer vision are closely related to our current and future lives.
In recent years, deep learning has been
the transformative power for advancing the performance of computer vision systems.
It can be said that the most advanced computer vision applications are almost inseparable from deep learning.
In view of this, this chapter will focus on the field of computer vision, and investigate methods and applications that have recently been influential in academia and industry.</p>
<p>In :numref:<code>chap_cnn</code> and :numref:<code>chap_modern_cnn</code>, we studied various convolutional neural networks that are
commonly used in computer vision, and applied them
to simple image classification tasks.
At the beginning of this chapter, we will describe
two methods that
may improve model generalization, namely <em>image augmentation</em> and <em>fine-tuning</em>,
and apply them to image classification.
Since deep neural networks can effectively represent images in multiple levels,
such layerwise representations have been successfully
used in various computer vision tasks such as <em>object detection</em>, <em>semantic segmentation</em>, and <em>style transfer</em>.
Following the key idea of leveraging layerwise representations in computer vision,
we will begin with major components and techniques for object detection. Next, we will show how to use <em>fully convolutional networks</em> for semantic segmentation of images. Then we will explain how to use style transfer techniques to generate images like the cover of this book.
In the end, we conclude this chapter
by applying the materials of this chapter and several previous chapters on two popular computer vision benchmark datasets.</p>
<pre><code class="language-toc">:maxdepth: 2

image-augmentation
fine-tuning
bounding-box
anchor
multiscale-object-detection
object-detection-dataset
ssd
rcnn
semantic-segmentation-and-dataset
transposed-conv
fcn
neural-style
kaggle-cifar10
kaggle-dog
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-augmentation"><a class="header" href="#image-augmentation">Image Augmentation</a></h1>
<p>:label:<code>sec_image_augmentation</code></p>
<p>In :numref:<code>sec_alexnet</code>,
we mentioned that large datasets
are a prerequisite
for the success of
deep neural networks
in various applications.
<em>Image augmentation</em>
generates similar but distinct training examples
after a series of random changes to the training images, thereby expanding the size of the training set.
Alternatively,
image augmentation can be motivated
by the fact that
random tweaks of training examples
allow models to rely less on
certain attributes, thereby improving their generalization ability.
For example, we can crop an image in different ways to make the object of interest appear in different positions, thereby reducing the dependence of a model on the position of the object.
We can also adjust factors such as brightness and color to reduce a model's sensitivity to color.
It is probably true
that image augmentation was indispensable
for the success of AlexNet at that time.
In this section we will discuss this widely used technique in computer vision.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, image, init, np, npx
from mxnet.gluon import nn

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
from torch import nn
</code></pre>
<h2 id="common-image-augmentation-methods"><a class="header" href="#common-image-augmentation-methods">Common Image Augmentation Methods</a></h2>
<p>In our investigation of common image augmentation methods, we will use the following $400\times 500$ image an example.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.set_figsize()
img = image.imread('../img/cat1.jpg')
d2l.plt.imshow(img.asnumpy());
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
d2l.set_figsize()
img = d2l.Image.open('../img/cat1.jpg')
d2l.plt.imshow(img);
</code></pre>
<p>Most image augmentation methods have a certain degree of randomness. To make it easier for us to observe the effect of image augmentation, next we define an auxiliary function <code>apply</code>. This function runs the image augmentation method <code>aug</code> multiple times on the input image <code>img</code> and shows all the results.</p>
<pre><code class="language-{.python .input}">#@tab all
def apply(img, aug, num_rows=2, num_cols=4, scale=1.5):
    Y = [aug(img) for _ in range(num_rows * num_cols)]
    d2l.show_images(Y, num_rows, num_cols, scale=scale)
</code></pre>
<h3 id="flipping-and-cropping"><a class="header" href="#flipping-and-cropping">Flipping and Cropping</a></h3>
<p>:begin_tab:<code>mxnet</code>
[<strong>Flipping the image left and right</strong>] usually does not change the category of the object.
This is one of the earliest and most widely used methods of image augmentation.
Next, we use the <code>transforms</code> module to create the <code>RandomFlipLeftRight</code> instance, which flips
an image left and right with a 50% chance.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>Flipping the image left and right</strong>] usually does not change the category of the object.
This is one of the earliest and most widely used methods of image augmentation.
Next, we use the <code>transforms</code> module to create the <code>RandomHorizontalFlip</code> instance, which flips
an image left and right with a 50% chance.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
apply(img, gluon.data.vision.transforms.RandomFlipLeftRight())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
apply(img, torchvision.transforms.RandomHorizontalFlip())
</code></pre>
<p>:begin_tab:<code>mxnet</code>
[<strong>Flipping up and down</strong>] is not as common as flipping left and right. But at least for this example image, flipping up and down does not hinder recognition.
Next, we create a <code>RandomFlipTopBottom</code> instance to flip
an image up and down with a 50% chance.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
[<strong>Flipping up and down</strong>] is not as common as flipping left and right. But at least for this example image, flipping up and down does not hinder recognition.
Next, we create a <code>RandomVerticalFlip</code> instance to flip
an image up and down with a 50% chance.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
apply(img, gluon.data.vision.transforms.RandomFlipTopBottom())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
apply(img, torchvision.transforms.RandomVerticalFlip())
</code></pre>
<p>In the example image we used, the cat is in the middle of the image, but this may not be the case in general.
In :numref:<code>sec_pooling</code>, we explained that the pooling layer can reduce the sensitivity of a convolutional layer to the target position.
In addition, we can also randomly crop the image to make objects appear in different positions in the image at different scales, which can also reduce the sensitivity of a model to the target position.</p>
<p>In the code below, we [<strong>randomly crop</strong>] an area with an area of $10% \sim 100%$ of the original area each time, and the ratio of width to height of this area is randomly selected from $0.5 \sim 2$. Then, the width and height of the region are both scaled to 200 pixels.
Unless otherwise specified, the random number between $a$ and $b$ in this section refers to a continuous value obtained by random and uniform sampling from the interval $[a, b]$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
shape_aug = gluon.data.vision.transforms.RandomResizedCrop(
    (200, 200), scale=(0.1, 1), ratio=(0.5, 2))
apply(img, shape_aug)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
shape_aug = torchvision.transforms.RandomResizedCrop(
    (200, 200), scale=(0.1, 1), ratio=(0.5, 2))
apply(img, shape_aug)
</code></pre>
<h3 id="changing-colors"><a class="header" href="#changing-colors">Changing Colors</a></h3>
<p>Another augmentation method is changing colors. We can change four aspects of the image color: brightness, contrast, saturation, and hue. In the example below, we [<strong>randomly change the brightness</strong>] of the image to a value between 50% ($1-0.5$) and 150% ($1+0.5$) of the original image.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
apply(img, gluon.data.vision.transforms.RandomBrightness(0.5))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
apply(img, torchvision.transforms.ColorJitter(
    brightness=0.5, contrast=0, saturation=0, hue=0))
</code></pre>
<p>Similarly, we can [<strong>randomly change the hue</strong>] of the image.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
apply(img, gluon.data.vision.transforms.RandomHue(0.5))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
apply(img, torchvision.transforms.ColorJitter(
    brightness=0, contrast=0, saturation=0, hue=0.5))
</code></pre>
<p>We can also create a <code>RandomColorJitter</code> instance and set how to [<strong>randomly change the <code>brightness</code>, <code>contrast</code>, <code>saturation</code>, and <code>hue</code> of the image at the same time</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
color_aug = gluon.data.vision.transforms.RandomColorJitter(
    brightness=0.5, contrast=0.5, saturation=0.5, hue=0.5)
apply(img, color_aug)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
color_aug = torchvision.transforms.ColorJitter(
    brightness=0.5, contrast=0.5, saturation=0.5, hue=0.5)
apply(img, color_aug)
</code></pre>
<h3 id="combining-multiple-image-augmentation-methods"><a class="header" href="#combining-multiple-image-augmentation-methods">Combining Multiple Image Augmentation Methods</a></h3>
<p>In practice, we will [<strong>combine multiple image augmentation methods</strong>].
For example,
we can combine the different image augmentation methods defined above and apply them to each image via a <code>Compose</code> instance.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
augs = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.RandomFlipLeftRight(), color_aug, shape_aug])
apply(img, augs)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
augs = torchvision.transforms.Compose([
    torchvision.transforms.RandomHorizontalFlip(), color_aug, shape_aug])
apply(img, augs)
</code></pre>
<h2 id="training-with-image-augmentation"><a class="header" href="#training-with-image-augmentation">[<strong>Training with Image Augmentation</strong>]</a></h2>
<p>Let's train a model with image augmentation.
Here we use the CIFAR-10 dataset instead of the Fashion-MNIST dataset that we used before.
This is because the position and size of the objects in the Fashion-MNIST dataset have been normalized, while the color and size of the objects in the CIFAR-10 dataset have more significant differences.
The first 32 training images in the CIFAR-10 dataset are shown below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.show_images(gluon.data.vision.CIFAR10(
    train=True)[:32][0], 4, 8, scale=0.8);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
all_images = torchvision.datasets.CIFAR10(train=True, root="../data",
                                          download=True)
d2l.show_images([all_images[i][0] for i in range(32)], 4, 8, scale=0.8);
</code></pre>
<p>In order to obtain definitive results during prediction, we usually only apply image augmentation to training examples, and do not use image augmentation with random operations during prediction.
[<strong>Here we only use the simplest random left-right flipping method</strong>]. In addition, we use a <code>ToTensor</code> instance to convert a minibatch of images into the format required by the deep learning framework, i.e.,
32-bit floating point numbers between 0 and 1 with the shape of (batch size, number of channels, height, width).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_augs = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.RandomFlipLeftRight(),
    gluon.data.vision.transforms.ToTensor()])

test_augs = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.ToTensor()])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_augs = torchvision.transforms.Compose([
     torchvision.transforms.RandomHorizontalFlip(),
     torchvision.transforms.ToTensor()])

test_augs = torchvision.transforms.Compose([
     torchvision.transforms.ToTensor()])
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Next, we define an auxiliary function to facilitate reading the image and
applying image augmentation.
The <code>transform_first</code> function provided by Gluon's
datasets applies image augmentation to the first element of each training
example (image and label), i.e., the image.
For
a detailed introduction to <code>DataLoader</code>, please refer to :numref:<code>sec_fashion_mnist</code>.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Next, we [<strong>define an auxiliary function to facilitate reading the image and
applying image augmentation</strong>].
The <code>transform</code> argument provided by PyTorch's
dataset applies augmentation to transform the images.
For
a detailed introduction to <code>DataLoader</code>, please refer to :numref:<code>sec_fashion_mnist</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def load_cifar10(is_train, augs, batch_size):
    return gluon.data.DataLoader(
        gluon.data.vision.CIFAR10(train=is_train).transform_first(augs),
        batch_size=batch_size, shuffle=is_train,
        num_workers=d2l.get_dataloader_workers())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def load_cifar10(is_train, augs, batch_size):
    dataset = torchvision.datasets.CIFAR10(root="../data", train=is_train,
                                           transform=augs, download=True)
    dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size,
                    shuffle=is_train, num_workers=d2l.get_dataloader_workers())
    return dataloader
</code></pre>
<h3 id="multi-gpu-training"><a class="header" href="#multi-gpu-training">Multi-GPU Training</a></h3>
<p>We train the ResNet-18 model from
:numref:<code>sec_resnet</code> on the
CIFAR-10 dataset.
Recall the introduction to
multi-GPU training in :numref:<code>sec_multi_gpu_concise</code>.
In the following,
[<strong>we define a function to train and evaluate the model using multiple GPUs</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def train_batch_ch13(net, features, labels, loss, trainer, devices,
                     split_f=d2l.split_batch):
    """Train for a minibatch with multiple GPUs (defined in Chapter 13)."""
    X_shards, y_shards = split_f(features, labels, devices)
    with autograd.record():
        pred_shards = [net(X_shard) for X_shard in X_shards]
        ls = [loss(pred_shard, y_shard) for pred_shard, y_shard
              in zip(pred_shards, y_shards)]
    for l in ls:
        l.backward()
    # The `True` flag allows parameters with stale gradients, which is useful
    # later (e.g., in fine-tuning BERT)
    trainer.step(labels.shape[0], ignore_stale_grad=True)
    train_loss_sum = sum([float(l.sum()) for l in ls])
    train_acc_sum = sum(d2l.accuracy(pred_shard, y_shard)
                        for pred_shard, y_shard in zip(pred_shards, y_shards))
    return train_loss_sum, train_acc_sum
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def train_batch_ch13(net, X, y, loss, trainer, devices):
    """Train for a minibatch with multiple GPUs (defined in Chapter 13)."""
    if isinstance(X, list):
        # Required for BERT fine-tuning (to be covered later)
        X = [x.to(devices[0]) for x in X]
    else:
        X = X.to(devices[0])
    y = y.to(devices[0])
    net.train()
    trainer.zero_grad()
    pred = net(X)
    l = loss(pred, y)
    l.sum().backward()
    trainer.step()
    train_loss_sum = l.sum()
    train_acc_sum = d2l.accuracy(pred, y)
    return train_loss_sum, train_acc_sum
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,
               devices=d2l.try_all_gpus(), split_f=d2l.split_batch):
    """Train a model with multiple GPUs (defined in Chapter 13)."""
    timer, num_batches = d2l.Timer(), len(train_iter)
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0, 1],
                            legend=['train loss', 'train acc', 'test acc'])
    for epoch in range(num_epochs):
        # Sum of training loss, sum of training accuracy, no. of examples,
        # no. of predictions
        metric = d2l.Accumulator(4)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            l, acc = train_batch_ch13(
                net, features, labels, loss, trainer, devices, split_f)
            metric.add(l, acc, labels.shape[0], labels.size)
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[2], metric[1] / metric[3],
                              None))
        test_acc = d2l.evaluate_accuracy_gpus(net, test_iter, split_f)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'loss {metric[0] / metric[2]:.3f}, train acc '
          f'{metric[1] / metric[3]:.3f}, test acc {test_acc:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec on '
          f'{str(devices)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,
               devices=d2l.try_all_gpus()):
    """Train a model with multiple GPUs (defined in Chapter 13)."""
    timer, num_batches = d2l.Timer(), len(train_iter)
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0, 1],
                            legend=['train loss', 'train acc', 'test acc'])
    net = nn.DataParallel(net, device_ids=devices).to(devices[0])
    for epoch in range(num_epochs):
        # Sum of training loss, sum of training accuracy, no. of examples,
        # no. of predictions
        metric = d2l.Accumulator(4)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            l, acc = train_batch_ch13(
                net, features, labels, loss, trainer, devices)
            metric.add(l, acc, labels.shape[0], labels.numel())
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[2], metric[1] / metric[3],
                              None))
        test_acc = d2l.evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'loss {metric[0] / metric[2]:.3f}, train acc '
          f'{metric[1] / metric[3]:.3f}, test acc {test_acc:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec on '
          f'{str(devices)}')
</code></pre>
<p>Now we can [<strong>define the <code>train_with_data_aug</code> function to train the model with image augmentation</strong>].
This function gets all available GPUs,
uses Adam as the optimization algorithm,
applies image augmentation to the training dataset,
and finally calls the <code>train_ch13</code> function just defined to train and evaluate the model.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
batch_size, devices, net = 256, d2l.try_all_gpus(), d2l.resnet18(10)
net.initialize(init=init.Xavier(), ctx=devices)

def train_with_data_aug(train_augs, test_augs, net, lr=0.001):
    train_iter = load_cifar10(True, train_augs, batch_size)
    test_iter = load_cifar10(False, test_augs, batch_size)
    loss = gluon.loss.SoftmaxCrossEntropyLoss()
    trainer = gluon.Trainer(net.collect_params(), 'adam',
                            {'learning_rate': lr})
    train_ch13(net, train_iter, test_iter, loss, trainer, 10, devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
batch_size, devices, net = 256, d2l.try_all_gpus(), d2l.resnet18(10, 3)
net.apply(d2l.init_cnn)

def train_with_data_aug(train_augs, test_augs, net, lr=0.001):
    train_iter = load_cifar10(True, train_augs, batch_size)
    test_iter = load_cifar10(False, test_augs, batch_size)
    loss = nn.CrossEntropyLoss(reduction="none")
    trainer = torch.optim.Adam(net.parameters(), lr=lr)
    net(next(iter(train_iter))[0])
    train_ch13(net, train_iter, test_iter, loss, trainer, 10, devices)
</code></pre>
<p>Let's [<strong>train the model</strong>] using image augmentation based on random left-right flipping.</p>
<pre><code class="language-{.python .input}">#@tab all
train_with_data_aug(train_augs, test_augs, net)
</code></pre>
<h2 id="summary-72"><a class="header" href="#summary-72">Summary</a></h2>
<ul>
<li>Image augmentation generates random images based on existing training data to improve the generalization ability of models.</li>
<li>In order to obtain definitive results during prediction, we usually only apply image augmentation to training examples, and do not use image augmentation with random operations during prediction.</li>
<li>Deep learning frameworks provide many different image augmentation methods, which can be applied simultaneously.</li>
</ul>
<h2 id="exercises-92"><a class="header" href="#exercises-92">Exercises</a></h2>
<ol>
<li>Train the model without using image augmentation: <code>train_with_data_aug(test_augs, test_augs)</code>. Compare training and testing accuracy when using and not using image augmentation. Can this comparative experiment support the argument that image augmentation can mitigate overfitting? Why?</li>
<li>Combine multiple different image augmentation methods in model training on the CIFAR-10 dataset. Does it improve test accuracy?</li>
<li>Refer to the online documentation of the deep learning framework. What other image augmentation methods does it also provide?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/367">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1404">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fine-tuning"><a class="header" href="#fine-tuning">Fine-Tuning</a></h1>
<p>:label:<code>sec_fine_tuning</code></p>
<p>In earlier chapters, we discussed how to train models on the Fashion-MNIST training dataset with only 60000 images. We also described ImageNet, the most widely used large-scale image dataset in academia, which has more than 10 million images and 1000 objects. However, the size of the dataset that we usually encounter is between those of the two datasets.</p>
<p>Suppose that we want to recognize different types of chairs from images, and then recommend purchase links to users.
One possible method is to first identify
100 common chairs,
take 1000 images of different angles for each chair,
and then train a classification model on the collected image dataset.
Although this chair dataset may be larger than the Fashion-MNIST dataset,
the number of examples is still less than one-tenth of
that in ImageNet.
This may lead to overfitting of complicated models
that are suitable for ImageNet on this chair dataset.
Besides, due to the limited amount of training examples,
the accuracy of the trained model
may not meet practical requirements.</p>
<p>In order to address the above problems,
an obvious solution is to collect more data.
However, collecting and labeling data can take a lot of time and money.
For example, in order to collect the ImageNet dataset, researchers have spent millions of dollars from research funding.
Although the current data collection cost has been significantly reduced, this cost still cannot be ignored.</p>
<p>Another solution is to apply <em>transfer learning</em> to transfer the knowledge learned from the <em>source dataset</em> to the <em>target dataset</em>.
For example, although most of the images in the ImageNet dataset have nothing to do with chairs, the model trained on this dataset may extract more general image features, which can help identify edges, textures, shapes, and object composition.
These similar features may
also be effective for recognizing chairs.</p>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<p>In this section, we will introduce a common technique in transfer learning: <em>fine-tuning</em>. As shown in :numref:<code>fig_finetune</code>, fine-tuning consists of the following four steps:</p>
<ol>
<li>Pretrain a neural network model, i.e., the <em>source model</em>, on a source dataset (e.g., the ImageNet dataset).</li>
<li>Create a new neural network model, i.e., the <em>target model</em>. This copies all model designs and their parameters on the source model except the output layer. We assume that these model parameters contain the knowledge learned from the source dataset and this knowledge will also be applicable to the target dataset. We also assume that the output layer of the source model is closely related to the labels of the source dataset; thus it is not used in the target model.</li>
<li>Add an output layer to the target model, whose number of outputs is the number of categories in the target dataset. Then randomly initialize the model parameters of this layer.</li>
<li>Train the target model on the target dataset, such as a chair dataset. The output layer will be trained from scratch, while the parameters of all the other layers are fine-tuned based on the parameters of the source model.</li>
</ol>
<p><img src="chapter_computer-vision/../img/finetune.svg" alt="Fine tuning." />
:label:<code>fig_finetune</code></p>
<p>When target datasets are much smaller than source datasets, fine-tuning helps to improve models' generalization ability.</p>
<h2 id="hot-dog-recognition"><a class="header" href="#hot-dog-recognition">Hot Dog Recognition</a></h2>
<p>Let's demonstrate fine-tuning via a concrete case:
hot dog recognition.
We will fine-tune a ResNet model on a small dataset,
which was pretrained on the ImageNet dataset.
This small dataset consists of
thousands of images with and without hot dogs.
We will use the fine-tuned model to recognize
hot dogs from images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, init, np, npx
from mxnet.gluon import nn
import os

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from torch import nn
import torch
import torchvision
import os
</code></pre>
<h3 id="reading-the-dataset-5"><a class="header" href="#reading-the-dataset-5">Reading the Dataset</a></h3>
<p>[<strong>The hot dog dataset we use was taken from online images</strong>].
This dataset consists of
1400 positive-class images containing hot dogs,
and as many negative-class images containing other foods.
1000 images of both classes are used for training and the rest are for testing.</p>
<p>After unzipping the downloaded dataset,
we obtain two folders <code>hotdog/train</code> and <code>hotdog/test</code>. Both folders have <code>hotdog</code> and <code>not-hotdog</code> subfolders, either of which contains images of
the corresponding class.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['hotdog'] = (d2l.DATA_URL + 'hotdog.zip', 
                         'fba480ffa8aa7e0febbb511d181409f899b9baa5')

data_dir = d2l.download_extract('hotdog')
</code></pre>
<p>We create two instances to read all the image files in the training and testing datasets, respectively.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_imgs = gluon.data.vision.ImageFolderDataset(
    os.path.join(data_dir, 'train'))
test_imgs = gluon.data.vision.ImageFolderDataset(
    os.path.join(data_dir, 'test'))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_imgs = torchvision.datasets.ImageFolder(os.path.join(data_dir, 'train'))
test_imgs = torchvision.datasets.ImageFolder(os.path.join(data_dir, 'test'))
</code></pre>
<p>The first 8 positive examples and the last 8 negative images are shown below. As you can see, [<strong>the images vary in size and aspect ratio</strong>].</p>
<pre><code class="language-{.python .input}">#@tab all
hotdogs = [train_imgs[i][0] for i in range(8)]
not_hotdogs = [train_imgs[-i - 1][0] for i in range(8)]
d2l.show_images(hotdogs + not_hotdogs, 2, 8, scale=1.4);
</code></pre>
<p>During training, we first crop a random area of random size and random aspect ratio from the image,
and then scale this area
to a $224 \times 224$ input image.
During testing, we scale both the height and width of an image to 256 pixels, and then crop a central $224 \times 224$ area as input.
In addition,
for the three RGB (red, green, and blue) color channels
we <em>standardize</em> their values channel by channel.
Concretely,
the mean value of a channel is subtracted from each value of that channel and then the result is divided by the standard deviation of that channel.</p>
<p>[<del>Data augmentations</del>]</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Specify the means and standard deviations of the three RGB channels to
# standardize each channel
normalize = gluon.data.vision.transforms.Normalize(
    [0.485, 0.456, 0.406], [0.229, 0.224, 0.225])

train_augs = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.RandomResizedCrop(224),
    gluon.data.vision.transforms.RandomFlipLeftRight(),
    gluon.data.vision.transforms.ToTensor(),
    normalize])

test_augs = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.Resize(256),
    gluon.data.vision.transforms.CenterCrop(224),
    gluon.data.vision.transforms.ToTensor(),
    normalize])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Specify the means and standard deviations of the three RGB channels to
# standardize each channel
normalize = torchvision.transforms.Normalize(
    [0.485, 0.456, 0.406], [0.229, 0.224, 0.225])

train_augs = torchvision.transforms.Compose([
    torchvision.transforms.RandomResizedCrop(224),
    torchvision.transforms.RandomHorizontalFlip(),
    torchvision.transforms.ToTensor(),
    normalize])

test_augs = torchvision.transforms.Compose([
    torchvision.transforms.Resize([256, 256]),
    torchvision.transforms.CenterCrop(224),
    torchvision.transforms.ToTensor(),
    normalize])
</code></pre>
<h3 id="defining-and-initializing-the-model"><a class="header" href="#defining-and-initializing-the-model">[<strong>Defining and Initializing the Model</strong>]</a></h3>
<p>We use ResNet-18, which was pretrained on the ImageNet dataset, as the source model. Here, we specify <code>pretrained=True</code> to automatically download the pretrained model parameters.
If this model is used for the first time,
Internet connection is required for download.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
pretrained_net = gluon.model_zoo.vision.resnet18_v2(pretrained=True)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
pretrained_net = torchvision.models.resnet18(pretrained=True)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
The pretrained source model instance contains two member variables: <code>features</code> and <code>output</code>. The former contains all layers of the model except the output layer, and the latter is the output layer of the model.
The main purpose of this division is to facilitate the fine-tuning of model parameters of all layers but the output layer. The member variable <code>output</code> of source model is shown below.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
The pretrained source model instance contains a number of feature layers and an output layer <code>fc</code>.
The main purpose of this division is to facilitate the fine-tuning of model parameters of all layers but the output layer. The member variable <code>fc</code> of source model is given below.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
pretrained_net.output
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
pretrained_net.fc
</code></pre>
<p>As a fully connected layer, it transforms ResNet's final global average pooling outputs into 1000 class outputs of the ImageNet dataset.
We then construct a new neural network as the target model. It is defined in the same way as the pretrained source model except that
its number of outputs in the final layer
is set to
the number of classes in the target dataset (rather than 1000).</p>
<p>In the code below, the model parameters before the output layer of the target model instance <code>finetune_net</code> are initialized to model parameters of the corresponding layers from the source model.
Since these model parameters were obtained via pretraining on ImageNet,
they are effective.
Therefore, we can only use
a small learning rate to <em>fine-tune</em> such pretrained parameters.
In contrast, model parameters in the output layer are randomly initialized and generally require a larger learning rate to be learned from scratch.
Letting the base learning rate be $\eta$, a learning rate of $10\eta$ will be used to iterate the model parameters in the output layer.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
finetune_net = gluon.model_zoo.vision.resnet18_v2(classes=2)
finetune_net.features = pretrained_net.features
finetune_net.output.initialize(init.Xavier())
# The model parameters in the output layer will be iterated using a learning
# rate ten times greater
finetune_net.output.collect_params().setattr('lr_mult', 10)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
finetune_net = torchvision.models.resnet18(pretrained=True)
finetune_net.fc = nn.Linear(finetune_net.fc.in_features, 2)
nn.init.xavier_uniform_(finetune_net.fc.weight);
</code></pre>
<h3 id="fine-tuning-the-model"><a class="header" href="#fine-tuning-the-model">[<strong>Fine-Tuning the Model</strong>]</a></h3>
<p>First, we define a training function <code>train_fine_tuning</code> that uses fine-tuning so it can be called multiple times.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train_fine_tuning(net, learning_rate, batch_size=128, num_epochs=5):
    train_iter = gluon.data.DataLoader(
        train_imgs.transform_first(train_augs), batch_size, shuffle=True)
    test_iter = gluon.data.DataLoader(
        test_imgs.transform_first(test_augs), batch_size)
    devices = d2l.try_all_gpus()
    net.collect_params().reset_ctx(devices)
    net.hybridize()
    loss = gluon.loss.SoftmaxCrossEntropyLoss()
    trainer = gluon.Trainer(net.collect_params(), 'sgd', {
        'learning_rate': learning_rate, 'wd': 0.001})
    d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,
                   devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# If `param_group=True`, the model parameters in the output layer will be
# updated using a learning rate ten times greater
def train_fine_tuning(net, learning_rate, batch_size=128, num_epochs=5,
                      param_group=True):
    train_iter = torch.utils.data.DataLoader(torchvision.datasets.ImageFolder(
        os.path.join(data_dir, 'train'), transform=train_augs),
        batch_size=batch_size, shuffle=True)
    test_iter = torch.utils.data.DataLoader(torchvision.datasets.ImageFolder(
        os.path.join(data_dir, 'test'), transform=test_augs),
        batch_size=batch_size)
    devices = d2l.try_all_gpus()
    loss = nn.CrossEntropyLoss(reduction="none")
    if param_group:
        params_1x = [param for name, param in net.named_parameters()
             if name not in ["fc.weight", "fc.bias"]]
        trainer = torch.optim.SGD([{'params': params_1x},
                                   {'params': net.fc.parameters(),
                                    'lr': learning_rate * 10}],
                                lr=learning_rate, weight_decay=0.001)
    else:
        trainer = torch.optim.SGD(net.parameters(), lr=learning_rate,
                                  weight_decay=0.001)    
    d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,
                   devices)
</code></pre>
<p>We [<strong>set the base learning rate to a small value</strong>]
in order to <em>fine-tune</em> the model parameters obtained via pretraining. Based on the previous settings, we will train the output layer parameters of the target model from scratch using a learning rate ten times greater.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_fine_tuning(finetune_net, 0.01)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_fine_tuning(finetune_net, 5e-5)
</code></pre>
<p>[<strong>For comparison,</strong>] we define an identical model, but (<strong>initialize all of its model parameters to random values</strong>). Since the entire model needs to be trained from scratch, we can use a larger learning rate.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
scratch_net = gluon.model_zoo.vision.resnet18_v2(classes=2)
scratch_net.initialize(init=init.Xavier())
train_fine_tuning(scratch_net, 0.1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
scratch_net = torchvision.models.resnet18()
scratch_net.fc = nn.Linear(scratch_net.fc.in_features, 2)
train_fine_tuning(scratch_net, 5e-4, param_group=False)
</code></pre>
<p>As we can see, the fine-tuned model tends to perform better for the same epoch
because its initial parameter values are more effective.</p>
<h2 id="summary-73"><a class="header" href="#summary-73">Summary</a></h2>
<ul>
<li>Transfer learning transfers knowledge learned from the source dataset to the target dataset. Fine-tuning is a common technique for transfer learning.</li>
<li>The target model copies all model designs with their parameters from the source model except the output layer, and fine-tunes these parameters based on the target dataset. In contrast, the output layer of the target model needs to be trained from scratch.</li>
<li>Generally, fine-tuning parameters uses a smaller learning rate, while training the output layer from scratch can use a larger learning rate.</li>
</ul>
<h2 id="exercises-93"><a class="header" href="#exercises-93">Exercises</a></h2>
<ol>
<li>Keep increasing the learning rate of <code>finetune_net</code>. How does the accuracy of the model change?</li>
<li>Further adjust hyperparameters of <code>finetune_net</code> and <code>scratch_net</code> in the comparative experiment. Do they still differ in accuracy?</li>
<li>Set the parameters before the output layer of <code>finetune_net</code> to those of the source model and do <em>not</em> update them during training. How does the accuracy of the model change? You can use the following code.</li>
</ol>
<pre><code class="language-{.python .input}">#@tab mxnet
finetune_net.features.collect_params().setattr('grad_req', 'null')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
for param in finetune_net.parameters():
    param.requires_grad = False
</code></pre>
<ol start="4">
<li>In fact, there is a "hotdog" class in the <code>ImageNet</code> dataset. Its corresponding weight parameter in the output layer can be obtained via the following code. How can we leverage this weight parameter?</li>
</ol>
<pre><code class="language-{.python .input}">#@tab mxnet
weight = pretrained_net.output.weight
hotdog_w = np.split(weight.data(), 1000, axis=0)[713]
hotdog_w.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
weight = pretrained_net.fc.weight
hotdog_w = torch.split(weight.data, 1, dim=0)[934]
hotdog_w.shape
</code></pre>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/368">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1439">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-detection-and-bounding-boxes"><a class="header" href="#object-detection-and-bounding-boxes">Object Detection and Bounding Boxes</a></h1>
<p>:label:<code>sec_bbox</code></p>
<p>In earlier sections (e.g., :numref:<code>sec_alexnet</code>--:numref:<code>sec_googlenet</code>),
we introduced various models for image classification.
In image classification tasks,
we assume that there is only <em>one</em>
major object
in the image and we only focus on how to
recognize its category.
However, there are often <em>multiple</em> objects
in the image of interest.
We not only want to know their categories, but also their specific positions in the image.
In computer vision, we refer to such tasks as <em>object detection</em> (or <em>object recognition</em>).</p>
<p>Object detection has been
widely applied in many fields.
For example, self-driving needs to plan
traveling routes
by detecting the positions
of vehicles, pedestrians, roads, and obstacles in the captured video images.
Besides,
robots may use this technique
to detect and localize objects of interest
throughout its navigation of an environment.
Moreover,
security systems
may need to detect abnormal objects, such as intruders or bombs.</p>
<p>In the next few sections, we will introduce
several deep learning methods for object detection.
We will begin with an introduction
to <em>positions</em> (or <em>locations</em>) of objects.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import image, npx, np

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<p>We will load the sample image to be used in this section. We can see that there is a dog on the left side of the image and a cat on the right.
They are the two major objects in this image.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.set_figsize()
img = image.imread('../img/catdog.jpg').asnumpy()
d2l.plt.imshow(img);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch, tensorflow
d2l.set_figsize()
img = d2l.plt.imread('../img/catdog.jpg')
d2l.plt.imshow(img);
</code></pre>
<h2 id="bounding-boxes"><a class="header" href="#bounding-boxes">Bounding Boxes</a></h2>
<p>In object detection,
we usually use a <em>bounding box</em> to describe the spatial location of an object.
The bounding box is rectangular, which is determined by the $x$ and $y$ coordinates of the upper-left corner of the rectangle and the such coordinates of the lower-right corner.
Another commonly used bounding box representation is the $(x, y)$-axis
coordinates of the bounding box center, and the width and height of the box.</p>
<p>[<strong>Here we define functions to convert between</strong>] these (<strong>two
representations</strong>):
<code>box_corner_to_center</code> converts from the two-corner
representation to the center-width-height presentation,
and <code>box_center_to_corner</code> vice versa.
The input argument <code>boxes</code> should be a two-dimensional tensor of
shape ($n$, 4), where $n$ is the number of bounding boxes.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def box_corner_to_center(boxes):
    """Convert from (upper-left, lower-right) to (center, width, height)."""
    x1, y1, x2, y2 = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]
    cx = (x1 + x2) / 2
    cy = (y1 + y2) / 2
    w = x2 - x1
    h = y2 - y1
    boxes = d2l.stack((cx, cy, w, h), axis=-1)
    return boxes

#@save
def box_center_to_corner(boxes):
    """Convert from (center, width, height) to (upper-left, lower-right)."""
    cx, cy, w, h = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]
    x1 = cx - 0.5 * w
    y1 = cy - 0.5 * h
    x2 = cx + 0.5 * w
    y2 = cy + 0.5 * h
    boxes = d2l.stack((x1, y1, x2, y2), axis=-1)
    return boxes
</code></pre>
<p>We will [<strong>define the bounding boxes of the dog and the cat in the image</strong>] based
on the coordinate information.
The origin of the coordinates in the image
is the upper-left corner of the image, and to the right and down are the
positive directions of the $x$ and $y$ axes, respectively.</p>
<pre><code class="language-{.python .input}">#@tab all
# Here `bbox` is the abbreviation for bounding box
dog_bbox, cat_bbox = [60.0, 45.0, 378.0, 516.0], [400.0, 112.0, 655.0, 493.0]
</code></pre>
<p>We can verify the correctness of the two
bounding box conversion functions by converting twice.</p>
<pre><code class="language-{.python .input}">#@tab all
boxes = d2l.tensor((dog_bbox, cat_bbox))
box_center_to_corner(box_corner_to_center(boxes)) == boxes
</code></pre>
<p>Let's [<strong>draw the bounding boxes in the image</strong>] to check if they are accurate.
Before drawing, we will define a helper function <code>bbox_to_rect</code>. It represents the bounding box in the bounding box format of the  <code>matplotlib</code> package.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def bbox_to_rect(bbox, color):
    """Convert bounding box to matplotlib format."""
    # Convert the bounding box (upper-left x, upper-left y, lower-right x,
    # lower-right y) format to the matplotlib format: ((upper-left x,
    # upper-left y), width, height)
    return d2l.plt.Rectangle(
        xy=(bbox[0], bbox[1]), width=bbox[2]-bbox[0], height=bbox[3]-bbox[1],
        fill=False, edgecolor=color, linewidth=2)
</code></pre>
<p>After adding the bounding boxes on the image,
we can see that the main outline of the two objects are basically inside the two boxes.</p>
<pre><code class="language-{.python .input}">#@tab all
fig = d2l.plt.imshow(img)
fig.axes.add_patch(bbox_to_rect(dog_bbox, 'blue'))
fig.axes.add_patch(bbox_to_rect(cat_bbox, 'red'));
</code></pre>
<h2 id="summary-74"><a class="header" href="#summary-74">Summary</a></h2>
<ul>
<li>Object detection not only recognizes all the objects of interest in the image, but also their positions. The position is generally represented by a rectangular bounding box.</li>
<li>We can convert between two commonly used bounding box representations.</li>
</ul>
<h2 id="exercises-94"><a class="header" href="#exercises-94">Exercises</a></h2>
<ol>
<li>Find another image and try to label a bounding box that contains the object. Compare labeling bounding boxes and categories: which usually takes longer?</li>
<li>Why is the innermost dimension of the input argument <code>boxes</code> of <code>box_corner_to_center</code> and <code>box_center_to_corner</code> always 4?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/369">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1527">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anchor-boxes"><a class="header" href="#anchor-boxes">Anchor Boxes</a></h1>
<p>:label:<code>sec_anchor</code></p>
<p>Object detection algorithms usually
sample a large number of regions in the input image, determine whether these regions contain
objects of interest, and adjust the boundaries
of the regions so as to predict the
<em>ground-truth bounding boxes</em>
of the objects more accurately.
Different models may adopt
different region sampling schemes.
Here we introduce one of such methods:
it generates multiple bounding boxes with varying scales and aspect ratios centered on each pixel.
These bounding boxes are called <em>anchor boxes</em>.
We will design an object detection model
based on anchor boxes in :numref:<code>sec_ssd</code>.</p>
<p>First, let's modify the printing accuracy
just for more concise outputs.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, image, np, npx

np.set_printoptions(2)  # Simplify printing accuracy
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

torch.set_printoptions(2)  # Simplify printing accuracy
</code></pre>
<h2 id="generating-multiple-anchor-boxes"><a class="header" href="#generating-multiple-anchor-boxes">Generating Multiple Anchor Boxes</a></h2>
<p>Suppose that the input image has a height of $h$ and width of $w$.
We generate anchor boxes with different shapes centered on each pixel of the image.
Let the <em>scale</em> be $s\in (0, 1]$ and
the <em>aspect ratio</em> (ratio of width to height) is $r &gt; 0$.
Then [<strong>the width and height of the anchor box are $ws\sqrt{r}$ and $hs/\sqrt{r}$, respectively.</strong>]
Note that when the center position is given, an anchor box with known width and height is determined.</p>
<p>To generate multiple anchor boxes with different shapes,
let's set a series of scales
$s_1,\ldots, s_n$ and
a series of aspect ratios $r_1,\ldots, r_m$.
When using all the combinations of these scales and aspect ratios with each pixel as the center,
the input image will have a total of $whnm$ anchor boxes. Although these anchor boxes may cover all the
ground-truth bounding boxes, the computational complexity is easily too high.
In practice,
we can only (<strong>consider those combinations
containing</strong>) $s_1$ or $r_1$:</p>
<p>(<strong>$$(s_1, r_1), (s_1, r_2), \ldots, (s_1, r_m), (s_2, r_1), (s_3, r_1), \ldots, (s_n, r_1).$$</strong>)</p>
<p>That is to say, the number of anchor boxes centered on the same pixel is $n+m-1$. For the entire input image, we will generate a total of $wh(n+m-1)$ anchor boxes.</p>
<p>The above method of generating anchor boxes is implemented in the following <code>multibox_prior</code> function. We specify the input image, a list of scales, and a list of aspect ratios, then this function will return all the anchor boxes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def multibox_prior(data, sizes, ratios):
    """Generate anchor boxes with different shapes centered on each pixel."""
    in_height, in_width = data.shape[-2:]
    device, num_sizes, num_ratios = data.ctx, len(sizes), len(ratios)
    boxes_per_pixel = (num_sizes + num_ratios - 1)
    size_tensor = d2l.tensor(sizes, ctx=device)
    ratio_tensor = d2l.tensor(ratios, ctx=device)
    # Offsets are required to move the anchor to the center of a pixel. Since
    # a pixel has height=1 and width=1, we choose to offset our centers by 0.5
    offset_h, offset_w = 0.5, 0.5
    steps_h = 1.0 / in_height  # Scaled steps in y-axis
    steps_w = 1.0 / in_width  # Scaled steps in x-axis

    # Generate all center points for the anchor boxes
    center_h = (d2l.arange(in_height, ctx=device) + offset_h) * steps_h
    center_w = (d2l.arange(in_width, ctx=device) + offset_w) * steps_w
    shift_x, shift_y = d2l.meshgrid(center_w, center_h)
    shift_x, shift_y = shift_x.reshape(-1), shift_y.reshape(-1)

    # Generate `boxes_per_pixel` number of heights and widths that are later
    # used to create anchor box corner coordinates (xmin, xmax, ymin, ymax)
    w = np.concatenate((size_tensor * np.sqrt(ratio_tensor[0]),
                        sizes[0] * np.sqrt(ratio_tensor[1:]))) \
                        * in_height / in_width  # Handle rectangular inputs
    h = np.concatenate((size_tensor / np.sqrt(ratio_tensor[0]),
                        sizes[0] / np.sqrt(ratio_tensor[1:])))
    # Divide by 2 to get half height and half width
    anchor_manipulations = np.tile(np.stack((-w, -h, w, h)).T,
                                   (in_height * in_width, 1)) / 2

    # Each center point will have `boxes_per_pixel` number of anchor boxes, so
    # generate a grid of all anchor box centers with `boxes_per_pixel` repeats
    out_grid = d2l.stack([shift_x, shift_y, shift_x, shift_y],
                         axis=1).repeat(boxes_per_pixel, axis=0)
    output = out_grid + anchor_manipulations
    return np.expand_dims(output, axis=0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def multibox_prior(data, sizes, ratios):
    """Generate anchor boxes with different shapes centered on each pixel."""
    in_height, in_width = data.shape[-2:]
    device, num_sizes, num_ratios = data.device, len(sizes), len(ratios)
    boxes_per_pixel = (num_sizes + num_ratios - 1)
    size_tensor = d2l.tensor(sizes, device=device)
    ratio_tensor = d2l.tensor(ratios, device=device)
    # Offsets are required to move the anchor to the center of a pixel. Since
    # a pixel has height=1 and width=1, we choose to offset our centers by 0.5
    offset_h, offset_w = 0.5, 0.5
    steps_h = 1.0 / in_height  # Scaled steps in y axis
    steps_w = 1.0 / in_width  # Scaled steps in x axis

    # Generate all center points for the anchor boxes
    center_h = (torch.arange(in_height, device=device) + offset_h) * steps_h
    center_w = (torch.arange(in_width, device=device) + offset_w) * steps_w
    shift_y, shift_x = torch.meshgrid(center_h, center_w, indexing='ij')
    shift_y, shift_x = shift_y.reshape(-1), shift_x.reshape(-1)

    # Generate `boxes_per_pixel` number of heights and widths that are later
    # used to create anchor box corner coordinates (xmin, xmax, ymin, ymax)
    w = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),
                   sizes[0] * torch.sqrt(ratio_tensor[1:])))\
                   * in_height / in_width  # Handle rectangular inputs
    h = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),
                   sizes[0] / torch.sqrt(ratio_tensor[1:])))
    # Divide by 2 to get half height and half width
    anchor_manipulations = torch.stack((-w, -h, w, h)).T.repeat(
                                        in_height * in_width, 1) / 2

    # Each center point will have `boxes_per_pixel` number of anchor boxes, so
    # generate a grid of all anchor box centers with `boxes_per_pixel` repeats
    out_grid = torch.stack([shift_x, shift_y, shift_x, shift_y],
                dim=1).repeat_interleave(boxes_per_pixel, dim=0)
    output = out_grid + anchor_manipulations
    return output.unsqueeze(0)
</code></pre>
<p>We can see that [<strong>the shape of the returned anchor box variable <code>Y</code></strong>] is
(batch size, number of anchor boxes, 4).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
img = image.imread('../img/catdog.jpg').asnumpy()
h, w = img.shape[:2]

print(h, w)
X = np.random.uniform(size=(1, 3, h, w))  # Construct input data
Y = multibox_prior(X, sizes=[0.75, 0.5, 0.25], ratios=[1, 2, 0.5])
Y.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
img = d2l.plt.imread('../img/catdog.jpg')
h, w = img.shape[:2]

print(h, w)
X = torch.rand(size=(1, 3, h, w))  # Construct input data
Y = multibox_prior(X, sizes=[0.75, 0.5, 0.25], ratios=[1, 2, 0.5])
Y.shape
</code></pre>
<p>After changing the shape of the anchor box variable <code>Y</code> to (image height, image width, number of anchor boxes centered on the same pixel, 4),
we can obtain all the anchor boxes centered on a specified pixel position.
In the following,
we [<strong>access the first anchor box centered on (250, 250)</strong>]. It has four elements: the $(x, y)$-axis coordinates at the upper-left corner and the $(x, y)$-axis coordinates at the lower-right corner of the anchor box.
The coordinate values of both axes
are divided by the width and height of the image, respectively.</p>
<pre><code class="language-{.python .input}">#@tab all
boxes = Y.reshape(h, w, 5, 4)
boxes[250, 250, 0, :]
</code></pre>
<p>In order to [<strong>show all the anchor boxes centered on one pixel in the image</strong>],
we define the following <code>show_bboxes</code> function to draw multiple bounding boxes on the image.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def show_bboxes(axes, bboxes, labels=None, colors=None):
    """Show bounding boxes."""

    def make_list(obj, default_values=None):
        if obj is None:
            obj = default_values
        elif not isinstance(obj, (list, tuple)):
            obj = [obj]
        return obj

    labels = make_list(labels)
    colors = make_list(colors, ['b', 'g', 'r', 'm', 'c'])
    for i, bbox in enumerate(bboxes):
        color = colors[i % len(colors)]
        rect = d2l.bbox_to_rect(d2l.numpy(bbox), color)
        axes.add_patch(rect)
        if labels and len(labels) &gt; i:
            text_color = 'k' if color == 'w' else 'w'
            axes.text(rect.xy[0], rect.xy[1], labels[i],
                      va='center', ha='center', fontsize=9, color=text_color,
                      bbox=dict(facecolor=color, lw=0))
</code></pre>
<p>As we just saw, the coordinate values of the $x$ and $y$ axes in the variable <code>boxes</code> have been divided by the width and height of the image, respectively.
When drawing anchor boxes,
we need to restore their original coordinate values;
thus, we define variable <code>bbox_scale</code> below.
Now, we can draw all the anchor boxes centered on (250, 250) in the image.
As you can see, the blue anchor box with a scale of 0.75 and an aspect ratio of 1 well
surrounds the dog in the image.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.set_figsize()
bbox_scale = d2l.tensor((w, h, w, h))
fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, boxes[250, 250, :, :] * bbox_scale,
            ['s=0.75, r=1', 's=0.5, r=1', 's=0.25, r=1', 's=0.75, r=2',
             's=0.75, r=0.5'])
</code></pre>
<h2 id="intersection-over-union-iou"><a class="header" href="#intersection-over-union-iou">[<strong>Intersection over Union (IoU)</strong>]</a></h2>
<p>We just mentioned that an anchor box "well" surrounds the dog in the image.
If the ground-truth bounding box of the object is known, how can "well" here be quantified?
Intuitively, we can measure the similarity between
the anchor box and the ground-truth bounding box.
We know that the <em>Jaccard index</em> can measure the similarity between two sets. Given sets $\mathcal{A}$ and $\mathcal{B}$, their Jaccard index is the size of their intersection divided by the size of their union:</p>
<p>$$J(\mathcal{A},\mathcal{B}) = \frac{\left|\mathcal{A} \cap \mathcal{B}\right|}{\left| \mathcal{A} \cup \mathcal{B}\right|}.$$</p>
<p>In fact, we can consider the pixel area of any bounding box as a set of pixels.
In this way, we can measure the similarity of the two bounding boxes by the Jaccard index of their pixel sets. For two bounding boxes, we usually refer their Jaccard index as <em>intersection over union</em> (<em>IoU</em>), which is the ratio of their intersection area to their union area, as shown in :numref:<code>fig_iou</code>.
The range of an IoU is between 0 and 1:
0 means that two bounding boxes do not overlap at all,
while 1 indicates that the two bounding boxes are equal.</p>
<p><img src="chapter_computer-vision/../img/iou.svg" alt="IoU is the ratio of the intersection area to the union area of two bounding boxes." />
:label:<code>fig_iou</code></p>
<p>For the remainder of this section, we will use IoU to measure the similarity between anchor boxes and ground-truth bounding boxes, and between different anchor boxes.
Given two lists of anchor or bounding boxes,
the following <code>box_iou</code> computes their pairwise IoU
across these two lists.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def box_iou(boxes1, boxes2):
    """Compute pairwise IoU across two lists of anchor or bounding boxes."""
    box_area = lambda boxes: ((boxes[:, 2] - boxes[:, 0]) *
                              (boxes[:, 3] - boxes[:, 1]))
    # Shape of `boxes1`, `boxes2`, `areas1`, `areas2`: (no. of boxes1, 4),
    # (no. of boxes2, 4), (no. of boxes1,), (no. of boxes2,)
    areas1 = box_area(boxes1)
    areas2 = box_area(boxes2)
    # Shape of `inter_upperlefts`, `inter_lowerrights`, `inters`: (no. of
    # boxes1, no. of boxes2, 2)
    inter_upperlefts = np.maximum(boxes1[:, None, :2], boxes2[:, :2])
    inter_lowerrights = np.minimum(boxes1[:, None, 2:], boxes2[:, 2:])
    inters = (inter_lowerrights - inter_upperlefts).clip(min=0)
    # Shape of `inter_areas` and `union_areas`: (no. of boxes1, no. of boxes2)
    inter_areas = inters[:, :, 0] * inters[:, :, 1]
    union_areas = areas1[:, None] + areas2 - inter_areas
    return inter_areas / union_areas
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def box_iou(boxes1, boxes2):
    """Compute pairwise IoU across two lists of anchor or bounding boxes."""
    box_area = lambda boxes: ((boxes[:, 2] - boxes[:, 0]) *
                              (boxes[:, 3] - boxes[:, 1]))
    # Shape of `boxes1`, `boxes2`, `areas1`, `areas2`: (no. of boxes1, 4),
    # (no. of boxes2, 4), (no. of boxes1,), (no. of boxes2,)
    areas1 = box_area(boxes1)
    areas2 = box_area(boxes2)
    # Shape of `inter_upperlefts`, `inter_lowerrights`, `inters`: (no. of
    # boxes1, no. of boxes2, 2)
    inter_upperlefts = torch.max(boxes1[:, None, :2], boxes2[:, :2])
    inter_lowerrights = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])
    inters = (inter_lowerrights - inter_upperlefts).clamp(min=0)
    # Shape of `inter_areas` and `union_areas`: (no. of boxes1, no. of boxes2)
    inter_areas = inters[:, :, 0] * inters[:, :, 1]
    union_areas = areas1[:, None] + areas2 - inter_areas
    return inter_areas / union_areas
</code></pre>
<h2 id="labeling-anchor-boxes-in-training-data"><a class="header" href="#labeling-anchor-boxes-in-training-data">Labeling Anchor Boxes in Training Data</a></h2>
<p>:label:<code>subsec_labeling-anchor-boxes</code></p>
<p>In a training dataset,
we consider each anchor box as a training example.
In order to train an object detection model,
we need <em>class</em> and <em>offset</em> labels for each anchor box,
where the former is
the class of the object relevant to the anchor box
and the latter is the offset
of the ground-truth bounding box relative to the anchor box.
During the prediction,
for each image
we generate multiple anchor boxes,
predict classes and offsets for all the anchor boxes,
adjust their positions according to the predicted offsets to obtain the predicted bounding boxes,
and finally only output those
predicted bounding boxes that satisfy certain criteria.</p>
<p>As we know, an object detection training set
comes with labels for
locations of <em>ground-truth bounding boxes</em>
and classes of their surrounded objects.
To label any generated <em>anchor box</em>,
we refer to the labeled
location and class of its <em>assigned</em> ground-truth bounding box that is closest to the anchor box.
In the following,
we describe an algorithm for assigning
closest ground-truth bounding boxes to anchor boxes.</p>
<h3 id="assigning-ground-truth-bounding-boxes-to-anchor-boxes"><a class="header" href="#assigning-ground-truth-bounding-boxes-to-anchor-boxes">[<strong>Assigning Ground-Truth Bounding Boxes to Anchor Boxes</strong>]</a></h3>
<p>Given an image,
suppose that the anchor boxes are $A_1, A_2, \ldots, A_{n_a}$ and the ground-truth bounding boxes are $B_1, B_2, \ldots, B_{n_b}$, where $n_a \geq n_b$.
Let's define a matrix $\mathbf{X} \in \mathbb{R}^{n_a \times n_b}$, whose element $x_{ij}$ in the $i^\textrm{th}$ row and $j^\textrm{th}$ column is the IoU of the anchor box $A_i$ and the ground-truth bounding box $B_j$. The algorithm consists of the following steps:</p>
<ol>
<li>Find the largest element in matrix $\mathbf{X}$ and denote its row and column indices as $i_1$ and $j_1$, respectively. Then the ground-truth bounding box $B_{j_1}$ is assigned to the anchor box $A_{i_1}$. This is quite intuitive because $A_{i_1}$ and $B_{j_1}$ are the closest among all the pairs of anchor boxes and ground-truth bounding boxes. After the first assignment, discard all the elements in the ${i_1}^\textrm{th}$ row and the ${j_1}^\textrm{th}$ column in matrix $\mathbf{X}$.</li>
<li>Find the largest of the remaining elements in matrix $\mathbf{X}$ and denote its row and column indices as $i_2$ and $j_2$, respectively. We assign ground-truth bounding box $B_{j_2}$ to anchor box $A_{i_2}$ and discard all the elements in the ${i_2}^\textrm{th}$ row and the ${j_2}^\textrm{th}$ column in matrix $\mathbf{X}$.</li>
<li>At this point, elements in two rows and two columns in  matrix $\mathbf{X}$ have been discarded. We proceed until all elements in $n_b$ columns in matrix $\mathbf{X}$ are discarded. At this time, we have assigned a ground-truth bounding box to each of $n_b$ anchor boxes.</li>
<li>Only traverse through the remaining $n_a - n_b$ anchor boxes. For example, given any anchor box $A_i$, find the ground-truth bounding box $B_j$ with the largest IoU with $A_i$ throughout the $i^\textrm{th}$ row of matrix $\mathbf{X}$, and assign $B_j$ to $A_i$ only if this IoU is greater than a predefined threshold.</li>
</ol>
<p>Let's illustrate the above algorithm using a concrete
example.
As shown in :numref:<code>fig_anchor_label</code> (left), assuming that the maximum value in matrix $\mathbf{X}$ is $x_{23}$, we assign the ground-truth bounding box $B_3$ to the anchor box $A_2$.
Then, we discard all the elements in row 2 and column 3 of the matrix, find the largest $x_{71}$ in the remaining  elements (shaded area), and assign the ground-truth bounding box $B_1$ to the anchor box $A_7$.
Next, as shown in :numref:<code>fig_anchor_label</code> (middle), discard all the elements in row 7 and column 1 of the matrix, find the largest $x_{54}$ in the remaining  elements (shaded area), and assign the ground-truth bounding box $B_4$ to the anchor box $A_5$.
Finally, as shown in :numref:<code>fig_anchor_label</code> (right), discard all the elements in row 5 and column 4 of the matrix, find the largest $x_{92}$ in the remaining elements (shaded area), and assign the ground-truth bounding box $B_2$ to the anchor box $A_9$.
After that, we only need to traverse through
the remaining anchor boxes $A_1, A_3, A_4, A_6, A_8$ and determine whether to assign them ground-truth bounding boxes according to the threshold.</p>
<p><img src="chapter_computer-vision/../img/anchor-label.svg" alt="Assigning ground-truth bounding boxes to anchor boxes." />
:label:<code>fig_anchor_label</code></p>
<p>This algorithm is implemented in the following <code>assign_anchor_to_bbox</code> function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def assign_anchor_to_bbox(ground_truth, anchors, device, iou_threshold=0.5):
    """Assign closest ground-truth bounding boxes to anchor boxes."""
    num_anchors, num_gt_boxes = anchors.shape[0], ground_truth.shape[0]
    # Element x_ij in the i-th row and j-th column is the IoU of the anchor
    # box i and the ground-truth bounding box j
    jaccard = box_iou(anchors, ground_truth)
    # Initialize the tensor to hold the assigned ground-truth bounding box for
    # each anchor
    anchors_bbox_map = np.full((num_anchors,), -1, dtype=np.int32, ctx=device)
    # Assign ground-truth bounding boxes according to the threshold
    max_ious, indices = np.max(jaccard, axis=1), np.argmax(jaccard, axis=1)
    anc_i = np.nonzero(max_ious &gt;= iou_threshold)[0]
    box_j = indices[max_ious &gt;= iou_threshold]
    anchors_bbox_map[anc_i] = box_j
    col_discard = np.full((num_anchors,), -1)
    row_discard = np.full((num_gt_boxes,), -1)
    for _ in range(num_gt_boxes):
        max_idx = np.argmax(jaccard)  # Find the largest IoU
        box_idx = (max_idx % num_gt_boxes).astype('int32')
        anc_idx = (max_idx / num_gt_boxes).astype('int32')
        anchors_bbox_map[anc_idx] = box_idx
        jaccard[:, box_idx] = col_discard
        jaccard[anc_idx, :] = row_discard
    return anchors_bbox_map
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def assign_anchor_to_bbox(ground_truth, anchors, device, iou_threshold=0.5):
    """Assign closest ground-truth bounding boxes to anchor boxes."""
    num_anchors, num_gt_boxes = anchors.shape[0], ground_truth.shape[0]
    # Element x_ij in the i-th row and j-th column is the IoU of the anchor
    # box i and the ground-truth bounding box j
    jaccard = box_iou(anchors, ground_truth)
    # Initialize the tensor to hold the assigned ground-truth bounding box for
    # each anchor
    anchors_bbox_map = torch.full((num_anchors,), -1, dtype=torch.long,
                                  device=device)
    # Assign ground-truth bounding boxes according to the threshold
    max_ious, indices = torch.max(jaccard, dim=1)
    anc_i = torch.nonzero(max_ious &gt;= iou_threshold).reshape(-1)
    box_j = indices[max_ious &gt;= iou_threshold]
    anchors_bbox_map[anc_i] = box_j
    col_discard = torch.full((num_anchors,), -1)
    row_discard = torch.full((num_gt_boxes,), -1)
    for _ in range(num_gt_boxes):
        max_idx = torch.argmax(jaccard)  # Find the largest IoU
        box_idx = (max_idx % num_gt_boxes).long()
        anc_idx = (max_idx / num_gt_boxes).long()
        anchors_bbox_map[anc_idx] = box_idx
        jaccard[:, box_idx] = col_discard
        jaccard[anc_idx, :] = row_discard
    return anchors_bbox_map
</code></pre>
<h3 id="labeling-classes-and-offsets"><a class="header" href="#labeling-classes-and-offsets">Labeling Classes and Offsets</a></h3>
<p>Now we can label the class and offset for each anchor box. Suppose that an anchor box $A$ is assigned
a ground-truth bounding box $B$.
On the one hand,
the class of the anchor box $A$ will be
labeled as that of $B$.
On the other hand,
the offset of the anchor box $A$
will be labeled according to the
relative position between
the central coordinates of $B$ and $A$
together with the relative size between
these two boxes.
Given varying
positions and sizes of different boxes in the dataset,
we can apply transformations
to those relative positions and sizes
that may lead to
more uniformly distributed offsets
that are easier to fit.
Here we describe a common transformation.
[**Given the central coordinates of $A$ and $B$ as $(x_a, y_a)$ and $(x_b, y_b)$,
their widths as $w_a$ and $w_b$,
and their heights as $h_a$ and $h_b$, respectively.
We may label the offset of $A$ as</p>
<p>$$\left( \frac{ \frac{x_b - x_a}{w_a} - \mu_x }{\sigma_x},
\frac{ \frac{y_b - y_a}{h_a} - \mu_y }{\sigma_y},
\frac{ \log \frac{w_b}{w_a} - \mu_w }{\sigma_w},
\frac{ \log \frac{h_b}{h_a} - \mu_h }{\sigma_h}\right),$$
**]
where default values of the constants are $\mu_x = \mu_y = \mu_w = \mu_h = 0, \sigma_x=\sigma_y=0.1$, and $\sigma_w=\sigma_h=0.2$.
This transformation is implemented below in the <code>offset_boxes</code> function.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def offset_boxes(anchors, assigned_bb, eps=1e-6):
    """Transform for anchor box offsets."""
    c_anc = d2l.box_corner_to_center(anchors)
    c_assigned_bb = d2l.box_corner_to_center(assigned_bb)
    offset_xy = 10 * (c_assigned_bb[:, :2] - c_anc[:, :2]) / c_anc[:, 2:]
    offset_wh = 5 * d2l.log(eps + c_assigned_bb[:, 2:] / c_anc[:, 2:])
    offset = d2l.concat([offset_xy, offset_wh], axis=1)
    return offset
</code></pre>
<p>If an anchor box is not assigned a ground-truth bounding box, we just label the class of the anchor box as "background".
Anchor boxes whose classes are background are often referred to as <em>negative</em> anchor boxes,
and the rest are called <em>positive</em> anchor boxes.
We implement the following <code>multibox_target</code> function
to [<strong>label classes and offsets for anchor boxes</strong>] (the <code>anchors</code> argument) using ground-truth bounding boxes (the <code>labels</code> argument).
This function sets the background class to zero and increments the integer index of a new class by one.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def multibox_target(anchors, labels):
    """Label anchor boxes using ground-truth bounding boxes."""
    batch_size, anchors = labels.shape[0], anchors.squeeze(0)
    batch_offset, batch_mask, batch_class_labels = [], [], []
    device, num_anchors = anchors.ctx, anchors.shape[0]
    for i in range(batch_size):
        label = labels[i, :, :]
        anchors_bbox_map = assign_anchor_to_bbox(
            label[:, 1:], anchors, device)
        bbox_mask = np.tile((np.expand_dims((anchors_bbox_map &gt;= 0),
                                            axis=-1)), (1, 4)).astype('int32')
        # Initialize class labels and assigned bounding box coordinates with
        # zeros
        class_labels = d2l.zeros(num_anchors, dtype=np.int32, ctx=device)
        assigned_bb = d2l.zeros((num_anchors, 4), dtype=np.float32,
                                ctx=device)
        # Label classes of anchor boxes using their assigned ground-truth
        # bounding boxes. If an anchor box is not assigned any, we label its
        # class as background (the value remains zero)
        indices_true = np.nonzero(anchors_bbox_map &gt;= 0)[0]
        bb_idx = anchors_bbox_map[indices_true]
        class_labels[indices_true] = label[bb_idx, 0].astype('int32') + 1
        assigned_bb[indices_true] = label[bb_idx, 1:]
        # Offset transformation
        offset = offset_boxes(anchors, assigned_bb) * bbox_mask
        batch_offset.append(offset.reshape(-1))
        batch_mask.append(bbox_mask.reshape(-1))
        batch_class_labels.append(class_labels)
    bbox_offset = d2l.stack(batch_offset)
    bbox_mask = d2l.stack(batch_mask)
    class_labels = d2l.stack(batch_class_labels)
    return (bbox_offset, bbox_mask, class_labels)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def multibox_target(anchors, labels):
    """Label anchor boxes using ground-truth bounding boxes."""
    batch_size, anchors = labels.shape[0], anchors.squeeze(0)
    batch_offset, batch_mask, batch_class_labels = [], [], []
    device, num_anchors = anchors.device, anchors.shape[0]
    for i in range(batch_size):
        label = labels[i, :, :]
        anchors_bbox_map = assign_anchor_to_bbox(
            label[:, 1:], anchors, device)
        bbox_mask = ((anchors_bbox_map &gt;= 0).float().unsqueeze(-1)).repeat(
            1, 4)
        # Initialize class labels and assigned bounding box coordinates with
        # zeros
        class_labels = torch.zeros(num_anchors, dtype=torch.long,
                                   device=device)
        assigned_bb = torch.zeros((num_anchors, 4), dtype=torch.float32,
                                  device=device)
        # Label classes of anchor boxes using their assigned ground-truth
        # bounding boxes. If an anchor box is not assigned any, we label its
        # class as background (the value remains zero)
        indices_true = torch.nonzero(anchors_bbox_map &gt;= 0)
        bb_idx = anchors_bbox_map[indices_true]
        class_labels[indices_true] = label[bb_idx, 0].long() + 1
        assigned_bb[indices_true] = label[bb_idx, 1:]
        # Offset transformation
        offset = offset_boxes(anchors, assigned_bb) * bbox_mask
        batch_offset.append(offset.reshape(-1))
        batch_mask.append(bbox_mask.reshape(-1))
        batch_class_labels.append(class_labels)
    bbox_offset = torch.stack(batch_offset)
    bbox_mask = torch.stack(batch_mask)
    class_labels = torch.stack(batch_class_labels)
    return (bbox_offset, bbox_mask, class_labels)
</code></pre>
<h3 id="an-example-1"><a class="header" href="#an-example-1">An Example</a></h3>
<p>Let's illustrate anchor box labeling
via a concrete example.
We define ground-truth bounding boxes for the dog and cat in the loaded image,
where the first element is the class (0 for dog and 1 for cat) and the remaining four elements are the
$(x, y)$-axis coordinates
at the upper-left corner and the lower-right corner
(range is between 0 and 1).
We also construct five anchor boxes to be labeled
using the coordinates of
the upper-left corner and the lower-right corner:
$A_0, \ldots, A_4$ (the index starts from 0).
Then we [<strong>plot these ground-truth bounding boxes
and anchor boxes
in the image.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab all
ground_truth = d2l.tensor([[0, 0.1, 0.08, 0.52, 0.92],
                         [1, 0.55, 0.2, 0.9, 0.88]])
anchors = d2l.tensor([[0, 0.1, 0.2, 0.3], [0.15, 0.2, 0.4, 0.4],
                    [0.63, 0.05, 0.88, 0.98], [0.66, 0.45, 0.8, 0.8],
                    [0.57, 0.3, 0.92, 0.9]])

fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, ground_truth[:, 1:] * bbox_scale, ['dog', 'cat'], 'k')
show_bboxes(fig.axes, anchors * bbox_scale, ['0', '1', '2', '3', '4']);
</code></pre>
<p>Using the <code>multibox_target</code> function defined above,
we can [<strong>label classes and offsets
of these anchor boxes based on
the ground-truth bounding boxes</strong>] for the dog and cat.
In this example, indices of
the background, dog, and cat classes
are 0, 1, and 2, respectively.
Below we add an dimension for examples of anchor boxes and ground-truth bounding boxes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
labels = multibox_target(np.expand_dims(anchors, axis=0),
                         np.expand_dims(ground_truth, axis=0))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
labels = multibox_target(anchors.unsqueeze(dim=0),
                         ground_truth.unsqueeze(dim=0))
</code></pre>
<p>There are three items in the returned result, all of which are in the tensor format.
The third item contains the labeled classes of the input anchor boxes.</p>
<p>Let's analyze the returned class labels below based on
anchor box and ground-truth bounding box positions in the image.
First, among all the pairs of anchor boxes
and ground-truth bounding boxes,
the IoU of the anchor box $A_4$ and the ground-truth bounding box of the cat is the largest.
Thus, the class of $A_4$ is labeled as the cat.
Taking out
pairs containing $A_4$ or the ground-truth bounding box of the cat, among the rest
the pair of the anchor box $A_1$ and the ground-truth bounding box of the dog has the largest IoU.
So the class of $A_1$ is labeled as the dog.
Next, we need to traverse through the remaining three unlabeled anchor boxes: $A_0$, $A_2$, and $A_3$.
For $A_0$,
the class of the ground-truth bounding box with the largest IoU is the dog,
but the IoU is below the predefined threshold (0.5),
so the class is labeled as background;
for $A_2$,
the class of the ground-truth bounding box with the largest IoU is the cat and the IoU exceeds the threshold, so the class is labeled as the cat;
for $A_3$,
the class of the ground-truth bounding box with the largest IoU is the cat, but the value is below the threshold, so the class is labeled as background.</p>
<pre><code class="language-{.python .input}">#@tab all
labels[2]
</code></pre>
<p>The second returned item is a mask variable of the shape (batch size, four times the number of anchor boxes).
Every four elements in the mask variable
correspond to the four offset values of each anchor box.
Since we do not care about background detection,
offsets of this negative class should not affect the objective function.
Through elementwise multiplications, zeros in the mask variable will filter out negative class offsets before calculating the objective function.</p>
<pre><code class="language-{.python .input}">#@tab all
labels[1]
</code></pre>
<p>The first returned item contains the four offset values labeled for each anchor box.
Note that the offsets of negative-class anchor boxes are labeled as zeros.</p>
<pre><code class="language-{.python .input}">#@tab all
labels[0]
</code></pre>
<h2 id="predicting-bounding-boxes-with-non-maximum-suppression"><a class="header" href="#predicting-bounding-boxes-with-non-maximum-suppression">Predicting Bounding Boxes with Non-Maximum Suppression</a></h2>
<p>:label:<code>subsec_predicting-bounding-boxes-nms</code></p>
<p>During prediction,
we generate multiple anchor boxes for the image and predict classes and offsets for each of them.
A <em>predicted bounding box</em>
is thus obtained according to
an anchor box with its predicted offset.
Below we implement the <code>offset_inverse</code> function
that takes in anchors and
offset predictions as inputs and [<strong>applies inverse offset transformations to
return the predicted bounding box coordinates</strong>].</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def offset_inverse(anchors, offset_preds):
    """Predict bounding boxes based on anchor boxes with predicted offsets."""
    anc = d2l.box_corner_to_center(anchors)
    pred_bbox_xy = (offset_preds[:, :2] * anc[:, 2:] / 10) + anc[:, :2]
    pred_bbox_wh = d2l.exp(offset_preds[:, 2:] / 5) * anc[:, 2:]
    pred_bbox = d2l.concat((pred_bbox_xy, pred_bbox_wh), axis=1)
    predicted_bbox = d2l.box_center_to_corner(pred_bbox)
    return predicted_bbox
</code></pre>
<p>When there are many anchor boxes,
many similar (with significant overlap)
predicted bounding boxes
can be potentially output for surrounding the same object.
To simplify the output,
we can merge similar predicted bounding boxes
that belong to the same object
by using <em>non-maximum suppression</em> (NMS).</p>
<p>Here is how non-maximum suppression works.
For a predicted bounding box $B$,
the object detection model calculates the predicted likelihood
for each class.
Denoting by $p$ the largest predicted likelihood,
the class corresponding to this probability is the predicted class for $B$.
Specifically, we refer to $p$ as the <em>confidence</em> (score) of the predicted bounding box $B$.
On the same image,
all the predicted non-background bounding boxes
are sorted by confidence in descending order
to generate a list $L$.
Then we manipulate the sorted list $L$ in the following steps:</p>
<ol>
<li>Select the predicted bounding box $B_1$ with the highest confidence from $L$ as a basis and remove all non-basis predicted bounding boxes whose IoU with $B_1$ exceeds a predefined threshold $\epsilon$ from $L$. At this point, $L$ keeps the predicted bounding box with the highest confidence but drops others that are too similar to it. In a nutshell, those with <em>non-maximum</em> confidence scores are <em>suppressed</em>.</li>
<li>Select the predicted bounding box $B_2$ with the second highest confidence from $L$ as another basis and remove all non-basis predicted bounding boxes whose IoU with $B_2$ exceeds $\epsilon$ from $L$.</li>
<li>Repeat the above process until all the predicted bounding boxes in $L$ have been used as a basis. At this time, the IoU of any pair of predicted bounding boxes in $L$ is below the threshold $\epsilon$; thus, no pair is too similar with each other.</li>
<li>Output all the predicted bounding boxes in the list $L$.</li>
</ol>
<p>[<strong>The following <code>nms</code> function sorts confidence scores in descending order and returns their indices.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def nms(boxes, scores, iou_threshold):
    """Sort confidence scores of predicted bounding boxes."""
    B = scores.argsort()[::-1]
    keep = []  # Indices of predicted bounding boxes that will be kept
    while B.size &gt; 0:
        i = B[0]
        keep.append(i)
        if B.size == 1: break
        iou = box_iou(boxes[i, :].reshape(-1, 4),
                      boxes[B[1:], :].reshape(-1, 4)).reshape(-1)
        inds = np.nonzero(iou &lt;= iou_threshold)[0]
        B = B[inds + 1]
    return np.array(keep, dtype=np.int32, ctx=boxes.ctx)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def nms(boxes, scores, iou_threshold):
    """Sort confidence scores of predicted bounding boxes."""
    B = torch.argsort(scores, dim=-1, descending=True)
    keep = []  # Indices of predicted bounding boxes that will be kept
    while B.numel() &gt; 0:
        i = B[0]
        keep.append(i)
        if B.numel() == 1: break
        iou = box_iou(boxes[i, :].reshape(-1, 4),
                      boxes[B[1:], :].reshape(-1, 4)).reshape(-1)
        inds = torch.nonzero(iou &lt;= iou_threshold).reshape(-1)
        B = B[inds + 1]
    return d2l.tensor(keep, device=boxes.device)
</code></pre>
<p>We define the following <code>multibox_detection</code>
to [<strong>apply non-maximum suppression
to predicting bounding boxes</strong>].
Do not worry if you find the implementation
a bit complicated: we will show how it works
with a concrete example right after the implementation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def multibox_detection(cls_probs, offset_preds, anchors, nms_threshold=0.5,
                       pos_threshold=0.009999999):
    """Predict bounding boxes using non-maximum suppression."""
    device, batch_size = cls_probs.ctx, cls_probs.shape[0]
    anchors = np.squeeze(anchors, axis=0)
    num_classes, num_anchors = cls_probs.shape[1], cls_probs.shape[2]
    out = []
    for i in range(batch_size):
        cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-1, 4)
        conf, class_id = np.max(cls_prob[1:], 0), np.argmax(cls_prob[1:], 0)
        predicted_bb = offset_inverse(anchors, offset_pred)
        keep = nms(predicted_bb, conf, nms_threshold)
        # Find all non-`keep` indices and set the class to background
        all_idx = np.arange(num_anchors, dtype=np.int32, ctx=device)
        combined = d2l.concat((keep, all_idx))
        unique, counts = np.unique(combined, return_counts=True)
        non_keep = unique[counts == 1]
        all_id_sorted = d2l.concat((keep, non_keep))
        class_id[non_keep] = -1
        class_id = class_id[all_id_sorted].astype('float32')
        conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted]
        # Here `pos_threshold` is a threshold for positive (non-background)
        # predictions
        below_min_idx = (conf &lt; pos_threshold)
        class_id[below_min_idx] = -1
        conf[below_min_idx] = 1 - conf[below_min_idx]
        pred_info = d2l.concat((np.expand_dims(class_id, axis=1),
                                np.expand_dims(conf, axis=1),
                                predicted_bb), axis=1)
        out.append(pred_info)
    return d2l.stack(out)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def multibox_detection(cls_probs, offset_preds, anchors, nms_threshold=0.5,
                       pos_threshold=0.009999999):
    """Predict bounding boxes using non-maximum suppression."""
    device, batch_size = cls_probs.device, cls_probs.shape[0]
    anchors = anchors.squeeze(0)
    num_classes, num_anchors = cls_probs.shape[1], cls_probs.shape[2]
    out = []
    for i in range(batch_size):
        cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-1, 4)
        conf, class_id = torch.max(cls_prob[1:], 0)
        predicted_bb = offset_inverse(anchors, offset_pred)
        keep = nms(predicted_bb, conf, nms_threshold)
        # Find all non-`keep` indices and set the class to background
        all_idx = torch.arange(num_anchors, dtype=torch.long, device=device)
        combined = torch.cat((keep, all_idx))
        uniques, counts = combined.unique(return_counts=True)
        non_keep = uniques[counts == 1]
        all_id_sorted = torch.cat((keep, non_keep))
        class_id[non_keep] = -1
        class_id = class_id[all_id_sorted]
        conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted]
        # Here `pos_threshold` is a threshold for positive (non-background)
        # predictions
        below_min_idx = (conf &lt; pos_threshold)
        class_id[below_min_idx] = -1
        conf[below_min_idx] = 1 - conf[below_min_idx]
        pred_info = torch.cat((class_id.unsqueeze(1),
                               conf.unsqueeze(1),
                               predicted_bb), dim=1)
        out.append(pred_info)
    return d2l.stack(out)
</code></pre>
<p>Now let's [<strong>apply the above implementations
to a concrete example with four anchor boxes</strong>].
For simplicity, we assume that the
predicted offsets are all zeros.
This means that the predicted bounding boxes are anchor boxes.
For each class among the background, dog, and cat,
we also define its predicted likelihood.</p>
<pre><code class="language-{.python .input}">#@tab all
anchors = d2l.tensor([[0.1, 0.08, 0.52, 0.92], [0.08, 0.2, 0.56, 0.95],
                      [0.15, 0.3, 0.62, 0.91], [0.55, 0.2, 0.9, 0.88]])
offset_preds = d2l.tensor([0] * d2l.size(anchors))
cls_probs = d2l.tensor([[0] * 4,  # Predicted background likelihood 
                      [0.9, 0.8, 0.7, 0.1],  # Predicted dog likelihood 
                      [0.1, 0.2, 0.3, 0.9]])  # Predicted cat likelihood
</code></pre>
<p>We can [<strong>plot these predicted bounding boxes with their confidence on the image.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab all
fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, anchors * bbox_scale,
            ['dog=0.9', 'dog=0.8', 'dog=0.7', 'cat=0.9'])
</code></pre>
<p>Now we can invoke the <code>multibox_detection</code> function
to perform non-maximum suppression,
where the threshold is set to 0.5.
Note that we add
a dimension for examples in the tensor input.</p>
<p>We can see that [<strong>the shape of the returned result</strong>] is
(batch size, number of anchor boxes, 6).
The six elements in the innermost dimension
gives the output information for the same predicted bounding box.
The first element is the predicted class index, which starts from 0 (0 is dog and 1 is cat). The value -1 indicates background or removal in non-maximum suppression.
The second element is the confidence of the predicted bounding box.
The remaining four elements are the $(x, y)$-axis coordinates of the upper-left corner and
the lower-right corner of the predicted bounding box, respectively (range is between 0 and 1).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
output = multibox_detection(np.expand_dims(cls_probs, axis=0),
                            np.expand_dims(offset_preds, axis=0),
                            np.expand_dims(anchors, axis=0),
                            nms_threshold=0.5)
output
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
output = multibox_detection(cls_probs.unsqueeze(dim=0),
                            offset_preds.unsqueeze(dim=0),
                            anchors.unsqueeze(dim=0),
                            nms_threshold=0.5)
output
</code></pre>
<p>After removing those predicted bounding boxes
of class -1,
we can [<strong>output the final predicted bounding box
kept by non-maximum suppression</strong>].</p>
<pre><code class="language-{.python .input}">#@tab all
fig = d2l.plt.imshow(img)
for i in d2l.numpy(output[0]):
    if i[0] == -1:
        continue
    label = ('dog=', 'cat=')[int(i[0])] + str(i[1])
    show_bboxes(fig.axes, [d2l.tensor(i[2:]) * bbox_scale], label)
</code></pre>
<p>In practice, we can remove predicted bounding boxes with lower confidence even before performing non-maximum suppression, thereby reducing computation in this algorithm.
We may also post-process the output of non-maximum suppression, for example, by only keeping
results with higher confidence
in the final output.</p>
<h2 id="summary-75"><a class="header" href="#summary-75">Summary</a></h2>
<ul>
<li>We generate anchor boxes with different shapes centered on each pixel of the image.</li>
<li>Intersection over union (IoU), also known as Jaccard index, measures the similarity of two bounding boxes. It is the ratio of their intersection area to their union area.</li>
<li>In a training set, we need two types of labels for each anchor box. One is the class of the object relevant to the anchor box and the other is the offset of the ground-truth bounding box relative to the anchor box.</li>
<li>During prediction, we can use non-maximum suppression (NMS) to remove similar predicted bounding boxes, thereby simplifying the output.</li>
</ul>
<h2 id="exercises-95"><a class="header" href="#exercises-95">Exercises</a></h2>
<ol>
<li>Change values of <code>sizes</code> and <code>ratios</code> in the <code>multibox_prior</code> function. What are the changes to the generated anchor boxes?</li>
<li>Construct and visualize two bounding boxes with an IoU of 0.5. How do they overlap with each other?</li>
<li>Modify the variable <code>anchors</code> in :numref:<code>subsec_labeling-anchor-boxes</code> and :numref:<code>subsec_predicting-bounding-boxes-nms</code>. How do the results change?</li>
<li>Non-maximum suppression is a greedy algorithm that suppresses predicted bounding boxes by <em>removing</em> them. Is it possible that some of these removed ones are actually useful? How can this algorithm be modified to suppress <em>softly</em>? You may refer to Soft-NMS :cite:<code>Bodla.Singh.Chellappa.ea.2017</code>.</li>
<li>Rather than being hand-crafted, can non-maximum suppression be learned?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/370">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1603">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiscale-object-detection"><a class="header" href="#multiscale-object-detection">Multiscale Object Detection</a></h1>
<p>:label:<code>sec_multiscale-object-detection</code></p>
<p>In :numref:<code>sec_anchor</code>,
we generated multiple anchor boxes centered on each pixel of an input image.
Essentially these anchor boxes
represent samples of
different regions of the image.
However,
we may end up with too many anchor boxes to compute
if they are generated for <em>every</em> pixel.
Think of a $561 \times 728$ input image.
If five anchor boxes
with varying shapes
are generated for each pixel as their center,
over two million anchor boxes ($561 \times 728 \times 5$) need to be labeled and predicted on the image.</p>
<h2 id="multiscale-anchor-boxes"><a class="header" href="#multiscale-anchor-boxes">Multiscale Anchor Boxes</a></h2>
<p>:label:<code>subsec_multiscale-anchor-boxes</code></p>
<p>You may realize that
it is not difficult to reduce anchor boxes on an image.
For instance, we can just
uniformly sample a small portion of pixels
from the input image
to generate anchor boxes centered on them.
In addition,
at different scales
we can generate different numbers of anchor boxes
of different sizes.
Intuitively,
smaller objects are more likely
to appear on an image than larger ones.
As an example,
$1 \times 1$, $1 \times 2$, and $2 \times 2$ objects
can appear on a $2 \times 2$ image
in 4, 2, and 1 possible ways, respectively.
Therefore, when using smaller anchor boxes to detect smaller objects, we can sample more regions,
while for larger objects we can sample fewer regions.</p>
<p>To demonstrate how to generate anchor boxes
at multiple scales, let's read an image.
Its height and width are 561 and 728 pixels, respectively.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import image, np, npx

npx.set_np()

img = image.imread('../img/catdog.jpg')
h, w = img.shape[:2]
h, w
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

img = d2l.plt.imread('../img/catdog.jpg')
h, w = img.shape[:2]
h, w
</code></pre>
<p>Recall that in :numref:<code>sec_conv_layer</code>
we call a two-dimensional array output of
a convolutional layer a feature map.
By defining the feature map shape,
we can determine centers of uniformly sampled anchor boxes  on any image.</p>
<p>The <code>display_anchors</code> function is defined below.
[<strong>We generate anchor boxes (<code>anchors</code>) on the feature map (<code>fmap</code>) with each unit (pixel) as the anchor box center.</strong>]
Since the $(x, y)$-axis coordinate values
in the anchor boxes (<code>anchors</code>) have been divided by the width and height of the feature map (<code>fmap</code>),
these values are between 0 and 1,
which indicate the relative positions of
anchor boxes in the feature map.</p>
<p>Since centers of the anchor boxes (<code>anchors</code>)
are spread over all units on the feature map (<code>fmap</code>),
these centers must be <em>uniformly</em> distributed
on any input image
in terms of their relative spatial positions.
More concretely,
given the width and height of the feature map <code>fmap_w</code> and <code>fmap_h</code>, respectively,
the following function will <em>uniformly</em> sample
pixels in <code>fmap_h</code> rows and <code>fmap_w</code> columns
on any input image.
Centered on these uniformly sampled pixels,
anchor boxes of scale <code>s</code> (assuming the length of the list <code>s</code> is 1) and different aspect ratios (<code>ratios</code>)
will be generated.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def display_anchors(fmap_w, fmap_h, s):
    d2l.set_figsize()
    # Values on the first two dimensions do not affect the output
    fmap = np.zeros((1, 10, fmap_h, fmap_w))
    anchors = npx.multibox_prior(fmap, sizes=s, ratios=[1, 2, 0.5])
    bbox_scale = np.array((w, h, w, h))
    d2l.show_bboxes(d2l.plt.imshow(img.asnumpy()).axes,
                    anchors[0] * bbox_scale)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def display_anchors(fmap_w, fmap_h, s):
    d2l.set_figsize()
    # Values on the first two dimensions do not affect the output
    fmap = d2l.zeros((1, 10, fmap_h, fmap_w))
    anchors = d2l.multibox_prior(fmap, sizes=s, ratios=[1, 2, 0.5])
    bbox_scale = d2l.tensor((w, h, w, h))
    d2l.show_bboxes(d2l.plt.imshow(img).axes,
                    anchors[0] * bbox_scale)
</code></pre>
<p>First, let's [<strong>consider
detection of small objects</strong>].
In order to make it easier to distinguish when displayed, the anchor boxes with different centers here do not overlap:
the anchor box scale is set to 0.15
and the height and width of the feature map are set to 4. We can see
that the centers of the anchor boxes in 4 rows and 4 columns on the image are uniformly distributed.</p>
<pre><code class="language-{.python .input}">#@tab all
display_anchors(fmap_w=4, fmap_h=4, s=[0.15])
</code></pre>
<p>We move on to [<strong>reduce the height and width of the feature map by half and use larger anchor boxes to detect larger objects</strong>]. When the scale is set to 0.4,
some anchor boxes will overlap with each other.</p>
<pre><code class="language-{.python .input}">#@tab all
display_anchors(fmap_w=2, fmap_h=2, s=[0.4])
</code></pre>
<p>Finally, we [<strong>further reduce the height and width of the feature map by half and increase the anchor box scale to 0.8</strong>]. Now the center of the anchor box is the center of the image.</p>
<pre><code class="language-{.python .input}">#@tab all
display_anchors(fmap_w=1, fmap_h=1, s=[0.8])
</code></pre>
<h2 id="multiscale-detection"><a class="header" href="#multiscale-detection">Multiscale Detection</a></h2>
<p>Since we have generated multiscale anchor boxes,
we will use them to detect objects of various sizes
at different scales.
In the following
we introduce a CNN-based multiscale object detection
method that we will implement
in :numref:<code>sec_ssd</code>.</p>
<p>At some scale,
say that we have $c$ feature maps of shape $h \times w$.
Using the method in :numref:<code>subsec_multiscale-anchor-boxes</code>,
we generate $hw$ sets of anchor boxes,
where each set has $a$ anchor boxes with the same center.
For example,
at the first scale in the experiments in :numref:<code>subsec_multiscale-anchor-boxes</code>,
given ten (number of channels) $4 \times 4$ feature maps,
we generated 16 sets of anchor boxes,
where each set contains 3 anchor boxes with the same center.
Next, each anchor box is labeled with
the class and offset based on ground-truth bounding boxes. At the current scale, the object detection model needs to predict the classes and offsets of $hw$ sets of anchor boxes on the input image, where different sets have different centers.</p>
<p>Assume that the $c$ feature maps here
are the intermediate outputs obtained
by the CNN forward propagation based on the input image. Since there are $hw$ different spatial positions on each feature map,
the same spatial position can be
thought of as having $c$ units.
According to the
definition of receptive field in :numref:<code>sec_conv_layer</code>,
these $c$ units at the same spatial position
of the feature maps
have the same receptive field on the input image:
they represent the input image information
in the same receptive field.
Therefore, we can transform the $c$ units
of the feature maps at the same spatial position
into the
classes and offsets of the $a$ anchor boxes
generated using this spatial position.
In essence,
we use the information of the input image in a certain receptive field
to predict the classes and offsets of the anchor boxes
that are
close to that receptive field
on the input image.</p>
<p>When the feature maps at different layers
have varying-size receptive fields on the input image, they can be used to detect objects of different sizes.
For example, we can design a neural network where
units of feature maps that are closer to the output layer
have wider receptive fields,
so they can detect larger objects from the input image.</p>
<p>In a nutshell, we can leverage
layerwise representations of images at multiple levels
by deep neural networks
for multiscale object detection.
We will show how this works through a concrete example
in :numref:<code>sec_ssd</code>.</p>
<h2 id="summary-76"><a class="header" href="#summary-76">Summary</a></h2>
<ul>
<li>At multiple scales, we can generate anchor boxes with different sizes to detect objects with different sizes.</li>
<li>By defining the shape of feature maps, we can determine centers of uniformly sampled anchor boxes on any image.</li>
<li>We use the information of the input image in a certain receptive field to predict the classes and offsets of the anchor boxes that are close to that receptive field on the input image.</li>
<li>Through deep learning, we can leverage its layerwise representations of images at multiple levels for multiscale object detection.</li>
</ul>
<h2 id="exercises-96"><a class="header" href="#exercises-96">Exercises</a></h2>
<ol>
<li>According to our discussions in :numref:<code>sec_alexnet</code>, deep neural networks learn hierarchical features with increasing levels of abstraction for images. In multiscale object detection, do feature maps at different scales correspond to different levels of abstraction? Why or why not?</li>
<li>At the first scale (<code>fmap_w=4, fmap_h=4</code>) in the experiments in :numref:<code>subsec_multiscale-anchor-boxes</code>, generate uniformly distributed anchor boxes that may overlap.</li>
<li>Given a feature map variable with shape $1 \times c \times h \times w$, where $c$, $h$, and $w$ are the number of channels, height, and width of the feature maps, respectively. How can you transform this variable into the classes and offsets of anchor boxes? What is the shape of the output?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/371">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1607">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-object-detection-dataset"><a class="header" href="#the-object-detection-dataset">The Object Detection Dataset</a></h1>
<p>:label:<code>sec_object-detection-dataset</code></p>
<p>There is no small dataset such as MNIST and Fashion-MNIST in the field of object detection.
In order to quickly demonstrate object detection models,
[<strong>we collected and labeled a small dataset</strong>].
First, we took photos of free bananas from our office
and generated
1000 banana images with different rotations and sizes.
Then we placed each banana image
at a random position on some background image.
In the end, we labeled bounding boxes for those bananas on the images.</p>
<h2 id="downloading-the-dataset"><a class="header" href="#downloading-the-dataset">[<strong>Downloading the Dataset</strong>]</a></h2>
<p>The banana detection dataset with all the image and
csv label files can be downloaded directly from the Internet.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, image, np, npx
import os
import pandas as pd

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
import os
import pandas as pd
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['banana-detection'] = (
    d2l.DATA_URL + 'banana-detection.zip',
    '5de26c8fce5ccdea9f91267273464dc968d20d72')
</code></pre>
<h2 id="reading-the-dataset-6"><a class="header" href="#reading-the-dataset-6">Reading the Dataset</a></h2>
<p>We are going to [<strong>read the banana detection dataset</strong>] in the <code>read_data_bananas</code>
function below.
The dataset includes a csv file for
object class labels and
ground-truth bounding box coordinates
at the upper-left and lower-right corners.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def read_data_bananas(is_train=True):
    """Read the banana detection dataset images and labels."""
    data_dir = d2l.download_extract('banana-detection')
    csv_fname = os.path.join(data_dir, 'bananas_train' if is_train
                             else 'bananas_val', 'label.csv')
    csv_data = pd.read_csv(csv_fname)
    csv_data = csv_data.set_index('img_name')
    images, targets = [], []
    for img_name, target in csv_data.iterrows():
        images.append(image.imread(
            os.path.join(data_dir, 'bananas_train' if is_train else
                         'bananas_val', 'images', f'{img_name}')))
        # Here `target` contains (class, upper-left x, upper-left y,
        # lower-right x, lower-right y), where all the images have the same
        # banana class (index 0)
        targets.append(list(target))
    return images, np.expand_dims(np.array(targets), 1) / 256
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def read_data_bananas(is_train=True):
    """Read the banana detection dataset images and labels."""
    data_dir = d2l.download_extract('banana-detection')
    csv_fname = os.path.join(data_dir, 'bananas_train' if is_train
                             else 'bananas_val', 'label.csv')
    csv_data = pd.read_csv(csv_fname)
    csv_data = csv_data.set_index('img_name')
    images, targets = [], []
    for img_name, target in csv_data.iterrows():
        images.append(torchvision.io.read_image(
            os.path.join(data_dir, 'bananas_train' if is_train else
                         'bananas_val', 'images', f'{img_name}')))
        # Here `target` contains (class, upper-left x, upper-left y,
        # lower-right x, lower-right y), where all the images have the same
        # banana class (index 0)
        targets.append(list(target))
    return images, torch.tensor(targets).unsqueeze(1) / 256
</code></pre>
<p>By using the <code>read_data_bananas</code> function to read images and labels,
the following <code>BananasDataset</code> class
will allow us to [<strong>create a customized <code>Dataset</code> instance</strong>]
for loading the banana detection dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class BananasDataset(gluon.data.Dataset):
    """A customized dataset to load the banana detection dataset."""
    def __init__(self, is_train):
        self.features, self.labels = read_data_bananas(is_train)
        print('read ' + str(len(self.features)) + (f' training examples' if
              is_train else f' validation examples'))

    def __getitem__(self, idx):
        return (self.features[idx].astype('float32').transpose(2, 0, 1),
                self.labels[idx])

    def __len__(self):
        return len(self.features)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class BananasDataset(torch.utils.data.Dataset):
    """A customized dataset to load the banana detection dataset."""
    def __init__(self, is_train):
        self.features, self.labels = read_data_bananas(is_train)
        print('read ' + str(len(self.features)) + (f' training examples' if
              is_train else f' validation examples'))

    def __getitem__(self, idx):
        return (self.features[idx].float(), self.labels[idx])

    def __len__(self):
        return len(self.features)
</code></pre>
<p>Finally, we define
the <code>load_data_bananas</code> function to [<strong>return two
data iterator instances for both the training and test sets.</strong>]
For the test dataset,
there is no need to read it in random order.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_bananas(batch_size):
    """Load the banana detection dataset."""
    train_iter = gluon.data.DataLoader(BananasDataset(is_train=True),
                                       batch_size, shuffle=True)
    val_iter = gluon.data.DataLoader(BananasDataset(is_train=False),
                                     batch_size)
    return train_iter, val_iter
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_bananas(batch_size):
    """Load the banana detection dataset."""
    train_iter = torch.utils.data.DataLoader(BananasDataset(is_train=True),
                                             batch_size, shuffle=True)
    val_iter = torch.utils.data.DataLoader(BananasDataset(is_train=False),
                                           batch_size)
    return train_iter, val_iter
</code></pre>
<p>Let's [<strong>read a minibatch and print the shapes of
both images and labels</strong>] in this minibatch.
The shape of the image minibatch,
(batch size, number of channels, height, width),
looks familiar:
it is the same as in our earlier image classification tasks.
The shape of the label minibatch is
(batch size, $m$, 5),
where $m$ is the largest possible number of bounding boxes
that any image has in the dataset.</p>
<p>Although computation in minibatches is more efficient,
it requires that all the image examples
contain the same number of bounding boxes to form a minibatch via concatenation.
In general,
images may have a varying number of bounding boxes;
thus,
images with fewer than $m$ bounding boxes
will be padded with illegal bounding boxes
until $m$ is reached.
Then
the label of each bounding box is represented by an array of length 5.
The first element in the array is the class of the object in the bounding box,
where -1 indicates an illegal bounding box for padding.
The remaining four elements of the array are
the ($x$, $y$)-coordinate values
of the upper-left corner and the lower-right corner
of the bounding box (the range is between 0 and 1).
For the banana dataset,
since there is only one bounding box on each image,
we have $m=1$.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size, edge_size = 32, 256
train_iter, _ = load_data_bananas(batch_size)
batch = next(iter(train_iter))
batch[0].shape, batch[1].shape
</code></pre>
<h2 id="demonstration"><a class="header" href="#demonstration">[<strong>Demonstration</strong>]</a></h2>
<p>Let's demonstrate ten images with their labeled ground-truth bounding boxes.
We can see that the rotations, sizes, and positions of bananas vary across all these images.
Of course, this is just a simple artificial dataset.
In practice, real-world datasets are usually much more complicated.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
imgs = (batch[0][:10].transpose(0, 2, 3, 1)) / 255
axes = d2l.show_images(imgs, 2, 5, scale=2)
for ax, label in zip(axes, batch[1][:10]):
    d2l.show_bboxes(ax, [label[0][1:5] * edge_size], colors=['w'])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
imgs = (batch[0][:10].permute(0, 2, 3, 1)) / 255
axes = d2l.show_images(imgs, 2, 5, scale=2)
for ax, label in zip(axes, batch[1][:10]):
    d2l.show_bboxes(ax, [label[0][1:5] * edge_size], colors=['w'])
</code></pre>
<h2 id="summary-77"><a class="header" href="#summary-77">Summary</a></h2>
<ul>
<li>The banana detection dataset we collected can be used to demonstrate object detection models.</li>
<li>The data loading for object detection is similar to that for image classification. However, in object detection the labels also contain information of ground-truth bounding boxes, which is missing in image classification.</li>
</ul>
<h2 id="exercises-97"><a class="header" href="#exercises-97">Exercises</a></h2>
<ol>
<li>Demonstrate other images with ground-truth bounding boxes in the banana detection dataset. How do they differ with respect to bounding boxes and objects?</li>
<li>Say that we want to apply data augmentation, such as random cropping, to object detection. How can it be different from that in image classification? Hint: what if a cropped image only contains a small portion of an object?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/372">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1608">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-shot-multibox-detection"><a class="header" href="#single-shot-multibox-detection">Single Shot Multibox Detection</a></h1>
<p>:label:<code>sec_ssd</code></p>
<p>In :numref:<code>sec_bbox</code>--:numref:<code>sec_object-detection-dataset</code>,
we introduced bounding boxes, anchor boxes,
multiscale object detection, and the dataset for object detection.
Now we are ready to use such background
knowledge to design an object detection model:
single shot multibox detection
(SSD) :cite:<code>Liu.Anguelov.Erhan.ea.2016</code>.
This model is simple, fast, and widely used.
Although this is just one of vast amounts of
object detection models,
some of the design principles
and implementation details in this section
are also applicable to other models.</p>
<h2 id="model-7"><a class="header" href="#model-7">Model</a></h2>
<p>:numref:<code>fig_ssd</code> provides an overview of
the design of single-shot multibox detection.
This model mainly consists of
a base network
followed by
several multiscale feature map blocks.
The base network
is for extracting features from the input image,
so it can use a deep CNN.
For example,
the original single-shot multibox detection paper
adopts a VGG network truncated before the
classification layer :cite:<code>Liu.Anguelov.Erhan.ea.2016</code>,
while ResNet has also been commonly used.
Through our design
we can make the base network output
larger feature maps
so as to generate more anchor boxes
for detecting smaller objects.
Subsequently,
each multiscale feature map block
reduces (e.g., by half)
the height and width of the feature maps
from the previous block,
and enables each unit
of the feature maps
to increase its receptive field on the input image.</p>
<p>Recall the design
of multiscale object detection
through layerwise representations of images by
deep neural networks
in :numref:<code>sec_multiscale-object-detection</code>.
Since
multiscale feature maps closer to the top of :numref:<code>fig_ssd</code>
are smaller but have larger receptive fields,
they are suitable for detecting
fewer but larger objects.</p>
<p>In a nutshell,
via its base network and several multiscale feature map blocks,
single-shot multibox detection
generates a varying number of anchor boxes with different sizes,
and detects varying-size objects
by predicting classes and offsets
of these anchor boxes (thus the bounding boxes);
thus, this is a multiscale object detection model.</p>
<p><img src="chapter_computer-vision/../img/ssd.svg" alt="As a multiscale object detection model, single-shot multibox detection mainly consists of a base network followed by several multiscale feature map blocks." />
:label:<code>fig_ssd</code></p>
<p>In the following,
we will describe the implementation details
of different blocks in :numref:<code>fig_ssd</code>. To begin with, we discuss how to implement
the class and bounding box prediction.</p>
<h3 id="class-prediction-layer"><a class="header" href="#class-prediction-layer">[<strong>Class Prediction Layer</strong>]</a></h3>
<p>Let the number of object classes be $q$.
Then anchor boxes have $q+1$ classes,
where class 0 is background.
At some scale,
suppose that the height and width of feature maps
are $h$ and $w$, respectively.
When $a$ anchor boxes
are generated with
each spatial position of these feature maps as their center,
a total of $hwa$ anchor boxes need to be classified.
This often makes classification with fully connected layers infeasible due to likely
heavy parametrization costs.
Recall how we used channels of
convolutional layers
to predict classes in :numref:<code>sec_nin</code>.
Single-shot multibox detection uses the
same technique to reduce model complexity.</p>
<p>Specifically,
the class prediction layer uses a convolutional layer
without altering width or height of feature maps.
In this way,
there can be a one-to-one correspondence
between outputs and inputs
at the same spatial dimensions (width and height)
of feature maps.
More concretely,
channels of the output feature maps
at any spatial position ($x$, $y$)
represent class predictions
for all the anchor boxes centered on
($x$, $y$) of the input feature maps.
To produce valid predictions,
there must be $a(q+1)$ output channels,
where for the same spatial position
the output channel with index $i(q+1) + j$
represents the prediction of
the class $j$ ($0 \leq j \leq q$)
for the anchor box $i$ ($0 \leq i &lt; a$).</p>
<p>Below we define such a class prediction layer,
specifying $a$ and $q$ via arguments <code>num_anchors</code> and <code>num_classes</code>, respectively.
This layer uses a $3\times3$ convolutional layer with a
padding of 1.
The width and height of the input and output of this
convolutional layer remain unchanged.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, image, init, np, npx
from mxnet.gluon import nn

npx.set_np()

def cls_predictor(num_anchors, num_classes):
    return nn.Conv2D(num_anchors * (num_classes + 1), kernel_size=3,
                     padding=1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
from torch import nn
from torch.nn import functional as F

def cls_predictor(num_inputs, num_anchors, num_classes):
    return nn.Conv2d(num_inputs, num_anchors * (num_classes + 1),
                     kernel_size=3, padding=1)
</code></pre>
<h3 id="bounding-box-prediction-layer"><a class="header" href="#bounding-box-prediction-layer">(<strong>Bounding Box Prediction Layer</strong>)</a></h3>
<p>The design of the bounding box prediction layer is similar to that of the class prediction layer.
The only difference lies in the number of outputs for each anchor box:
here we need to predict four offsets rather than $q+1$ classes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def bbox_predictor(num_anchors):
    return nn.Conv2D(num_anchors * 4, kernel_size=3, padding=1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def bbox_predictor(num_inputs, num_anchors):
    return nn.Conv2d(num_inputs, num_anchors * 4, kernel_size=3, padding=1)
</code></pre>
<h3 id="concatenating-predictions-for-multiple-scales"><a class="header" href="#concatenating-predictions-for-multiple-scales">[<strong>Concatenating Predictions for Multiple Scales</strong>]</a></h3>
<p>As we mentioned, single-shot multibox detection
uses multiscale feature maps to generate anchor boxes and predict their classes and offsets.
At different scales,
the shapes of feature maps
or the numbers of anchor boxes centered on the same unit
may vary.
Therefore,
shapes of the prediction outputs
at different scales may vary.</p>
<p>In the following example,
we construct feature maps at two different scales,
<code>Y1</code> and <code>Y2</code>,
for the same minibatch,
where the height and width of <code>Y2</code>
are half of those of <code>Y1</code>.
Let's take class prediction as an example.
Suppose that
5 and 3 anchor boxes
are generated for every unit in <code>Y1</code> and <code>Y2</code>, respectively.
Suppose further that
the number of object classes is 10.
For feature maps <code>Y1</code> and <code>Y2</code>
the numbers of channels in the class prediction outputs
are $5\times(10+1)=55$ and $3\times(10+1)=33$, respectively,
where either output shape is
(batch size, number of channels, height, width).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def forward(x, block):
    block.initialize()
    return block(x)

Y1 = forward(np.zeros((2, 8, 20, 20)), cls_predictor(5, 10))
Y2 = forward(np.zeros((2, 16, 10, 10)), cls_predictor(3, 10))
Y1.shape, Y2.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def forward(x, block):
    return block(x)

Y1 = forward(torch.zeros((2, 8, 20, 20)), cls_predictor(8, 5, 10))
Y2 = forward(torch.zeros((2, 16, 10, 10)), cls_predictor(16, 3, 10))
Y1.shape, Y2.shape
</code></pre>
<p>As we can see, except for the batch size dimension,
the other three dimensions all have different sizes.
To concatenate these two prediction outputs for more efficient computation,
we will transform these tensors into a more consistent format.</p>
<p>Note that
the channel dimension holds the predictions for
anchor boxes with the same center.
We first move this dimension to the innermost.
Since the batch size remains the same for different scales,
we can transform the prediction output
into a two-dimensional tensor
with shape (batch size, height $\times$ width $\times$ number of channels).
Then we can concatenate
such outputs at different scales
along dimension 1.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def flatten_pred(pred):
    return npx.batch_flatten(pred.transpose(0, 2, 3, 1))

def concat_preds(preds):
    return np.concatenate([flatten_pred(p) for p in preds], axis=1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def flatten_pred(pred):
    return torch.flatten(pred.permute(0, 2, 3, 1), start_dim=1)

def concat_preds(preds):
    return torch.cat([flatten_pred(p) for p in preds], dim=1)
</code></pre>
<p>In this way,
even though <code>Y1</code> and <code>Y2</code> have different sizes
in channels, heights, and widths,
we can still concatenate these two prediction outputs at two different scales for the same minibatch.</p>
<pre><code class="language-{.python .input}">#@tab all
concat_preds([Y1, Y2]).shape
</code></pre>
<h3 id="downsampling-block"><a class="header" href="#downsampling-block">[<strong>Downsampling Block</strong>]</a></h3>
<p>In order to detect objects at multiple scales,
we define the following downsampling block <code>down_sample_blk</code> that
halves the height and width of input feature maps.
In fact,
this block applies the design of VGG blocks
in :numref:<code>subsec_vgg-blocks</code>.
More concretely,
each downsampling block consists of
two $3\times3$ convolutional layers with padding of 1
followed by a $2\times2$ max-pooling layer with stride of 2.
As we know, $3\times3$ convolutional layers with padding of 1 do not change the shape of feature maps.
However, the subsequent $2\times2$ max-pooling  reduces the height and width of input feature maps by half.
For both input and output feature maps of this downsampling block,
because $1\times 2+(3-1)+(3-1)=6$,
each unit in the output
has a $6\times6$ receptive field on the input.
Therefore, the downsampling block enlarges the receptive field of each unit in its output feature maps.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def down_sample_blk(num_channels):
    blk = nn.Sequential()
    for _ in range(2):
        blk.add(nn.Conv2D(num_channels, kernel_size=3, padding=1),
                nn.BatchNorm(in_channels=num_channels),
                nn.Activation('relu'))
    blk.add(nn.MaxPool2D(2))
    return blk
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def down_sample_blk(in_channels, out_channels):
    blk = []
    for _ in range(2):
        blk.append(nn.Conv2d(in_channels, out_channels,
                             kernel_size=3, padding=1))
        blk.append(nn.BatchNorm2d(out_channels))
        blk.append(nn.ReLU())
        in_channels = out_channels
    blk.append(nn.MaxPool2d(2))
    return nn.Sequential(*blk)
</code></pre>
<p>In the following example, our constructed downsampling block changes the number of input channels and halves the height and width of the input feature maps.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
forward(np.zeros((2, 3, 20, 20)), down_sample_blk(10)).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
forward(torch.zeros((2, 3, 20, 20)), down_sample_blk(3, 10)).shape
</code></pre>
<h3 id="base-network-block"><a class="header" href="#base-network-block">[<strong>Base Network Block</strong>]</a></h3>
<p>The base network block is used to extract features from input images.
For simplicity,
we construct a small base network
consisting of three downsampling blocks
that double the number of channels at each block.
Given a $256\times256$ input image,
this base network block outputs $32 \times 32$ feature maps ($256/2^3=32$).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def base_net():
    blk = nn.Sequential()
    for num_filters in [16, 32, 64]:
        blk.add(down_sample_blk(num_filters))
    return blk

forward(np.zeros((2, 3, 256, 256)), base_net()).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def base_net():
    blk = []
    num_filters = [3, 16, 32, 64]
    for i in range(len(num_filters) - 1):
        blk.append(down_sample_blk(num_filters[i], num_filters[i+1]))
    return nn.Sequential(*blk)

forward(torch.zeros((2, 3, 256, 256)), base_net()).shape
</code></pre>
<h3 id="the-complete-model"><a class="header" href="#the-complete-model">The Complete Model</a></h3>
<p>[<strong>The complete
single shot multibox detection model
consists of five blocks.</strong>]
The feature maps produced by each block
are used for both
(i) generating anchor boxes
and (ii) predicting classes and offsets of these anchor boxes.
Among these five blocks,
the first one
is the base network block,
the second to the fourth are
downsampling blocks,
and the last block
uses global max-pooling
to reduce both the height and width to 1.
Technically,
the second to the fifth blocks
are all
those
multiscale feature map blocks
in :numref:<code>fig_ssd</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_blk(i):
    if i == 0:
        blk = base_net()
    elif i == 4:
        blk = nn.GlobalMaxPool2D()
    else:
        blk = down_sample_blk(128)
    return blk
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_blk(i):
    if i == 0:
        blk = base_net()
    elif i == 1:
        blk = down_sample_blk(64, 128)
    elif i == 4:
        blk = nn.AdaptiveMaxPool2d((1,1))
    else:
        blk = down_sample_blk(128, 128)
    return blk
</code></pre>
<p>Now we [<strong>define the forward propagation</strong>]
for each block.
Different from
in image classification tasks,
outputs here include
(i) CNN feature maps <code>Y</code>,
(ii) anchor boxes generated using <code>Y</code> at the current scale,
and (iii) classes and offsets predicted (based on <code>Y</code>)
for these anchor boxes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def blk_forward(X, blk, size, ratio, cls_predictor, bbox_predictor):
    Y = blk(X)
    anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio)
    cls_preds = cls_predictor(Y)
    bbox_preds = bbox_predictor(Y)
    return (Y, anchors, cls_preds, bbox_preds)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def blk_forward(X, blk, size, ratio, cls_predictor, bbox_predictor):
    Y = blk(X)
    anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio)
    cls_preds = cls_predictor(Y)
    bbox_preds = bbox_predictor(Y)
    return (Y, anchors, cls_preds, bbox_preds)
</code></pre>
<p>Recall that
in :numref:<code>fig_ssd</code>
a multiscale feature map block
that is closer to the top
is for detecting larger objects;
thus, it needs to generate larger anchor boxes.
In the above forward propagation,
at each multiscale feature map block
we pass in a list of two scale values
via the <code>sizes</code> argument
of the invoked <code>multibox_prior</code> function (described in :numref:<code>sec_anchor</code>).
In the following,
the interval between 0.2 and 1.05
is split evenly
into five sections to determine the
smaller scale values at the five blocks: 0.2, 0.37, 0.54, 0.71, and 0.88.
Then their larger scale values
are given by
$\sqrt{0.2 \times 0.37} = 0.272$, $\sqrt{0.37 \times 0.54} = 0.447$, and so on.</p>
<p>[<del>Hyperparameters for each block</del>]</p>
<pre><code class="language-{.python .input}">#@tab all
sizes = [[0.2, 0.272], [0.37, 0.447], [0.54, 0.619], [0.71, 0.79],
         [0.88, 0.961]]
ratios = [[1, 2, 0.5]] * 5
num_anchors = len(sizes[0]) + len(ratios[0]) - 1
</code></pre>
<p>Now we can [<strong>define the complete model</strong>] <code>TinySSD</code> as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class TinySSD(nn.Block):
    def __init__(self, num_classes, **kwargs):
        super(TinySSD, self).__init__(**kwargs)
        self.num_classes = num_classes
        for i in range(5):
            # Equivalent to the assignment statement `self.blk_i = get_blk(i)`
            setattr(self, f'blk_{i}', get_blk(i))
            setattr(self, f'cls_{i}', cls_predictor(num_anchors, num_classes))
            setattr(self, f'bbox_{i}', bbox_predictor(num_anchors))

    def forward(self, X):
        anchors, cls_preds, bbox_preds = [None] * 5, [None] * 5, [None] * 5
        for i in range(5):
            # Here `getattr(self, 'blk_%d' % i)` accesses `self.blk_i`
            X, anchors[i], cls_preds[i], bbox_preds[i] = blk_forward(
                X, getattr(self, f'blk_{i}'), sizes[i], ratios[i],
                getattr(self, f'cls_{i}'), getattr(self, f'bbox_{i}'))
        anchors = np.concatenate(anchors, axis=1)
        cls_preds = concat_preds(cls_preds)
        cls_preds = cls_preds.reshape(
            cls_preds.shape[0], -1, self.num_classes + 1)
        bbox_preds = concat_preds(bbox_preds)
        return anchors, cls_preds, bbox_preds
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class TinySSD(nn.Module):
    def __init__(self, num_classes, **kwargs):
        super(TinySSD, self).__init__(**kwargs)
        self.num_classes = num_classes
        idx_to_in_channels = [64, 128, 128, 128, 128]
        for i in range(5):
            # Equivalent to the assignment statement `self.blk_i = get_blk(i)`
            setattr(self, f'blk_{i}', get_blk(i))
            setattr(self, f'cls_{i}', cls_predictor(idx_to_in_channels[i],
                                                    num_anchors, num_classes))
            setattr(self, f'bbox_{i}', bbox_predictor(idx_to_in_channels[i],
                                                      num_anchors))

    def forward(self, X):
        anchors, cls_preds, bbox_preds = [None] * 5, [None] * 5, [None] * 5
        for i in range(5):
            # Here `getattr(self, 'blk_%d' % i)` accesses `self.blk_i`
            X, anchors[i], cls_preds[i], bbox_preds[i] = blk_forward(
                X, getattr(self, f'blk_{i}'), sizes[i], ratios[i],
                getattr(self, f'cls_{i}'), getattr(self, f'bbox_{i}'))
        anchors = torch.cat(anchors, dim=1)
        cls_preds = concat_preds(cls_preds)
        cls_preds = cls_preds.reshape(
            cls_preds.shape[0], -1, self.num_classes + 1)
        bbox_preds = concat_preds(bbox_preds)
        return anchors, cls_preds, bbox_preds
</code></pre>
<p>We [<strong>create a model instance
and use it to perform forward propagation</strong>]
on a minibatch of $256 \times 256$ images <code>X</code>.</p>
<p>As shown earlier in this section,
the first block outputs $32 \times 32$ feature maps.
Recall that
the second to fourth downsampling blocks
halve the height and width
and the fifth block uses global pooling.
Since 4 anchor boxes
are generated for each unit along spatial dimensions
of feature maps,
at all the five scales
a total of $(32^2 + 16^2 + 8^2 + 4^2 + 1)\times 4 = 5444$ anchor boxes are generated for each image.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = TinySSD(num_classes=1)
net.initialize()
X = np.zeros((32, 3, 256, 256))
anchors, cls_preds, bbox_preds = net(X)

print('output anchors:', anchors.shape)
print('output class preds:', cls_preds.shape)
print('output bbox preds:', bbox_preds.shape)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = TinySSD(num_classes=1)
X = torch.zeros((32, 3, 256, 256))
anchors, cls_preds, bbox_preds = net(X)

print('output anchors:', anchors.shape)
print('output class preds:', cls_preds.shape)
print('output bbox preds:', bbox_preds.shape)
</code></pre>
<h2 id="training-25"><a class="header" href="#training-25">Training</a></h2>
<p>Now we will explain
how to train the single shot multibox detection model
for object detection.</p>
<h3 id="reading-the-dataset-and-initializing-the-model"><a class="header" href="#reading-the-dataset-and-initializing-the-model">Reading the Dataset and Initializing the Model</a></h3>
<p>To begin with,
let's [<strong>read
the banana detection dataset</strong>]
described in :numref:<code>sec_object-detection-dataset</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size = 32
train_iter, _ = d2l.load_data_bananas(batch_size)
</code></pre>
<p>There is only one class in the banana detection dataset. After defining the model,
we need to (<strong>initialize its parameters and define
the optimization algorithm</strong>).</p>
<pre><code class="language-{.python .input}">#@tab mxnet
device, net = d2l.try_gpu(), TinySSD(num_classes=1)
net.initialize(init=init.Xavier(), ctx=device)
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'learning_rate': 0.2, 'wd': 5e-4})
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
device, net = d2l.try_gpu(), TinySSD(num_classes=1)
trainer = torch.optim.SGD(net.parameters(), lr=0.2, weight_decay=5e-4)
</code></pre>
<h3 id="defining-loss-and-evaluation-functions"><a class="header" href="#defining-loss-and-evaluation-functions">[<strong>Defining Loss and Evaluation Functions</strong>]</a></h3>
<p>Object detection has two types of losses.
The first loss concerns classes of anchor boxes:
its computation
can simply reuse
the cross-entropy loss function
that we used for image classification.
The second loss
concerns offsets of positive (non-background) anchor boxes:
this is a regression problem.
For this regression problem,
however,
here we do not use the squared loss
described in :numref:<code>subsec_normal_distribution_and_squared_loss</code>.
Instead,
we use the $\ell_1$ norm loss,
the absolute value of the difference between
the prediction and the ground-truth.
The mask variable <code>bbox_masks</code> filters out
negative anchor boxes and illegal (padded)
anchor boxes in the loss calculation.
In the end, we sum up
the anchor box class loss
and the anchor box offset loss
to obtain the loss function for the model.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
cls_loss = gluon.loss.SoftmaxCrossEntropyLoss()
bbox_loss = gluon.loss.L1Loss()

def calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks):
    cls = cls_loss(cls_preds, cls_labels)
    bbox = bbox_loss(bbox_preds * bbox_masks, bbox_labels * bbox_masks)
    return cls + bbox
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
cls_loss = nn.CrossEntropyLoss(reduction='none')
bbox_loss = nn.L1Loss(reduction='none')

def calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks):
    batch_size, num_classes = cls_preds.shape[0], cls_preds.shape[2]
    cls = cls_loss(cls_preds.reshape(-1, num_classes),
                   cls_labels.reshape(-1)).reshape(batch_size, -1).mean(dim=1)
    bbox = bbox_loss(bbox_preds * bbox_masks,
                     bbox_labels * bbox_masks).mean(dim=1)
    return cls + bbox
</code></pre>
<p>We can use accuracy to evaluate the classification results.
Due to the used $\ell_1$ norm loss for the offsets,
we use the <em>mean absolute error</em> to evaluate the
predicted bounding boxes.
These prediction results are obtained
from the generated anchor boxes and the
predicted offsets for them.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def cls_eval(cls_preds, cls_labels):
    # Because the class prediction results are on the final dimension,
    # `argmax` needs to specify this dimension
    return float((cls_preds.argmax(axis=-1).astype(
        cls_labels.dtype) == cls_labels).sum())

def bbox_eval(bbox_preds, bbox_labels, bbox_masks):
    return float((np.abs((bbox_labels - bbox_preds) * bbox_masks)).sum())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def cls_eval(cls_preds, cls_labels):
    # Because the class prediction results are on the final dimension,
    # `argmax` needs to specify this dimension
    return float((cls_preds.argmax(dim=-1).type(
        cls_labels.dtype) == cls_labels).sum())

def bbox_eval(bbox_preds, bbox_labels, bbox_masks):
    return float((torch.abs((bbox_labels - bbox_preds) * bbox_masks)).sum())
</code></pre>
<h3 id="training-the-model"><a class="header" href="#training-the-model">[<strong>Training the Model</strong>]</a></h3>
<p>When training the model,
we need to generate multiscale anchor boxes (<code>anchors</code>)
and predict their classes (<code>cls_preds</code>) and offsets (<code>bbox_preds</code>) in the forward propagation.
Then we label the classes (<code>cls_labels</code>) and offsets (<code>bbox_labels</code>) of such generated anchor boxes
based on the label information <code>Y</code>.
Finally, we calculate the loss function
using the predicted and labeled values
of the classes and offsets.
For concise implementations,
evaluation of the test dataset is omitted here.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
num_epochs, timer = 20, d2l.Timer()
animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                        legend=['class error', 'bbox mae'])
for epoch in range(num_epochs):
    # Sum of training accuracy, no. of examples in sum of training accuracy,
    # Sum of absolute error, no. of examples in sum of absolute error
    metric = d2l.Accumulator(4)
    for features, target in train_iter:
        timer.start()
        X = features.as_in_ctx(device)
        Y = target.as_in_ctx(device)
        with autograd.record():
            # Generate multiscale anchor boxes and predict their classes and
            # offsets
            anchors, cls_preds, bbox_preds = net(X)
            # Label the classes and offsets of these anchor boxes
            bbox_labels, bbox_masks, cls_labels = d2l.multibox_target(anchors,
                                                                      Y)
            # Calculate the loss function using the predicted and labeled
            # values of the classes and offsets
            l = calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels,
                          bbox_masks)
        l.backward()
        trainer.step(batch_size)
        metric.add(cls_eval(cls_preds, cls_labels), cls_labels.size,
                   bbox_eval(bbox_preds, bbox_labels, bbox_masks),
                   bbox_labels.size)
    cls_err, bbox_mae = 1 - metric[0] / metric[1], metric[2] / metric[3]
    animator.add(epoch + 1, (cls_err, bbox_mae))
print(f'class err {cls_err:.2e}, bbox mae {bbox_mae:.2e}')
print(f'{len(train_iter._dataset) / timer.stop():.1f} examples/sec on '
      f'{str(device)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
num_epochs, timer = 20, d2l.Timer()
animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                        legend=['class error', 'bbox mae'])
net = net.to(device)
for epoch in range(num_epochs):
    # Sum of training accuracy, no. of examples in sum of training accuracy,
    # Sum of absolute error, no. of examples in sum of absolute error
    metric = d2l.Accumulator(4)
    net.train()
    for features, target in train_iter:
        timer.start()
        trainer.zero_grad()
        X, Y = features.to(device), target.to(device)
        # Generate multiscale anchor boxes and predict their classes and
        # offsets
        anchors, cls_preds, bbox_preds = net(X)
        # Label the classes and offsets of these anchor boxes
        bbox_labels, bbox_masks, cls_labels = d2l.multibox_target(anchors, Y)
        # Calculate the loss function using the predicted and labeled values
        # of the classes and offsets
        l = calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels,
                      bbox_masks)
        l.mean().backward()
        trainer.step()
        metric.add(cls_eval(cls_preds, cls_labels), cls_labels.numel(),
                   bbox_eval(bbox_preds, bbox_labels, bbox_masks),
                   bbox_labels.numel())
    cls_err, bbox_mae = 1 - metric[0] / metric[1], metric[2] / metric[3]
    animator.add(epoch + 1, (cls_err, bbox_mae))
print(f'class err {cls_err:.2e}, bbox mae {bbox_mae:.2e}')
print(f'{len(train_iter.dataset) / timer.stop():.1f} examples/sec on '
      f'{str(device)}')
</code></pre>
<h2 id="prediction-3"><a class="header" href="#prediction-3">[<strong>Prediction</strong>]</a></h2>
<p>During prediction,
the goal is to detect all the objects of interest
on the image.
Below
we read and resize a test image,
converting it to
a four-dimensional tensor that is
required by convolutional layers.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
img = image.imread('../img/banana.jpg')
feature = image.imresize(img, 256, 256).astype('float32')
X = np.expand_dims(feature.transpose(2, 0, 1), axis=0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X = torchvision.io.read_image('../img/banana.jpg').unsqueeze(0).float()
img = X.squeeze(0).permute(1, 2, 0).long()
</code></pre>
<p>Using the <code>multibox_detection</code> function below,
the predicted bounding boxes
are obtained
from the anchor boxes and their predicted offsets.
Then non-maximum suppression is used
to remove similar predicted bounding boxes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def predict(X):
    anchors, cls_preds, bbox_preds = net(X.as_in_ctx(device))
    cls_probs = npx.softmax(cls_preds).transpose(0, 2, 1)
    output = d2l.multibox_detection(cls_probs, bbox_preds, anchors)
    idx = [i for i, row in enumerate(output[0]) if row[0] != -1]
    return output[0, idx]

output = predict(X)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def predict(X):
    net.eval()
    anchors, cls_preds, bbox_preds = net(X.to(device))
    cls_probs = F.softmax(cls_preds, dim=2).permute(0, 2, 1)
    output = d2l.multibox_detection(cls_probs, bbox_preds, anchors)
    idx = [i for i, row in enumerate(output[0]) if row[0] != -1]
    return output[0, idx]

output = predict(X)
</code></pre>
<p>Finally, we [<strong>display
all the predicted bounding boxes with
confidence 0.9 or above</strong>]
as output.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def display(img, output, threshold):
    d2l.set_figsize((5, 5))
    fig = d2l.plt.imshow(img.asnumpy())
    for row in output:
        score = float(row[1])
        if score &lt; threshold:
            continue
        h, w = img.shape[:2]
        bbox = [row[2:6] * np.array((w, h, w, h), ctx=row.ctx)]
        d2l.show_bboxes(fig.axes, bbox, '%.2f' % score, 'w')

display(img, output, threshold=0.9)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def display(img, output, threshold):
    d2l.set_figsize((5, 5))
    fig = d2l.plt.imshow(img)
    for row in output:
        score = float(row[1])
        if score &lt; threshold:
            continue
        h, w = img.shape[:2]
        bbox = [row[2:6] * torch.tensor((w, h, w, h), device=row.device)]
        d2l.show_bboxes(fig.axes, bbox, '%.2f' % score, 'w')

display(img, output.cpu(), threshold=0.9)
</code></pre>
<h2 id="summary-78"><a class="header" href="#summary-78">Summary</a></h2>
<ul>
<li>Single shot multibox detection is a multiscale object detection model. Via its base network and several multiscale feature map blocks, single-shot multibox detection generates a varying number of anchor boxes with different sizes, and detects varying-size objects by predicting classes and offsets of these anchor boxes (thus the bounding boxes).</li>
<li>When training the single-shot multibox detection model, the loss function is calculated based on the predicted and labeled values of the anchor box classes and offsets.</li>
</ul>
<h2 id="exercises-98"><a class="header" href="#exercises-98">Exercises</a></h2>
<ol>
<li>Can you improve the single-shot multibox detection by improving the loss function? For example, replace $\ell_1$ norm loss with smooth $\ell_1$ norm loss for the predicted offsets. This loss function uses a square function around zero for smoothness, which is controlled by the hyperparameter $\sigma$:</li>
</ol>
<p>$$
f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \textrm{if }|x| &lt; 1/\sigma^2\
|x|-0.5/\sigma^2,&amp; \textrm{otherwise}
\end{cases}
$$</p>
<p>When $\sigma$ is very large, this loss is similar to the $\ell_1$ norm loss. When its value is smaller, the loss function is smoother.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
sigmas = [10, 1, 0.5]
lines = ['-', '--', '-.']
x = np.arange(-2, 2, 0.1)
d2l.set_figsize()

for l, s in zip(lines, sigmas):
    y = npx.smooth_l1(x, scalar=s)
    d2l.plt.plot(x.asnumpy(), y.asnumpy(), l, label='sigma=%.1f' % s)
d2l.plt.legend();
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def smooth_l1(data, scalar):
    out = []
    for i in data:
        if abs(i) &lt; 1 / (scalar ** 2):
            out.append(((scalar * i) ** 2) / 2)
        else:
            out.append(abs(i) - 0.5 / (scalar ** 2))
    return torch.tensor(out)

sigmas = [10, 1, 0.5]
lines = ['-', '--', '-.']
x = torch.arange(-2, 2, 0.1)
d2l.set_figsize()

for l, s in zip(lines, sigmas):
    y = smooth_l1(x, scalar=s)
    d2l.plt.plot(x, y, l, label='sigma=%.1f' % s)
d2l.plt.legend();
</code></pre>
<p>Besides, in the experiment we used cross-entropy loss for class prediction:
denoting by $p_j$ the predicted probability for the ground-truth class $j$, the cross-entropy loss is $-\log p_j$. We can also use the focal loss
:cite:<code>Lin.Goyal.Girshick.ea.2017</code>: given hyperparameters $\gamma &gt; 0$
and $\alpha &gt; 0$, this loss is defined as:</p>
<p>$$ - \alpha (1-p_j)^{\gamma} \log p_j.$$</p>
<p>As we can see, increasing $\gamma$
can effectively reduce the relative loss
for well-classified examples (e.g., $p_j &gt; 0.5$)
so the training
can focus more on those difficult examples that are misclassified.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def focal_loss(gamma, x):
    return -(1 - x) ** gamma * np.log(x)

x = np.arange(0.01, 1, 0.01)
for l, gamma in zip(lines, [0, 1, 5]):
    y = d2l.plt.plot(x.asnumpy(), focal_loss(gamma, x).asnumpy(), l,
                     label='gamma=%.1f' % gamma)
d2l.plt.legend();
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def focal_loss(gamma, x):
    return -(1 - x) ** gamma * torch.log(x)

x = torch.arange(0.01, 1, 0.01)
for l, gamma in zip(lines, [0, 1, 5]):
    y = d2l.plt.plot(x, focal_loss(gamma, x), l, label='gamma=%.1f' % gamma)
d2l.plt.legend();
</code></pre>
<ol start="2">
<li>Due to space limitations, we have omitted some implementation details of the single shot multibox detection model in this section. Can you further improve the model in the following aspects:
<ol>
<li>When an object is much smaller compared with the image, the model could resize the input image bigger.</li>
<li>There are typically a vast number of negative anchor boxes. To make the class distribution more balanced, we could downsample negative anchor boxes.</li>
<li>In the loss function, assign different weight hyperparameters to the class loss and the offset loss.</li>
<li>Use other methods to evaluate the object detection model, such as those in the single shot multibox detection paper :cite:<code>Liu.Anguelov.Erhan.ea.2016</code>.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/373">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1604">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="region-based-cnns-r-cnns"><a class="header" href="#region-based-cnns-r-cnns">Region-based CNNs (R-CNNs)</a></h1>
<p>:label:<code>sec_rcnn</code></p>
<p>Besides single shot multibox detection
described in :numref:<code>sec_ssd</code>,
region-based CNNs or regions with CNN features (R-CNNs)
are also among many pioneering
approaches of
applying
deep learning to object detection
:cite:<code>Girshick.Donahue.Darrell.ea.2014</code>.
In this section, we will introduce
the R-CNN and its series of improvements: the fast R-CNN
:cite:<code>Girshick.2015</code>, the faster R-CNN :cite:<code>Ren.He.Girshick.ea.2015</code>, and the mask R-CNN
:cite:<code>He.Gkioxari.Dollar.ea.2017</code>.
Due to limited space, we will only
focus on the design of these models.</p>
<h2 id="r-cnns"><a class="header" href="#r-cnns">R-CNNs</a></h2>
<p>The <em>R-CNN</em> first extracts
many (e.g., 2000) <em>region proposals</em>
from the input image
(e.g., anchor boxes can also be considered
as region proposals),
labeling their classes and bounding boxes (e.g., offsets).
:cite:<code>Girshick.Donahue.Darrell.ea.2014</code>
Then a CNN is used to
perform forward propagation on each region proposal
to extract its features.
Next, features of each region proposal
are used for
predicting the class and bounding box
of this region proposal.</p>
<p><img src="chapter_computer-vision/../img/r-cnn.svg" alt="The R-CNN model." />
:label:<code>fig_r-cnn</code></p>
<p>:numref:<code>fig_r-cnn</code> shows the R-CNN model. More concretely, the R-CNN consists of the following four steps:</p>
<ol>
<li>Perform <em>selective search</em> to extract multiple high-quality region proposals on the input image :cite:<code>Uijlings.Van-De-Sande.Gevers.ea.2013</code>. These proposed regions are usually selected at multiple scales with different shapes and sizes. Each region proposal will be labeled with a class and a ground-truth bounding box.</li>
<li>Choose a pretrained CNN and truncate it before the output layer. Resize each region proposal to the input size required by the network, and output the extracted features for the region proposal through forward propagation.</li>
<li>Take the extracted features and labeled class of each region proposal as an example. Train multiple support vector machines to classify objects, where each support vector machine individually determines whether the example contains a specific class.</li>
<li>Take the extracted features and labeled bounding box of each region proposal as an example. Train a linear regression model to predict the ground-truth bounding box.</li>
</ol>
<p>Although the R-CNN model uses pretrained CNNs to effectively extract image features,
it is slow.
Imagine that we select
thousands of region proposals from a single input image:
this requires thousands of
CNN forward propagations to perform object detection.
This massive
computing load makes it infeasible to
widely use R-CNNs in real-world applications.</p>
<h2 id="fast-r-cnn"><a class="header" href="#fast-r-cnn">Fast R-CNN</a></h2>
<p>The main performance bottleneck of
an R-CNN lies in
the independent CNN forward propagation
for each region proposal,
without sharing computation.
Since these regions usually have
overlaps,
independent feature extractions lead to
much repeated computation.
One of the major improvements of
the <em>fast R-CNN</em> from the
R-CNN is that
the CNN forward propagation
is only performed on
the entire image :cite:<code>Girshick.2015</code>.</p>
<p><img src="chapter_computer-vision/../img/fast-rcnn.svg" alt="The fast R-CNN model." />
:label:<code>fig_fast_r-cnn</code></p>
<p>:numref:<code>fig_fast_r-cnn</code> describes the fast R-CNN model. Its major computations are as follows:</p>
<ol>
<li>Compared with the R-CNN, in the fast R-CNN the input of the CNN for feature extraction is the entire image, rather than individual region proposals. Moreover, this CNN is trainable. Given an input image, let the shape of the CNN output be $1 \times c \times h_1  \times w_1$.</li>
<li>Suppose that selective search generates $n$ region proposals. These region proposals (of different shapes) mark regions of interest (of different shapes) on the CNN output. Then these regions of interest further extract features of the same shape (say height $h_2$ and width $w_2$ are specified) in order to be easily concatenated. To achieve this, the fast R-CNN introduces the <em>region of interest (RoI) pooling</em> layer: the CNN output and region proposals are input into this layer, outputting concatenated features of shape $n \times c \times h_2 \times w_2$ that are further extracted for all the region proposals.</li>
<li>Using a fully connected layer, transform the concatenated features into an output of shape $n \times d$, where $d$ depends on the model design.</li>
<li>Predict the class and bounding box for each of the $n$ region proposals. More concretely, in class and bounding box prediction, transform the fully connected layer output into an output of shape $n \times q$ ($q$ is the number of classes) and an output of shape $n \times 4$, respectively. The class prediction uses softmax regression.</li>
</ol>
<p>The region of interest pooling layer proposed in the fast R-CNN is different from the pooling layer introduced in :numref:<code>sec_pooling</code>.
In the pooling layer,
we indirectly control the output shape
by specifying sizes of
the pooling window, padding, and stride.
In contrast,
we can directly specify the output shape
in the region of interest pooling layer.</p>
<p>For example, let's specify
the output height and width
for each region as $h_2$ and $w_2$, respectively.
For any region of interest window
of shape $h \times w$,
this window is divided into a $h_2 \times w_2$ grid
of subwindows,
where the shape of each subwindow is approximately
$(h/h_2) \times (w/w_2)$.
In practice,
the height and width of any subwindow shall be rounded up, and the largest element shall be used as output of the subwindow.
Therefore, the region of interest pooling layer can extract features of the same shape
even when regions of interest have different shapes.</p>
<p>As an illustrative example,
in :numref:<code>fig_roi</code>,
the upper-left $3\times 3$ region of interest
is selected on a $4 \times 4$ input.
For this region of interest,
we use a $2\times 2$ region of interest pooling layer to obtain
a $2\times 2$ output.
Note that
each of the four divided subwindows
contains elements
0, 1, 4, and 5 (5 is the maximum);
2 and 6 (6 is the maximum);
8 and 9 (9 is the maximum);
and 10.</p>
<p><img src="chapter_computer-vision/../img/roi.svg" alt="A $2\times 2$ region of interest pooling layer." />
:label:<code>fig_roi</code></p>
<p>Below we demonstrate the computation of the region of interest pooling layer. Suppose that the height and width of the CNN-extracted features <code>X</code> are both 4, and there is only a single channel.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from mxnet import np, npx

npx.set_np()

X = np.arange(16).reshape(1, 1, 4, 4)
X
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
import torch
import torchvision

X = torch.arange(16.).reshape(1, 1, 4, 4)
X
</code></pre>
<p>Let's further suppose
that  the height and width of the input image are both 40 pixels and that selective search generates two region proposals on this image.
Each region proposal
is expressed as five elements:
its object class followed by the $(x, y)$-coordinates of its upper-left and lower-right corners.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
rois = np.array([[0, 0, 0, 20, 20], [0, 0, 10, 30, 30]])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
rois = torch.Tensor([[0, 0, 0, 20, 20], [0, 0, 10, 30, 30]])
</code></pre>
<p>Because the height and width of <code>X</code> are $1/10$ of the height and width of the input image,
the coordinates of the two region proposals
are multiplied by 0.1 according to the specified <code>spatial_scale</code> argument.
Then the two regions of interest are marked on <code>X</code> as <code>X[:, :, 0:3, 0:3]</code> and <code>X[:, :, 1:4, 0:4]</code>, respectively.
Finally in the $2\times 2$ region of interest pooling,
each region of interest is divided
into a grid of sub-windows to
further extract features of the same shape $2\times 2$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
npx.roi_pooling(X, rois, pooled_size=(2, 2), spatial_scale=0.1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torchvision.ops.roi_pool(X, rois, output_size=(2, 2), spatial_scale=0.1)
</code></pre>
<h2 id="faster-r-cnn"><a class="header" href="#faster-r-cnn">Faster R-CNN</a></h2>
<p>To be more accurate in object detection,
the fast R-CNN model
usually has to generate
a lot of region proposals in selective search.
To reduce region proposals
without loss of accuracy,
the <em>faster R-CNN</em>
proposes to replace selective search with a <em>region proposal network</em> :cite:<code>Ren.He.Girshick.ea.2015</code>.</p>
<p><img src="chapter_computer-vision/../img/faster-rcnn.svg" alt="The faster R-CNN model." />
:label:<code>fig_faster_r-cnn</code></p>
<p>:numref:<code>fig_faster_r-cnn</code> shows the faster R-CNN model. Compared with the fast R-CNN,
the faster R-CNN only changes
the region proposal method
from selective search to a region proposal network.
The rest of the model remain
unchanged.
The region proposal network
works in the following steps:</p>
<ol>
<li>Use a $3\times 3$ convolutional layer with padding of 1 to transform the CNN output to a new output with $c$ channels. In this way, each unit along the spatial dimensions of the CNN-extracted feature maps gets a new feature vector of length $c$.</li>
<li>Centered on each pixel of the feature maps, generate multiple anchor boxes of different scales and aspect ratios and label them.</li>
<li>Using the length-$c$ feature vector at the center of each anchor box, predict the binary class (background or objects) and bounding box for this anchor box.</li>
<li>Consider those predicted bounding boxes whose  predicted classes are objects. Remove overlapped results using non-maximum suppression. The remaining  predicted bounding boxes for objects are the region proposals required by the region of interest pooling layer.</li>
</ol>
<p>It is worth noting that,
as part of the faster R-CNN model,
the region
proposal network is jointly trained
with the rest of the model.
In other words, the objective function of
the faster R-CNN includes
not only the class and bounding box prediction
in object detection,
but also the binary class and bounding box prediction
of anchor boxes in the region proposal network.
As a result of the end-to-end training,
the region proposal network learns
how to generate high-quality region proposals,
so as to stay accurate in object detection
with a reduced number of region proposals
that are learned from data.</p>
<h2 id="mask-r-cnn"><a class="header" href="#mask-r-cnn">Mask R-CNN</a></h2>
<p>In the training dataset,
if pixel-level positions of object
are also labeled on images,
the <em>mask R-CNN</em> can effectively leverage
such detailed labels
to further improve the accuracy of object detection :cite:<code>He.Gkioxari.Dollar.ea.2017</code>.</p>
<p><img src="chapter_computer-vision/../img/mask-rcnn.svg" alt="The mask R-CNN model." />
:label:<code>fig_mask_r-cnn</code></p>
<p>As shown in :numref:<code>fig_mask_r-cnn</code>,
the mask R-CNN
is modified based on the faster R-CNN.
Specifically,
the mask R-CNN replaces the
region of interest pooling layer with the
<em>region of interest (RoI) alignment</em> layer.
This region of interest alignment layer
uses bilinear interpolation
to preserve the spatial information on the feature maps, which is more suitable for pixel-level prediction.
The output of this layer
contains feature maps of the same shape
for all the regions of interest.
They are used
to predict
not only the class and bounding box for each region of interest,
but also the pixel-level position of the object through an additional fully convolutional network.
More details on using a fully convolutional network to predict pixel-level semantics of an image
will be provided
in subsequent sections of this chapter.</p>
<h2 id="summary-79"><a class="header" href="#summary-79">Summary</a></h2>
<ul>
<li>The R-CNN extracts many region proposals from the input image, uses a CNN to perform forward propagation on each region proposal to extract its features, then uses these features to predict the class and bounding box of this region proposal.</li>
<li>One of the major improvements of  the fast R-CNN from the R-CNN is that the CNN forward propagation is only performed on  the entire image. It also introduces the region of interest pooling layer, so that features of the same shape can be further extracted for regions of interest that have different shapes.</li>
<li>The faster R-CNN replaces the selective search used in the fast R-CNN with a jointly trained region proposal network, so that the former can stay accurate in object detection with a reduced number of region proposals.</li>
<li>Based on the faster R-CNN, the mask R-CNN additionally introduces a fully convolutional network, so as to leverage pixel-level labels to further improve the accuracy of object detection.</li>
</ul>
<h2 id="exercises-99"><a class="header" href="#exercises-99">Exercises</a></h2>
<ol>
<li>Can we frame object detection as a single regression problem, such as predicting bounding boxes and class probabilities? You may refer to the design of the YOLO model :cite:<code>Redmon.Divvala.Girshick.ea.2016</code>.</li>
<li>Compare single shot multibox detection with the methods introduced in this section. What are their major differences? You may refer to Figure 2 of :citet:<code>Zhao.Zheng.Xu.ea.2019</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/374">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1409">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semantic-segmentation-and-the-dataset"><a class="header" href="#semantic-segmentation-and-the-dataset">Semantic Segmentation and the Dataset</a></h1>
<p>:label:<code>sec_semantic_segmentation</code></p>
<p>When discussing object detection tasks
in :numref:<code>sec_bbox</code>--:numref:<code>sec_rcnn</code>,
rectangular bounding boxes
are used to label and predict objects in images.
This section will discuss the problem of <em>semantic segmentation</em>,
which focuses on how to divide an image into regions belonging to different semantic classes.
Different from object detection,
semantic segmentation
recognizes and understands
what are in images in pixel level:
its labeling and prediction of semantic regions are
in pixel level.
:numref:<code>fig_segmentation</code> shows the labels
of the dog, cat, and background of the image in semantic segmentation.
Compared with in object detection,
the pixel-level borders labeled
in semantic segmentation are obviously more fine-grained.</p>
<p><img src="chapter_computer-vision/../img/segmentation.svg" alt="Labels of the dog, cat, and background of the image in semantic segmentation." />
:label:<code>fig_segmentation</code></p>
<h2 id="image-segmentation-and-instance-segmentation"><a class="header" href="#image-segmentation-and-instance-segmentation">Image Segmentation and Instance Segmentation</a></h2>
<p>There are also two important tasks
in the field of computer vision that are similar to semantic segmentation,
namely image segmentation and instance segmentation.
We will briefly
distinguish them from semantic segmentation as follows.</p>
<ul>
<li><em>Image segmentation</em> divides an image into several constituent regions. The methods for this type of problem usually make use of the correlation between pixels in the image. It does not need label information about image pixels during training, and it cannot guarantee that the segmented regions will have the semantics that we hope to obtain during prediction. Taking the image in :numref:<code>fig_segmentation</code> as input, image segmentation may divide the dog into two regions: one covers the mouth and eyes which are mainly black, and the other covers the rest of the body which is mainly yellow.</li>
<li><em>Instance segmentation</em> is also called <em>simultaneous detection and segmentation</em>. It studies how to recognize the pixel-level regions of each object instance in an image. Different from semantic segmentation, instance segmentation needs to distinguish not only semantics, but also different object instances. For example, if there are two dogs in the image, instance segmentation needs to distinguish which of the two dogs a pixel belongs to.</li>
</ul>
<h2 id="the-pascal-voc2012-semantic-segmentation-dataset"><a class="header" href="#the-pascal-voc2012-semantic-segmentation-dataset">The Pascal VOC2012 Semantic Segmentation Dataset</a></h2>
<p>[<strong>On of the most important semantic segmentation dataset
is <a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/">Pascal VOC2012</a>.</strong>]
In the following,
we will take a look at this dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, image, np, npx
import os

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
import os
</code></pre>
<p>The tar file of the dataset is about 2 GB,
so it may take a while to download the file.
The extracted dataset is located at <code>../data/VOCdevkit/VOC2012</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['voc2012'] = (d2l.DATA_URL + 'VOCtrainval_11-May-2012.tar',
                           '4e443f8a2eca6b1dac8a6c57641b67dd40621a49')

voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012')
</code></pre>
<p>After entering the path <code>../data/VOCdevkit/VOC2012</code>,
we can see the different components of the dataset.
The <code>ImageSets/Segmentation</code> path contains text files
that specify training and test samples,
while the <code>JPEGImages</code> and <code>SegmentationClass</code> paths
store the input image and label for each example, respectively.
The label here is also in the image format,
with the same size
as its labeled input image.
Besides,
pixels with the same color in any label image belong to the same semantic class.
The following defines the <code>read_voc_images</code> function to [<strong>read all the input images and labels into the memory</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def read_voc_images(voc_dir, is_train=True):
    """Read all VOC feature and label images."""
    txt_fname = os.path.join(voc_dir, 'ImageSets', 'Segmentation',
                             'train.txt' if is_train else 'val.txt')
    with open(txt_fname, 'r') as f:
        images = f.read().split()
    features, labels = [], []
    for i, fname in enumerate(images):
        features.append(image.imread(os.path.join(
            voc_dir, 'JPEGImages', f'{fname}.jpg')))
        labels.append(image.imread(os.path.join(
            voc_dir, 'SegmentationClass', f'{fname}.png')))
    return features, labels

train_features, train_labels = read_voc_images(voc_dir, True)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def read_voc_images(voc_dir, is_train=True):
    """Read all VOC feature and label images."""
    txt_fname = os.path.join(voc_dir, 'ImageSets', 'Segmentation',
                             'train.txt' if is_train else 'val.txt')
    mode = torchvision.io.image.ImageReadMode.RGB
    with open(txt_fname, 'r') as f:
        images = f.read().split()
    features, labels = [], []
    for i, fname in enumerate(images):
        features.append(torchvision.io.read_image(os.path.join(
            voc_dir, 'JPEGImages', f'{fname}.jpg')))
        labels.append(torchvision.io.read_image(os.path.join(
            voc_dir, 'SegmentationClass' ,f'{fname}.png'), mode))
    return features, labels

train_features, train_labels = read_voc_images(voc_dir, True)
</code></pre>
<p>We [<strong>draw the first five input images and their labels</strong>].
In the label images, white and black represent borders and  background, respectively, while the other colors correspond to different classes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
n = 5
imgs = train_features[:n] + train_labels[:n]
d2l.show_images(imgs, 2, n);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
n = 5
imgs = train_features[:n] + train_labels[:n]
imgs = [img.permute(1,2,0) for img in imgs]
d2l.show_images(imgs, 2, n);
</code></pre>
<p>Next, we [<strong>enumerate
the RGB color values and class names</strong>]
for all the labels in this dataset.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
VOC_COLORMAP = [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0],
                [0, 0, 128], [128, 0, 128], [0, 128, 128], [128, 128, 128],
                [64, 0, 0], [192, 0, 0], [64, 128, 0], [192, 128, 0],
                [64, 0, 128], [192, 0, 128], [64, 128, 128], [192, 128, 128],
                [0, 64, 0], [128, 64, 0], [0, 192, 0], [128, 192, 0],
                [0, 64, 128]]

#@save
VOC_CLASSES = ['background', 'aeroplane', 'bicycle', 'bird', 'boat',
               'bottle', 'bus', 'car', 'cat', 'chair', 'cow',
               'diningtable', 'dog', 'horse', 'motorbike', 'person',
               'potted plant', 'sheep', 'sofa', 'train', 'tv/monitor']
</code></pre>
<p>With the two constants defined above,
we can conveniently
[<strong>find the class index for each pixel in a label</strong>].
We define the <code>voc_colormap2label</code> function
to build the mapping from the above RGB color values
to class indices,
and the <code>voc_label_indices</code> function
to map any RGB values to their class indices in this Pascal VOC2012 dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def voc_colormap2label():
    """Build the mapping from RGB to class indices for VOC labels."""
    colormap2label = np.zeros(256 ** 3)
    for i, colormap in enumerate(VOC_COLORMAP):
        colormap2label[
            (colormap[0] * 256 + colormap[1]) * 256 + colormap[2]] = i
    return colormap2label

#@save
def voc_label_indices(colormap, colormap2label):
    """Map any RGB values in VOC labels to their class indices."""
    colormap = colormap.astype(np.int32)
    idx = ((colormap[:, :, 0] * 256 + colormap[:, :, 1]) * 256
           + colormap[:, :, 2])
    return colormap2label[idx]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def voc_colormap2label():
    """Build the mapping from RGB to class indices for VOC labels."""
    colormap2label = torch.zeros(256 ** 3, dtype=torch.long)
    for i, colormap in enumerate(VOC_COLORMAP):
        colormap2label[
            (colormap[0] * 256 + colormap[1]) * 256 + colormap[2]] = i
    return colormap2label

#@save
def voc_label_indices(colormap, colormap2label):
    """Map any RGB values in VOC labels to their class indices."""
    colormap = colormap.permute(1, 2, 0).numpy().astype('int32')
    idx = ((colormap[:, :, 0] * 256 + colormap[:, :, 1]) * 256
           + colormap[:, :, 2])
    return colormap2label[idx]
</code></pre>
<p>[<strong>For example</strong>], in the first example image,
the class index for the front part of the airplane is 1,
while the background index is 0.</p>
<pre><code class="language-{.python .input}">#@tab all
y = voc_label_indices(train_labels[0], voc_colormap2label())
y[105:115, 130:140], VOC_CLASSES[1]
</code></pre>
<h3 id="data-preprocessing-2"><a class="header" href="#data-preprocessing-2">Data Preprocessing</a></h3>
<p>In previous experiments
such as in :numref:<code>sec_alexnet</code>--:numref:<code>sec_googlenet</code>,
images are rescaled
to fit the model's required input shape.
However, in semantic segmentation,
doing so
requires rescaling the predicted pixel classes
back to the original shape of the input image.
Such rescaling may be inaccurate,
especially for segmented regions with different classes. To avoid this issue,
we crop the image to a <em>fixed</em> shape instead of rescaling. Specifically, [<strong>using random cropping from image augmentation, we crop the same area of
the input image and the label</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def voc_rand_crop(feature, label, height, width):
    """Randomly crop both feature and label images."""
    feature, rect = image.random_crop(feature, (width, height))
    label = image.fixed_crop(label, *rect)
    return feature, label
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def voc_rand_crop(feature, label, height, width):
    """Randomly crop both feature and label images."""
    rect = torchvision.transforms.RandomCrop.get_params(
        feature, (height, width))
    feature = torchvision.transforms.functional.crop(feature, *rect)
    label = torchvision.transforms.functional.crop(label, *rect)
    return feature, label
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
imgs = []
for _ in range(n):
    imgs += voc_rand_crop(train_features[0], train_labels[0], 200, 300)
d2l.show_images(imgs[::2] + imgs[1::2], 2, n);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
imgs = []
for _ in range(n):
    imgs += voc_rand_crop(train_features[0], train_labels[0], 200, 300)

imgs = [img.permute(1, 2, 0) for img in imgs]
d2l.show_images(imgs[::2] + imgs[1::2], 2, n);
</code></pre>
<h3 id="custom-semantic-segmentation-dataset-class"><a class="header" href="#custom-semantic-segmentation-dataset-class">[<strong>Custom Semantic Segmentation Dataset Class</strong>]</a></h3>
<p>We define a custom semantic segmentation dataset class <code>VOCSegDataset</code> by inheriting the <code>Dataset</code> class provided by high-level APIs.
By implementing the <code>__getitem__</code> function,
we can arbitrarily access the input image indexed as <code>idx</code> in the dataset and the class index of each pixel in this image.
Since some images in the dataset
have a smaller size
than the output size of random cropping,
these examples are filtered out
by a custom <code>filter</code> function.
In addition, we also
define the <code>normalize_image</code> function to
standardize the values of the three RGB channels of input images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class VOCSegDataset(gluon.data.Dataset):
    """A customized dataset to load the VOC dataset."""
    def __init__(self, is_train, crop_size, voc_dir):
        self.rgb_mean = np.array([0.485, 0.456, 0.406])
        self.rgb_std = np.array([0.229, 0.224, 0.225])
        self.crop_size = crop_size
        features, labels = read_voc_images(voc_dir, is_train=is_train)
        self.features = [self.normalize_image(feature)
                         for feature in self.filter(features)]
        self.labels = self.filter(labels)
        self.colormap2label = voc_colormap2label()
        print('read ' + str(len(self.features)) + ' examples')

    def normalize_image(self, img):
        return (img.astype('float32') / 255 - self.rgb_mean) / self.rgb_std

    def filter(self, imgs):
        return [img for img in imgs if (
            img.shape[0] &gt;= self.crop_size[0] and
            img.shape[1] &gt;= self.crop_size[1])]

    def __getitem__(self, idx):
        feature, label = voc_rand_crop(self.features[idx], self.labels[idx],
                                       *self.crop_size)
        return (feature.transpose(2, 0, 1),
                voc_label_indices(label, self.colormap2label))

    def __len__(self):
        return len(self.features)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class VOCSegDataset(torch.utils.data.Dataset):
    """A customized dataset to load the VOC dataset."""

    def __init__(self, is_train, crop_size, voc_dir):
        self.transform = torchvision.transforms.Normalize(
            mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        self.crop_size = crop_size
        features, labels = read_voc_images(voc_dir, is_train=is_train)
        self.features = [self.normalize_image(feature)
                         for feature in self.filter(features)]
        self.labels = self.filter(labels)
        self.colormap2label = voc_colormap2label()
        print('read ' + str(len(self.features)) + ' examples')

    def normalize_image(self, img):
        return self.transform(img.float() / 255)

    def filter(self, imgs):
        return [img for img in imgs if (
            img.shape[1] &gt;= self.crop_size[0] and
            img.shape[2] &gt;= self.crop_size[1])]

    def __getitem__(self, idx):
        feature, label = voc_rand_crop(self.features[idx], self.labels[idx],
                                       *self.crop_size)
        return (feature, voc_label_indices(label, self.colormap2label))

    def __len__(self):
        return len(self.features)
</code></pre>
<h3 id="reading-the-dataset-7"><a class="header" href="#reading-the-dataset-7">[<strong>Reading the Dataset</strong>]</a></h3>
<p>We use the custom <code>VOCSegDatase</code>t class to
create instances of the training set and test set, respectively.
Suppose that
we specify that the output shape of randomly cropped images is $320\times 480$.
Below we can view the number of examples
that are retained in the training set and test set.</p>
<pre><code class="language-{.python .input}">#@tab all
crop_size = (320, 480)
voc_train = VOCSegDataset(True, crop_size, voc_dir)
voc_test = VOCSegDataset(False, crop_size, voc_dir)
</code></pre>
<p>Setting the batch size to 64,
we define the data iterator for the training set.
Let's print the shape of the first minibatch.
Different from in image classification or object detection, labels here are three-dimensional tensors.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
batch_size = 64
train_iter = gluon.data.DataLoader(voc_train, batch_size, shuffle=True,
                                   last_batch='discard',
                                   num_workers=d2l.get_dataloader_workers())
for X, Y in train_iter:
    print(X.shape)
    print(Y.shape)
    break
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
batch_size = 64
train_iter = torch.utils.data.DataLoader(voc_train, batch_size, shuffle=True,
                                    drop_last=True,
                                    num_workers=d2l.get_dataloader_workers())
for X, Y in train_iter:
    print(X.shape)
    print(Y.shape)
    break
</code></pre>
<h3 id="putting-it-all-together-2"><a class="header" href="#putting-it-all-together-2">[<strong>Putting It All Together</strong>]</a></h3>
<p>Finally, we define the following <code>load_data_voc</code> function
to download and read the Pascal VOC2012 semantic segmentation dataset.
It returns data iterators for both the training and test datasets.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_voc(batch_size, crop_size):
    """Load the VOC semantic segmentation dataset."""
    voc_dir = d2l.download_extract('voc2012', os.path.join(
        'VOCdevkit', 'VOC2012'))
    num_workers = d2l.get_dataloader_workers()
    train_iter = gluon.data.DataLoader(
        VOCSegDataset(True, crop_size, voc_dir), batch_size,
        shuffle=True, last_batch='discard', num_workers=num_workers)
    test_iter = gluon.data.DataLoader(
        VOCSegDataset(False, crop_size, voc_dir), batch_size,
        last_batch='discard', num_workers=num_workers)
    return train_iter, test_iter
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_voc(batch_size, crop_size):
    """Load the VOC semantic segmentation dataset."""
    voc_dir = d2l.download_extract('voc2012', os.path.join(
        'VOCdevkit', 'VOC2012'))
    num_workers = d2l.get_dataloader_workers()
    train_iter = torch.utils.data.DataLoader(
        VOCSegDataset(True, crop_size, voc_dir), batch_size,
        shuffle=True, drop_last=True, num_workers=num_workers)
    test_iter = torch.utils.data.DataLoader(
        VOCSegDataset(False, crop_size, voc_dir), batch_size,
        drop_last=True, num_workers=num_workers)
    return train_iter, test_iter
</code></pre>
<h2 id="summary-80"><a class="header" href="#summary-80">Summary</a></h2>
<ul>
<li>Semantic segmentation recognizes and understands what are in an image in pixel level by dividing the image into regions belonging to different semantic classes.</li>
<li>One of the most important semantic segmentation dataset is Pascal VOC2012.</li>
<li>In semantic segmentation, since the input image and  label correspond one-to-one on the pixel, the input image is randomly cropped to a fixed shape rather than rescaled.</li>
</ul>
<h2 id="exercises-100"><a class="header" href="#exercises-100">Exercises</a></h2>
<ol>
<li>How can semantic segmentation be applied in autonomous vehicles and medical image diagnostics? Can you think of other applications?</li>
<li>Recall the descriptions of data augmentation in :numref:<code>sec_image_augmentation</code>. Which of the image augmentation methods used in image classification would be infeasible to be applied in semantic segmentation?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/375">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1480">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transposed-convolution"><a class="header" href="#transposed-convolution">Transposed Convolution</a></h1>
<p>:label:<code>sec_transposed_conv</code></p>
<p>The CNN layers we have seen so far,
such as convolutional layers (:numref:<code>sec_conv_layer</code>) and pooling layers (:numref:<code>sec_pooling</code>),
typically reduce (downsample) the spatial dimensions (height and width) of the input,
or keep them unchanged.
In semantic segmentation
that classifies at pixel-level,
it will be convenient if
the spatial dimensions of the
input and output are the same.
For example,
the channel dimension at one output pixel
can hold the classification results
for the input pixel at the same spatial position.</p>
<p>To achieve this, especially after
the spatial dimensions are reduced by CNN layers,
we can use another type
of CNN layers
that can increase (upsample) the spatial dimensions
of intermediate feature maps.
In this section,
we will introduce
<em>transposed convolution</em>, which is also called <em>fractionally-strided convolution</em> :cite:<code>Dumoulin.Visin.2016</code>,
for reversing downsampling operations
by the convolution.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from mxnet import np, npx, init
from mxnet.gluon import nn
from d2l import mxnet as d2l

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
import torch
from torch import nn
from d2l import torch as d2l
</code></pre>
<h2 id="basic-operation"><a class="header" href="#basic-operation">Basic Operation</a></h2>
<p>Ignoring channels for now,
let's begin with
the basic transposed convolution operation
with stride of 1 and no padding.
Suppose that
we are given a
$n_h \times n_w$ input tensor
and a $k_h \times k_w$ kernel.
Sliding the kernel window with stride of 1
for $n_w$ times in each row
and $n_h$ times in each column
yields
a total of $n_h n_w$ intermediate results.
Each intermediate result is
a $(n_h + k_h - 1) \times (n_w + k_w - 1)$
tensor that are initialized as zeros.
To compute each intermediate tensor,
each element in the input tensor
is multiplied by the kernel
so that the resulting $k_h \times k_w$ tensor
replaces a portion in
each intermediate tensor.
Note that
the position of the replaced portion in each
intermediate tensor corresponds to the position of the element
in the input tensor used for the computation.
In the end, all the intermediate results
are summed over to produce the output.</p>
<p>As an example,
:numref:<code>fig_trans_conv</code> illustrates
how transposed convolution with a $2\times 2$ kernel is computed for a $2\times 2$ input tensor.</p>
<p><img src="chapter_computer-vision/../img/trans_conv.svg" alt="Transposed convolution with a $2\times 2$ kernel. The shaded portions are a portion of an intermediate tensor as well as the input and kernel tensor elements used for the  computation." />
:label:<code>fig_trans_conv</code></p>
<p>We can (<strong>implement this basic transposed convolution operation</strong>) <code>trans_conv</code> for a input matrix <code>X</code> and a kernel matrix <code>K</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def trans_conv(X, K):
    h, w = K.shape
    Y = d2l.zeros((X.shape[0] + h - 1, X.shape[1] + w - 1))
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            Y[i: i + h, j: j + w] += X[i, j] * K
    return Y
</code></pre>
<p>In contrast to the regular convolution (in :numref:<code>sec_conv_layer</code>) that <em>reduces</em> input elements
via the kernel,
the transposed convolution
<em>broadcasts</em> input elements
via the kernel, thereby
producing an output
that is larger than the input.
We can construct the input tensor <code>X</code> and the kernel tensor <code>K</code> from :numref:<code>fig_trans_conv</code> to [<strong>validate the output of the above implementation</strong>] of the basic two-dimensional transposed convolution operation.</p>
<pre><code class="language-{.python .input}">#@tab all
X = d2l.tensor([[0.0, 1.0], [2.0, 3.0]])
K = d2l.tensor([[0.0, 1.0], [2.0, 3.0]])
trans_conv(X, K)
</code></pre>
<p>Alternatively,
when the input <code>X</code> and kernel <code>K</code> are both
four-dimensional tensors,
we can [<strong>use high-level APIs to obtain the same results</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2)
tconv = nn.Conv2DTranspose(1, kernel_size=2)
tconv.initialize(init.Constant(K))
tconv(X)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2)
tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, bias=False)
tconv.weight.data = K
tconv(X)
</code></pre>
<h2 id="padding-strides-and-multiple-channels"><a class="header" href="#padding-strides-and-multiple-channels">[<strong>Padding, Strides, and Multiple Channels</strong>]</a></h2>
<p>Different from in the regular convolution
where padding is applied to input,
it is applied to output
in the transposed convolution.
For example,
when specifying the padding number
on either side of the height and width
as 1,
the first and last rows and columns
will be removed from the transposed convolution output.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
tconv = nn.Conv2DTranspose(1, kernel_size=2, padding=1)
tconv.initialize(init.Constant(K))
tconv(X)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, padding=1, bias=False)
tconv.weight.data = K
tconv(X)
</code></pre>
<p>In the transposed convolution,
strides are specified for intermediate results (thus output), not for input.
Using the same input and kernel tensors
from :numref:<code>fig_trans_conv</code>,
changing the stride from 1 to 2
increases both the height and weight
of intermediate tensors, hence the output tensor
in :numref:<code>fig_trans_conv_stride2</code>.</p>
<p><img src="chapter_computer-vision/../img/trans_conv_stride2.svg" alt="Transposed convolution with a $2\times 2$ kernel with stride of 2. The shaded portions are a portion of an intermediate tensor as well as the input and kernel tensor elements used for the  computation." />
:label:<code>fig_trans_conv_stride2</code></p>
<p>The following code snippet can validate the transposed convolution output for stride of 2 in :numref:<code>fig_trans_conv_stride2</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
tconv = nn.Conv2DTranspose(1, kernel_size=2, strides=2)
tconv.initialize(init.Constant(K))
tconv(X)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, stride=2, bias=False)
tconv.weight.data = K
tconv(X)
</code></pre>
<p>For multiple input and output channels,
the transposed convolution
works in the same way as the regular convolution.
Suppose that
the input has $c_i$ channels,
and that the transposed convolution
assigns a $k_h\times k_w$ kernel tensor
to each input channel.
When multiple output channels
are specified,
we will have a $c_i\times k_h\times k_w$ kernel for each output channel.</p>
<p>As in all, if we feed $\mathsf{X}$ into a convolutional layer $f$ to output $\mathsf{Y}=f(\mathsf{X})$ and create a transposed convolutional layer $g$ with the same hyperparameters as $f$ except
for the number of output channels
being the number of channels in $\mathsf{X}$,
then $g(Y)$ will have the same shape as $\mathsf{X}$.
This can be illustrated in the following example.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
X = np.random.uniform(size=(1, 10, 16, 16))
conv = nn.Conv2D(20, kernel_size=5, padding=2, strides=3)
tconv = nn.Conv2DTranspose(10, kernel_size=5, padding=2, strides=3)
conv.initialize()
tconv.initialize()
tconv(conv(X)).shape == X.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X = torch.rand(size=(1, 10, 16, 16))
conv = nn.Conv2d(10, 20, kernel_size=5, padding=2, stride=3)
tconv = nn.ConvTranspose2d(20, 10, kernel_size=5, padding=2, stride=3)
tconv(conv(X)).shape == X.shape
</code></pre>
<h2 id="connection-to-matrix-transposition"><a class="header" href="#connection-to-matrix-transposition">[<strong>Connection to Matrix Transposition</strong>]</a></h2>
<p>:label:<code>subsec-connection-to-mat-transposition</code></p>
<p>The transposed convolution is named after
the matrix transposition.
To explain,
let's first
see how to implement convolutions
using matrix multiplications.
In the example below, we define a $3\times 3$ input <code>X</code> and a $2\times 2$ convolution kernel <code>K</code>, and then use the <code>corr2d</code> function to compute the convolution output <code>Y</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
X = d2l.arange(9.0).reshape(3, 3)
K = d2l.tensor([[1.0, 2.0], [3.0, 4.0]])
Y = d2l.corr2d(X, K)
Y
</code></pre>
<p>Next, we rewrite the convolution kernel <code>K</code> as
a sparse weight matrix <code>W</code>
containing a lot of zeros.
The shape of the weight matrix is ($4$, $9$),
where the non-zero elements come from
the convolution kernel <code>K</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def kernel2matrix(K):
    k, W = d2l.zeros(5), d2l.zeros((4, 9))
    k[:2], k[3:5] = K[0, :], K[1, :]
    W[0, :5], W[1, 1:6], W[2, 3:8], W[3, 4:] = k, k, k, k
    return W

W = kernel2matrix(K)
W
</code></pre>
<p>Concatenate the input <code>X</code> row by row to get a vector of length 9. Then the matrix multiplication of <code>W</code> and the vectorized <code>X</code> gives a vector of length 4.
After reshaping it, we can obtain the same result <code>Y</code>
from the original convolution operation above:
we just implemented convolutions using matrix multiplications.</p>
<pre><code class="language-{.python .input}">#@tab all
Y == d2l.matmul(W, d2l.reshape(X, -1)).reshape(2, 2)
</code></pre>
<p>Likewise, we can implement transposed convolutions using
matrix multiplications.
In the following example,
we take the $2 \times 2$ output <code>Y</code> from the above
regular convolution
as input to the transposed convolution.
To implement this operation by multiplying matrices,
we only need to transpose the weight matrix <code>W</code>
with the new shape $(9, 4)$.</p>
<pre><code class="language-{.python .input}">#@tab all
Z = trans_conv(Y, K)
Z == d2l.matmul(W.T, d2l.reshape(Y, -1)).reshape(3, 3)
</code></pre>
<p>Consider implementing the convolution
by multiplying matrices.
Given an input vector $\mathbf{x}$
and a weight matrix $\mathbf{W}$,
the forward propagation function of the convolution
can be implemented
by multiplying its input with the weight matrix
and outputting a vector
$\mathbf{y}=\mathbf{W}\mathbf{x}$.
Since backpropagation
follows the chain rule
and $\nabla_{\mathbf{x}}\mathbf{y}=\mathbf{W}^\top$,
the backpropagation function of the convolution
can be implemented
by multiplying its input with the
transposed weight matrix $\mathbf{W}^\top$.
Therefore,
the transposed convolutional layer
can just exchange the forward propagation function
and the backpropagation function of the convolutional layer:
its forward propagation
and backpropagation functions
multiply their input vector with
$\mathbf{W}^\top$ and $\mathbf{W}$, respectively.</p>
<h2 id="summary-81"><a class="header" href="#summary-81">Summary</a></h2>
<ul>
<li>In contrast to the regular convolution that reduces input elements via the kernel, the transposed convolution broadcasts input elements via the kernel, thereby producing an output that is larger than the input.</li>
<li>If we feed $\mathsf{X}$ into a convolutional layer $f$ to output $\mathsf{Y}=f(\mathsf{X})$ and create a transposed convolutional layer $g$ with the same hyperparameters as $f$ except for the number of output channels being the number of channels in $\mathsf{X}$, then $g(Y)$ will have the same shape as $\mathsf{X}$.</li>
<li>We can implement convolutions using matrix multiplications. The transposed convolutional layer can just exchange the forward propagation function and the backpropagation function of the convolutional layer.</li>
</ul>
<h2 id="exercises-101"><a class="header" href="#exercises-101">Exercises</a></h2>
<ol>
<li>In :numref:<code>subsec-connection-to-mat-transposition</code>, the convolution input <code>X</code> and the transposed convolution output <code>Z</code> have the same shape. Do they have the same value? Why?</li>
<li>Is it efficient to use matrix multiplications to implement convolutions? Why?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/376">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1450">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fully-convolutional-networks"><a class="header" href="#fully-convolutional-networks">Fully Convolutional Networks</a></h1>
<p>:label:<code>sec_fcn</code></p>
<p>As discussed in :numref:<code>sec_semantic_segmentation</code>,
semantic segmentation
classifies images in pixel level.
A fully convolutional network (FCN)
uses a convolutional neural network to
transform image pixels to pixel classes :cite:<code>Long.Shelhamer.Darrell.2015</code>.
Unlike the CNNs that we encountered earlier
for image classification
or object detection,
a fully convolutional network
transforms
the height and width of intermediate feature maps
back to those of the input image:
this is achieved by
the transposed convolutional layer
introduced in :numref:<code>sec_transposed_conv</code>.
As a result,
the classification output
and the input image
have a one-to-one correspondence
in pixel level:
the channel dimension at any output pixel
holds the classification results
for the input pixel at the same spatial position.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import gluon, image, init, np, npx
from mxnet.gluon import nn

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
from torch import nn
from torch.nn import functional as F
</code></pre>
<h2 id="the-model-1"><a class="header" href="#the-model-1">The Model</a></h2>
<p>Here we describe the basic design of the fully convolutional network model.
As shown in :numref:<code>fig_fcn</code>,
this model first uses a CNN to extract image features,
then transforms the number of channels into
the number of classes
via a $1\times 1$ convolutional layer,
and finally transforms the height and width of
the feature maps
to those
of the input image via
the transposed convolution introduced in :numref:<code>sec_transposed_conv</code>.
As a result,
the model output has the same height and width as the input image,
where the output channel contains the predicted classes
for the input pixel at the same spatial position.</p>
<p><img src="chapter_computer-vision/../img/fcn.svg" alt="Fully convolutional network." />
:label:<code>fig_fcn</code></p>
<p>Below, we [<strong>use a ResNet-18 model pretrained on the ImageNet dataset to extract image features</strong>]
and denote the model instance as <code>pretrained_net</code>.
The last few layers of this model
include a global average pooling layer
and a fully connected layer:
they are not needed
in the fully convolutional network.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
pretrained_net = gluon.model_zoo.vision.resnet18_v2(pretrained=True)
pretrained_net.features[-3:], pretrained_net.output
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
pretrained_net = torchvision.models.resnet18(pretrained=True)
list(pretrained_net.children())[-3:]
</code></pre>
<p>Next, we [<strong>create the fully convolutional network instance <code>net</code></strong>].
It copies all the pretrained layers in the ResNet-18
except for the final global average pooling layer
and the fully connected layer that are closest
to the output.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = nn.HybridSequential()
for layer in pretrained_net.features[:-2]:
    net.add(layer)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = nn.Sequential(*list(pretrained_net.children())[:-2])
</code></pre>
<p>Given an input with height and width of 320 and 480 respectively,
the forward propagation of <code>net</code>
reduces the input height and width to 1/32 of the original, namely 10 and 15.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
X = np.random.uniform(size=(1, 3, 320, 480))
net(X).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X = torch.rand(size=(1, 3, 320, 480))
net(X).shape
</code></pre>
<p>Next, we [<strong>use a $1\times 1$ convolutional layer to transform the number of output channels into the number of classes (21) of the Pascal VOC2012 dataset.</strong>]
Finally, we need to (<strong>increase the height and width of the feature maps by 32 times</strong>) to change them back to the height and width of the input image.
Recall how to calculate
the output shape of a convolutional layer in :numref:<code>sec_padding</code>.
Since $(320-64+16\times2+32)/32=10$ and $(480-64+16\times2+32)/32=15$, we construct a transposed convolutional layer with stride of $32$,
setting
the height and width of the kernel
to $64$, the padding to $16$.
In general,
we can see that
for stride $s$,
padding $s/2$ (assuming $s/2$ is an integer),
and the height and width of the kernel $2s$,
the transposed convolution will increase
the height and width of the input by $s$ times.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
num_classes = 21
net.add(nn.Conv2D(num_classes, kernel_size=1),
        nn.Conv2DTranspose(
            num_classes, kernel_size=64, padding=16, strides=32))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
num_classes = 21
net.add_module('final_conv', nn.Conv2d(512, num_classes, kernel_size=1))
net.add_module('transpose_conv', nn.ConvTranspose2d(num_classes, num_classes,
                                    kernel_size=64, padding=16, stride=32))
</code></pre>
<h2 id="initializing-transposed-convolutional-layers"><a class="header" href="#initializing-transposed-convolutional-layers">[<strong>Initializing Transposed Convolutional Layers</strong>]</a></h2>
<p>We already know that
transposed convolutional layers can increase
the height and width of
feature maps.
In image processing, we may need to scale up
an image, i.e., <em>upsampling</em>.
<em>Bilinear interpolation</em>
is one of the commonly used upsampling techniques.
It is also often used for initializing transposed convolutional layers.</p>
<p>To explain bilinear interpolation,
say that
given an input image
we want to
calculate each pixel
of the upsampled output image.
In order to calculate the pixel of the output image
at coordinate $(x, y)$,
first map $(x, y)$ to coordinate $(x', y')$ on the input image, for example, according to the ratio of the input size to the output size.
Note that the mapped $x'$ and $y'$ are real numbers.
Then, find the four pixels closest to coordinate
$(x', y')$ on the input image.
Finally, the pixel of the output image at coordinate $(x, y)$ is calculated based on these four closest pixels
on the input image and their relative distance from $(x', y')$.</p>
<p>Upsampling of bilinear interpolation
can be implemented by the transposed convolutional layer
with the kernel constructed by the following <code>bilinear_kernel</code> function.
Due to space limitations, we only provide the implementation of the <code>bilinear_kernel</code> function below
without discussions on its algorithm design.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def bilinear_kernel(in_channels, out_channels, kernel_size):
    factor = (kernel_size + 1) // 2
    if kernel_size % 2 == 1:
        center = factor - 1
    else:
        center = factor - 0.5
    og = (np.arange(kernel_size).reshape(-1, 1),
          np.arange(kernel_size).reshape(1, -1))
    filt = (1 - np.abs(og[0] - center) / factor) * \
           (1 - np.abs(og[1] - center) / factor)
    weight = np.zeros((in_channels, out_channels, kernel_size, kernel_size))
    weight[range(in_channels), range(out_channels), :, :] = filt
    return np.array(weight)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def bilinear_kernel(in_channels, out_channels, kernel_size):
    factor = (kernel_size + 1) // 2
    if kernel_size % 2 == 1:
        center = factor - 1
    else:
        center = factor - 0.5
    og = (torch.arange(kernel_size).reshape(-1, 1),
          torch.arange(kernel_size).reshape(1, -1))
    filt = (1 - torch.abs(og[0] - center) / factor) * \
           (1 - torch.abs(og[1] - center) / factor)
    weight = torch.zeros((in_channels, out_channels,
                          kernel_size, kernel_size))
    weight[range(in_channels), range(out_channels), :, :] = filt
    return weight
</code></pre>
<p>Let's [<strong>experiment with upsampling of bilinear interpolation</strong>]
that is implemented by a transposed convolutional layer.
We construct a transposed convolutional layer that
doubles the height and weight,
and initialize its kernel with the <code>bilinear_kernel</code> function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
conv_trans = nn.Conv2DTranspose(3, kernel_size=4, padding=1, strides=2)
conv_trans.initialize(init.Constant(bilinear_kernel(3, 3, 4)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
conv_trans = nn.ConvTranspose2d(3, 3, kernel_size=4, padding=1, stride=2,
                                bias=False)
conv_trans.weight.data.copy_(bilinear_kernel(3, 3, 4));
</code></pre>
<p>Read the image <code>X</code> and assign the upsampling output to <code>Y</code>. In order to print the image, we need to adjust the position of the channel dimension.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
img = image.imread('../img/catdog.jpg')
X = np.expand_dims(img.astype('float32').transpose(2, 0, 1), axis=0) / 255
Y = conv_trans(X)
out_img = Y[0].transpose(1, 2, 0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
img = torchvision.transforms.ToTensor()(d2l.Image.open('../img/catdog.jpg'))
X = img.unsqueeze(0)
Y = conv_trans(X)
out_img = Y[0].permute(1, 2, 0).detach()
</code></pre>
<p>As we can see, the transposed convolutional layer increases both the height and width of the image by a factor of two.
Except for the different scales in coordinates,
the image scaled up by bilinear interpolation and the original image printed in :numref:<code>sec_bbox</code> look the same.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.set_figsize()
print('input image shape:', img.shape)
d2l.plt.imshow(img.asnumpy());
print('output image shape:', out_img.shape)
d2l.plt.imshow(out_img.asnumpy());
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
d2l.set_figsize()
print('input image shape:', img.permute(1, 2, 0).shape)
d2l.plt.imshow(img.permute(1, 2, 0));
print('output image shape:', out_img.shape)
d2l.plt.imshow(out_img);
</code></pre>
<p>In a fully convolutional network, we [<strong>initialize the transposed convolutional layer with upsampling of bilinear interpolation. For the $1\times 1$ convolutional layer, we use Xavier initialization.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab mxnet
W = bilinear_kernel(num_classes, num_classes, 64)
net[-1].initialize(init.Constant(W))
net[-2].initialize(init=init.Xavier())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
W = bilinear_kernel(num_classes, num_classes, 64)
net.transpose_conv.weight.data.copy_(W);
</code></pre>
<h2 id="reading-the-dataset-8"><a class="header" href="#reading-the-dataset-8">[<strong>Reading the Dataset</strong>]</a></h2>
<p>We read
the semantic segmentation dataset
as introduced in :numref:<code>sec_semantic_segmentation</code>.
The output image shape of random cropping is
specified as $320\times 480$: both the height and width are divisible by $32$.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size, crop_size = 32, (320, 480)
train_iter, test_iter = d2l.load_data_voc(batch_size, crop_size)
</code></pre>
<h2 id="training-26"><a class="header" href="#training-26">[<strong>Training</strong>]</a></h2>
<p>Now we can train our constructed
fully convolutional network.
The loss function and accuracy calculation here
are not essentially different from those in image classification of earlier chapters.
Because we use the output channel of the
transposed convolutional layer to
predict the class for each pixel,
the channel dimension is specified in the loss calculation.
In addition, the accuracy is calculated
based on correctness
of the predicted class for all the pixels.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
num_epochs, lr, wd, devices = 5, 0.1, 1e-3, d2l.try_all_gpus()
loss = gluon.loss.SoftmaxCrossEntropyLoss(axis=1)
net.collect_params().reset_ctx(devices)
trainer = gluon.Trainer(net.collect_params(), 'sgd',
                        {'learning_rate': lr, 'wd': wd})
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def loss(inputs, targets):
    return F.cross_entropy(inputs, targets, reduction='none').mean(1).mean(1)

num_epochs, lr, wd, devices = 5, 0.001, 1e-3, d2l.try_all_gpus()
trainer = torch.optim.SGD(net.parameters(), lr=lr, weight_decay=wd)
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<h2 id="prediction-4"><a class="header" href="#prediction-4">[<strong>Prediction</strong>]</a></h2>
<p>When predicting, we need to standardize the input image
in each channel and transform the image into the four-dimensional input format required by the CNN.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def predict(img):
    X = test_iter._dataset.normalize_image(img)
    X = np.expand_dims(X.transpose(2, 0, 1), axis=0)
    pred = net(X.as_in_ctx(devices[0])).argmax(axis=1)
    return pred.reshape(pred.shape[1], pred.shape[2])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def predict(img):
    X = test_iter.dataset.normalize_image(img).unsqueeze(0)
    pred = net(X.to(devices[0])).argmax(dim=1)
    return pred.reshape(pred.shape[1], pred.shape[2])
</code></pre>
<p>To [<strong>visualize the predicted class</strong>] of each pixel, we map the predicted class back to its label color in the dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def label2image(pred):
    colormap = np.array(d2l.VOC_COLORMAP, ctx=devices[0], dtype='uint8')
    X = pred.astype('int32')
    return colormap[X, :]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def label2image(pred):
    colormap = torch.tensor(d2l.VOC_COLORMAP, device=devices[0])
    X = pred.long()
    return colormap[X, :]
</code></pre>
<p>Images in the test dataset vary in size and shape.
Since the model uses a transposed convolutional layer with stride of 32,
when the height or width of an input image is indivisible by 32,
the output height or width of the
transposed convolutional layer will deviate from the shape of the input image.
In order to address this issue,
we can crop multiple rectangular areas with height and width that are integer multiples of 32 in the image,
and perform forward propagation
on the pixels in these areas separately.
Note that
the union of these rectangular areas needs to completely cover the input image.
When a pixel is covered by multiple rectangular areas,
the average of the transposed convolution outputs
in separate areas for this same pixel
can be input to
the softmax operation
to predict the class.</p>
<p>For simplicity, we only read a few larger test images,
and crop a $320\times480$ area for prediction starting from the upper-left corner of an image.
For these test images, we
print their cropped areas,
prediction results,
and ground-truth row by row.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012')
test_images, test_labels = d2l.read_voc_images(voc_dir, False)
n, imgs = 4, []
for i in range(n):
    crop_rect = (0, 0, 480, 320)
    X = image.fixed_crop(test_images[i], *crop_rect)
    pred = label2image(predict(X))
    imgs += [X, pred, image.fixed_crop(test_labels[i], *crop_rect)]
d2l.show_images(imgs[::3] + imgs[1::3] + imgs[2::3], 3, n, scale=2);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012')
test_images, test_labels = d2l.read_voc_images(voc_dir, False)
n, imgs = 4, []
for i in range(n):
    crop_rect = (0, 0, 320, 480)
    X = torchvision.transforms.functional.crop(test_images[i], *crop_rect)
    pred = label2image(predict(X))
    imgs += [X.permute(1,2,0), pred.cpu(),
             torchvision.transforms.functional.crop(
                 test_labels[i], *crop_rect).permute(1,2,0)]
d2l.show_images(imgs[::3] + imgs[1::3] + imgs[2::3], 3, n, scale=2);
</code></pre>
<h2 id="summary-82"><a class="header" href="#summary-82">Summary</a></h2>
<ul>
<li>The fully convolutional network first uses a CNN to extract image features, then transforms the number of channels into the number of classes via a $1\times 1$ convolutional layer, and finally transforms the height and width of the feature maps to those of the input image via the transposed convolution.</li>
<li>In a fully convolutional network, we can use upsampling of bilinear interpolation to initialize the transposed convolutional layer.</li>
</ul>
<h2 id="exercises-102"><a class="header" href="#exercises-102">Exercises</a></h2>
<ol>
<li>If we use Xavier initialization for the transposed convolutional layer in the experiment, how does the result change?</li>
<li>Can you further improve the accuracy of the model by tuning the hyperparameters?</li>
<li>Predict the classes of all pixels in test images.</li>
<li>The original fully convolutional network paper also uses outputs of some intermediate CNN layers :cite:<code>Long.Shelhamer.Darrell.2015</code>. Try to implement this idea.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/377">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1582">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neural-style-transfer"><a class="header" href="#neural-style-transfer">Neural Style Transfer</a></h1>
<p>If you are a photography enthusiast,
you may be familiar with the filter.
It can change the color style of photos
so that landscape photos become sharper
or portrait photos have whitened skins.
However,
one filter usually only changes
one aspect of the photo.
To apply an ideal style
to a photo,
you probably need to
try many different filter combinations.
This process is
as complex as tuning the hyperparameters of a model.</p>
<p>In this section, we will
leverage layerwise representations of a CNN
to automatically apply the style of one image
to another image, i.e., <em>style transfer</em> :cite:<code>Gatys.Ecker.Bethge.2016</code>.
This task needs two input images:
one is the <em>content image</em> and
the other is the <em>style image</em>.
We will use neural networks
to modify the content image
to make it close to the style image in style.
For example,
the content image in :numref:<code>fig_style_transfer</code> is a landscape photo taken by us
in Mount Rainier National Park in the suburbs of Seattle, while the style image is an oil painting
with the theme of autumn oak trees.
In the output synthesized image,
the oil brush strokes of the style image
are applied, leading to more vivid colors,
while preserving the main shape of the objects
in the content image.</p>
<p><img src="chapter_computer-vision/../img/style-transfer.svg" alt="Given content and style images, style transfer outputs a synthesized image." />
:label:<code>fig_style_transfer</code></p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>:numref:<code>fig_style_transfer_model</code> illustrates
the CNN-based style transfer method with a simplified example.
First, we initialize the synthesized image,
for example, into the content image.
This synthesized image is the only variable that needs to be updated during the style transfer process,
i.e., the model parameters to be updated during training.
Then we choose a pretrained CNN
to extract image features and freeze its
model parameters during training.
This deep CNN uses multiple layers
to extract
hierarchical features for images.
We can choose the output of some of these layers as content features or style features.
Take :numref:<code>fig_style_transfer_model</code> as an example.
The pretrained neural network here has 3 convolutional layers,
where the second layer outputs the content features,
and the first and third layers output the style features.</p>
<p><img src="chapter_computer-vision/../img/neural-style.svg" alt="CNN-based style transfer process. Solid lines show the direction of forward propagation and dotted lines show backward propagation. " />
:label:<code>fig_style_transfer_model</code></p>
<p>Next, we calculate the loss function of style transfer through forward propagation (direction of solid arrows), and update the model parameters (the synthesized image for output) through backpropagation (direction of dashed arrows).
The loss function commonly used in style transfer consists of three parts:
(i) <em>content loss</em> makes the synthesized image and the content image close in content features;
(ii) <em>style loss</em> makes the synthesized image and style image close in style features;
and (iii) <em>total variation loss</em> helps to reduce the noise in the synthesized image.
Finally, when the model training is over, we output the model parameters of the style transfer to generate
the final synthesized image.</p>
<p>In the following,
we will explain the technical details of style transfer via a concrete experiment.</p>
<h2 id="reading-the-content-and-style-images"><a class="header" href="#reading-the-content-and-style-images">[<strong>Reading the Content and Style Images</strong>]</a></h2>
<p>First, we read the content and style images.
From their printed coordinate axes,
we can tell that these images have different sizes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, image, init, np, npx
from mxnet.gluon import nn

npx.set_np()

d2l.set_figsize()
content_img = image.imread('../img/rainier.jpg')
d2l.plt.imshow(content_img.asnumpy());
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
import torchvision
from torch import nn

d2l.set_figsize()
content_img = d2l.Image.open('../img/rainier.jpg')
d2l.plt.imshow(content_img);
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
style_img = image.imread('../img/autumn-oak.jpg')
d2l.plt.imshow(style_img.asnumpy());
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
style_img = d2l.Image.open('../img/autumn-oak.jpg')
d2l.plt.imshow(style_img);
</code></pre>
<h2 id="preprocessing-and-postprocessing"><a class="header" href="#preprocessing-and-postprocessing">[<strong>Preprocessing and Postprocessing</strong>]</a></h2>
<p>Below, we define two functions for preprocessing and postprocessing images.
The <code>preprocess</code> function standardizes
each of the three RGB channels of the input image and transforms the results into the CNN input format.
The <code>postprocess</code> function restores the pixel values in the output image to their original values before standardization.
Since the image printing function requires that each pixel has a floating point value from 0 to 1,
we replace any value smaller than 0 or greater than 1 with 0 or 1, respectively.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
rgb_mean = np.array([0.485, 0.456, 0.406])
rgb_std = np.array([0.229, 0.224, 0.225])

def preprocess(img, image_shape):
    img = image.imresize(img, *image_shape)
    img = (img.astype('float32') / 255 - rgb_mean) / rgb_std
    return np.expand_dims(img.transpose(2, 0, 1), axis=0)

def postprocess(img):
    img = img[0].as_in_ctx(rgb_std.ctx)
    return (img.transpose(1, 2, 0) * rgb_std + rgb_mean).clip(0, 1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
rgb_mean = torch.tensor([0.485, 0.456, 0.406])
rgb_std = torch.tensor([0.229, 0.224, 0.225])

def preprocess(img, image_shape):
    transforms = torchvision.transforms.Compose([
        torchvision.transforms.Resize(image_shape),
        torchvision.transforms.ToTensor(),
        torchvision.transforms.Normalize(mean=rgb_mean, std=rgb_std)])
    return transforms(img).unsqueeze(0)

def postprocess(img):
    img = img[0].to(rgb_std.device)
    img = torch.clamp(img.permute(1, 2, 0) * rgb_std + rgb_mean, 0, 1)
    return torchvision.transforms.ToPILImage()(img.permute(2, 0, 1))
</code></pre>
<h2 id="extracting-features"><a class="header" href="#extracting-features">[<strong>Extracting Features</strong>]</a></h2>
<p>We use the VGG-19 model pretrained on the ImageNet dataset to extract image features :cite:<code>Gatys.Ecker.Bethge.2016</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
pretrained_net = gluon.model_zoo.vision.vgg19(pretrained=True)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
pretrained_net = torchvision.models.vgg19(pretrained=True)
</code></pre>
<p>In order to extract the content features and style features of the image, we can select the output of certain layers in the VGG network.
Generally speaking, the closer to the input layer, the easier to extract details of the image, and vice versa, the easier to extract the global information of the image. In order to avoid excessively
retaining the details of the content image in the synthesized image,
we choose a VGG layer that is closer to the output as the <em>content layer</em> to output the content features of the image.
We also select the output of different VGG layers for extracting local and global style features.
These layers are also called <em>style layers</em>.
As mentioned in :numref:<code>sec_vgg</code>,
the VGG network uses 5 convolutional blocks.
In the experiment, we choose the last convolutional layer of the fourth convolutional block as the content layer, and the first convolutional layer of each convolutional block as the style layer.
The indices of these layers can be obtained by printing the <code>pretrained_net</code> instance.</p>
<pre><code class="language-{.python .input}">#@tab all
style_layers, content_layers = [0, 5, 10, 19, 28], [25]
</code></pre>
<p>When extracting features using VGG layers,
we only need to use all those
from the input layer to the content layer or style layer that is closest to the output layer.
Let's construct a new network instance <code>net</code>, which only retains all the VGG layers to be
used for feature extraction.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = nn.Sequential()
for i in range(max(content_layers + style_layers) + 1):
    net.add(pretrained_net.features[i])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = nn.Sequential(*[pretrained_net.features[i] for i in
                      range(max(content_layers + style_layers) + 1)])
</code></pre>
<p>Given the input <code>X</code>, if we simply invoke
the forward propagation <code>net(X)</code>, we can only get the output of the last layer.
Since we also need the outputs of intermediate layers,
we need to perform layer-by-layer computation and keep
the content and style layer outputs.</p>
<pre><code class="language-{.python .input}">#@tab all
def extract_features(X, content_layers, style_layers):
    contents = []
    styles = []
    for i in range(len(net)):
        X = net[i](X)
        if i in style_layers:
            styles.append(X)
        if i in content_layers:
            contents.append(X)
    return contents, styles
</code></pre>
<p>Two functions are defined below:
the <code>get_contents</code> function extracts content features from the content image,
and the <code>get_styles</code> function extracts style features from the style image.
Since there is no need to update the model parameters of the pretrained VGG during training,
we can extract the content and the style features
even before the training starts.
Since the synthesized image
is a set of model parameters to be updated
for style transfer,
we can only extract the content and style features of the synthesized image by calling the <code>extract_features</code> function during training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_contents(image_shape, device):
    content_X = preprocess(content_img, image_shape).copyto(device)
    contents_Y, _ = extract_features(content_X, content_layers, style_layers)
    return content_X, contents_Y

def get_styles(image_shape, device):
    style_X = preprocess(style_img, image_shape).copyto(device)
    _, styles_Y = extract_features(style_X, content_layers, style_layers)
    return style_X, styles_Y
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_contents(image_shape, device):
    content_X = preprocess(content_img, image_shape).to(device)
    contents_Y, _ = extract_features(content_X, content_layers, style_layers)
    return content_X, contents_Y

def get_styles(image_shape, device):
    style_X = preprocess(style_img, image_shape).to(device)
    _, styles_Y = extract_features(style_X, content_layers, style_layers)
    return style_X, styles_Y
</code></pre>
<h2 id="defining-the-loss-function-2"><a class="header" href="#defining-the-loss-function-2">[<strong>Defining the Loss Function</strong>]</a></h2>
<p>Now we will describe the loss function for style transfer. The loss function consists of
the content loss, style loss, and total variation loss.</p>
<h3 id="content-loss"><a class="header" href="#content-loss">Content Loss</a></h3>
<p>Similar to the loss function in linear regression,
the content loss measures the difference
in content features
between the synthesized image and the content image via
the squared loss function.
The two inputs of the squared loss function
are both
outputs of the content layer computed by the <code>extract_features</code> function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def content_loss(Y_hat, Y):
    return np.square(Y_hat - Y).mean()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def content_loss(Y_hat, Y):
    # We detach the target content from the tree used to dynamically compute
    # the gradient: this is a stated value, not a variable. Otherwise the loss
    # will throw an error.
    return torch.square(Y_hat - Y.detach()).mean()
</code></pre>
<h3 id="style-loss"><a class="header" href="#style-loss">Style Loss</a></h3>
<p>Style loss, similar to content loss,
also uses the squared loss function to measure the difference in style between the synthesized image and the style image.
To express the style output of any style layer,
we first use the <code>extract_features</code> function to
compute the style layer output.
Suppose that the output has
1 example, $c$ channels,
height $h$, and width $w$,
we can transform this output into
matrix $\mathbf{X}$ with $c$ rows and $hw$ columns.
This matrix can be thought of as
the concatenation of
$c$ vectors $\mathbf{x}_1, \ldots, \mathbf{x}_c$,
each of which has a length of $hw$.
Here, vector $\mathbf{x}_i$ represents the style feature of channel $i$.</p>
<p>In the <em>Gram matrix</em> of these vectors $\mathbf{X}\mathbf{X}^\top \in \mathbb{R}^{c \times c}$, element $x_{ij}$ in row $i$ and column $j$ is the dot product of vectors $\mathbf{x}_i$ and $\mathbf{x}_j$.
It represents the correlation of the style features of channels $i$ and $j$.
We use this Gram matrix to represent the style output of any style layer.
Note that when the value of $hw$ is larger,
it likely leads to larger values in the Gram matrix.
Note also that the height and width of the Gram matrix are both the number of channels $c$.
To allow style loss not to be affected
by these values,
the <code>gram</code> function below divides
the Gram matrix by the number of its elements, i.e., $chw$.</p>
<pre><code class="language-{.python .input}">#@tab all
def gram(X):
    num_channels, n = X.shape[1], d2l.size(X) // X.shape[1]
    X = d2l.reshape(X, (num_channels, n))
    return d2l.matmul(X, X.T) / (num_channels * n)
</code></pre>
<p>Obviously,
the two Gram matrix inputs of the squared loss function for style loss are based on
the style layer outputs for
the synthesized image and the style image.
It is assumed here that the Gram matrix <code>gram_Y</code> based on the style image has been precomputed.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def style_loss(Y_hat, gram_Y):
    return np.square(gram(Y_hat) - gram_Y).mean()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def style_loss(Y_hat, gram_Y):
    return torch.square(gram(Y_hat) - gram_Y.detach()).mean()
</code></pre>
<h3 id="total-variation-loss"><a class="header" href="#total-variation-loss">Total Variation Loss</a></h3>
<p>Sometimes, the learned synthesized image
has a lot of high-frequency noise,
i.e., particularly bright or dark pixels.
One common noise reduction method is
<em>total variation denoising</em>.
Denote by $x_{i, j}$ the pixel value at coordinate $(i, j)$.
Reducing total variation loss</p>
<p>$$\sum_{i, j} \left|x_{i, j} - x_{i+1, j}\right| + \left|x_{i, j} - x_{i, j+1}\right|$$</p>
<p>makes values of neighboring pixels on the synthesized image closer.</p>
<pre><code class="language-{.python .input}">#@tab all
def tv_loss(Y_hat):
    return 0.5 * (d2l.abs(Y_hat[:, :, 1:, :] - Y_hat[:, :, :-1, :]).mean() +
                  d2l.abs(Y_hat[:, :, :, 1:] - Y_hat[:, :, :, :-1]).mean())
</code></pre>
<h3 id="loss-function-2"><a class="header" href="#loss-function-2">Loss Function</a></h3>
<p>[<strong>The loss function of style transfer is the weighted sum of content loss, style loss, and total variation loss</strong>].
By adjusting these weight hyperparameters,
we can balance among
content retention,
style transfer,
and noise reduction on the synthesized image.</p>
<pre><code class="language-{.python .input}">#@tab all
content_weight, style_weight, tv_weight = 1, 1e4, 10

def compute_loss(X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram):
    # Calculate the content, style, and total variance losses respectively
    contents_l = [content_loss(Y_hat, Y) * content_weight for Y_hat, Y in zip(
        contents_Y_hat, contents_Y)]
    styles_l = [style_loss(Y_hat, Y) * style_weight for Y_hat, Y in zip(
        styles_Y_hat, styles_Y_gram)]
    tv_l = tv_loss(X) * tv_weight
    # Add up all the losses
    l = sum(styles_l + contents_l + [tv_l])
    return contents_l, styles_l, tv_l, l
</code></pre>
<h2 id="initializing-the-synthesized-image"><a class="header" href="#initializing-the-synthesized-image">[<strong>Initializing the Synthesized Image</strong>]</a></h2>
<p>In style transfer,
the synthesized image is the only variable that needs to be updated during training.
Thus, we can define a simple model, <code>SynthesizedImage</code>, and treat the synthesized image as the model parameters.
In this model, forward propagation just returns the model parameters.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class SynthesizedImage(nn.Block):
    def __init__(self, img_shape, **kwargs):
        super(SynthesizedImage, self).__init__(**kwargs)
        self.weight = self.params.get('weight', shape=img_shape)

    def forward(self):
        return self.weight.data()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class SynthesizedImage(nn.Module):
    def __init__(self, img_shape, **kwargs):
        super(SynthesizedImage, self).__init__(**kwargs)
        self.weight = nn.Parameter(torch.rand(*img_shape))

    def forward(self):
        return self.weight
</code></pre>
<p>Next, we define the <code>get_inits</code> function.
This function creates a synthesized image model instance and initializes it to the image <code>X</code>.
Gram matrices for the style image at various style layers, <code>styles_Y_gram</code>, are computed prior to training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_inits(X, device, lr, styles_Y):
    gen_img = SynthesizedImage(X.shape)
    gen_img.initialize(init.Constant(X), ctx=device, force_reinit=True)
    trainer = gluon.Trainer(gen_img.collect_params(), 'adam',
                            {'learning_rate': lr})
    styles_Y_gram = [gram(Y) for Y in styles_Y]
    return gen_img(), styles_Y_gram, trainer
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_inits(X, device, lr, styles_Y):
    gen_img = SynthesizedImage(X.shape).to(device)
    gen_img.weight.data.copy_(X.data)
    trainer = torch.optim.Adam(gen_img.parameters(), lr=lr)
    styles_Y_gram = [gram(Y) for Y in styles_Y]
    return gen_img(), styles_Y_gram, trainer
</code></pre>
<h2 id="training-27"><a class="header" href="#training-27">[<strong>Training</strong>]</a></h2>
<p>When training the model for style transfer,
we continuously extract
content features and style features of the synthesized image, and calculate the loss function.
Below defines the training loop.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(X, contents_Y, styles_Y, device, lr, num_epochs, lr_decay_epoch):
    X, styles_Y_gram, trainer = get_inits(X, device, lr, styles_Y)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[10, num_epochs], ylim=[0, 20],
                            legend=['content', 'style', 'TV'],
                            ncols=2, figsize=(7, 2.5))
    for epoch in range(num_epochs):
        with autograd.record():
            contents_Y_hat, styles_Y_hat = extract_features(
                X, content_layers, style_layers)
            contents_l, styles_l, tv_l, l = compute_loss(
                X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)
        l.backward()
        trainer.step(1)
        if (epoch + 1) % lr_decay_epoch == 0:
            trainer.set_learning_rate(trainer.learning_rate * 0.8)
        if (epoch + 1) % 10 == 0:
            animator.axes[1].imshow(postprocess(X).asnumpy())
            animator.add(epoch + 1, [float(sum(contents_l)),
                                     float(sum(styles_l)), float(tv_l)])
    return X
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(X, contents_Y, styles_Y, device, lr, num_epochs, lr_decay_epoch):
    X, styles_Y_gram, trainer = get_inits(X, device, lr, styles_Y)
    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_decay_epoch, 0.8)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[10, num_epochs],
                            legend=['content', 'style', 'TV'],
                            ncols=2, figsize=(7, 2.5))
    for epoch in range(num_epochs):
        trainer.zero_grad()
        contents_Y_hat, styles_Y_hat = extract_features(
            X, content_layers, style_layers)
        contents_l, styles_l, tv_l, l = compute_loss(
            X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)
        l.backward()
        trainer.step()
        scheduler.step()
        if (epoch + 1) % 10 == 0:
            animator.axes[1].imshow(postprocess(X))
            animator.add(epoch + 1, [float(sum(contents_l)),
                                     float(sum(styles_l)), float(tv_l)])
    return X
</code></pre>
<p>Now we [<strong>start to train the model</strong>].
We rescale the height and width of the content and style images to 300 by 450 pixels.
We use the content image to initialize the synthesized image.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
device, image_shape = d2l.try_gpu(), (450, 300)
net.collect_params().reset_ctx(device)
content_X, contents_Y = get_contents(image_shape, device)
_, styles_Y = get_styles(image_shape, device)
output = train(content_X, contents_Y, styles_Y, device, 0.9, 500, 50)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
device, image_shape = d2l.try_gpu(), (300, 450)  # PIL Image (h, w)
net = net.to(device)
content_X, contents_Y = get_contents(image_shape, device)
_, styles_Y = get_styles(image_shape, device)
output = train(content_X, contents_Y, styles_Y, device, 0.3, 500, 50)
</code></pre>
<p>We can see that the synthesized image
retains the scenery and objects of the content image,
and transfers the color of the style image
at the same time.
For example,
the synthesized image has blocks of color like
those in the style image.
Some of these blocks even have the subtle texture of brush strokes.</p>
<h2 id="summary-83"><a class="header" href="#summary-83">Summary</a></h2>
<ul>
<li>The loss function commonly used in style transfer consists of three parts: (i) content loss makes the synthesized image and the content image close in content features; (ii) style loss makes the synthesized image and style image close in style features; and (iii) total variation loss helps to reduce the noise in the synthesized image.</li>
<li>We can use a pretrained CNN to extract image features and minimize the loss function to continuously update the synthesized image as model parameters during training.</li>
<li>We use Gram matrices to represent the style outputs from the style layers.</li>
</ul>
<h2 id="exercises-103"><a class="header" href="#exercises-103">Exercises</a></h2>
<ol>
<li>How does the output change when you select different content and style layers?</li>
<li>Adjust the weight hyperparameters in the loss function. Does the output retain more content or have less noise?</li>
<li>Use different content and style images. Can you create more interesting synthesized images?</li>
<li>Can we apply style transfer for text? Hint: you may refer to the survey paper by :citet:<code>10.1145/3544903.3544906</code>.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/378">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1476">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-classification-cifar-10-on-kaggle"><a class="header" href="#image-classification-cifar-10-on-kaggle">Image Classification (CIFAR-10) on Kaggle</a></h1>
<p>:label:<code>sec_kaggle_cifar10</code></p>
<p>So far, we have been using high-level APIs of deep learning frameworks to directly obtain image datasets in tensor format.
However, custom image datasets
often come in the form of image files.
In this section, we will start from
raw image files,
and organize, read, then transform them
into tensor format step by step.</p>
<p>We experimented with the CIFAR-10 dataset in :numref:<code>sec_image_augmentation</code>,
which is an important dataset in computer vision.
In this section,
we will apply the knowledge we learned
in previous sections
to practice the Kaggle competition of
CIFAR-10 image classification.
(<strong>The web address of the competition is https://www.kaggle.com/c/cifar-10</strong>)</p>
<p>:numref:<code>fig_kaggle_cifar10</code> shows the information on the competition's webpage.
In order to submit the results,
you need to register a Kaggle account.</p>
<p><img src="chapter_computer-vision/../img/kaggle-cifar10.png" alt="CIFAR-10 image classification competition webpage information. The competition dataset can be obtained by clicking the &quot;Data&quot; tab." />
:width:<code>600px</code>
:label:<code>fig_kaggle_cifar10</code></p>
<pre><code class="language-{.python .input}">#@tab mxnet
import collections
from d2l import mxnet as d2l
import math
from mxnet import gluon, init, npx
from mxnet.gluon import nn
import os
import pandas as pd
import shutil

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
import collections
from d2l import torch as d2l
import math
import torch
import torchvision
from torch import nn
import os
import pandas as pd
import shutil
</code></pre>
<h2 id="obtaining-and-organizing-the-dataset"><a class="header" href="#obtaining-and-organizing-the-dataset">Obtaining and Organizing the Dataset</a></h2>
<p>The competition dataset is divided into
a training set and a test set,
which contain 50000 and 300000 images, respectively.
In the test set,
10000 images will be used for evaluation,
while the remaining 290000 images will not
be evaluated:
they are included just
to make it hard
to cheat with
<em>manually</em> labeled results of the test set.
The images in this dataset
are all png color (RGB channels) image files,
whose height and width are both 32 pixels.
The images cover a total of 10 categories, namely airplanes, cars, birds, cats, deer, dogs, frogs, horses, boats, and trucks.
The upper-left corner of :numref:<code>fig_kaggle_cifar10</code> shows some images of airplanes, cars, and birds in the dataset.</p>
<h3 id="downloading-the-dataset-1"><a class="header" href="#downloading-the-dataset-1">Downloading the Dataset</a></h3>
<p>After logging in to Kaggle, we can click the "Data" tab on the CIFAR-10 image classification competition webpage shown in :numref:<code>fig_kaggle_cifar10</code> and download the dataset by clicking the "Download All" button.
After unzipping the downloaded file in <code>../data</code>, and unzipping <code>train.7z</code> and <code>test.7z</code> inside it, you will find the entire dataset in the following paths:</p>
<ul>
<li><code>../data/cifar-10/train/[1-50000].png</code></li>
<li><code>../data/cifar-10/test/[1-300000].png</code></li>
<li><code>../data/cifar-10/trainLabels.csv</code></li>
<li><code>../data/cifar-10/sampleSubmission.csv</code></li>
</ul>
<p>where the <code>train</code> and <code>test</code> directories contain the training and testing images, respectively, <code>trainLabels.csv</code> provides labels for the training images, and <code>sample_submission.csv</code> is a sample submission file.</p>
<p>To make it easier to get started, [<strong>we provide a small-scale sample of the dataset that
contains the first 1000 training images and 5 random testing images.</strong>]
To use the full dataset of the Kaggle competition, you need to set the following <code>demo</code> variable to <code>False</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['cifar10_tiny'] = (d2l.DATA_URL + 'kaggle_cifar10_tiny.zip',
                                '2068874e4b9a9f0fb07ebe0ad2b29754449ccacd')

# If you use the full dataset downloaded for the Kaggle competition, set
# `demo` to False
demo = True

if demo:
    data_dir = d2l.download_extract('cifar10_tiny')
else:
    data_dir = '../data/cifar-10/'
</code></pre>
<h3 id="organizing-the-dataset"><a class="header" href="#organizing-the-dataset">[<strong>Organizing the Dataset</strong>]</a></h3>
<p>We need to organize datasets to facilitate model training and testing.
Let's first read the labels from the csv file.
The following function returns a dictionary that maps
the non-extension part of the filename to its label.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def read_csv_labels(fname):
    """Read `fname` to return a filename to label dictionary."""
    with open(fname, 'r') as f:
        # Skip the file header line (column name)
        lines = f.readlines()[1:]
    tokens = [l.rstrip().split(',') for l in lines]
    return dict(((name, label) for name, label in tokens))

labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv'))
print('# training examples:', len(labels))
print('# classes:', len(set(labels.values())))
</code></pre>
<p>Next, we define the <code>reorg_train_valid</code> function to [<strong>split the validation set out of the original training set.</strong>]
The argument <code>valid_ratio</code> in this function is the ratio of the number of examples in the validation set to the number of examples in the original training set.
More concretely,
let $n$ be the number of images of the class with the least examples, and $r$ be the ratio.
The validation set will split out
$\max(\lfloor nr\rfloor,1)$ images for each class.
Let's use <code>valid_ratio=0.1</code> as an example. Since the original training set has 50000 images,
there will be 45000 images used for training in the path <code>train_valid_test/train</code>,
while the other 5000 images will be split out
as validation set in the path <code>train_valid_test/valid</code>. After organizing the dataset, images of the same class will be placed under the same folder.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def copyfile(filename, target_dir):
    """Copy a file into a target directory."""
    os.makedirs(target_dir, exist_ok=True)
    shutil.copy(filename, target_dir)

#@save
def reorg_train_valid(data_dir, labels, valid_ratio):
    """Split the validation set out of the original training set."""
    # The number of examples of the class that has the fewest examples in the
    # training dataset
    n = collections.Counter(labels.values()).most_common()[-1][1]
    # The number of examples per class for the validation set
    n_valid_per_label = max(1, math.floor(n * valid_ratio))
    label_count = {}
    for train_file in os.listdir(os.path.join(data_dir, 'train')):
        label = labels[train_file.split('.')[0]]
        fname = os.path.join(data_dir, 'train', train_file)
        copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                     'train_valid', label))
        if label not in label_count or label_count[label] &lt; n_valid_per_label:
            copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                         'valid', label))
            label_count[label] = label_count.get(label, 0) + 1
        else:
            copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                         'train', label))
    return n_valid_per_label
</code></pre>
<p>The <code>reorg_test</code> function below [<strong>organizes the testing set for data loading during prediction.</strong>]</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def reorg_test(data_dir):
    """Organize the testing set for data loading during prediction."""
    for test_file in os.listdir(os.path.join(data_dir, 'test')):
        copyfile(os.path.join(data_dir, 'test', test_file),
                 os.path.join(data_dir, 'train_valid_test', 'test',
                              'unknown'))
</code></pre>
<p>Finally, we use a function to [<strong>invoke</strong>]
the <code>read_csv_labels</code>, <code>reorg_train_valid</code>, and <code>reorg_test</code> (<strong>functions defined above.</strong>)</p>
<pre><code class="language-{.python .input}">#@tab all
def reorg_cifar10_data(data_dir, valid_ratio):
    labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv'))
    reorg_train_valid(data_dir, labels, valid_ratio)
    reorg_test(data_dir)
</code></pre>
<p>Here we only set the batch size to 32 for the small-scale sample of the dataset.
When training and testing
the complete dataset of the Kaggle competition,
<code>batch_size</code> should be set to a larger integer, such as 128.
We split out 10% of the training examples as the validation set for tuning hyperparameters.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size = 32 if demo else 128
valid_ratio = 0.1
reorg_cifar10_data(data_dir, valid_ratio)
</code></pre>
<h2 id="image-augmentation-1"><a class="header" href="#image-augmentation-1">[<strong>Image Augmentation</strong>]</a></h2>
<p>We use image augmentation to address overfitting.
For example, images can be flipped horizontally at random during training.
We can also perform standardization for the three RGB channels of color images. Below lists some of these operations that you can tweak.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
transform_train = gluon.data.vision.transforms.Compose([
    # Scale the image up to a square of 40 pixels in both height and width
    gluon.data.vision.transforms.Resize(40),
    # Randomly crop a square image of 40 pixels in both height and width to
    # produce a small square of 0.64 to 1 times the area of the original
    # image, and then scale it to a square of 32 pixels in both height and
    # width
    gluon.data.vision.transforms.RandomResizedCrop(32, scale=(0.64, 1.0),
                                                   ratio=(1.0, 1.0)),
    gluon.data.vision.transforms.RandomFlipLeftRight(),
    gluon.data.vision.transforms.ToTensor(),
    # Standardize each channel of the image
    gluon.data.vision.transforms.Normalize([0.4914, 0.4822, 0.4465],
                                           [0.2023, 0.1994, 0.2010])])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
transform_train = torchvision.transforms.Compose([
    # Scale the image up to a square of 40 pixels in both height and width
    torchvision.transforms.Resize(40),
    # Randomly crop a square image of 40 pixels in both height and width to
    # produce a small square of 0.64 to 1 times the area of the original
    # image, and then scale it to a square of 32 pixels in both height and
    # width
    torchvision.transforms.RandomResizedCrop(32, scale=(0.64, 1.0),
                                                   ratio=(1.0, 1.0)),
    torchvision.transforms.RandomHorizontalFlip(),
    torchvision.transforms.ToTensor(),
    # Standardize each channel of the image
    torchvision.transforms.Normalize([0.4914, 0.4822, 0.4465],
                                     [0.2023, 0.1994, 0.2010])])
</code></pre>
<p>During testing,
we only perform standardization on images
so as to
remove randomness in the evaluation results.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
transform_test = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.ToTensor(),
    gluon.data.vision.transforms.Normalize([0.4914, 0.4822, 0.4465],
                                           [0.2023, 0.1994, 0.2010])])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
transform_test = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor(),
    torchvision.transforms.Normalize([0.4914, 0.4822, 0.4465],
                                     [0.2023, 0.1994, 0.2010])])
</code></pre>
<h2 id="reading-the-dataset-9"><a class="header" href="#reading-the-dataset-9">Reading the Dataset</a></h2>
<p>Next, we [<strong>read the organized dataset consisting of raw image files</strong>]. Each example includes an image and a label.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_ds, valid_ds, train_valid_ds, test_ds = [
    gluon.data.vision.ImageFolderDataset(
        os.path.join(data_dir, 'train_valid_test', folder))
    for folder in ['train', 'valid', 'train_valid', 'test']]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_ds, train_valid_ds = [torchvision.datasets.ImageFolder(
    os.path.join(data_dir, 'train_valid_test', folder),
    transform=transform_train) for folder in ['train', 'train_valid']]

valid_ds, test_ds = [torchvision.datasets.ImageFolder(
    os.path.join(data_dir, 'train_valid_test', folder),
    transform=transform_test) for folder in ['valid', 'test']]
</code></pre>
<p>During training,
we need to [<strong>specify all the image augmentation operations defined above</strong>].
When the validation set
is used for model evaluation during hyperparameter tuning,
no randomness from image augmentation should be introduced.
Before final prediction,
we train the model on the combined training set and validation set to make full use of all the labeled data.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_iter, train_valid_iter = [gluon.data.DataLoader(
    dataset.transform_first(transform_train), batch_size, shuffle=True,
    last_batch='discard') for dataset in (train_ds, train_valid_ds)]

valid_iter = gluon.data.DataLoader(
    valid_ds.transform_first(transform_test), batch_size, shuffle=False,
    last_batch='discard')

test_iter = gluon.data.DataLoader(
    test_ds.transform_first(transform_test), batch_size, shuffle=False,
    last_batch='keep')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_iter, train_valid_iter = [torch.utils.data.DataLoader(
    dataset, batch_size, shuffle=True, drop_last=True)
    for dataset in (train_ds, train_valid_ds)]

valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=False,
                                         drop_last=True)

test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=False,
                                        drop_last=False)
</code></pre>
<h2 id="defining-the-model-7"><a class="header" href="#defining-the-model-7">Defining the [<strong>Model</strong>]</a></h2>
<p>:begin_tab:<code>mxnet</code>
Here, we build the residual blocks based on the <code>HybridBlock</code> class, which is
slightly different from the implementation described in
:numref:<code>sec_resnet</code>.
This is for improving computational efficiency.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class Residual(nn.HybridBlock):
    def __init__(self, num_channels, use_1x1conv=False, strides=1, **kwargs):
        super(Residual, self).__init__(**kwargs)
        self.conv1 = nn.Conv2D(num_channels, kernel_size=3, padding=1,
                               strides=strides)
        self.conv2 = nn.Conv2D(num_channels, kernel_size=3, padding=1)
        if use_1x1conv:
            self.conv3 = nn.Conv2D(num_channels, kernel_size=1,
                                   strides=strides)
        else:
            self.conv3 = None
        self.bn1 = nn.BatchNorm()
        self.bn2 = nn.BatchNorm()

    def hybrid_forward(self, F, X):
        Y = F.npx.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3:
            X = self.conv3(X)
        return F.npx.relu(Y + X)
</code></pre>
<p>:begin_tab:<code>mxnet</code>
Next, we define the ResNet-18 model.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def resnet18(num_classes):
    net = nn.HybridSequential()
    net.add(nn.Conv2D(64, kernel_size=3, strides=1, padding=1),
            nn.BatchNorm(), nn.Activation('relu'))

    def resnet_block(num_channels, num_residuals, first_block=False):
        blk = nn.HybridSequential()
        for i in range(num_residuals):
            if i == 0 and not first_block:
                blk.add(Residual(num_channels, use_1x1conv=True, strides=2))
            else:
                blk.add(Residual(num_channels))
        return blk

    net.add(resnet_block(64, 2, first_block=True),
            resnet_block(128, 2),
            resnet_block(256, 2),
            resnet_block(512, 2))
    net.add(nn.GlobalAvgPool2D(), nn.Dense(num_classes))
    return net
</code></pre>
<p>:begin_tab:<code>mxnet</code>
We use Xavier initialization described in :numref:<code>subsec_xavier</code> before training begins.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
We define the ResNet-18 model described in
:numref:<code>sec_resnet</code>.
:end_tab:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_net(devices):
    num_classes = 10
    net = resnet18(num_classes)
    net.initialize(ctx=devices, init=init.Xavier())
    return net

loss = gluon.loss.SoftmaxCrossEntropyLoss()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_net():
    num_classes = 10
    net = d2l.resnet18(num_classes, 3)
    return net

loss = nn.CrossEntropyLoss(reduction="none")
</code></pre>
<h2 id="defining-the-training-function"><a class="header" href="#defining-the-training-function">Defining the [<strong>Training Function</strong>]</a></h2>
<p>We will select models and tune hyperparameters according to the model's performance on the validation set.
In the following, we define the model training function <code>train</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
          lr_decay):
    trainer = gluon.Trainer(net.collect_params(), 'sgd',
                            {'learning_rate': lr, 'momentum': 0.9, 'wd': wd})
    num_batches, timer = len(train_iter), d2l.Timer()
    legend = ['train loss', 'train acc']
    if valid_iter is not None:
        legend.append('valid acc')
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=legend)
    for epoch in range(num_epochs):
        metric = d2l.Accumulator(3)
        if epoch &gt; 0 and epoch % lr_period == 0:
            trainer.set_learning_rate(trainer.learning_rate * lr_decay)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            l, acc = d2l.train_batch_ch13(
                net, features, labels.astype('float32'), loss, trainer,
                devices, d2l.split_batch)
            metric.add(l, acc, labels.shape[0])
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[2], metric[1] / metric[2],
                              None))
        if valid_iter is not None:
            valid_acc = d2l.evaluate_accuracy_gpus(net, valid_iter,
                                                   d2l.split_batch)
            animator.add(epoch + 1, (None, None, valid_acc))
    measures = (f'train loss {metric[0] / metric[2]:.3f}, '
                f'train acc {metric[1] / metric[2]:.3f}')
    if valid_iter is not None:
        measures += f', valid acc {valid_acc:.3f}'
    print(measures + f'\n{metric[2] * num_epochs / timer.sum():.1f}'
          f' examples/sec on {str(devices)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
          lr_decay):
    trainer = torch.optim.SGD(net.parameters(), lr=lr, momentum=0.9,
                              weight_decay=wd)
    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay)
    num_batches, timer = len(train_iter), d2l.Timer()
    legend = ['train loss', 'train acc']
    if valid_iter is not None:
        legend.append('valid acc')
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=legend)
    net = nn.DataParallel(net, device_ids=devices).to(devices[0])
    for epoch in range(num_epochs):
        net.train()
        metric = d2l.Accumulator(3)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            l, acc = d2l.train_batch_ch13(net, features, labels,
                                          loss, trainer, devices)
            metric.add(l, acc, labels.shape[0])
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[2], metric[1] / metric[2],
                              None))
        if valid_iter is not None:
            valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter)
            animator.add(epoch + 1, (None, None, valid_acc))
        scheduler.step()
    measures = (f'train loss {metric[0] / metric[2]:.3f}, '
                f'train acc {metric[1] / metric[2]:.3f}')
    if valid_iter is not None:
        measures += f', valid acc {valid_acc:.3f}'
    print(measures + f'\n{metric[2] * num_epochs / timer.sum():.1f}'
          f' examples/sec on {str(devices)}')
</code></pre>
<h2 id="training-and-validating-the-model"><a class="header" href="#training-and-validating-the-model">[<strong>Training and Validating the Model</strong>]</a></h2>
<p>Now, we can train and validate the model.
All the following hyperparameters can be tuned.
For example, we can increase the number of epochs.
When <code>lr_period</code> and <code>lr_decay</code> are set to 4 and 0.9, respectively, the learning rate of the optimization algorithm will be multiplied by 0.9 after every 4 epochs. Just for ease of demonstration,
we only train 20 epochs here.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
devices, num_epochs, lr, wd = d2l.try_all_gpus(), 20, 0.02, 5e-4
lr_period, lr_decay, net = 4, 0.9, get_net(devices)
net.hybridize()
train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
      lr_decay)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
devices, num_epochs, lr, wd = d2l.try_all_gpus(), 20, 2e-4, 5e-4
lr_period, lr_decay, net = 4, 0.9, get_net()
net(next(iter(train_iter))[0])
train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
      lr_decay)
</code></pre>
<h2 id="classifying-the-testing-set-and-submitting-results-on-kaggle"><a class="header" href="#classifying-the-testing-set-and-submitting-results-on-kaggle">[<strong>Classifying the Testing Set</strong>] and Submitting Results on Kaggle</a></h2>
<p>After obtaining a promising model with hyperparameters,
we use all the labeled data (including the validation set) to retrain the model and classify the testing set.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net, preds = get_net(devices), []
net.hybridize()
train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period,
      lr_decay)

for X, _ in test_iter:
    y_hat = net(X.as_in_ctx(devices[0]))
    preds.extend(y_hat.argmax(axis=1).astype(int).asnumpy())
sorted_ids = list(range(1, len(test_ds) + 1))
sorted_ids.sort(key=lambda x: str(x))
df = pd.DataFrame({'id': sorted_ids, 'label': preds})
df['label'] = df['label'].apply(lambda x: train_valid_ds.synsets[x])
df.to_csv('submission.csv', index=False)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net, preds = get_net(), []
net(next(iter(train_valid_iter))[0])
train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period,
      lr_decay)

for X, _ in test_iter:
    y_hat = net(X.to(devices[0]))
    preds.extend(y_hat.argmax(dim=1).type(torch.int32).cpu().numpy())
sorted_ids = list(range(1, len(test_ds) + 1))
sorted_ids.sort(key=lambda x: str(x))
df = pd.DataFrame({'id': sorted_ids, 'label': preds})
df['label'] = df['label'].apply(lambda x: train_valid_ds.classes[x])
df.to_csv('submission.csv', index=False)
</code></pre>
<p>The above code
will generate a <code>submission.csv</code> file,
whose format
meets the requirement of the Kaggle competition.
The method
for submitting results to Kaggle
is similar to that in :numref:<code>sec_kaggle_house</code>.</p>
<h2 id="summary-84"><a class="header" href="#summary-84">Summary</a></h2>
<ul>
<li>We can read datasets containing raw image files after organizing them into the required format.</li>
</ul>
<p>:begin_tab:<code>mxnet</code></p>
<ul>
<li>We can use convolutional neural networks, image augmentation, and hybrid programing in an image classification competition.
:end_tab:</li>
</ul>
<p>:begin_tab:<code>pytorch</code></p>
<ul>
<li>We can use convolutional neural networks and image augmentation in an image classification competition.
:end_tab:</li>
</ul>
<h2 id="exercises-104"><a class="header" href="#exercises-104">Exercises</a></h2>
<ol>
<li>Use the complete CIFAR-10 dataset for this Kaggle competition. Set hyperparameters as <code>batch_size = 128</code>, <code>num_epochs = 100</code>, <code>lr = 0.1</code>, <code>lr_period = 50</code>, and <code>lr_decay = 0.1</code>.  See what accuracy and ranking you can achieve in this competition. Can you further improve them?</li>
<li>What accuracy can you get when not using image augmentation?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/379">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1479">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dog-breed-identification-imagenet-dogs-on-kaggle"><a class="header" href="#dog-breed-identification-imagenet-dogs-on-kaggle">Dog Breed Identification (ImageNet Dogs) on Kaggle</a></h1>
<p>In this section, we will practice
the dog breed identification problem on
Kaggle. (<strong>The web address of this competition is https://www.kaggle.com/c/dog-breed-identification</strong>)</p>
<p>In this competition,
120 different breeds of dogs will be recognized.
In fact,
the dataset for this competition is
a subset of the ImageNet dataset.
Unlike the images in the CIFAR-10 dataset in :numref:<code>sec_kaggle_cifar10</code>,
the images in the ImageNet dataset are both higher and wider in varying dimensions.
:numref:<code>fig_kaggle_dog</code> shows the information on the competition's webpage. You need a Kaggle account
to submit your results.</p>
<p><img src="chapter_computer-vision/../img/kaggle-dog.jpg" alt="The dog breed identification competition website. The competition dataset can be obtained by clicking the &quot;Data&quot; tab." />
:width:<code>400px</code>
:label:<code>fig_kaggle_dog</code></p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, npx
from mxnet.gluon import nn
import os

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
import torchvision
from torch import nn
import os
</code></pre>
<h2 id="obtaining-and-organizing-the-dataset-1"><a class="header" href="#obtaining-and-organizing-the-dataset-1">Obtaining and Organizing the Dataset</a></h2>
<p>The competition dataset is divided into a training set and a test set, which contain 10222 and 10357 JPEG images
of three RGB (color) channels, respectively.
Among the training dataset,
there are 120 breeds of dogs
such as Labradors, Poodles, Dachshunds, Samoyeds, Huskies, Chihuahuas, and Yorkshire Terriers.</p>
<h3 id="downloading-the-dataset-2"><a class="header" href="#downloading-the-dataset-2">Downloading the Dataset</a></h3>
<p>After logging into Kaggle,
you can click on the "Data" tab on the
competition webpage shown in :numref:<code>fig_kaggle_dog</code> and download the dataset by clicking the "Download All" button.
After unzipping the downloaded file in <code>../data</code>, you will find the entire dataset in the following paths:</p>
<ul>
<li>../data/dog-breed-identification/labels.csv</li>
<li>../data/dog-breed-identification/sample_submission.csv</li>
<li>../data/dog-breed-identification/train</li>
<li>../data/dog-breed-identification/test</li>
</ul>
<p>You may have noticed that the above structure is
similar to that of the CIFAR-10 competition in :numref:<code>sec_kaggle_cifar10</code>, where folders <code>train/</code> and <code>test/</code> contain training and testing dog images, respectively, and <code>labels.csv</code> contains
the labels for the training images.
Similarly, to make it easier to get started, [<strong>we provide a small sample of the dataset</strong>] mentioned above: <code>train_valid_test_tiny.zip</code>.
If you are going to use the full dataset for the Kaggle competition, you need to change the <code>demo</code> variable below to <code>False</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['dog_tiny'] = (d2l.DATA_URL + 'kaggle_dog_tiny.zip',
                            '0cb91d09b814ecdc07b50f31f8dcad3e81d6a86d')

# If you use the full dataset downloaded for the Kaggle competition, change
# the variable below to `False`
demo = True
if demo:
    data_dir = d2l.download_extract('dog_tiny')
else:
    data_dir = os.path.join('..', 'data', 'dog-breed-identification')
</code></pre>
<h3 id="organizing-the-dataset-1"><a class="header" href="#organizing-the-dataset-1">[<strong>Organizing the Dataset</strong>]</a></h3>
<p>We can organize the dataset similarly to what we did in :numref:<code>sec_kaggle_cifar10</code>, namely splitting out
a validation set from the original training set, and moving images into subfolders grouped by labels.</p>
<p>The <code>reorg_dog_data</code> function below reads
the training data labels, splits out the validation set, and organizes the training set.</p>
<pre><code class="language-{.python .input}">#@tab all
def reorg_dog_data(data_dir, valid_ratio):
    labels = d2l.read_csv_labels(os.path.join(data_dir, 'labels.csv'))
    d2l.reorg_train_valid(data_dir, labels, valid_ratio)
    d2l.reorg_test(data_dir)


batch_size = 32 if demo else 128
valid_ratio = 0.1
reorg_dog_data(data_dir, valid_ratio)
</code></pre>
<h2 id="image-augmentation-2"><a class="header" href="#image-augmentation-2">[<strong>Image Augmentation</strong>]</a></h2>
<p>Recall that this dog breed dataset
is a subset of the ImageNet dataset,
whose images
are larger than those of the CIFAR-10 dataset
in :numref:<code>sec_kaggle_cifar10</code>.
The following
lists a few image augmentation operations
that might be useful for relatively larger images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
transform_train = gluon.data.vision.transforms.Compose([
    # Randomly crop the image to obtain an image with an area of 0.08 to 1 of
    # the original area and height-to-width ratio between 3/4 and 4/3. Then,
    # scale the image to create a new 224 x 224 image
    gluon.data.vision.transforms.RandomResizedCrop(224, scale=(0.08, 1.0),
                                                   ratio=(3.0/4.0, 4.0/3.0)),
    gluon.data.vision.transforms.RandomFlipLeftRight(),
    # Randomly change the brightness, contrast, and saturation
    gluon.data.vision.transforms.RandomColorJitter(brightness=0.4,
                                                   contrast=0.4,
                                                   saturation=0.4),
    # Add random noise
    gluon.data.vision.transforms.RandomLighting(0.1),
    gluon.data.vision.transforms.ToTensor(),
    # Standardize each channel of the image
    gluon.data.vision.transforms.Normalize([0.485, 0.456, 0.406],
                                           [0.229, 0.224, 0.225])])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
transform_train = torchvision.transforms.Compose([
    # Randomly crop the image to obtain an image with an area of 0.08 to 1 of
    # the original area and height-to-width ratio between 3/4 and 4/3. Then,
    # scale the image to create a new 224 x 224 image
    torchvision.transforms.RandomResizedCrop(224, scale=(0.08, 1.0),
                                             ratio=(3.0/4.0, 4.0/3.0)),
    torchvision.transforms.RandomHorizontalFlip(),
    # Randomly change the brightness, contrast, and saturation
    torchvision.transforms.ColorJitter(brightness=0.4,
                                       contrast=0.4,
                                       saturation=0.4),
    # Add random noise
    torchvision.transforms.ToTensor(),
    # Standardize each channel of the image
    torchvision.transforms.Normalize([0.485, 0.456, 0.406],
                                     [0.229, 0.224, 0.225])])
</code></pre>
<p>During prediction,
we only use image preprocessing operations
without randomness.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
transform_test = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.Resize(256),
    # Crop a 224 x 224 square area from the center of the image
    gluon.data.vision.transforms.CenterCrop(224),
    gluon.data.vision.transforms.ToTensor(),
    gluon.data.vision.transforms.Normalize([0.485, 0.456, 0.406],
                                           [0.229, 0.224, 0.225])])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
transform_test = torchvision.transforms.Compose([
    torchvision.transforms.Resize(256),
    # Crop a 224 x 224 square area from the center of the image
    torchvision.transforms.CenterCrop(224),
    torchvision.transforms.ToTensor(),
    torchvision.transforms.Normalize([0.485, 0.456, 0.406],
                                     [0.229, 0.224, 0.225])])
</code></pre>
<h2 id="reading-the-dataset-10"><a class="header" href="#reading-the-dataset-10">[<strong>Reading the Dataset</strong>]</a></h2>
<p>As in :numref:<code>sec_kaggle_cifar10</code>,
we can read the organized dataset
consisting of raw image files.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_ds, valid_ds, train_valid_ds, test_ds = [
    gluon.data.vision.ImageFolderDataset(
        os.path.join(data_dir, 'train_valid_test', folder))
    for folder in ('train', 'valid', 'train_valid', 'test')]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_ds, train_valid_ds = [torchvision.datasets.ImageFolder(
    os.path.join(data_dir, 'train_valid_test', folder),
    transform=transform_train) for folder in ['train', 'train_valid']]

valid_ds, test_ds = [torchvision.datasets.ImageFolder(
    os.path.join(data_dir, 'train_valid_test', folder),
    transform=transform_test) for folder in ['valid', 'test']]
</code></pre>
<p>Below we create data iterator instances
the same way
as in :numref:<code>sec_kaggle_cifar10</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_iter, train_valid_iter = [gluon.data.DataLoader(
    dataset.transform_first(transform_train), batch_size, shuffle=True,
    last_batch='discard') for dataset in (train_ds, train_valid_ds)]

valid_iter = gluon.data.DataLoader(
    valid_ds.transform_first(transform_test), batch_size, shuffle=False,
    last_batch='discard')

test_iter = gluon.data.DataLoader(
    test_ds.transform_first(transform_test), batch_size, shuffle=False,
    last_batch='keep')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_iter, train_valid_iter = [torch.utils.data.DataLoader(
    dataset, batch_size, shuffle=True, drop_last=True)
    for dataset in (train_ds, train_valid_ds)]

valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=False,
                                         drop_last=True)

test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=False,
                                        drop_last=False)
</code></pre>
<h2 id="fine-tuning-a-pretrained-model"><a class="header" href="#fine-tuning-a-pretrained-model">[<strong>Fine-Tuning a Pretrained Model</strong>]</a></h2>
<p>Again,
the dataset for this competition is a subset of the ImageNet dataset.
Therefore, we can use the approach discussed in
:numref:<code>sec_fine_tuning</code>
to select a model pretrained on the
full ImageNet dataset and use it to extract image features to be fed into a
custom small-scale output network.
High-level APIs of deep learning frameworks
provide a wide range of models
pretrained on the ImageNet dataset.
Here, we choose
a pretrained ResNet-34 model,
where we simply reuse
the input of this model's output layer
(i.e., the extracted
features).
Then we can replace the original output layer with a small custom
output network that can be trained,
such as stacking two
fully connected layers.
Different from the experiment in
:numref:<code>sec_fine_tuning</code>,
the following does
not retrain the pretrained model used for feature
extraction. This reduces training time and
memory for storing gradients.</p>
<p>Recall that we
standardized images using
the means and standard deviations of the three RGB channels for the full ImageNet dataset.
In fact,
this is also consistent with the standardization operation
by the pretrained model on ImageNet.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_net(devices):
    finetune_net = gluon.model_zoo.vision.resnet34_v2(pretrained=True)
    # Define a new output network
    finetune_net.output_new = nn.HybridSequential(prefix='')
    finetune_net.output_new.add(nn.Dense(256, activation='relu'))
    # There are 120 output categories
    finetune_net.output_new.add(nn.Dense(120))
    # Initialize the output network
    finetune_net.output_new.initialize(init.Xavier(), ctx=devices)
    # Distribute the model parameters to the CPUs or GPUs used for computation
    finetune_net.collect_params().reset_ctx(devices)
    return finetune_net
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_net(devices):
    finetune_net = nn.Sequential()
    finetune_net.features = torchvision.models.resnet34(pretrained=True)
    # Define a new output network (there are 120 output categories)
    finetune_net.output_new = nn.Sequential(nn.Linear(1000, 256),
                                            nn.ReLU(),
                                            nn.Linear(256, 120))
    # Move the model to devices
    finetune_net = finetune_net.to(devices[0])
    # Freeze parameters of feature layers
    for param in finetune_net.features.parameters():
        param.requires_grad = False
    return finetune_net
</code></pre>
<p>Before [<strong>calculating the loss</strong>],
we first obtain the input of the pretrained model's output layer, i.e., the extracted feature.
Then we use this feature as input for our small custom output network to calculate the loss.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
loss = gluon.loss.SoftmaxCrossEntropyLoss()

def evaluate_loss(data_iter, net, devices):
    l_sum, n = 0.0, 0
    for features, labels in data_iter:
        X_shards, y_shards = d2l.split_batch(features, labels, devices)
        output_features = [net.features(X_shard) for X_shard in X_shards]
        outputs = [net.output_new(feature) for feature in output_features]
        ls = [loss(output, y_shard).sum() for output, y_shard
              in zip(outputs, y_shards)]
        l_sum += sum([float(l.sum()) for l in ls])
        n += labels.size
    return l_sum / n
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
loss = nn.CrossEntropyLoss(reduction='none')

def evaluate_loss(data_iter, net, devices):
    l_sum, n = 0.0, 0
    for features, labels in data_iter:
        features, labels = features.to(devices[0]), labels.to(devices[0])
        outputs = net(features)
        l = loss(outputs, labels)
        l_sum += l.sum()
        n += labels.numel()
    return l_sum / n
</code></pre>
<h2 id="defining-the-training-function-1"><a class="header" href="#defining-the-training-function-1">Defining [<strong>the Training Function</strong>]</a></h2>
<p>We will select the model and tune hyperparameters according to the model's performance on the validation set. The model training function <code>train</code> only
iterates parameters of the small custom output network.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
          lr_decay):
    # Only train the small custom output network
    trainer = gluon.Trainer(net.output_new.collect_params(), 'sgd',
                            {'learning_rate': lr, 'momentum': 0.9, 'wd': wd})
    num_batches, timer = len(train_iter), d2l.Timer()
    legend = ['train loss']
    if valid_iter is not None:
        legend.append('valid loss')
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=legend)
    for epoch in range(num_epochs):
        metric = d2l.Accumulator(2)
        if epoch &gt; 0 and epoch % lr_period == 0:
            trainer.set_learning_rate(trainer.learning_rate * lr_decay)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            X_shards, y_shards = d2l.split_batch(features, labels, devices)
            output_features = [net.features(X_shard) for X_shard in X_shards]
            with autograd.record():
                outputs = [net.output_new(feature)
                           for feature in output_features]
                ls = [loss(output, y_shard).sum() for output, y_shard
                      in zip(outputs, y_shards)]
            for l in ls:
                l.backward()
            trainer.step(batch_size)
            metric.add(sum([float(l.sum()) for l in ls]), labels.shape[0])
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[1], None))
        if valid_iter is not None:
            valid_loss = evaluate_loss(valid_iter, net, devices)
            animator.add(epoch + 1, (None, valid_loss))
    measures = f'train loss {metric[0] / metric[1]:.3f}'
    if valid_iter is not None:
        measures += f', valid loss {valid_loss:.3f}'
    print(measures + f'\n{metric[1] * num_epochs / timer.sum():.1f}'
          f' examples/sec on {str(devices)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
          lr_decay):
    # Only train the small custom output network
    net = nn.DataParallel(net, device_ids=devices).to(devices[0])
    trainer = torch.optim.SGD((param for param in net.parameters()
                               if param.requires_grad), lr=lr,
                              momentum=0.9, weight_decay=wd)
    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay)
    num_batches, timer = len(train_iter), d2l.Timer()
    legend = ['train loss']
    if valid_iter is not None:
        legend.append('valid loss')
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=legend)
    for epoch in range(num_epochs):
        metric = d2l.Accumulator(2)
        for i, (features, labels) in enumerate(train_iter):
            timer.start()
            features, labels = features.to(devices[0]), labels.to(devices[0])
            trainer.zero_grad()
            output = net(features)
            l = loss(output, labels).sum()
            l.backward()
            trainer.step()
            metric.add(l, labels.shape[0])
            timer.stop()
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[1], None))
        measures = f'train loss {metric[0] / metric[1]:.3f}'
        if valid_iter is not None:
            valid_loss = evaluate_loss(valid_iter, net, devices)
            animator.add(epoch + 1, (None, valid_loss.detach().cpu()))
        scheduler.step()
    if valid_iter is not None:
        measures += f', valid loss {valid_loss:.3f}'
    print(measures + f'\n{metric[1] * num_epochs / timer.sum():.1f}'
          f' examples/sec on {str(devices)}')
</code></pre>
<h2 id="training-and-validating-the-model-1"><a class="header" href="#training-and-validating-the-model-1">[<strong>Training and Validating the Model</strong>]</a></h2>
<p>Now we can train and validate the model.
The following hyperparameters are all tunable.
For example, the number of epochs can be increased. Because <code>lr_period</code> and <code>lr_decay</code> are set to 2 and 0.9, respectively, the learning rate of the optimization algorithm will be multiplied by 0.9 after every 2 epochs.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
devices, num_epochs, lr, wd = d2l.try_all_gpus(), 10, 5e-3, 1e-4
lr_period, lr_decay, net = 2, 0.9, get_net(devices)
net.hybridize()
train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
      lr_decay)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
devices, num_epochs, lr, wd = d2l.try_all_gpus(), 10, 1e-4, 1e-4
lr_period, lr_decay, net = 2, 0.9, get_net(devices)
train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
      lr_decay)
</code></pre>
<h2 id="classifying-the-testing-set-and-submitting-results-on-kaggle-1"><a class="header" href="#classifying-the-testing-set-and-submitting-results-on-kaggle-1">[<strong>Classifying the Testing Set</strong>] and Submitting Results on Kaggle</a></h2>
<p>Similar to the final step in :numref:<code>sec_kaggle_cifar10</code>,
in the end all the labeled data (including the validation set) are used for training the model and classifying the testing set.
We will use the trained custom output network
for classification.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = get_net(devices)
net.hybridize()
train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period,
      lr_decay)

preds = []
for data, label in test_iter:
    output_features = net.features(data.as_in_ctx(devices[0]))
    output = npx.softmax(net.output_new(output_features))
    preds.extend(output.asnumpy())
ids = sorted(os.listdir(
    os.path.join(data_dir, 'train_valid_test', 'test', 'unknown')))
with open('submission.csv', 'w') as f:
    f.write('id,' + ','.join(train_valid_ds.synsets) + '\n')
    for i, output in zip(ids, preds):
        f.write(i.split('.')[0] + ',' + ','.join(
            [str(num) for num in output]) + '\n')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = get_net(devices)
train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period,
      lr_decay)

preds = []
for data, label in test_iter:
    output = torch.nn.functional.softmax(net(data.to(devices[0])), dim=1)
    preds.extend(output.cpu().detach().numpy())
ids = sorted(os.listdir(
    os.path.join(data_dir, 'train_valid_test', 'test', 'unknown')))
with open('submission.csv', 'w') as f:
    f.write('id,' + ','.join(train_valid_ds.classes) + '\n')
    for i, output in zip(ids, preds):
        f.write(i.split('.')[0] + ',' + ','.join(
            [str(num) for num in output]) + '\n')
</code></pre>
<p>The above code
will generate a <code>submission.csv</code> file
to be submitted
to Kaggle in the same way described in :numref:<code>sec_kaggle_house</code>.</p>
<h2 id="summary-85"><a class="header" href="#summary-85">Summary</a></h2>
<ul>
<li>Images in the ImageNet dataset are larger (with varying dimensions) than CIFAR-10 images. We may modify image augmentation operations for tasks on a different dataset.</li>
<li>To classify a subset of the ImageNet dataset, we can leverage pre-trained models on the full ImageNet dataset to extract features and only train a custom small-scale output network. This will lead to less computational time and memory cost.</li>
</ul>
<h2 id="exercises-105"><a class="header" href="#exercises-105">Exercises</a></h2>
<ol>
<li>When using the full Kaggle competition dataset, what results can you achieve when you increase <code>batch_size</code> (batch size) and <code>num_epochs</code> (number of epochs) while setting some other hyperparameters as <code>lr = 0.01</code>, <code>lr_period = 10</code>, and <code>lr_decay = 0.1</code>?</li>
<li>Do you get better results if you use a deeper pretrained model? How do you tune hyperparameters? Can you further improve the results?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/380">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1481">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-language-processing-pretraining"><a class="header" href="#natural-language-processing-pretraining">Natural Language Processing: Pretraining</a></h1>
<p>:label:<code>chap_nlp_pretrain</code></p>
<p>Humans need to communicate.
Out of this basic need of the human condition, a vast amount of written text has been generated on an everyday basis.
Given rich text in social media, chat apps, emails, product reviews, news articles,  research papers, and books, it becomes vital to enable computers to understand them to offer assistance or make decisions based on human languages.</p>
<p><em>Natural language processing</em> studies interactions between computers and humans using natural languages.
In practice, it is very common to use natural language processing techniques to process and analyze text (human natural language) data, such as language models in :numref:<code>sec_language-model</code> and machine translation models in :numref:<code>sec_machine_translation</code>.</p>
<p>To understand text, we can begin by learning
its representations.
Leveraging the existing text sequences
from large corpora,
<em>self-supervised learning</em>
has been extensively
used to pretrain text representations,
such as by predicting some hidden part of the text
using some other part of their surrounding text.
In this way,
models learn through supervision
from <em>massive</em> text data
without <em>expensive</em> labeling efforts!</p>
<p>As we will see in this chapter,
when treating each word or subword as an individual token,
the representation of each token can be pretrained
using word2vec, GloVe, or subword embedding models
on large corpora.
After pretraining, representation of each token can be a vector,
however, it remains the same no matter what the context is.
For instance, the vector representation of "bank" is the same
in both
"go to the bank to deposit some money"
and
"go to the bank to sit down".
Thus, many more recent pretraining models adapt representation of the same token
to different contexts.
Among them is BERT, a much deeper self-supervised model based on the Transformer encoder.
In this chapter, we will focus on how to pretrain such representations for text,
as highlighted in :numref:<code>fig_nlp-map-pretrain</code>.</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/nlp-map-pretrain.svg" alt="Pretrained text representations can be fed to various deep learning architectures for different downstream natural language processing applications. This chapter focuses on the upstream text representation pretraining." />
:label:<code>fig_nlp-map-pretrain</code></p>
<p>For sight of the big picture,
:numref:<code>fig_nlp-map-pretrain</code> shows that
the pretrained text representations can be fed to
a variety of deep learning architectures for different downstream natural language processing applications.
We will cover them in :numref:<code>chap_nlp_app</code>.</p>
<pre><code class="language-toc">:maxdepth: 2

word2vec
approx-training
word-embedding-dataset
word2vec-pretraining
glove
subword-embedding
similarity-analogy
bert
bert-dataset
bert-pretraining

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="word-embedding-word2vec"><a class="header" href="#word-embedding-word2vec">Word Embedding (word2vec)</a></h1>
<p>:label:<code>sec_word2vec</code></p>
<p>Natural language is a complex system used to express meanings.
In this system, words are the basic unit of the meaning.
As the name implies,
<em>word vectors</em> are vectors used to represent words,
and can also be considered as feature vectors or representations of words.
The technique of mapping words to real vectors
is called <em>word embedding</em>.
In recent years,
word embedding has gradually become
the basic knowledge of natural language processing.</p>
<h2 id="one-hot-vectors-are-a-bad-choice"><a class="header" href="#one-hot-vectors-are-a-bad-choice">One-Hot Vectors Are a Bad Choice</a></h2>
<p>We used one-hot vectors to represent words (characters are words) in :numref:<code>sec_rnn-scratch</code>.
Suppose that the number of different words in the dictionary (the dictionary size) is $N$,
and each word corresponds to
a different integer (index) from $0$ to $N-1$.
To obtain the one-hot vector representation
for any word with index $i$,
we create a length-$N$ vector with all 0s
and set the element at position $i$ to 1.
In this way, each word is represented as a vector of length $N$, and it
can be used directly by neural networks.</p>
<p>Although one-hot word vectors are easy to construct,
they are usually not a good choice.
A main reason is that one-hot word vectors cannot accurately express the similarity between different words, such as the <em>cosine similarity</em> that we often use.
For vectors $\mathbf{x}, \mathbf{y} \in \mathbb{R}^d$, their cosine similarity is the cosine of the angle between them:</p>
<p>$$\frac{\mathbf{x}^\top \mathbf{y}}{|\mathbf{x}| |\mathbf{y}|} \in [-1, 1].$$</p>
<p>Since the cosine similarity between one-hot vectors of any two different words is 0,
one-hot vectors cannot encode similarities among words.</p>
<h2 id="self-supervised-word2vec"><a class="header" href="#self-supervised-word2vec">Self-Supervised word2vec</a></h2>
<p>The <a href="https://code.google.com/archive/p/word2vec/">word2vec</a> tool was proposed to address the above issue.
It maps each word to a fixed-length vector, and  these vectors can better express the similarity and analogy relationship among different words.
The word2vec tool contains two models, namely <em>skip-gram</em> :cite:<code>Mikolov.Sutskever.Chen.ea.2013</code>  and <em>continuous bag of words</em> (CBOW) :cite:<code>Mikolov.Chen.Corrado.ea.2013</code>.
For semantically meaningful representations,
their training relies on
conditional probabilities
that can be viewed as predicting
some words using some of their surrounding words
in corpora.
Since supervision comes from the data without labels,
both skip-gram and continuous bag of words
are self-supervised models.</p>
<p>In the following, we will introduce these two models and their training methods.</p>
<h2 id="the-skip-gram-model"><a class="header" href="#the-skip-gram-model">The Skip-Gram Model</a></h2>
<p>:label:<code>subsec_skip-gram</code></p>
<p>The <em>skip-gram</em> model assumes that a word can be used to generate its surrounding words in a text sequence.
Take the text sequence "the", "man", "loves", "his", "son" as an example.
Let's choose "loves" as the <em>center word</em> and set the context window size to 2.
As shown in :numref:<code>fig_skip_gram</code>,
given the center word "loves",
the skip-gram model considers
the conditional probability for generating the <em>context words</em>: "the", "man", "his", and "son",
which are no more than 2 words away from the center word:</p>
<p>$$P(\textrm{"the"},\textrm{"man"},\textrm{"his"},\textrm{"son"}\mid\textrm{"loves"}).$$</p>
<p>Assume that
the context words are independently generated
given the center word (i.e., conditional independence).
In this case, the above conditional probability
can be rewritten as</p>
<p>$$P(\textrm{"the"}\mid\textrm{"loves"})\cdot P(\textrm{"man"}\mid\textrm{"loves"})\cdot P(\textrm{"his"}\mid\textrm{"loves"})\cdot P(\textrm{"son"}\mid\textrm{"loves"}).$$</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/skip-gram.svg" alt="The skip-gram model considers the conditional probability of generating the surrounding context words given a center word." />
:label:<code>fig_skip_gram</code></p>
<p>In the skip-gram model, each word
has two $d$-dimensional-vector representations
for calculating conditional probabilities.
More concretely,
for any word with index $i$ in the dictionary,
denote by $\mathbf{v}_i\in\mathbb{R}^d$
and $\mathbf{u}_i\in\mathbb{R}^d$
its two vectors
when used as a <em>center</em> word and a <em>context</em> word, respectively.
The conditional probability of generating any
context word $w_o$ (with index $o$ in the dictionary) given the center word $w_c$ (with index $c$ in the dictionary) can be modeled by
a softmax operation on vector dot products:</p>
<p>$$P(w_o \mid w_c) = \frac{\exp(\mathbf{u}_o^\top \mathbf{v}<em>c)}{ \sum</em>{i \in \mathcal{V}} \exp(\mathbf{u}_i^\top \mathbf{v}_c)},$$
:eqlabel:<code>eq_skip-gram-softmax</code></p>
<p>where the vocabulary index set $\mathcal{V} = {0, 1, \ldots, |\mathcal{V}|-1}$.
Given a text sequence of length $T$, where the word at time step $t$ is denoted as $w^{(t)}$.
Assume that
context words are independently generated
given any center word.
For context window size $m$,
the likelihood function of the skip-gram model
is the probability of generating all context words
given any center word:</p>
<p>$$ \prod_{t=1}^{T} \prod_{-m \leq j \leq m,\ j \neq 0} P(w^{(t+j)} \mid w^{(t)}),$$</p>
<p>where any time step that is less than $1$ or greater than $T$ can be omitted.</p>
<h3 id="training-28"><a class="header" href="#training-28">Training</a></h3>
<p>The skip-gram model parameters are the center word vector and context word vector for each word in the vocabulary.
In training, we learn the model parameters by maximizing the likelihood function (i.e., maximum likelihood estimation). This is equivalent to minimizing the following loss function:</p>
<p>$$ - \sum_{t=1}^{T} \sum_{-m \leq j \leq m,\ j \neq 0} \textrm{log}, P(w^{(t+j)} \mid w^{(t)}).$$</p>
<p>When using stochastic gradient descent to minimize the loss,
in each iteration
we can
randomly sample a shorter subsequence to calculate the (stochastic) gradient for this subsequence to update the model parameters.
To calculate this (stochastic) gradient,
we need to obtain
the gradients of
the log conditional probability with respect to the center word vector and the context word vector.
In general, according to :eqref:<code>eq_skip-gram-softmax</code>
the log conditional probability
involving any pair of the center word $w_c$ and
the context word $w_o$ is</p>
<p>$$\log P(w_o \mid w_c) =\mathbf{u}_o^\top \mathbf{v}<em>c - \log\left(\sum</em>{i \in \mathcal{V}} \exp(\mathbf{u}_i^\top \mathbf{v}_c)\right).$$
:eqlabel:<code>eq_skip-gram-log</code></p>
<p>Through differentiation, we can obtain its gradient
with respect to the center word vector $\mathbf{v}_c$ as</p>
<p>$$\begin{aligned}\frac{\partial \textrm{log}, P(w_o \mid w_c)}{\partial \mathbf{v}_c}&amp;= \mathbf{u}<em>o - \frac{\sum</em>{j \in \mathcal{V}} \exp(\mathbf{u}_j^\top \mathbf{v}_c)\mathbf{u}<em>j}{\sum</em>{i \in \mathcal{V}} \exp(\mathbf{u}_i^\top \mathbf{v}_c)}\&amp;= \mathbf{u}<em>o - \sum</em>{j \in \mathcal{V}} \left(\frac{\exp(\mathbf{u}_j^\top \mathbf{v}<em>c)}{ \sum</em>{i \in \mathcal{V}} \exp(\mathbf{u}_i^\top \mathbf{v}_c)}\right) \mathbf{u}_j\&amp;= \mathbf{u}<em>o - \sum</em>{j \in \mathcal{V}} P(w_j \mid w_c) \mathbf{u}_j.\end{aligned}$$
:eqlabel:<code>eq_skip-gram-grad</code></p>
<p>Note that the calculation in :eqref:<code>eq_skip-gram-grad</code> requires the conditional probabilities of all words in the dictionary with $w_c$ as the center word.
The gradients for the other word vectors can be obtained in the same way.</p>
<p>After training, for any word with index $i$ in the dictionary, we obtain both word vectors
$\mathbf{v}_i$ (as the center word) and $\mathbf{u}_i$ (as the context word).
In natural language processing applications, the center word vectors of the skip-gram model are typically
used as the word representations.</p>
<h2 id="the-continuous-bag-of-words-cbow-model"><a class="header" href="#the-continuous-bag-of-words-cbow-model">The Continuous Bag of Words (CBOW) Model</a></h2>
<p>The <em>continuous bag of words</em> (CBOW) model is similar to the skip-gram model.
The major difference
from the skip-gram model is that
the continuous bag of words model
assumes that a center word is generated
based on its surrounding context words in the text sequence.
For example,
in the same text sequence "the", "man", "loves", "his", and "son", with "loves" as the center word and the context window size being 2,
the continuous bag of words model
considers
the conditional probability of generating the center word "loves" based on the context words "the", "man", "his" and "son" (as shown in :numref:<code>fig_cbow</code>), which is</p>
<p>$$P(\textrm{"loves"}\mid\textrm{"the"},\textrm{"man"},\textrm{"his"},\textrm{"son"}).$$</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/cbow.svg" alt="The continuous bag of words model considers the conditional probability of generating the center word given its surrounding context words." />
:label:<code>fig_cbow</code></p>
<p>Since there are multiple context words
in the continuous bag of words model,
these context word vectors are averaged
in the calculation of the conditional probability.
Specifically,
for any word with index $i$ in the dictionary,
denote by $\mathbf{v}<em>i\in\mathbb{R}^d$
and $\mathbf{u}<em>i\in\mathbb{R}^d$
its two vectors
when used as a <em>context</em> word and a <em>center</em> word
(meanings are switched in the skip-gram model), respectively.
The conditional probability of generating any
center word $w_c$ (with index $c$ in the dictionary) given its surrounding context words $w</em>{o_1}, \ldots, w</em>{o_{2m}}$ (with index $o_1, \ldots, o_{2m}$ in the dictionary) can be modeled by</p>
<p>$$P(w_c \mid w_{o_1}, \ldots, w_{o_{2m}}) = \frac{\exp\left(\frac{1}{2m}\mathbf{u}<em>c^\top (\mathbf{v}</em>{o_1} + \ldots + \mathbf{v}<em>{o</em>{2m}}) \right)}{ \sum_{i \in \mathcal{V}} \exp\left(\frac{1}{2m}\mathbf{u}<em>i^\top (\mathbf{v}</em>{o_1} + \ldots + \mathbf{v}<em>{o</em>{2m}}) \right)}.$$
:eqlabel:<code>fig_cbow-full</code></p>
<p>For brevity, let $\mathcal{W}<em>o= {w</em>{o_1}, \ldots, w_{o_{2m}}}$ and $\bar{\mathbf{v}}<em>o = \left(\mathbf{v}</em>{o_1} + \ldots + \mathbf{v}<em>{o</em>{2m}} \right)/(2m)$. Then :eqref:<code>fig_cbow-full</code> can be simplified as</p>
<p>$$P(w_c \mid \mathcal{W}_o) = \frac{\exp\left(\mathbf{u}_c^\top \bar{\mathbf{v}}<em>o\right)}{\sum</em>{i \in \mathcal{V}} \exp\left(\mathbf{u}_i^\top \bar{\mathbf{v}}_o\right)}.$$</p>
<p>Given a text sequence of length $T$, where the word at time step $t$ is denoted as $w^{(t)}$.
For context window size $m$,
the likelihood function of the continuous bag of words model
is the probability of generating all center words
given their context words:</p>
<p>$$ \prod_{t=1}^{T}  P(w^{(t)} \mid  w^{(t-m)}, \ldots, w^{(t-1)}, w^{(t+1)}, \ldots, w^{(t+m)}).$$</p>
<h3 id="training-29"><a class="header" href="#training-29">Training</a></h3>
<p>Training continuous bag of words models
is almost the same as
training skip-gram models.
The maximum likelihood estimation of the
continuous bag of words model is equivalent to minimizing the following loss function:</p>
<p>$$  -\sum_{t=1}^T  \textrm{log}, P(w^{(t)} \mid  w^{(t-m)}, \ldots, w^{(t-1)}, w^{(t+1)}, \ldots, w^{(t+m)}).$$</p>
<p>Notice that</p>
<p>$$\log,P(w_c \mid \mathcal{W}_o) = \mathbf{u}_c^\top \bar{\mathbf{v}}<em>o - \log,\left(\sum</em>{i \in \mathcal{V}} \exp\left(\mathbf{u}_i^\top \bar{\mathbf{v}}_o\right)\right).$$</p>
<p>Through differentiation, we can obtain its gradient
with respect to any context word vector $\mathbf{v}_{o_i}$($i = 1, \ldots, 2m$)
as</p>
<p>$$\frac{\partial \log, P(w_c \mid \mathcal{W}<em>o)}{\partial \mathbf{v}</em>{o_i}} = \frac{1}{2m} \left(\mathbf{u}<em>c - \sum</em>{j \in \mathcal{V}} \frac{\exp(\mathbf{u}_j^\top \bar{\mathbf{v}}_o)\mathbf{u}<em>j}{ \sum</em>{i \in \mathcal{V}} \exp(\mathbf{u}_i^\top \bar{\mathbf{v}}_o)} \right) = \frac{1}{2m}\left(\mathbf{u}<em>c - \sum</em>{j \in \mathcal{V}} P(w_j \mid \mathcal{W}_o) \mathbf{u}_j \right).$$
:eqlabel:<code>eq_cbow-gradient</code></p>
<p>The gradients for the other word vectors can be obtained in the same way.
Unlike the skip-gram model,
the continuous bag of words model
typically
uses context word vectors as the word representations.</p>
<h2 id="summary-86"><a class="header" href="#summary-86">Summary</a></h2>
<ul>
<li>Word vectors are vectors used to represent words, and can also be considered as feature vectors or representations of words. The technique of mapping words to real vectors is called word embedding.</li>
<li>The word2vec tool contains both the skip-gram  and continuous bag of words models.</li>
<li>The skip-gram model assumes that a word can be used to generate its surrounding words in a text sequence; while the continuous bag of words model assumes that a center word is generated based on its surrounding context words.</li>
</ul>
<h2 id="exercises-106"><a class="header" href="#exercises-106">Exercises</a></h2>
<ol>
<li>What is the computational complexity for calculating each gradient? What could be the issue if the dictionary size is huge?</li>
<li>Some fixed phrases in English consist of multiple words, such as "new york". How to train their word vectors? Hint: see Section 4 in the word2vec paper :cite:<code>Mikolov.Sutskever.Chen.ea.2013</code>.</li>
<li>Let's reflect on the word2vec design by taking the skip-gram model as an example. What is the relationship between the dot product of two word vectors in the skip-gram model and the cosine similarity? For a pair of words with similar semantics, why may the cosine similarity of their word vectors (trained by the skip-gram model) be high?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/381">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="approximate-training"><a class="header" href="#approximate-training">Approximate Training</a></h1>
<p>:label:<code>sec_approx_train</code></p>
<p>Recall our discussions in :numref:<code>sec_word2vec</code>.
The main idea of the skip-gram model is
using softmax operations to calculate
the conditional probability of
generating a context word $w_o$
based on the given center word $w_c$
in :eqref:<code>eq_skip-gram-softmax</code>,
whose corresponding logarithmic loss is given by
the opposite of :eqref:<code>eq_skip-gram-log</code>.</p>
<p>Due to the nature of the softmax operation,
since a context word may be anyone in the
dictionary $\mathcal{V}$,
the opposite of :eqref:<code>eq_skip-gram-log</code>
contains the summation
of items as many as the entire size of the vocabulary.
Consequently,
the gradient calculation
for the skip-gram model
in :eqref:<code>eq_skip-gram-grad</code>
and that
for the continuous bag-of-words model
in :eqref:<code>eq_cbow-gradient</code>
both contain
the summation.
Unfortunately,
the computational cost
for such gradients
that sum over
a large dictionary
(often with
hundreds of thousands or millions of words)
is huge!</p>
<p>In order to reduce the aforementioned computational complexity, this section will introduce two approximate training methods:
<em>negative sampling</em> and <em>hierarchical softmax</em>.
Due to the similarity
between the skip-gram model and
the continuous bag of words model,
we will just take the skip-gram model as an example
to describe these two approximate training methods.</p>
<h2 id="negative-sampling"><a class="header" href="#negative-sampling">Negative Sampling</a></h2>
<p>:label:<code>subsec_negative-sampling</code></p>
<p>Negative sampling modifies the original objective function.
Given the context window of a center word $w_c$,
the fact that any (context) word $w_o$
comes from this context window
is considered as an event with the probability
modeled by</p>
<p>$$P(D=1\mid w_c, w_o) = \sigma(\mathbf{u}_o^\top \mathbf{v}_c),$$</p>
<p>where $\sigma$ uses the definition of the sigmoid activation function:</p>
<p>$$\sigma(x) = \frac{1}{1+\exp(-x)}.$$
:eqlabel:<code>eq_sigma-f</code></p>
<p>Let's begin by
maximizing the joint probability of
all such events in text sequences
to train word embeddings.
Specifically,
given a text sequence of length $T$,
denote by $w^{(t)}$ the word at time step $t$
and let the context window size be $m$,
consider maximizing the joint probability</p>
<p>$$ \prod_{t=1}^{T} \prod_{-m \leq j \leq m,\ j \neq 0} P(D=1\mid w^{(t)}, w^{(t+j)}).$$
:eqlabel:<code>eq-negative-sample-pos</code></p>
<p>However,
:eqref:<code>eq-negative-sample-pos</code>
only considers those events
that involve positive examples.
As a result,
the joint probability in
:eqref:<code>eq-negative-sample-pos</code>
is maximized to 1
only if all the word vectors are equal to infinity.
Of course,
such results are meaningless.
To make the objective function
more meaningful,
<em>negative sampling</em>
adds negative examples sampled
from a predefined distribution.</p>
<p>Denote by $S$
the event that
a context word $w_o$ comes from
the context window of a center word $w_c$.
For this event involving $w_o$,
from a predefined distribution $P(w)$
sample $K$ <em>noise words</em>
that are not from this context window.
Denote by $N_k$
the event that
a noise word $w_k$ ($k=1, \ldots, K$)
does not come from
the context window of $w_c$.
Assume that
these events involving
both the positive example and negative examples
$S, N_1, \ldots, N_K$ are mutually independent.
Negative sampling
rewrites the joint probability (involving only positive examples)
in :eqref:<code>eq-negative-sample-pos</code>
as</p>
<p>$$ \prod_{t=1}^{T} \prod_{-m \leq j \leq m,\ j \neq 0} P(w^{(t+j)} \mid w^{(t)}),$$</p>
<p>where the conditional probability is approximated through
events $S, N_1, \ldots, N_K$:</p>
<p>$$ P(w^{(t+j)} \mid w^{(t)}) =P(D=1\mid w^{(t)}, w^{(t+j)})\prod_{k=1,\ w_k \sim P(w)}^K P(D=0\mid w^{(t)}, w_k).$$
:eqlabel:<code>eq-negative-sample-conditional-prob</code></p>
<p>Denote by
$i_t$ and $h_k$
the indices of
a word $w^{(t)}$ at time step $t$
of a text sequence
and a noise word $w_k$,
respectively.
The logarithmic loss with respect to the conditional probabilities in :eqref:<code>eq-negative-sample-conditional-prob</code> is</p>
<p>$$
\begin{aligned}
-\log P(w^{(t+j)} \mid w^{(t)})
=&amp; -\log P(D=1\mid w^{(t)}, w^{(t+j)}) - \sum_{k=1,\ w_k \sim P(w)}^K \log P(D=0\mid w^{(t)}, w_k)\
=&amp;-  \log, \sigma\left(\mathbf{u}<em>{i</em>{t+j}}^\top \mathbf{v}<em>{i_t}\right) - \sum</em>{k=1,\ w_k \sim P(w)}^K \log\left(1-\sigma\left(\mathbf{u}<em>{h_k}^\top \mathbf{v}</em>{i_t}\right)\right)\
=&amp;-  \log, \sigma\left(\mathbf{u}<em>{i</em>{t+j}}^\top \mathbf{v}<em>{i_t}\right) - \sum</em>{k=1,\ w_k \sim P(w)}^K \log\sigma\left(-\mathbf{u}<em>{h_k}^\top \mathbf{v}</em>{i_t}\right).
\end{aligned}
$$</p>
<p>We can see that
now the computational cost for gradients
at each training step
has nothing to do with the dictionary size,
but linearly depends on $K$.
When setting the hyperparameter $K$
to a smaller value,
the computational cost for gradients
at each training step with negative sampling
is smaller.</p>
<h2 id="hierarchical-softmax"><a class="header" href="#hierarchical-softmax">Hierarchical Softmax</a></h2>
<p>As an alternative approximate training method,
<em>hierarchical softmax</em>
uses the binary tree,
a data structure
illustrated in :numref:<code>fig_hi_softmax</code>,
where each leaf node
of the tree represents
a word in dictionary $\mathcal{V}$.</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/hi-softmax.svg" alt="Hierarchical softmax for approximate training, where each leaf node of the tree represents a word in the dictionary." />
:label:<code>fig_hi_softmax</code></p>
<p>Denote by $L(w)$
the number of nodes (including both ends)
on the path
from the root node to the leaf node representing word $w$
in the binary tree.
Let $n(w,j)$ be the $j^\textrm{th}$ node on this path,
with its context word vector being
$\mathbf{u}_{n(w, j)}$.
For example,
$L(w_3) = 4$ in  :numref:<code>fig_hi_softmax</code>.
Hierarchical softmax approximates the conditional probability in :eqref:<code>eq_skip-gram-softmax</code> as</p>
<p>$$P(w_o \mid w_c) = \prod_{j=1}^{L(w_o)-1} \sigma\left( [![  n(w_o, j+1) = \textrm{leftChild}(n(w_o, j)) ]!] \cdot \mathbf{u}_{n(w_o, j)}^\top \mathbf{v}_c\right),$$</p>
<p>where function $\sigma$
is defined in :eqref:<code>eq_sigma-f</code>,
and $\textrm{leftChild}(n)$ is the left child node of node $n$: if $x$ is true, $[![x]!] = 1$; otherwise $[![x]!] = -1$.</p>
<p>To illustrate,
let's calculate
the conditional probability
of generating word $w_3$
given word $w_c$ in :numref:<code>fig_hi_softmax</code>.
This requires dot products
between the word vector
$\mathbf{v}_c$ of $w_c$
and
non-leaf node vectors
on the path (the path in bold in :numref:<code>fig_hi_softmax</code>) from the root to $w_3$,
which is traversed left, right, then left:</p>
<p>$$P(w_3 \mid w_c) = \sigma(\mathbf{u}_{n(w_3, 1)}^\top \mathbf{v}<em>c) \cdot \sigma(-\mathbf{u}</em>{n(w_3, 2)}^\top \mathbf{v}<em>c) \cdot \sigma(\mathbf{u}</em>{n(w_3, 3)}^\top \mathbf{v}_c).$$</p>
<p>Since $\sigma(x)+\sigma(-x) = 1$,
it holds that
the conditional probabilities of
generating all the words in
dictionary $\mathcal{V}$
based on any word $w_c$
sum up to one:</p>
<p>$$\sum_{w \in \mathcal{V}} P(w \mid w_c) = 1.$$
:eqlabel:<code>eq_hi-softmax-sum-one</code></p>
<p>Fortunately, since $L(w_o)-1$ is on the order of $\mathcal{O}(\textrm{log}_2|\mathcal{V}|)$ due to the binary tree structure,
when the dictionary size $\mathcal{V}$ is huge,
the computational cost for  each training step using hierarchical softmax
is significantly reduced compared with that
without approximate training.</p>
<h2 id="summary-87"><a class="header" href="#summary-87">Summary</a></h2>
<ul>
<li>Negative sampling constructs the loss function by considering mutually independent events that involve both positive and negative examples. The computational cost for training is linearly dependent on the number of noise words at each step.</li>
<li>Hierarchical softmax constructs the loss function using  the path from the root node to the leaf node in the binary tree. The computational cost for training is dependent on the logarithm of the dictionary size at each step.</li>
</ul>
<h2 id="exercises-107"><a class="header" href="#exercises-107">Exercises</a></h2>
<ol>
<li>How can we sample noise words in negative sampling?</li>
<li>Verify that :eqref:<code>eq_hi-softmax-sum-one</code> holds.</li>
<li>How to train the continuous bag of words model using negative sampling and hierarchical softmax, respectively?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/382">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-dataset-for-pretraining-word-embeddings"><a class="header" href="#the-dataset-for-pretraining-word-embeddings">The Dataset for Pretraining Word Embeddings</a></h1>
<p>:label:<code>sec_word2vec_data</code></p>
<p>Now that we know the technical details of
the word2vec models and approximate training methods,
let's walk through their implementations.
Specifically,
we will take the skip-gram model in :numref:<code>sec_word2vec</code>
and negative sampling in :numref:<code>sec_approx_train</code>
as an example.
In this section,
we begin with the dataset
for pretraining the word embedding model:
the original format of the data
will be transformed
into minibatches
that can be iterated over during training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
import collections
from d2l import mxnet as d2l
import math
from mxnet import gluon, np
import os
import random
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
import collections
from d2l import torch as d2l
import math
import torch
import os
import random
</code></pre>
<h2 id="reading-the-dataset-11"><a class="header" href="#reading-the-dataset-11">Reading the Dataset</a></h2>
<p>The dataset that we use here
is <a href="https://catalog.ldc.upenn.edu/LDC99T42">Penn Tree Bank (PTB)</a>.
This corpus is sampled
from Wall Street Journal articles,
split into training, validation, and test sets.
In the original format,
each line of the text file
represents a sentence of words that are separated by spaces.
Here we treat each word as a token.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['ptb'] = (d2l.DATA_URL + 'ptb.zip',
                       '319d85e578af0cdc590547f26231e4e31cdf1e42')

#@save
def read_ptb():
    """Load the PTB dataset into a list of text lines."""
    data_dir = d2l.download_extract('ptb')
    # Read the training set
    with open(os.path.join(data_dir, 'ptb.train.txt')) as f:
        raw_text = f.read()
    return [line.split() for line in raw_text.split('\n')]

sentences = read_ptb()
f'# sentences: {len(sentences)}'
</code></pre>
<p>After reading the training set,
we build a vocabulary for the corpus,
where any word that appears
less than 10 times is replaced by
the "&lt;unk&gt;" token.
Note that the original dataset
also contains "&lt;unk&gt;" tokens that represent rare (unknown) words.</p>
<pre><code class="language-{.python .input}">#@tab all
vocab = d2l.Vocab(sentences, min_freq=10)
f'vocab size: {len(vocab)}'
</code></pre>
<h2 id="subsampling"><a class="header" href="#subsampling">Subsampling</a></h2>
<p>Text data
typically have high-frequency words
such as "the", "a", and "in":
they may even occur billions of times in
very large corpora.
However,
these words often co-occur
with many different words in
context windows, providing little useful signals.
For instance,
consider the word "chip" in a context window:
intuitively
its co-occurrence with a low-frequency word "intel"
is more useful in training
than
the co-occurrence with a high-frequency word "a".
Moreover, training with vast amounts of (high-frequency) words
is slow.
Thus, when training word embedding models,
high-frequency words can be <em>subsampled</em> :cite:<code>Mikolov.Sutskever.Chen.ea.2013</code>.
Specifically,
each indexed word $w_i$
in the dataset will be discarded with probability</p>
<p>$$ P(w_i) = \max\left(1 - \sqrt{\frac{t}{f(w_i)}}, 0\right),$$</p>
<p>where $f(w_i)$ is the ratio of
the number of words $w_i$
to the total number of words in the dataset,
and the constant $t$ is a hyperparameter
($10^{-4}$ in the experiment).
We can see that only when
the relative frequency
$f(w_i) &gt; t$  can the (high-frequency) word $w_i$ be discarded,
and the higher the relative frequency of the word,
the greater the probability of being discarded.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def subsample(sentences, vocab):
    """Subsample high-frequency words."""
    # Exclude unknown tokens ('&lt;unk&gt;')
    sentences = [[token for token in line if vocab[token] != vocab.unk]
                 for line in sentences]
    counter = collections.Counter([
        token for line in sentences for token in line])
    num_tokens = sum(counter.values())

    # Return True if `token` is kept during subsampling
    def keep(token):
        return(random.uniform(0, 1) &lt;
               math.sqrt(1e-4 / counter[token] * num_tokens))

    return ([[token for token in line if keep(token)] for line in sentences],
            counter)

subsampled, counter = subsample(sentences, vocab)
</code></pre>
<p>The following code snippet
plots the histogram of
the number of tokens per sentence
before and after subsampling.
As expected,
subsampling significantly shortens sentences
by dropping high-frequency words,
which will lead to training speedup.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.show_list_len_pair_hist(['origin', 'subsampled'], '# tokens per sentence',
                            'count', sentences, subsampled);
</code></pre>
<p>For individual tokens, the sampling rate of the high-frequency word "the" is less than 1/20.</p>
<pre><code class="language-{.python .input}">#@tab all
def compare_counts(token):
    return (f'# of "{token}": '
            f'before={sum([l.count(token) for l in sentences])}, '
            f'after={sum([l.count(token) for l in subsampled])}')

compare_counts('the')
</code></pre>
<p>In contrast,
low-frequency words "join" are completely kept.</p>
<pre><code class="language-{.python .input}">#@tab all
compare_counts('join')
</code></pre>
<p>After subsampling, we map tokens to their indices for the corpus.</p>
<pre><code class="language-{.python .input}">#@tab all
corpus = [vocab[line] for line in subsampled]
corpus[:3]
</code></pre>
<h2 id="extracting-center-words-and-context-words"><a class="header" href="#extracting-center-words-and-context-words">Extracting Center Words and Context Words</a></h2>
<p>The following <code>get_centers_and_contexts</code>
function extracts all the
center words and their context words
from <code>corpus</code>.
It uniformly samples an integer between 1 and <code>max_window_size</code>
at random as the context window size.
For any center word,
those words
whose distance from it
does not exceed the sampled
context window size
are its context words.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def get_centers_and_contexts(corpus, max_window_size):
    """Return center words and context words in skip-gram."""
    centers, contexts = [], []
    for line in corpus:
        # To form a "center word--context word" pair, each sentence needs to
        # have at least 2 words
        if len(line) &lt; 2:
            continue
        centers += line
        for i in range(len(line)):  # Context window centered at `i`
            window_size = random.randint(1, max_window_size)
            indices = list(range(max(0, i - window_size),
                                 min(len(line), i + 1 + window_size)))
            # Exclude the center word from the context words
            indices.remove(i)
            contexts.append([line[idx] for idx in indices])
    return centers, contexts
</code></pre>
<p>Next, we create an artificial dataset containing two sentences of 7 and 3 words, respectively.
Let the maximum context window size be 2
and print all the center words and their context words.</p>
<pre><code class="language-{.python .input}">#@tab all
tiny_dataset = [list(range(7)), list(range(7, 10))]
print('dataset', tiny_dataset)
for center, context in zip(*get_centers_and_contexts(tiny_dataset, 2)):
    print('center', center, 'has contexts', context)
</code></pre>
<p>When training on the PTB dataset,
we set the maximum context window size to 5.
The following extracts all the center words and their context words in the dataset.</p>
<pre><code class="language-{.python .input}">#@tab all
all_centers, all_contexts = get_centers_and_contexts(corpus, 5)
f'# center-context pairs: {sum([len(contexts) for contexts in all_contexts])}'
</code></pre>
<h2 id="negative-sampling-1"><a class="header" href="#negative-sampling-1">Negative Sampling</a></h2>
<p>We use negative sampling for approximate training.
To sample noise words according to
a predefined distribution,
we define the following <code>RandomGenerator</code> class,
where the (possibly unnormalized) sampling distribution is passed
via the argument <code>sampling_weights</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
class RandomGenerator:
    """Randomly draw among {1, ..., n} according to n sampling weights."""
    def __init__(self, sampling_weights):
        # Exclude 
        self.population = list(range(1, len(sampling_weights) + 1))
        self.sampling_weights = sampling_weights
        self.candidates = []
        self.i = 0

    def draw(self):
        if self.i == len(self.candidates):
            # Cache `k` random sampling results
            self.candidates = random.choices(
                self.population, self.sampling_weights, k=10000)
            self.i = 0
        self.i += 1
        return self.candidates[self.i - 1]
</code></pre>
<p>For example,
we can draw 10 random variables $X$
among indices 1, 2, and 3
with sampling probabilities $P(X=1)=2/9, P(X=2)=3/9$, and $P(X=3)=4/9$ as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
generator = RandomGenerator([2, 3, 4])
[generator.draw() for _ in range(10)]
</code></pre>
<p>For a pair of center word and context word,
we randomly sample <code>K</code> (5 in the experiment) noise words. According to the suggestions in the word2vec paper,
the sampling probability $P(w)$ of
a noise word $w$
is
set to its relative frequency
in the dictionary
raised to
the power of 0.75 :cite:<code>Mikolov.Sutskever.Chen.ea.2013</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def get_negatives(all_contexts, vocab, counter, K):
    """Return noise words in negative sampling."""
    # Sampling weights for words with indices 1, 2, ... (index 0 is the
    # excluded unknown token) in the vocabulary
    sampling_weights = [counter[vocab.to_tokens(i)]**0.75
                        for i in range(1, len(vocab))]
    all_negatives, generator = [], RandomGenerator(sampling_weights)
    for contexts in all_contexts:
        negatives = []
        while len(negatives) &lt; len(contexts) * K:
            neg = generator.draw()
            # Noise words cannot be context words
            if neg not in contexts:
                negatives.append(neg)
        all_negatives.append(negatives)
    return all_negatives

all_negatives = get_negatives(all_contexts, vocab, counter, 5)
</code></pre>
<h2 id="loading-training-examples-in-minibatches"><a class="header" href="#loading-training-examples-in-minibatches">Loading Training Examples in Minibatches</a></h2>
<p>:label:<code>subsec_word2vec-minibatch-loading</code></p>
<p>After
all the center words
together with their
context words and sampled noise words are extracted,
they will be transformed into
minibatches of examples
that can be iteratively loaded
during training.</p>
<p>In a minibatch,
the $i^\textrm{th}$ example includes a center word
and its $n_i$ context words and $m_i$ noise words.
Due to varying context window sizes,
$n_i+m_i$ varies for different $i$.
Thus,
for each example
we concatenate its context words and noise words in
the <code>contexts_negatives</code> variable,
and pad zeros until the concatenation length
reaches $\max_i n_i+m_i$ (<code>max_len</code>).
To exclude paddings
in the calculation of the loss,
we define a mask variable <code>masks</code>.
There is a one-to-one correspondence
between elements in <code>masks</code> and elements in <code>contexts_negatives</code>,
where zeros (otherwise ones) in <code>masks</code> correspond to paddings in <code>contexts_negatives</code>.</p>
<p>To distinguish between positive and negative examples,
we separate context words from noise words in  <code>contexts_negatives</code> via a <code>labels</code> variable.
Similar to <code>masks</code>,
there is also a one-to-one correspondence
between elements in <code>labels</code> and elements in <code>contexts_negatives</code>,
where ones (otherwise zeros) in <code>labels</code> correspond to context words (positive examples) in <code>contexts_negatives</code>.</p>
<p>The above idea is implemented in the following <code>batchify</code> function.
Its input <code>data</code> is a list with length
equal to the batch size,
where each element is an example
consisting of
the center word <code>center</code>, its context words <code>context</code>, and its noise words <code>negative</code>.
This function returns
a minibatch that can be loaded for calculations
during training,
such as including the mask variable.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def batchify(data):
    """Return a minibatch of examples for skip-gram with negative sampling."""
    max_len = max(len(c) + len(n) for _, c, n in data)
    centers, contexts_negatives, masks, labels = [], [], [], []
    for center, context, negative in data:
        cur_len = len(context) + len(negative)
        centers += [center]
        contexts_negatives += [context + negative + [0] * (max_len - cur_len)]
        masks += [[1] * cur_len + [0] * (max_len - cur_len)]
        labels += [[1] * len(context) + [0] * (max_len - len(context))]
    return (d2l.reshape(d2l.tensor(centers), (-1, 1)), d2l.tensor(
        contexts_negatives), d2l.tensor(masks), d2l.tensor(labels))
</code></pre>
<p>Let's test this function using a minibatch of two examples.</p>
<pre><code class="language-{.python .input}">#@tab all
x_1 = (1, [2, 2], [3, 3, 3, 3])
x_2 = (1, [2, 2, 2], [3, 3])
batch = batchify((x_1, x_2))

names = ['centers', 'contexts_negatives', 'masks', 'labels']
for name, data in zip(names, batch):
    print(name, '=', data)
</code></pre>
<h2 id="putting-it-all-together-3"><a class="header" href="#putting-it-all-together-3">Putting It All Together</a></h2>
<p>Last, we define the <code>load_data_ptb</code> function that reads the PTB dataset and returns the data iterator and the vocabulary.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_ptb(batch_size, max_window_size, num_noise_words):
    """Download the PTB dataset and then load it into memory."""
    sentences = read_ptb()
    vocab = d2l.Vocab(sentences, min_freq=10)
    subsampled, counter = subsample(sentences, vocab)
    corpus = [vocab[line] for line in subsampled]
    all_centers, all_contexts = get_centers_and_contexts(
        corpus, max_window_size)
    all_negatives = get_negatives(
        all_contexts, vocab, counter, num_noise_words)
    dataset = gluon.data.ArrayDataset(
        all_centers, all_contexts, all_negatives)
    data_iter = gluon.data.DataLoader(
        dataset, batch_size, shuffle=True,batchify_fn=batchify,
        num_workers=d2l.get_dataloader_workers())
    return data_iter, vocab
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_ptb(batch_size, max_window_size, num_noise_words):
    """Download the PTB dataset and then load it into memory."""
    num_workers = d2l.get_dataloader_workers()
    sentences = read_ptb()
    vocab = d2l.Vocab(sentences, min_freq=10)
    subsampled, counter = subsample(sentences, vocab)
    corpus = [vocab[line] for line in subsampled]
    all_centers, all_contexts = get_centers_and_contexts(
        corpus, max_window_size)
    all_negatives = get_negatives(
        all_contexts, vocab, counter, num_noise_words)

    class PTBDataset(torch.utils.data.Dataset):
        def __init__(self, centers, contexts, negatives):
            assert len(centers) == len(contexts) == len(negatives)
            self.centers = centers
            self.contexts = contexts
            self.negatives = negatives

        def __getitem__(self, index):
            return (self.centers[index], self.contexts[index],
                    self.negatives[index])

        def __len__(self):
            return len(self.centers)

    dataset = PTBDataset(all_centers, all_contexts, all_negatives)

    data_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=True,
                                      collate_fn=batchify,
                                      num_workers=num_workers)
    return data_iter, vocab
</code></pre>
<p>Let's print the first minibatch of the data iterator.</p>
<pre><code class="language-{.python .input}">#@tab all
data_iter, vocab = load_data_ptb(512, 5, 5)
for batch in data_iter:
    for name, data in zip(names, batch):
        print(name, 'shape:', data.shape)
    break
</code></pre>
<h2 id="summary-88"><a class="header" href="#summary-88">Summary</a></h2>
<ul>
<li>High-frequency words may not be so useful in training. We can subsample them for speedup in training.</li>
<li>For computational efficiency, we load examples in minibatches. We can define other variables to distinguish paddings from non-paddings, and positive examples from negative ones.</li>
</ul>
<h2 id="exercises-108"><a class="header" href="#exercises-108">Exercises</a></h2>
<ol>
<li>How does the running time of code in this section changes if not using subsampling?</li>
<li>The <code>RandomGenerator</code> class caches <code>k</code> random sampling results. Set <code>k</code> to other values and see how it affects the data loading speed.</li>
<li>What other hyperparameters in the code of this section may affect the data loading speed?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/383">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1330">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretraining-word2vec"><a class="header" href="#pretraining-word2vec">Pretraining word2vec</a></h1>
<p>:label:<code>sec_word2vec_pretraining</code></p>
<p>We go on to implement the skip-gram
model defined in
:numref:<code>sec_word2vec</code>.
Then
we will pretrain word2vec using negative sampling
on the PTB dataset.
First of all,
let's obtain the data iterator
and the vocabulary for this dataset
by calling the <code>d2l.load_data_ptb</code>
function, which was described in :numref:<code>sec_word2vec_data</code></p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
import math
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
npx.set_np()

batch_size, max_window_size, num_noise_words = 512, 5, 5
data_iter, vocab = d2l.load_data_ptb(batch_size, max_window_size,
                                     num_noise_words)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import math
import torch
from torch import nn

batch_size, max_window_size, num_noise_words = 512, 5, 5
data_iter, vocab = d2l.load_data_ptb(batch_size, max_window_size,
                                     num_noise_words)
</code></pre>
<h2 id="the-skip-gram-model-1"><a class="header" href="#the-skip-gram-model-1">The Skip-Gram Model</a></h2>
<p>We implement the skip-gram model
by using embedding layers and batch matrix multiplications.
First, let's review
how embedding layers work.</p>
<h3 id="embedding-layer"><a class="header" href="#embedding-layer">Embedding Layer</a></h3>
<p>As described in :numref:<code>sec_seq2seq</code>,
an embedding layer
maps a token's index to its feature vector.
The weight of this layer
is a matrix whose number of rows equals to
the dictionary size (<code>input_dim</code>) and
number of columns equals to
the vector dimension for each token (<code>output_dim</code>).
After a word embedding model is trained,
this weight is what we need.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
embed = nn.Embedding(input_dim=20, output_dim=4)
embed.initialize()
embed.weight
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
embed = nn.Embedding(num_embeddings=20, embedding_dim=4)
print(f'Parameter embedding_weight ({embed.weight.shape}, '
      f'dtype={embed.weight.dtype})')
</code></pre>
<p>The input of an embedding layer is the
index of a token (word).
For any token index $i$,
its vector representation
can be obtained from
the $i^\textrm{th}$ row of the weight matrix
in the embedding layer.
Since the vector dimension (<code>output_dim</code>)
was set to 4,
the embedding layer
returns vectors with shape (2, 3, 4)
for a minibatch of token indices with shape
(2, 3).</p>
<pre><code class="language-{.python .input}">#@tab all
x = d2l.tensor([[1, 2, 3], [4, 5, 6]])
embed(x)
</code></pre>
<h3 id="defining-the-forward-propagation"><a class="header" href="#defining-the-forward-propagation">Defining the Forward Propagation</a></h3>
<p>In the forward propagation,
the input of the skip-gram model
includes
the center word indices <code>center</code>
of shape (batch size, 1)
and
the concatenated context and noise word indices <code>contexts_and_negatives</code>
of shape (batch size, <code>max_len</code>),
where <code>max_len</code>
is defined
in :numref:<code>subsec_word2vec-minibatch-loading</code>.
These two variables are first transformed from the
token indices into vectors via the embedding layer,
then their batch matrix multiplication
(described in :numref:<code>subsec_batch_dot</code>)
returns
an output of shape (batch size, 1, <code>max_len</code>).
Each element in the output is the dot product of
a center word vector and a context or noise word vector.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def skip_gram(center, contexts_and_negatives, embed_v, embed_u):
    v = embed_v(center)
    u = embed_u(contexts_and_negatives)
    pred = npx.batch_dot(v, u.swapaxes(1, 2))
    return pred
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def skip_gram(center, contexts_and_negatives, embed_v, embed_u):
    v = embed_v(center)
    u = embed_u(contexts_and_negatives)
    pred = torch.bmm(v, u.permute(0, 2, 1))
    return pred
</code></pre>
<p>Let's print the output shape of this <code>skip_gram</code> function for some example inputs.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
skip_gram(np.ones((2, 1)), np.ones((2, 4)), embed, embed).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
skip_gram(torch.ones((2, 1), dtype=torch.long),
          torch.ones((2, 4), dtype=torch.long), embed, embed).shape
</code></pre>
<h2 id="training-30"><a class="header" href="#training-30">Training</a></h2>
<p>Before training the skip-gram model with negative sampling,
let's first define its loss function.</p>
<h3 id="binary-cross-entropy-loss"><a class="header" href="#binary-cross-entropy-loss">Binary Cross-Entropy Loss</a></h3>
<p>According to the definition of the loss function
for negative sampling in :numref:<code>subsec_negative-sampling</code>,
we will use
the binary cross-entropy loss.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
loss = gluon.loss.SigmoidBCELoss()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class SigmoidBCELoss(nn.Module):
    # Binary cross-entropy loss with masking
    def __init__(self):
        super().__init__()

    def forward(self, inputs, target, mask=None):
        out = nn.functional.binary_cross_entropy_with_logits(
            inputs, target, weight=mask, reduction="none")
        return out.mean(dim=1)

loss = SigmoidBCELoss()
</code></pre>
<p>Recall our descriptions
of the mask variable
and the label variable in
:numref:<code>subsec_word2vec-minibatch-loading</code>.
The following
calculates the
binary cross-entropy loss
for the given variables.</p>
<pre><code class="language-{.python .input}">#@tab all
pred = d2l.tensor([[1.1, -2.2, 3.3, -4.4]] * 2)
label = d2l.tensor([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])
mask = d2l.tensor([[1, 1, 1, 1], [1, 1, 0, 0]])
loss(pred, label, mask) * mask.shape[1] / mask.sum(axis=1)
</code></pre>
<p>Below shows
how the above results are calculated
(in a less efficient way)
using the
sigmoid activation function
in the binary cross-entropy loss.
We can consider
the two outputs as
two normalized losses
that are averaged over non-masked predictions.</p>
<pre><code class="language-{.python .input}">#@tab all
def sigmd(x):
    return -math.log(1 / (1 + math.exp(-x)))

print(f'{(sigmd(1.1) + sigmd(2.2) + sigmd(-3.3) + sigmd(4.4)) / 4:.4f}')
print(f'{(sigmd(-1.1) + sigmd(-2.2)) / 2:.4f}')
</code></pre>
<h3 id="initializing-model-parameters-3"><a class="header" href="#initializing-model-parameters-3">Initializing Model Parameters</a></h3>
<p>We define two embedding layers
for all the words in the vocabulary
when they are used as center words
and context words, respectively.
The word vector dimension
<code>embed_size</code> is set to 100.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
embed_size = 100
net = nn.Sequential()
net.add(nn.Embedding(input_dim=len(vocab), output_dim=embed_size),
        nn.Embedding(input_dim=len(vocab), output_dim=embed_size))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
embed_size = 100
net = nn.Sequential(nn.Embedding(num_embeddings=len(vocab),
                                 embedding_dim=embed_size),
                    nn.Embedding(num_embeddings=len(vocab),
                                 embedding_dim=embed_size))
</code></pre>
<h3 id="defining-the-training-loop"><a class="header" href="#defining-the-training-loop">Defining the Training Loop</a></h3>
<p>The training loop is defined below. Because of the existence of padding, the calculation of the loss function is slightly different compared to the previous training functions.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(net, data_iter, lr, num_epochs, device=d2l.try_gpu()):
    net.initialize(ctx=device, force_reinit=True)
    trainer = gluon.Trainer(net.collect_params(), 'adam',
                            {'learning_rate': lr})
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs])
    # Sum of normalized losses, no. of normalized losses
    metric = d2l.Accumulator(2)
    for epoch in range(num_epochs):
        timer, num_batches = d2l.Timer(), len(data_iter)
        for i, batch in enumerate(data_iter):
            center, context_negative, mask, label = [
                data.as_in_ctx(device) for data in batch]
            with autograd.record():
                pred = skip_gram(center, context_negative, net[0], net[1])
                l = (loss(pred.reshape(label.shape), label, mask) *
                     mask.shape[1] / mask.sum(axis=1))
            l.backward()
            trainer.step(batch_size)
            metric.add(l.sum(), l.size)
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[1],))
    print(f'loss {metric[0] / metric[1]:.3f}, '
          f'{metric[1] / timer.stop():.1f} tokens/sec on {str(device)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net, data_iter, lr, num_epochs, device=d2l.try_gpu()):
    def init_weights(module):
        if type(module) == nn.Embedding:
            nn.init.xavier_uniform_(module.weight)
    net.apply(init_weights)
    net = net.to(device)
    optimizer = torch.optim.Adam(net.parameters(), lr=lr)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs])
    # Sum of normalized losses, no. of normalized losses
    metric = d2l.Accumulator(2)
    for epoch in range(num_epochs):
        timer, num_batches = d2l.Timer(), len(data_iter)
        for i, batch in enumerate(data_iter):
            optimizer.zero_grad()
            center, context_negative, mask, label = [
                data.to(device) for data in batch]

            pred = skip_gram(center, context_negative, net[0], net[1])
            l = (loss(pred.reshape(label.shape).float(), label.float(), mask)
                     / mask.sum(axis=1) * mask.shape[1])
            l.sum().backward()
            optimizer.step()
            metric.add(l.sum(), l.numel())
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (metric[0] / metric[1],))
    print(f'loss {metric[0] / metric[1]:.3f}, '
          f'{metric[1] / timer.stop():.1f} tokens/sec on {str(device)}')
</code></pre>
<p>Now we can train a skip-gram model using negative sampling.</p>
<pre><code class="language-{.python .input}">#@tab all
lr, num_epochs = 0.002, 5
train(net, data_iter, lr, num_epochs)
</code></pre>
<h2 id="applying-word-embeddings"><a class="header" href="#applying-word-embeddings">Applying Word Embeddings</a></h2>
<p>:label:<code>subsec_apply-word-embed</code></p>
<p>After training the word2vec model,
we can use the cosine similarity
of word vectors from the trained model
to
find words from the dictionary
that are most semantically similar
to an input word.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_similar_tokens(query_token, k, embed):
    W = embed.weight.data()
    x = W[vocab[query_token]]
    # Compute the cosine similarity. Add 1e-9 for numerical stability
    cos = np.dot(W, x) / np.sqrt(np.sum(W * W, axis=1) * np.sum(x * x) + 1e-9)
    topk = npx.topk(cos, k=k+1, ret_typ='indices').asnumpy().astype('int32')
    for i in topk[1:]:  # Remove the input words
        print(f'cosine sim={float(cos[i]):.3f}: {vocab.to_tokens(i)}')

get_similar_tokens('chip', 3, net[0])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_similar_tokens(query_token, k, embed):
    W = embed.weight.data
    x = W[vocab[query_token]]
    # Compute the cosine similarity. Add 1e-9 for numerical stability
    cos = torch.mv(W, x) / torch.sqrt(torch.sum(W * W, dim=1) *
                                      torch.sum(x * x) + 1e-9)
    topk = torch.topk(cos, k=k+1)[1].cpu().numpy().astype('int32')
    for i in topk[1:]:  # Remove the input words
        print(f'cosine sim={float(cos[i]):.3f}: {vocab.to_tokens(i)}')

get_similar_tokens('chip', 3, net[0])
</code></pre>
<h2 id="summary-89"><a class="header" href="#summary-89">Summary</a></h2>
<ul>
<li>We can train a skip-gram model with negative sampling using embedding layers and the binary cross-entropy loss.</li>
<li>Applications of word embeddings include finding semantically similar words for a given word based on the cosine similarity of word vectors.</li>
</ul>
<h2 id="exercises-109"><a class="header" href="#exercises-109">Exercises</a></h2>
<ol>
<li>Using the trained model, find semantically similar words for other input words. Can you improve the results by tuning hyperparameters?</li>
<li>When a training corpus is huge, we often sample context words and noise words for the center words in the current minibatch <em>when updating model parameters</em>. In other words, the same center word may have different context words or noise words in different training epochs. What are the benefits of this method? Try to implement this training method.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/384">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1335">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="word-embedding-with-global-vectors-glove"><a class="header" href="#word-embedding-with-global-vectors-glove">Word Embedding with Global Vectors (GloVe)</a></h1>
<p>:label:<code>sec_glove</code></p>
<p>Word-word co-occurrences
within context windows
may carry rich semantic information.
For example,
in a large corpus
word "solid" is
more likely to co-occur
with "ice" than "steam",
but word "gas"
probably co-occurs with "steam"
more frequently than "ice".
Besides,
global corpus statistics
of such co-occurrences
can be precomputed:
this can lead to more efficient training.
To leverage statistical
information in the entire corpus
for word embedding,
let's first revisit
the skip-gram model in :numref:<code>subsec_skip-gram</code>,
but interpreting it
using global corpus statistics
such as co-occurrence counts.</p>
<h2 id="skip-gram-with-global-corpus-statistics"><a class="header" href="#skip-gram-with-global-corpus-statistics">Skip-Gram with Global Corpus Statistics</a></h2>
<p>:label:<code>subsec_skipgram-global</code></p>
<p>Denoting by $q_{ij}$
the conditional probability
$P(w_j\mid w_i)$
of word $w_j$ given word $w_i$
in the skip-gram model,
we have</p>
<p>$$q_{ij}=\frac{\exp(\mathbf{u}_j^\top \mathbf{v}<em>i)}{ \sum</em>{k \in \mathcal{V}} \exp(\mathbf{u}_k^\top \mathbf{v}_i)},$$</p>
<p>where
for any index $i$
vectors $\mathbf{v}_i$ and $\mathbf{u}_i$
represent word $w_i$
as the center word and context word,
respectively, and $\mathcal{V} = {0, 1, \ldots, |\mathcal{V}|-1}$
is the index set of the vocabulary.</p>
<p>Consider word $w_i$
that may occur multiple times
in the corpus.
In the entire corpus,
all the context words
wherever $w_i$ is taken as their center word
form a <em>multiset</em> $\mathcal{C}_i$
of word indices
that <em>allows for multiple instances of the same element</em>.
For any element,
its number of instances is called its <em>multiplicity</em>.
To illustrate with an example,
suppose that word $w_i$ occurs twice in the corpus
and indices of the context words
that take $w_i$ as their center word
in the two context windows
are
$k, j, m, k$ and $k, l, k, j$.
Thus, multiset $\mathcal{C}_i = {j, j, k, k, k, k, l, m}$, where
multiplicities of elements $j, k, l, m$
are 2, 4, 1, 1, respectively.</p>
<p>Now let's denote the multiplicity of element $j$ in
multiset $\mathcal{C}<em>i$ as $x</em>{ij}$.
This is the global co-occurrence count
of word $w_j$ (as the context word)
and word $w_i$ (as the center word)
in the same context window
in the entire corpus.
Using such global corpus statistics,
the loss function of the skip-gram model
is equivalent to</p>
<p>$$-\sum_{i\in\mathcal{V}}\sum_{j\in\mathcal{V}} x_{ij} \log,q_{ij}.$$
:eqlabel:<code>eq_skipgram-x_ij</code></p>
<p>We further denote by
$x_i$
the number of all the context words
in the context windows
where $w_i$ occurs as their center word,
which is equivalent to $|\mathcal{C}<em>i|$.
Letting $p</em>{ij}$
be the conditional probability
$x_{ij}/x_i$ for generating
context word $w_j$ given center word $w_i$,
:eqref:<code>eq_skipgram-x_ij</code>
can be rewritten as</p>
<p>$$-\sum_{i\in\mathcal{V}} x_i \sum_{j\in\mathcal{V}} p_{ij} \log,q_{ij}.$$
:eqlabel:<code>eq_skipgram-p_ij</code></p>
<p>In :eqref:<code>eq_skipgram-p_ij</code>, $-\sum_{j\in\mathcal{V}} p_{ij} \log,q_{ij}$ calculates
the cross-entropy
of
the conditional distribution $p_{ij}$
of global corpus statistics
and
the
conditional distribution $q_{ij}$
of model predictions.
This loss
is also weighted by $x_i$ as explained above.
Minimizing the loss function in
:eqref:<code>eq_skipgram-p_ij</code>
will allow
the predicted conditional distribution
to get close to
the conditional distribution
from the global corpus statistics.</p>
<p>Though being commonly used
for measuring the distance
between probability distributions,
the cross-entropy loss function may not be a good choice here.
On the one hand, as we mentioned in :numref:<code>sec_approx_train</code>,
the cost of properly normalizing $q_{ij}$
results in the sum over the entire vocabulary,
which can be computationally expensive.
On the other hand,
a large number of rare
events from a large corpus
are often modeled by the cross-entropy loss
to be assigned with
too much weight.</p>
<h2 id="the-glove-model"><a class="header" href="#the-glove-model">The GloVe Model</a></h2>
<p>In view of this,
the <em>GloVe</em> model makes three changes
to the skip-gram model based on squared loss :cite:<code>Pennington.Socher.Manning.2014</code>:</p>
<ol>
<li>Use variables $p'<em>{ij}=x</em>{ij}$ and $q'_{ij}=\exp(\mathbf{u}<em>j^\top \mathbf{v}<em>i)$
that are not probability distributions
and take the logarithm of both, so the squared loss term is $\left(\log,p'</em>{ij} - \log,q'</em>{ij}\right)^2 = \left(\mathbf{u}_j^\top \mathbf{v}<em>i - \log,x</em>{ij}\right)^2$.</li>
<li>Add two scalar model parameters for each word $w_i$: the center word bias $b_i$ and the context word bias $c_i$.</li>
<li>Replace the weight of each loss term with the weight function $h(x_{ij})$, where $h(x)$ is increasing in the interval of $[0, 1]$.</li>
</ol>
<p>Putting all things together, training GloVe is to minimize the following loss function:</p>
<p>$$\sum_{i\in\mathcal{V}} \sum_{j\in\mathcal{V}} h(x_{ij}) \left(\mathbf{u}_j^\top \mathbf{v}<em>i + b_i + c_j - \log,x</em>{ij}\right)^2.$$
:eqlabel:<code>eq_glove-loss</code></p>
<p>For the weight function, a suggested choice is:
$h(x) = (x/c) ^\alpha$ (e.g $\alpha = 0.75$) if $x &lt; c$ (e.g., $c = 100$); otherwise $h(x) = 1$.
In this case,
because $h(0)=0$,
the squared loss term for any $x_{ij}=0$ can be omitted
for computational efficiency.
For example,
when using minibatch stochastic gradient descent for training,
at each iteration
we randomly sample a minibatch of <em>non-zero</em> $x_{ij}$
to calculate gradients
and update the model parameters.
Note that these non-zero $x_{ij}$ are precomputed
global corpus statistics;
thus, the model is called GloVe
for <em>Global Vectors</em>.</p>
<p>It should be emphasized that
if word $w_i$ appears in the context window of
word $w_j$, then <em>vice versa</em>.
Therefore, $x_{ij}=x_{ji}$.
Unlike word2vec
that fits the asymmetric conditional probability
$p_{ij}$,
GloVe fits the symmetric $\log , x_{ij}$.
Therefore, the center word vector and
the context word vector of any word are mathematically equivalent in the GloVe model.
However in practice, owing to different initialization values,
the same word may still get different values
in these two vectors after training:
GloVe sums them up as the output vector.</p>
<h2 id="interpreting-glove-from-the-ratio-of-co-occurrence-probabilities"><a class="header" href="#interpreting-glove-from-the-ratio-of-co-occurrence-probabilities">Interpreting GloVe from the Ratio of Co-occurrence Probabilities</a></h2>
<p>We can also interpret the GloVe model from another perspective.
Using the same notation in
:numref:<code>subsec_skipgram-global</code>,
let $p_{ij} \stackrel{\textrm{def}}{=} P(w_j \mid w_i)$ be the conditional probability of generating the context word $w_j$ given $w_i$ as the center word in the corpus.
:numref:<code>tab_glove</code>
lists several co-occurrence probabilities
given words "ice" and "steam"
and their ratios based on  statistics from a large corpus.</p>
<p>:Word-word co-occurrence probabilities and their ratios from a large corpus (adapted from Table 1 in :citet:<code>Pennington.Socher.Manning.2014</code>)
:label:<code>tab_glove</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">$w_k$=</th><th style="text-align: left">solid</th><th style="text-align: left">gas</th><th style="text-align: left">water</th><th style="text-align: left">fashion</th></tr></thead><tbody>
<tr><td style="text-align: left">$p_1=P(w_k\mid \textrm{ice})$</td><td style="text-align: left">0.00019</td><td style="text-align: left">0.000066</td><td style="text-align: left">0.003</td><td style="text-align: left">0.000017</td></tr>
<tr><td style="text-align: left">$p_2=P(w_k\mid\textrm{steam})$</td><td style="text-align: left">0.000022</td><td style="text-align: left">0.00078</td><td style="text-align: left">0.0022</td><td style="text-align: left">0.000018</td></tr>
<tr><td style="text-align: left">$p_1/p_2$</td><td style="text-align: left">8.9</td><td style="text-align: left">0.085</td><td style="text-align: left">1.36</td><td style="text-align: left">0.96</td></tr>
</tbody></table>
</div>
<p>We can observe the following from :numref:<code>tab_glove</code>:</p>
<ul>
<li>For a word $w_k$ that is related to "ice" but unrelated to "steam", such as $w_k=\textrm{solid}$, we expect a larger ratio of co-occurence probabilities, such as 8.9.</li>
<li>For a word $w_k$ that is related to "steam" but unrelated to "ice", such as $w_k=\textrm{gas}$, we expect a smaller ratio of co-occurence probabilities, such as 0.085.</li>
<li>For a word $w_k$ that is related to both "ice" and "steam", such as $w_k=\textrm{water}$, we expect a ratio of co-occurence probabilities that is close to 1, such as 1.36.</li>
<li>For a word $w_k$ that is unrelated to both "ice" and "steam", such as $w_k=\textrm{fashion}$, we expect a ratio of co-occurence probabilities that is close to 1, such as 0.96.</li>
</ul>
<p>It can be seen that the ratio
of co-occurrence probabilities
can intuitively express
the relationship between words.
Thus, we can design a function
of three word vectors
to fit this ratio.
For the ratio of co-occurrence probabilities
${p_{ij}}/{p_{ik}}$
with $w_i$ being the center word
and $w_j$ and $w_k$ being the context words,
we want to fit this ratio
using some function $f$:</p>
<p>$$f(\mathbf{u}_j, \mathbf{u}<em>k, {\mathbf{v}}<em>i) \approx \frac{p</em>{ij}}{p</em>{ik}}.$$
:eqlabel:<code>eq_glove-f</code></p>
<p>Among many possible designs for $f$,
we only pick a reasonable choice in the following.
Since the ratio of co-occurrence probabilities
is a scalar,
we require that
$f$ be a scalar function, such as
$f(\mathbf{u}_j, \mathbf{u}_k, {\mathbf{v}}_i) = f\left((\mathbf{u}_j - \mathbf{u}_k)^\top {\mathbf{v}}_i\right)$.
Switching word indices
$j$ and $k$ in :eqref:<code>eq_glove-f</code>,
it must hold that
$f(x)f(-x)=1$,
so one possibility is $f(x)=\exp(x)$,
i.e.,</p>
<p>$$f(\mathbf{u}_j, \mathbf{u}_k, {\mathbf{v}}_i) = \frac{\exp\left(\mathbf{u}_j^\top {\mathbf{v}}_i\right)}{\exp\left(\mathbf{u}<em>k^\top {\mathbf{v}}<em>i\right)} \approx \frac{p</em>{ij}}{p</em>{ik}}.$$</p>
<p>Now let's pick
$\exp\left(\mathbf{u}<em>j^\top {\mathbf{v}}<em>i\right) \approx \alpha p</em>{ij}$,
where $\alpha$ is a constant.
Since $p</em>{ij}=x_{ij}/x_i$, after taking the logarithm on both sides we get $\mathbf{u}_j^\top {\mathbf{v}}<em>i \approx \log,\alpha + \log,x</em>{ij} - \log,x_i$.
We may use additional bias terms to fit $- \log, \alpha + \log, x_i$, such as the center word bias $b_i$ and the context word bias $c_j$:</p>
<p>$$\mathbf{u}_j^\top \mathbf{v}<em>i + b_i + c_j \approx \log, x</em>{ij}.$$
:eqlabel:<code>eq_glove-square</code></p>
<p>Measuring the squared error of
:eqref:<code>eq_glove-square</code> with weights,
the GloVe loss function in
:eqref:<code>eq_glove-loss</code> is obtained.</p>
<h2 id="summary-90"><a class="header" href="#summary-90">Summary</a></h2>
<ul>
<li>The skip-gram model can be interpreted using global corpus statistics such as word-word co-occurrence counts.</li>
<li>The cross-entropy loss may not be a good choice for measuring the difference of two probability distributions, especially for a large corpus. GloVe uses squared loss to fit precomputed global corpus statistics.</li>
<li>The center word vector and the context word vector are mathematically equivalent for any word in GloVe.</li>
<li>GloVe can be interpreted from the ratio of word-word co-occurrence probabilities.</li>
</ul>
<h2 id="exercises-110"><a class="header" href="#exercises-110">Exercises</a></h2>
<ol>
<li>If words $w_i$ and $w_j$ co-occur in the same context window, how can we use their   distance in the text sequence to redesign the method for  calculating the conditional probability $p_{ij}$? Hint: see Section 4.2 of the GloVe paper :cite:<code>Pennington.Socher.Manning.2014</code>.</li>
<li>For any word, are its center word bias  and context word bias mathematically equivalent in GloVe? Why?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/385">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subword-embedding"><a class="header" href="#subword-embedding">Subword Embedding</a></h1>
<p>:label:<code>sec_fasttext</code></p>
<p>In English,
words such as
"helps", "helped", and "helping" are
inflected forms of the same word "help".
The relationship
between "dog" and "dogs"
is the same as
that between "cat" and "cats",
and
the relationship
between "boy" and "boyfriend"
is the same as
that between "girl" and "girlfriend".
In other languages
such as French and Spanish,
many verbs have over 40 inflected forms,
while in Finnish,
a noun may have up to 15 cases.
In linguistics,
morphology studies word formation and word relationships.
However,
the internal structure of words
was neither explored in word2vec
nor in GloVe.</p>
<h2 id="the-fasttext-model"><a class="header" href="#the-fasttext-model">The fastText Model</a></h2>
<p>Recall how words are represented in word2vec.
In both the skip-gram model
and the continuous bag-of-words model,
different inflected forms of the same word
are directly represented by different vectors
without shared parameters.
To use morphological information,
the <em>fastText</em> model
proposed a <em>subword embedding</em> approach,
where a subword is a character $n$-gram :cite:<code>Bojanowski.Grave.Joulin.ea.2017</code>.
Instead of learning word-level vector representations,
fastText can be considered as
the subword-level skip-gram,
where each <em>center word</em> is represented by the sum of
its subword vectors.</p>
<p>Let's illustrate how to obtain
subwords for each center word in fastText
using the word "where".
First, add special characters “&lt;” and “&gt;”
at the beginning and end of the word to distinguish prefixes and suffixes from other subwords.
Then, extract character $n$-grams from the word.
For example, when $n=3$,
we obtain all subwords of length 3: "&lt;wh", "whe", "her", "ere", "re&gt;", and the special subword "&lt;where&gt;".</p>
<p>In fastText, for any word $w$,
denote by $\mathcal{G}_w$
the union of all its subwords of length between 3 and 6
and its special subword.
The vocabulary
is the union of the subwords of all words.
Letting $\mathbf{z}_g$
be the vector of subword $g$ in the dictionary,
the vector $\mathbf{v}_w$ for
word $w$ as a center word
in the skip-gram model
is the sum of its subword vectors:</p>
<p>$$\mathbf{v}<em>w = \sum</em>{g\in\mathcal{G}_w} \mathbf{z}_g.$$</p>
<p>The rest of fastText is the same as the skip-gram model. Compared with the skip-gram model,
the vocabulary in fastText is larger,
resulting in more model parameters.
Besides,
to calculate the representation of a word,
all its subword vectors
have to be summed,
leading to higher computational complexity.
However,
thanks to shared parameters from subwords among words with similar structures,
rare words and even out-of-vocabulary words
may obtain better vector representations in fastText.</p>
<h2 id="byte-pair-encoding"><a class="header" href="#byte-pair-encoding">Byte Pair Encoding</a></h2>
<p>:label:<code>subsec_Byte_Pair_Encoding</code></p>
<p>In fastText, all the extracted subwords have to be of the specified lengths, such as $3$ to $6$, thus the vocabulary size cannot be predefined.
To allow for variable-length subwords in a fixed-size vocabulary,
we can apply a compression algorithm
called <em>byte pair encoding</em> (BPE) to extract subwords :cite:<code>Sennrich.Haddow.Birch.2015</code>.</p>
<p>Byte pair encoding performs a statistical analysis of the training dataset to discover common symbols within a word,
such as consecutive characters of arbitrary length.
Starting from symbols of length 1,
byte pair encoding iteratively merges the most frequent pair of consecutive symbols to produce new longer symbols.
Note that for efficiency, pairs crossing word boundaries are not considered.
In the end, we can use such symbols as subwords to segment words.
Byte pair encoding and its variants has been used for input representations in popular natural language processing pretraining models such as GPT-2 :cite:<code>Radford.Wu.Child.ea.2019</code> and RoBERTa :cite:<code>Liu.Ott.Goyal.ea.2019</code>.
In the following, we will illustrate how byte pair encoding works.</p>
<p>First, we initialize the vocabulary of symbols as all the English lowercase characters, a special end-of-word symbol <code>'_'</code>, and a special unknown symbol <code>'[UNK]'</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
import collections

symbols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
           'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
           '_', '[UNK]']
</code></pre>
<p>Since we do not consider symbol pairs that cross boundaries of words,
we only need a dictionary <code>raw_token_freqs</code> that maps words to their frequencies (number of occurrences)
in a dataset.
Note that the special symbol <code>'_'</code> is appended to each word so that
we can easily recover a word sequence (e.g., "a taller man")
from a sequence of output symbols ( e.g., "a_ tall er_ man").
Since we start the merging process from a vocabulary of only single characters and special symbols, space is inserted between every pair of consecutive characters within each word (keys of the dictionary <code>token_freqs</code>).
In other words, space is the delimiter between symbols within a word.</p>
<pre><code class="language-{.python .input}">#@tab all
raw_token_freqs = {'fast_': 4, 'faster_': 3, 'tall_': 5, 'taller_': 4}
token_freqs = {}
for token, freq in raw_token_freqs.items():
    token_freqs[' '.join(list(token))] = raw_token_freqs[token]
token_freqs
</code></pre>
<p>We define the following <code>get_max_freq_pair</code> function that
returns the most frequent pair of consecutive symbols within a word,
where words come from keys of the input dictionary <code>token_freqs</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def get_max_freq_pair(token_freqs):
    pairs = collections.defaultdict(int)
    for token, freq in token_freqs.items():
        symbols = token.split()
        for i in range(len(symbols) - 1):
            # Key of `pairs` is a tuple of two consecutive symbols
            pairs[symbols[i], symbols[i + 1]] += freq
    return max(pairs, key=pairs.get)  # Key of `pairs` with the max value
</code></pre>
<p>As a greedy approach based on frequency of consecutive symbols,
byte pair encoding will use the following <code>merge_symbols</code> function to merge the most frequent pair of consecutive symbols to produce new symbols.</p>
<pre><code class="language-{.python .input}">#@tab all
def merge_symbols(max_freq_pair, token_freqs, symbols):
    symbols.append(''.join(max_freq_pair))
    new_token_freqs = dict()
    for token, freq in token_freqs.items():
        new_token = token.replace(' '.join(max_freq_pair),
                                  ''.join(max_freq_pair))
        new_token_freqs[new_token] = token_freqs[token]
    return new_token_freqs
</code></pre>
<p>Now we iteratively perform the byte pair encoding algorithm over the keys of the dictionary <code>token_freqs</code>. In the first iteration, the most frequent pair of consecutive symbols are <code>'t'</code> and <code>'a'</code>, thus byte pair encoding merges them to produce a new symbol <code>'ta'</code>. In the second iteration, byte pair encoding continues to merge <code>'ta'</code> and <code>'l'</code> to result in another new symbol <code>'tal'</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
num_merges = 10
for i in range(num_merges):
    max_freq_pair = get_max_freq_pair(token_freqs)
    token_freqs = merge_symbols(max_freq_pair, token_freqs, symbols)
    print(f'merge #{i + 1}:', max_freq_pair)
</code></pre>
<p>After 10 iterations of byte pair encoding, we can see that list <code>symbols</code> now contains 10 more symbols that are iteratively merged from other symbols.</p>
<pre><code class="language-{.python .input}">#@tab all
print(symbols)
</code></pre>
<p>For the same dataset specified in the keys of the dictionary <code>raw_token_freqs</code>,
each word in the dataset is now segmented by subwords "fast_", "fast", "er_", "tall_", and "tall"
as a result of the byte pair encoding algorithm.
For instance, words "faster_" and "taller_" are segmented as "fast er_" and "tall er_", respectively.</p>
<pre><code class="language-{.python .input}">#@tab all
print(list(token_freqs.keys()))
</code></pre>
<p>Note that the result of byte pair encoding depends on the dataset being used.
We can also use the subwords learned from one dataset
to segment words of another dataset.
As a greedy approach, the following <code>segment_BPE</code> function tries to break words into the longest possible subwords from the input argument <code>symbols</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def segment_BPE(tokens, symbols):
    outputs = []
    for token in tokens:
        start, end = 0, len(token)
        cur_output = []
        # Segment token with the longest possible subwords from symbols
        while start &lt; len(token) and start &lt; end:
            if token[start: end] in symbols:
                cur_output.append(token[start: end])
                start = end
                end = len(token)
            else:
                end -= 1
        if start &lt; len(token):
            cur_output.append('[UNK]')
        outputs.append(' '.join(cur_output))
    return outputs
</code></pre>
<p>In the following, we use the subwords in list <code>symbols</code>, which is learned from the aforementioned dataset,
to segment <code>tokens</code> that represent another dataset.</p>
<pre><code class="language-{.python .input}">#@tab all
tokens = ['tallest_', 'fatter_']
print(segment_BPE(tokens, symbols))
</code></pre>
<h2 id="summary-91"><a class="header" href="#summary-91">Summary</a></h2>
<ul>
<li>The fastText model proposes a subword embedding approach. Based on the skip-gram model in word2vec, it represents a center word as the sum of its subword vectors.</li>
<li>Byte pair encoding performs a statistical analysis of the training dataset to discover common symbols within a word. As a greedy approach, byte pair encoding iteratively merges the most frequent pair of consecutive symbols.</li>
<li>Subword embedding may improve the quality of representations of rare words and out-of-dictionary words.</li>
</ul>
<h2 id="exercises-111"><a class="header" href="#exercises-111">Exercises</a></h2>
<ol>
<li>As an example, there are about $3\times 10^8$ possible  $6$-grams in English. What is the issue when there are too many subwords? How to address the issue? Hint: refer to the end of Section 3.2 of the fastText paper :cite:<code>Bojanowski.Grave.Joulin.ea.2017</code>.</li>
<li>How to design a subword embedding model based on the continuous bag-of-words model?</li>
<li>To get a vocabulary of size $m$, how many merging operations are needed when the initial symbol vocabulary size is $n$?</li>
<li>How to extend the idea of byte pair encoding to extract phrases?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/386">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/4587">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="word-similarity-and-analogy"><a class="header" href="#word-similarity-and-analogy">Word Similarity and Analogy</a></h1>
<p>:label:<code>sec_synonyms</code></p>
<p>In :numref:<code>sec_word2vec_pretraining</code>,
we trained a word2vec model on a small dataset,
and applied it
to find semantically similar words
for an input word.
In practice,
word vectors that are pretrained
on large corpora can be
applied to downstream
natural language processing tasks,
which will be covered later
in :numref:<code>chap_nlp_app</code>.
To demonstrate
semantics of pretrained word vectors
from large corpora in a straightforward way,
let's apply them
in the word similarity and analogy tasks.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
import os

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
import os
</code></pre>
<h2 id="loading-pretrained-word-vectors"><a class="header" href="#loading-pretrained-word-vectors">Loading Pretrained Word Vectors</a></h2>
<p>Below lists pretrained GloVe embeddings of dimension 50, 100, and 300,
which can be downloaded from the <a href="https://nlp.stanford.edu/projects/glove/">GloVe website</a>.
The pretrained fastText embeddings are available in multiple languages.
Here we consider one English version (300-dimensional "wiki.en") that can be downloaded from the
<a href="https://fasttext.cc/">fastText website</a>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['glove.6b.50d'] = (d2l.DATA_URL + 'glove.6B.50d.zip',
                                '0b8703943ccdb6eb788e6f091b8946e82231bc4d')

#@save
d2l.DATA_HUB['glove.6b.100d'] = (d2l.DATA_URL + 'glove.6B.100d.zip',
                                 'cd43bfb07e44e6f27cbcc7bc9ae3d80284fdaf5a')

#@save
d2l.DATA_HUB['glove.42b.300d'] = (d2l.DATA_URL + 'glove.42B.300d.zip',
                                  'b5116e234e9eb9076672cfeabf5469f3eec904fa')

#@save
d2l.DATA_HUB['wiki.en'] = (d2l.DATA_URL + 'wiki.en.zip',
                           'c1816da3821ae9f43899be655002f6c723e91b88')
</code></pre>
<p>To load these pretrained GloVe and fastText embeddings, we define the following <code>TokenEmbedding</code> class.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
class TokenEmbedding:
    """Token Embedding."""
    def __init__(self, embedding_name):
        self.idx_to_token, self.idx_to_vec = self._load_embedding(
            embedding_name)
        self.unknown_idx = 0
        self.token_to_idx = {token: idx for idx, token in
                             enumerate(self.idx_to_token)}

    def _load_embedding(self, embedding_name):
        idx_to_token, idx_to_vec = ['&lt;unk&gt;'], []
        data_dir = d2l.download_extract(embedding_name)
        # GloVe website: https://nlp.stanford.edu/projects/glove/
        # fastText website: https://fasttext.cc/
        with open(os.path.join(data_dir, 'vec.txt'), 'r') as f:
            for line in f:
                elems = line.rstrip().split(' ')
                token, elems = elems[0], [float(elem) for elem in elems[1:]]
                # Skip header information, such as the top row in fastText
                if len(elems) &gt; 1:
                    idx_to_token.append(token)
                    idx_to_vec.append(elems)
        idx_to_vec = [[0] * len(idx_to_vec[0])] + idx_to_vec
        return idx_to_token, d2l.tensor(idx_to_vec)

    def __getitem__(self, tokens):
        indices = [self.token_to_idx.get(token, self.unknown_idx)
                   for token in tokens]
        vecs = self.idx_to_vec[d2l.tensor(indices)]
        return vecs

    def __len__(self):
        return len(self.idx_to_token)
</code></pre>
<p>Below we load the
50-dimensional GloVe embeddings
(pretrained on a Wikipedia subset).
When creating the <code>TokenEmbedding</code> instance,
the specified embedding file has to be downloaded if it
was not yet.</p>
<pre><code class="language-{.python .input}">#@tab all
glove_6b50d = TokenEmbedding('glove.6b.50d')
</code></pre>
<p>Output the vocabulary size. The vocabulary contains 400000 words (tokens) and a special unknown token.</p>
<pre><code class="language-{.python .input}">#@tab all
len(glove_6b50d)
</code></pre>
<p>We can get the index of a word in the vocabulary, and vice versa.</p>
<pre><code class="language-{.python .input}">#@tab all
glove_6b50d.token_to_idx['beautiful'], glove_6b50d.idx_to_token[3367]
</code></pre>
<h2 id="applying-pretrained-word-vectors"><a class="header" href="#applying-pretrained-word-vectors">Applying Pretrained Word Vectors</a></h2>
<p>Using the loaded GloVe vectors,
we will demonstrate their semantics
by applying them
in the following word similarity and analogy tasks.</p>
<h3 id="word-similarity"><a class="header" href="#word-similarity">Word Similarity</a></h3>
<p>Similar to :numref:<code>subsec_apply-word-embed</code>,
in order to find semantically similar words
for an input word
based on cosine similarities between
word vectors,
we implement the following <code>knn</code>
($k$-nearest neighbors) function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def knn(W, x, k):
    # Add 1e-9 for numerical stability
    cos = np.dot(W, x.reshape(-1,)) / (
        np.sqrt(np.sum(W * W, axis=1) + 1e-9) * np.sqrt((x * x).sum()))
    topk = npx.topk(cos, k=k, ret_typ='indices')
    return topk, [cos[int(i)] for i in topk]
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def knn(W, x, k):
    # Add 1e-9 for numerical stability
    cos = torch.mv(W, x.reshape(-1,)) / (
        torch.sqrt(torch.sum(W * W, axis=1) + 1e-9) *
        torch.sqrt((x * x).sum()))
    _, topk = torch.topk(cos, k=k)
    return topk, [cos[int(i)] for i in topk]
</code></pre>
<p>Then, we
search for similar words
using the pretrained word vectors
from the <code>TokenEmbedding</code> instance <code>embed</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def get_similar_tokens(query_token, k, embed):
    topk, cos = knn(embed.idx_to_vec, embed[[query_token]], k + 1)
    for i, c in zip(topk[1:], cos[1:]):  # Exclude the input word
        print(f'cosine sim={float(c):.3f}: {embed.idx_to_token[int(i)]}')
</code></pre>
<p>The vocabulary of the pretrained word vectors
in <code>glove_6b50d</code> contains 400000 words and a special unknown token.
Excluding the input word and unknown token,
among this vocabulary
let's find
three most semantically similar words
to word "chip".</p>
<pre><code class="language-{.python .input}">#@tab all
get_similar_tokens('chip', 3, glove_6b50d)
</code></pre>
<p>Below outputs similar words
to "baby" and "beautiful".</p>
<pre><code class="language-{.python .input}">#@tab all
get_similar_tokens('baby', 3, glove_6b50d)
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
get_similar_tokens('beautiful', 3, glove_6b50d)
</code></pre>
<h3 id="word-analogy"><a class="header" href="#word-analogy">Word Analogy</a></h3>
<p>Besides finding similar words,
we can also apply word vectors
to word analogy tasks.
For example,
“man”:“woman”::“son”:“daughter”
is the form of a word analogy:
“man” is to “woman” as “son” is to “daughter”.
Specifically,
the word analogy completion task
can be defined as:
for a word analogy
$a : b :: c : d$, given the first three words $a$, $b$ and $c$, find $d$.
Denote the vector of word $w$ by $\textrm{vec}(w)$.
To complete the analogy,
we will find the word
whose vector is most similar
to the result of $\textrm{vec}(c)+\textrm{vec}(b)-\textrm{vec}(a)$.</p>
<pre><code class="language-{.python .input}">#@tab all
def get_analogy(token_a, token_b, token_c, embed):
    vecs = embed[[token_a, token_b, token_c]]
    x = vecs[1] - vecs[0] + vecs[2]
    topk, cos = knn(embed.idx_to_vec, x, 1)
    return embed.idx_to_token[int(topk[0])]  # Remove unknown words
</code></pre>
<p>Let's verify the "male-female" analogy using the loaded word vectors.</p>
<pre><code class="language-{.python .input}">#@tab all
get_analogy('man', 'woman', 'son', glove_6b50d)
</code></pre>
<p>Below completes a
“capital-country” analogy:
“beijing”:“china”::“tokyo”:“japan”.
This demonstrates
semantics in the pretrained word vectors.</p>
<pre><code class="language-{.python .input}">#@tab all
get_analogy('beijing', 'china', 'tokyo', glove_6b50d)
</code></pre>
<p>For the
“adjective-superlative adjective” analogy
such as
“bad”:“worst”::“big”:“biggest”,
we can see that the pretrained word vectors
may capture the syntactic information.</p>
<pre><code class="language-{.python .input}">#@tab all
get_analogy('bad', 'worst', 'big', glove_6b50d)
</code></pre>
<p>To show the captured notion
of past tense in the pretrained word vectors,
we can test the syntax using the
"present tense-past tense" analogy: “do”:“did”::“go”:“went”.</p>
<pre><code class="language-{.python .input}">#@tab all
get_analogy('do', 'did', 'go', glove_6b50d)
</code></pre>
<h2 id="summary-92"><a class="header" href="#summary-92">Summary</a></h2>
<ul>
<li>In practice, word vectors that are pretrained on large corpora can be applied to downstream natural language processing tasks.</li>
<li>Pretrained word vectors can be applied to the word similarity and analogy tasks.</li>
</ul>
<h2 id="exercises-112"><a class="header" href="#exercises-112">Exercises</a></h2>
<ol>
<li>Test the fastText results using <code>TokenEmbedding('wiki.en')</code>.</li>
<li>When the vocabulary is extremely large, how can we find similar words or complete a word analogy faster?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/387">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1336">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bidirectional-encoder-representations-from-transformers-bert"><a class="header" href="#bidirectional-encoder-representations-from-transformers-bert">Bidirectional Encoder Representations from Transformers (BERT)</a></h1>
<p>:label:<code>sec_bert</code></p>
<p>We have introduced several word embedding models for natural language understanding.
After pretraining, the output can be thought of as a matrix
where each row is a vector that represents a word of a predefined vocabulary.
In fact, these word embedding models are all <em>context-independent</em>.
Let's begin by illustrating this property.</p>
<h2 id="from-context-independent-to-context-sensitive"><a class="header" href="#from-context-independent-to-context-sensitive">From Context-Independent to Context-Sensitive</a></h2>
<p>Recall the experiments in :numref:<code>sec_word2vec_pretraining</code> and :numref:<code>sec_synonyms</code>.
For instance, word2vec and GloVe both assign the same pretrained vector to the same word regardless of the context of the word (if any).
Formally, a context-independent representation of any token $x$
is a function $f(x)$ that only takes $x$ as its input.
Given the abundance of polysemy and complex semantics in natural languages,
context-independent representations have obvious limitations.
For instance, the word "crane" in contexts
"a crane is flying" and "a crane driver came" has completely different meanings;
thus, the same word may be assigned different representations depending on contexts.</p>
<p>This motivates the development of <em>context-sensitive</em> word representations,
where representations of words depend on their contexts.
Hence, a context-sensitive representation of token $x$ is a function $f(x, c(x))$
depending on both $x$ and its context $c(x)$.
Popular context-sensitive representations
include TagLM (language-model-augmented sequence tagger) :cite:<code>Peters.Ammar.Bhagavatula.ea.2017</code>,
CoVe (Context Vectors) :cite:<code>McCann.Bradbury.Xiong.ea.2017</code>,
and ELMo (Embeddings from Language Models) :cite:<code>Peters.Neumann.Iyyer.ea.2018</code>.</p>
<p>For example, by taking the entire sequence as input,
ELMo is a function that assigns a representation to each word from the input sequence.
Specifically, ELMo combines all the intermediate layer representations from pretrained bidirectional LSTM as the output representation.
Then the ELMo representation will be added to a downstream task's existing supervised model
as additional features, such as by concatenating ELMo representation and the original representation (e.g., GloVe) of tokens in the existing model.
On the one hand,
all the weights in the pretrained bidirectional LSTM model are frozen after ELMo representations are added.
On the other hand,
the existing supervised model is specifically customized for a given task.
Leveraging different best models for different tasks at that time,
adding ELMo improved the state of the art across six natural language processing tasks:
sentiment analysis, natural language inference,
semantic role labeling, coreference resolution,
named entity recognition, and question answering.</p>
<h2 id="from-task-specific-to-task-agnostic"><a class="header" href="#from-task-specific-to-task-agnostic">From Task-Specific to Task-Agnostic</a></h2>
<p>Although ELMo has significantly improved solutions to a diverse set of natural language processing tasks,
each solution still hinges on a <em>task-specific</em> architecture.
However, it is practically non-trivial to craft a specific architecture for every natural language processing task.
The GPT (Generative Pre-Training) model represents an effort in designing
a general <em>task-agnostic</em> model for context-sensitive representations :cite:<code>Radford.Narasimhan.Salimans.ea.2018</code>.
Built on a Transformer decoder,
GPT pretrains a language model that will be used to represent text sequences.
When applying GPT to a downstream task,
the output of the language model will be fed into an added linear output layer
to predict the label of the task.
In sharp contrast to ELMo that freezes parameters of the pretrained model,
GPT fine-tunes <em>all</em> the parameters in the pretrained Transformer decoder
during supervised learning of the downstream task.
GPT was evaluated on twelve tasks of natural language inference,
question answering, sentence similarity, and classification,
and improved the state of the art in nine of them with minimal changes
to the model architecture.</p>
<p>However, due to the autoregressive nature of language models,
GPT only looks forward (left-to-right).
In contexts "i went to the bank to deposit cash" and "i went to the bank to sit down",
as "bank" is sensitive to the context to its left,
GPT will return the same representation for "bank",
though it has different meanings.</p>
<h2 id="bert-combining-the-best-of-both-worlds"><a class="header" href="#bert-combining-the-best-of-both-worlds">BERT: Combining the Best of Both Worlds</a></h2>
<p>As we have seen,
ELMo encodes context bidirectionally but uses task-specific architectures;
while GPT is task-agnostic but encodes context left-to-right.
Combining the best of both worlds,
BERT (Bidirectional Encoder Representations from Transformers)
encodes context bidirectionally and requires minimal architecture changes
for a wide range of natural language processing tasks :cite:<code>Devlin.Chang.Lee.ea.2018</code>.
Using a pretrained Transformer encoder,
BERT is able to represent any token based on its bidirectional context.
During supervised learning of downstream tasks,
BERT is similar to GPT in two aspects.
First, BERT representations will be fed into an added output layer,
with minimal changes to the model architecture depending on nature of tasks,
such as predicting for every token vs. predicting for the entire sequence.
Second,
all the parameters of the pretrained Transformer encoder are fine-tuned,
while the additional output layer will be trained from scratch.
:numref:<code>fig_elmo-gpt-bert</code> depicts the differences among ELMo, GPT, and BERT.</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/elmo-gpt-bert.svg" alt="A comparison of ELMo, GPT, and BERT." />
:label:<code>fig_elmo-gpt-bert</code></p>
<p>BERT further improved the state of the art on eleven natural language processing tasks
under broad categories of (i) single text classification (e.g., sentiment analysis), (ii) text pair classification (e.g., natural language inference),
(iii) question answering, (iv) text tagging (e.g., named entity recognition).
All proposed in 2018,
from context-sensitive ELMo to task-agnostic GPT and BERT,
conceptually simple yet empirically powerful pretraining of deep representations for natural languages have revolutionized solutions to various natural language processing tasks.</p>
<p>In the rest of this chapter,
we will dive into the pretraining of BERT.
When natural language processing applications are explained in :numref:<code>chap_nlp_app</code>,
we will illustrate fine-tuning of BERT for downstream applications.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, np, npx
from mxnet.gluon import nn

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<h2 id="input-representation"><a class="header" href="#input-representation">[<strong>Input Representation</strong>]</a></h2>
<p>:label:<code>subsec_bert_input_rep</code></p>
<p>In natural language processing,
some tasks (e.g., sentiment analysis) take single text as input,
while in some other tasks (e.g., natural language inference),
the input is a pair of text sequences.
The BERT input sequence unambiguously represents both single text and text pairs.
In the former,
the BERT input sequence is the concatenation of
the special classification token “&lt;cls&gt;”,
tokens of a text sequence,
and the special separation token “&lt;sep&gt;”.
In the latter,
the BERT input sequence is the concatenation of
“&lt;cls&gt;”, tokens of the first text sequence,
“&lt;sep&gt;”, tokens of the second text sequence, and “&lt;sep&gt;”.
We will consistently distinguish the terminology "BERT input sequence"
from other types of "sequences".
For instance, one <em>BERT input sequence</em> may include either one <em>text sequence</em> or two <em>text sequences</em>.</p>
<p>To distinguish text pairs,
the learned segment embeddings $\mathbf{e}_A$ and $\mathbf{e}_B$
are added to the token embeddings of the first sequence and the second sequence, respectively.
For single text inputs, only $\mathbf{e}_A$ is used.</p>
<p>The following <code>get_tokens_and_segments</code> takes either one sentence or two sentences
as input, then returns tokens of the BERT input sequence
and their corresponding segment IDs.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def get_tokens_and_segments(tokens_a, tokens_b=None):
    """Get tokens of the BERT input sequence and their segment IDs."""
    tokens = ['&lt;cls&gt;'] + tokens_a + ['&lt;sep&gt;']
    # 0 and 1 are marking segment A and B, respectively
    segments = [0] * (len(tokens_a) + 2)
    if tokens_b is not None:
        tokens += tokens_b + ['&lt;sep&gt;']
        segments += [1] * (len(tokens_b) + 1)
    return tokens, segments
</code></pre>
<p>BERT chooses the Transformer encoder as its bidirectional architecture.
Common in the Transformer encoder,
positional embeddings are added at every position of the BERT input sequence.
However, different from the original Transformer encoder,
BERT uses <em>learnable</em> positional embeddings.
To sum up, :numref:<code>fig_bert-input</code> shows that
the embeddings of the BERT input sequence are the sum
of the token embeddings, segment embeddings, and positional embeddings.</p>
<p><img src="chapter_natural-language-processing-pretraining/../img/bert-input.svg" alt="The embeddings of the BERT input sequence are the sum of the token embeddings, segment embeddings, and positional embeddings." />
:label:<code>fig_bert-input</code></p>
<p>The following [<strong><code>BERTEncoder</code> class</strong>] is similar to the <code>TransformerEncoder</code> class
as implemented in :numref:<code>sec_transformer</code>.
Different from <code>TransformerEncoder</code>, <code>BERTEncoder</code> uses
segment embeddings and learnable positional embeddings.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class BERTEncoder(nn.Block):
    """BERT encoder."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                 num_blks, dropout, max_len=1000, **kwargs):
        super(BERTEncoder, self).__init__(**kwargs)
        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)
        self.segment_embedding = nn.Embedding(2, num_hiddens)
        self.blks = nn.Sequential()
        for _ in range(num_blks):
            self.blks.add(d2l.TransformerEncoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, True))
        # In BERT, positional embeddings are learnable, thus we create a
        # parameter of positional embeddings that are long enough
        self.pos_embedding = self.params.get('pos_embedding',
                                             shape=(1, max_len, num_hiddens))

    def forward(self, tokens, segments, valid_lens):
        # Shape of `X` remains unchanged in the following code snippet:
        # (batch size, max sequence length, `num_hiddens`)
        X = self.token_embedding(tokens) + self.segment_embedding(segments)
        X = X + self.pos_embedding.data(ctx=X.ctx)[:, :X.shape[1], :]
        for blk in self.blks:
            X = blk(X, valid_lens)
        return X
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class BERTEncoder(nn.Module):
    """BERT encoder."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                 num_blks, dropout, max_len=1000, **kwargs):
        super(BERTEncoder, self).__init__(**kwargs)
        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)
        self.segment_embedding = nn.Embedding(2, num_hiddens)
        self.blks = nn.Sequential()
        for i in range(num_blks):
            self.blks.add_module(f"{i}", d2l.TransformerEncoderBlock(
                num_hiddens, ffn_num_hiddens, num_heads, dropout, True))
        # In BERT, positional embeddings are learnable, thus we create a
        # parameter of positional embeddings that are long enough
        self.pos_embedding = nn.Parameter(torch.randn(1, max_len,
                                                      num_hiddens))

    def forward(self, tokens, segments, valid_lens):
        # Shape of `X` remains unchanged in the following code snippet:
        # (batch size, max sequence length, `num_hiddens`)
        X = self.token_embedding(tokens) + self.segment_embedding(segments)
        X = X + self.pos_embedding[:, :X.shape[1], :]
        for blk in self.blks:
            X = blk(X, valid_lens)
        return X
</code></pre>
<p>Suppose that the vocabulary size is 10000.
To demonstrate forward [<strong>inference of <code>BERTEncoder</code></strong>],
let's create an instance of it and initialize its parameters.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
vocab_size, num_hiddens, ffn_num_hiddens, num_heads = 10000, 768, 1024, 4
num_blks, dropout = 2, 0.2
encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                      num_blks, dropout)
encoder.initialize()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
vocab_size, num_hiddens, ffn_num_hiddens, num_heads = 10000, 768, 1024, 4
ffn_num_input, num_blks, dropout = 768, 2, 0.2
encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                      num_blks, dropout)
</code></pre>
<p>We define <code>tokens</code> to be 2 BERT input sequences of length 8,
where each token is an index of the vocabulary.
The forward inference of <code>BERTEncoder</code> with the input <code>tokens</code>
returns the encoded result where each token is represented by a vector
whose length is predefined by the hyperparameter <code>num_hiddens</code>.
This hyperparameter is usually referred to as the <em>hidden size</em>
(number of hidden units) of the Transformer encoder.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
tokens = np.random.randint(0, vocab_size, (2, 8))
segments = np.array([[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1]])
encoded_X = encoder(tokens, segments, None)
encoded_X.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
tokens = torch.randint(0, vocab_size, (2, 8))
segments = torch.tensor([[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1]])
encoded_X = encoder(tokens, segments, None)
encoded_X.shape
</code></pre>
<h2 id="pretraining-tasks"><a class="header" href="#pretraining-tasks">Pretraining Tasks</a></h2>
<p>:label:<code>subsec_bert_pretraining_tasks</code></p>
<p>The forward inference of <code>BERTEncoder</code> gives the BERT representation
of each token of the input text and the inserted
special tokens “&lt;cls&gt;” and “&lt;seq&gt;”.
Next, we will use these representations to compute the loss function
for pretraining BERT.
The pretraining is composed of the following two tasks:
masked language modeling and next sentence prediction.</p>
<h3 id="masked-language-modeling"><a class="header" href="#masked-language-modeling">[<strong>Masked Language Modeling</strong>]</a></h3>
<p>:label:<code>subsec_mlm</code></p>
<p>As illustrated in :numref:<code>sec_language-model</code>,
a language model predicts a token using the context on its left.
To encode context bidirectionally for representing each token,
BERT randomly masks tokens and uses tokens from the bidirectional context to
predict the masked tokens in a self-supervised fashion.
This task is referred to as a <em>masked language model</em>.</p>
<p>In this pretraining task,
15% of tokens will be selected at random as the masked tokens for prediction.
To predict a masked token without cheating by using the label,
one straightforward approach is to always replace it with a special “&lt;mask&gt;” token in the BERT input sequence.
However, the artificial special token “&lt;mask&gt;” will never appear
in fine-tuning.
To avoid such a mismatch between pretraining and fine-tuning,
if a token is masked for prediction (e.g., "great" is selected to be masked and predicted in "this movie is great"),
in the input it will be replaced with:</p>
<ul>
<li>a special “&lt;mask&gt;” token for 80% of the time (e.g., "this movie is great" becomes "this movie is &lt;mask&gt;");</li>
<li>a random token for 10% of the time (e.g., "this movie is great" becomes "this movie is drink");</li>
<li>the unchanged label token for 10% of the time (e.g., "this movie is great" becomes "this movie is great").</li>
</ul>
<p>Note that for 10% of 15% time a random token is inserted.
This occasional noise encourages BERT to be less biased towards the masked token (especially when the label token remains unchanged) in its bidirectional context encoding.</p>
<p>We implement the following <code>MaskLM</code> class to predict masked tokens
in the masked language model task of BERT pretraining.
The prediction uses a one-hidden-layer MLP (<code>self.mlp</code>).
In forward inference, it takes two inputs:
the encoded result of <code>BERTEncoder</code> and the token positions for prediction.
The output is the prediction results at these positions.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class MaskLM(nn.Block):
    """The masked language model task of BERT."""
    def __init__(self, vocab_size, num_hiddens, **kwargs):
        super(MaskLM, self).__init__(**kwargs)
        self.mlp = nn.Sequential()
        self.mlp.add(
            nn.Dense(num_hiddens, flatten=False, activation='relu'))
        self.mlp.add(nn.LayerNorm())
        self.mlp.add(nn.Dense(vocab_size, flatten=False))

    def forward(self, X, pred_positions):
        num_pred_positions = pred_positions.shape[1]
        pred_positions = pred_positions.reshape(-1)
        batch_size = X.shape[0]
        batch_idx = np.arange(0, batch_size)
        # Suppose that `batch_size` = 2, `num_pred_positions` = 3, then
        # `batch_idx` is `np.array([0, 0, 0, 1, 1, 1])`
        batch_idx = np.repeat(batch_idx, num_pred_positions)
        masked_X = X[batch_idx, pred_positions]
        masked_X = masked_X.reshape((batch_size, num_pred_positions, -1))
        mlm_Y_hat = self.mlp(masked_X)
        return mlm_Y_hat
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class MaskLM(nn.Module):
    """The masked language model task of BERT."""
    def __init__(self, vocab_size, num_hiddens, **kwargs):
        super(MaskLM, self).__init__(**kwargs)
        self.mlp = nn.Sequential(nn.LazyLinear(num_hiddens),
                                 nn.ReLU(),
                                 nn.LayerNorm(num_hiddens),
                                 nn.LazyLinear(vocab_size))

    def forward(self, X, pred_positions):
        num_pred_positions = pred_positions.shape[1]
        pred_positions = pred_positions.reshape(-1)
        batch_size = X.shape[0]
        batch_idx = torch.arange(0, batch_size)
        # Suppose that `batch_size` = 2, `num_pred_positions` = 3, then
        # `batch_idx` is `torch.tensor([0, 0, 0, 1, 1, 1])`
        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)
        masked_X = X[batch_idx, pred_positions]
        masked_X = masked_X.reshape((batch_size, num_pred_positions, -1))
        mlm_Y_hat = self.mlp(masked_X)
        return mlm_Y_hat
</code></pre>
<p>To demonstrate [<strong>the forward inference of <code>MaskLM</code></strong>],
we create its instance <code>mlm</code> and initialize it.
Recall that <code>encoded_X</code> from the forward inference of <code>BERTEncoder</code>
represents 2 BERT input sequences.
We define <code>mlm_positions</code> as the 3 indices to predict in either BERT input sequence of <code>encoded_X</code>.
The forward inference of <code>mlm</code> returns prediction results <code>mlm_Y_hat</code>
at all the masked positions <code>mlm_positions</code> of <code>encoded_X</code>.
For each prediction, the size of the result is equal to the vocabulary size.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
mlm = MaskLM(vocab_size, num_hiddens)
mlm.initialize()
mlm_positions = np.array([[1, 5, 2], [6, 1, 5]])
mlm_Y_hat = mlm(encoded_X, mlm_positions)
mlm_Y_hat.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
mlm = MaskLM(vocab_size, num_hiddens)
mlm_positions = torch.tensor([[1, 5, 2], [6, 1, 5]])
mlm_Y_hat = mlm(encoded_X, mlm_positions)
mlm_Y_hat.shape
</code></pre>
<p>With the ground truth labels <code>mlm_Y</code> of the predicted tokens <code>mlm_Y_hat</code> under masks,
we can calculate the cross-entropy loss of the masked language model task in BERT pretraining.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
mlm_Y = np.array([[7, 8, 9], [10, 20, 30]])
loss = gluon.loss.SoftmaxCrossEntropyLoss()
mlm_l = loss(mlm_Y_hat.reshape((-1, vocab_size)), mlm_Y.reshape(-1))
mlm_l.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
mlm_Y = torch.tensor([[7, 8, 9], [10, 20, 30]])
loss = nn.CrossEntropyLoss(reduction='none')
mlm_l = loss(mlm_Y_hat.reshape((-1, vocab_size)), mlm_Y.reshape(-1))
mlm_l.shape
</code></pre>
<h3 id="next-sentence-prediction"><a class="header" href="#next-sentence-prediction">[<strong>Next Sentence Prediction</strong>]</a></h3>
<p>:label:<code>subsec_nsp</code></p>
<p>Although masked language modeling is able to encode bidirectional context
for representing words, it does not explicitly model the logical relationship
between text pairs.
To help understand the relationship between two text sequences,
BERT considers a binary classification task, <em>next sentence prediction</em>, in its pretraining.
When generating sentence pairs for pretraining,
for half of the time they are indeed consecutive sentences with the label "True";
while for the other half of the time the second sentence is randomly sampled from the corpus with the label "False".</p>
<p>The following <code>NextSentencePred</code> class uses a one-hidden-layer MLP
to predict whether the second sentence is the next sentence of the first
in the BERT input sequence.
Due to self-attention in the Transformer encoder,
the BERT representation of the special token “&lt;cls&gt;”
encodes both the two sentences from the input.
Hence, the output layer (<code>self.output</code>) of the MLP classifier takes <code>X</code> as input,
where <code>X</code> is the output of the MLP hidden layer whose input is the encoded “&lt;cls&gt;” token.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class NextSentencePred(nn.Block):
    """The next sentence prediction task of BERT."""
    def __init__(self, **kwargs):
        super(NextSentencePred, self).__init__(**kwargs)
        self.output = nn.Dense(2)

    def forward(self, X):
        # `X` shape: (batch size, `num_hiddens`)
        return self.output(X)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class NextSentencePred(nn.Module):
    """The next sentence prediction task of BERT."""
    def __init__(self, **kwargs):
        super(NextSentencePred, self).__init__(**kwargs)
        self.output = nn.LazyLinear(2)

    def forward(self, X):
        # `X` shape: (batch size, `num_hiddens`)
        return self.output(X)
</code></pre>
<p>We can see that [<strong>the forward inference of an <code>NextSentencePred</code></strong>] instance
returns binary predictions for each BERT input sequence.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
nsp = NextSentencePred()
nsp.initialize()
nsp_Y_hat = nsp(encoded_X)
nsp_Y_hat.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# PyTorch by default will not flatten the tensor as seen in mxnet where, if
# flatten=True, all but the first axis of input data are collapsed together
encoded_X = torch.flatten(encoded_X, start_dim=1)
# input_shape for NSP: (batch size, `num_hiddens`)
nsp = NextSentencePred()
nsp_Y_hat = nsp(encoded_X)
nsp_Y_hat.shape
</code></pre>
<p>The cross-entropy loss of the 2 binary classifications can also be computed.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
nsp_y = np.array([0, 1])
nsp_l = loss(nsp_Y_hat, nsp_y)
nsp_l.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
nsp_y = torch.tensor([0, 1])
nsp_l = loss(nsp_Y_hat, nsp_y)
nsp_l.shape
</code></pre>
<p>It is noteworthy that all the labels in both the aforementioned pretraining tasks
can be trivially obtained from the pretraining corpus without manual labeling effort.
The original BERT has been pretrained on the concatenation of BookCorpus :cite:<code>Zhu.Kiros.Zemel.ea.2015</code>
and English Wikipedia.
These two text corpora are huge:
they have 800 million words and 2.5 billion words, respectively.</p>
<h2 id="putting-it-all-together-4"><a class="header" href="#putting-it-all-together-4">[<strong>Putting It All Together</strong>]</a></h2>
<p>When pretraining BERT, the final loss function is a linear combination of
both the loss functions for masked language modeling and next sentence prediction.
Now we can define the <code>BERTModel</code> class by instantiating the three classes
<code>BERTEncoder</code>, <code>MaskLM</code>, and <code>NextSentencePred</code>.
The forward inference returns the encoded BERT representations <code>encoded_X</code>,
predictions of masked language modeling <code>mlm_Y_hat</code>,
and next sentence predictions <code>nsp_Y_hat</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class BERTModel(nn.Block):
    """The BERT model."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads,
                 num_blks, dropout, max_len=1000):
        super(BERTModel, self).__init__()
        self.encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens,
                                   num_heads, num_blks, dropout, max_len)
        self.hidden = nn.Dense(num_hiddens, activation='tanh')
        self.mlm = MaskLM(vocab_size, num_hiddens)
        self.nsp = NextSentencePred()

    def forward(self, tokens, segments, valid_lens=None, pred_positions=None):
        encoded_X = self.encoder(tokens, segments, valid_lens)
        if pred_positions is not None:
            mlm_Y_hat = self.mlm(encoded_X, pred_positions)
        else:
            mlm_Y_hat = None
        # The hidden layer of the MLP classifier for next sentence prediction.
        # 0 is the index of the '&lt;cls&gt;' token
        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, 0, :]))
        return encoded_X, mlm_Y_hat, nsp_Y_hat
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class BERTModel(nn.Module):
    """The BERT model."""
    def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, 
                 num_heads, num_blks, dropout, max_len=1000):
        super(BERTModel, self).__init__()
        self.encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens,
                                   num_heads, num_blks, dropout,
                                   max_len=max_len)
        self.hidden = nn.Sequential(nn.LazyLinear(num_hiddens),
                                    nn.Tanh())
        self.mlm = MaskLM(vocab_size, num_hiddens)
        self.nsp = NextSentencePred()

    def forward(self, tokens, segments, valid_lens=None, pred_positions=None):
        encoded_X = self.encoder(tokens, segments, valid_lens)
        if pred_positions is not None:
            mlm_Y_hat = self.mlm(encoded_X, pred_positions)
        else:
            mlm_Y_hat = None
        # The hidden layer of the MLP classifier for next sentence prediction.
        # 0 is the index of the '&lt;cls&gt;' token
        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, 0, :]))
        return encoded_X, mlm_Y_hat, nsp_Y_hat
</code></pre>
<h2 id="summary-93"><a class="header" href="#summary-93">Summary</a></h2>
<ul>
<li>Word embedding models such as word2vec and GloVe are context-independent. They assign the same pretrained vector to the same word regardless of the context of the word (if any). It is hard for them to handle well polysemy or complex semantics in natural languages.</li>
<li>For context-sensitive word representations such as ELMo and GPT, representations of words depend on their contexts.</li>
<li>ELMo encodes context bidirectionally but uses task-specific architectures (however, it is practically non-trivial to craft a specific architecture for every natural language processing task); while GPT is task-agnostic but encodes context left-to-right.</li>
<li>BERT combines the best of both worlds: it encodes context bidirectionally and requires minimal architecture changes for a wide range of natural language processing tasks.</li>
<li>The embeddings of the BERT input sequence are the sum of the token embeddings, segment embeddings, and positional embeddings.</li>
<li>Pretraining BERT is composed of two tasks: masked language modeling and next sentence prediction. The former is able to encode bidirectional context for representing words, while the latter explicitly models the logical relationship between text pairs.</li>
</ul>
<h2 id="exercises-113"><a class="header" href="#exercises-113">Exercises</a></h2>
<ol>
<li>All other things being equal, will a masked language model require more or fewer pretraining steps to converge than a left-to-right language model? Why?</li>
<li>In the original implementation of BERT, the positionwise feed-forward network in <code>BERTEncoder</code> (via <code>d2l.TransformerEncoderBlock</code>) and the fully connected layer in <code>MaskLM</code> both use the Gaussian error linear unit (GELU) :cite:<code>Hendrycks.Gimpel.2016</code> as the activation function. Research into the difference between GELU and ReLU.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/388">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1490">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-dataset-for-pretraining-bert"><a class="header" href="#the-dataset-for-pretraining-bert">The Dataset for Pretraining BERT</a></h1>
<p>:label:<code>sec_bert-dataset</code></p>
<p>To pretrain the BERT model as implemented in :numref:<code>sec_bert</code>,
we need to generate the dataset in the ideal format to facilitate
the two pretraining tasks:
masked language modeling and next sentence prediction.
On the one hand,
the original BERT model is pretrained on the concatenation of
two huge corpora BookCorpus and English Wikipedia (see :numref:<code>subsec_bert_pretraining_tasks</code>),
making it hard to run for most readers of this book.
On the other hand,
the off-the-shelf pretrained BERT model
may not fit for applications from specific domains like medicine.
Thus, it is getting popular to pretrain BERT on a customized dataset.
To facilitate the demonstration of BERT pretraining,
we use a smaller corpus WikiText-2 :cite:<code>Merity.Xiong.Bradbury.ea.2016</code>.</p>
<p>Comparing with the PTB dataset used for pretraining word2vec in :numref:<code>sec_word2vec_data</code>,
WikiText-2 (i) retains the original punctuation, making it suitable for next sentence prediction; (ii) retains the original case and numbers; (iii) is over twice larger.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, np, npx
import os
import random

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import os
import random
import torch
</code></pre>
<p>In [<strong>the WikiText-2 dataset</strong>],
each line represents a paragraph where
space is inserted between any punctuation and its preceding token.
Paragraphs with at least two sentences are retained.
To split sentences, we only use the period as the delimiter for simplicity.
We leave discussions of more complex sentence splitting techniques in the exercises
at the end of this section.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['wikitext-2'] = (
    'https://s3.amazonaws.com/research.metamind.io/wikitext/'
    'wikitext-2-v1.zip', '3c914d17d80b1459be871a5039ac23e752a53cbe')

#@save
def _read_wiki(data_dir):
    file_name = os.path.join(data_dir, 'wiki.train.tokens')
    with open(file_name, 'r') as f:
        lines = f.readlines()
    # Uppercase letters are converted to lowercase ones
    paragraphs = [line.strip().lower().split(' . ')
                  for line in lines if len(line.split(' . ')) &gt;= 2]
    random.shuffle(paragraphs)
    return paragraphs
</code></pre>
<h2 id="defining-helper-functions-for-pretraining-tasks"><a class="header" href="#defining-helper-functions-for-pretraining-tasks">Defining Helper Functions for Pretraining Tasks</a></h2>
<p>In the following,
we begin by implementing helper functions for the two BERT pretraining tasks:
next sentence prediction and masked language modeling.
These helper functions will be invoked later
when transforming the raw text corpus
into the dataset of the ideal format to pretrain BERT.</p>
<h3 id="generating-the-next-sentence-prediction-task"><a class="header" href="#generating-the-next-sentence-prediction-task">[<strong>Generating the Next Sentence Prediction Task</strong>]</a></h3>
<p>According to descriptions of :numref:<code>subsec_nsp</code>,
the <code>_get_next_sentence</code> function generates a training example
for the binary classification task.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def _get_next_sentence(sentence, next_sentence, paragraphs):
    if random.random() &lt; 0.5:
        is_next = True
    else:
        # `paragraphs` is a list of lists of lists
        next_sentence = random.choice(random.choice(paragraphs))
        is_next = False
    return sentence, next_sentence, is_next
</code></pre>
<p>The following function generates training examples for next sentence prediction
from the input <code>paragraph</code> by invoking the <code>_get_next_sentence</code> function.
Here <code>paragraph</code> is a list of sentences, where each sentence is a list of tokens.
The argument <code>max_len</code> specifies the maximum length of a BERT input sequence during pretraining.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def _get_nsp_data_from_paragraph(paragraph, paragraphs, vocab, max_len):
    nsp_data_from_paragraph = []
    for i in range(len(paragraph) - 1):
        tokens_a, tokens_b, is_next = _get_next_sentence(
            paragraph[i], paragraph[i + 1], paragraphs)
        # Consider 1 '&lt;cls&gt;' token and 2 '&lt;sep&gt;' tokens
        if len(tokens_a) + len(tokens_b) + 3 &gt; max_len:
            continue
        tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)
        nsp_data_from_paragraph.append((tokens, segments, is_next))
    return nsp_data_from_paragraph
</code></pre>
<h3 id="generating-the-masked-language-modeling-task"><a class="header" href="#generating-the-masked-language-modeling-task">[<strong>Generating the Masked Language Modeling Task</strong>]</a></h3>
<p>:label:<code>subsec_prepare_mlm_data</code></p>
<p>In order to generate training examples
for the masked language modeling task
from a BERT input sequence,
we define the following <code>_replace_mlm_tokens</code> function.
In its inputs, <code>tokens</code> is a list of tokens representing a BERT input sequence,
<code>candidate_pred_positions</code> is a list of token indices of the BERT input sequence
excluding those of special tokens (special tokens are not predicted in the masked language modeling task),
and <code>num_mlm_preds</code> indicates the number of predictions (recall 15% random tokens to predict).
Following the definition of the masked language modeling task in :numref:<code>subsec_mlm</code>,
at each prediction position, the input may be replaced by
a special “&lt;mask&gt;” token or a random token, or remain unchanged.
In the end, the function returns the input tokens after possible replacement,
the token indices where predictions take place and labels for these predictions.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def _replace_mlm_tokens(tokens, candidate_pred_positions, num_mlm_preds,
                        vocab):
    # For the input of a masked language model, make a new copy of tokens and
    # replace some of them by '&lt;mask&gt;' or random tokens
    mlm_input_tokens = [token for token in tokens]
    pred_positions_and_labels = []
    # Shuffle for getting 15% random tokens for prediction in the masked
    # language modeling task
    random.shuffle(candidate_pred_positions)
    for mlm_pred_position in candidate_pred_positions:
        if len(pred_positions_and_labels) &gt;= num_mlm_preds:
            break
        masked_token = None
        # 80% of the time: replace the word with the '&lt;mask&gt;' token
        if random.random() &lt; 0.8:
            masked_token = '&lt;mask&gt;'
        else:
            # 10% of the time: keep the word unchanged
            if random.random() &lt; 0.5:
                masked_token = tokens[mlm_pred_position]
            # 10% of the time: replace the word with a random word
            else:
                masked_token = random.choice(vocab.idx_to_token)
        mlm_input_tokens[mlm_pred_position] = masked_token
        pred_positions_and_labels.append(
            (mlm_pred_position, tokens[mlm_pred_position]))
    return mlm_input_tokens, pred_positions_and_labels
</code></pre>
<p>By invoking the aforementioned <code>_replace_mlm_tokens</code> function,
the following function takes a BERT input sequence (<code>tokens</code>)
as an input and returns indices of the input tokens
(after possible token replacement as described in :numref:<code>subsec_mlm</code>),
the token indices where predictions take place,
and label indices for these predictions.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def _get_mlm_data_from_tokens(tokens, vocab):
    candidate_pred_positions = []
    # `tokens` is a list of strings
    for i, token in enumerate(tokens):
        # Special tokens are not predicted in the masked language modeling
        # task
        if token in ['&lt;cls&gt;', '&lt;sep&gt;']:
            continue
        candidate_pred_positions.append(i)
    # 15% of random tokens are predicted in the masked language modeling task
    num_mlm_preds = max(1, round(len(tokens) * 0.15))
    mlm_input_tokens, pred_positions_and_labels = _replace_mlm_tokens(
        tokens, candidate_pred_positions, num_mlm_preds, vocab)
    pred_positions_and_labels = sorted(pred_positions_and_labels,
                                       key=lambda x: x[0])
    pred_positions = [v[0] for v in pred_positions_and_labels]
    mlm_pred_labels = [v[1] for v in pred_positions_and_labels]
    return vocab[mlm_input_tokens], pred_positions, vocab[mlm_pred_labels]
</code></pre>
<h2 id="transforming-text-into-the-pretraining-dataset"><a class="header" href="#transforming-text-into-the-pretraining-dataset">Transforming Text into the Pretraining Dataset</a></h2>
<p>Now we are almost ready to customize a <code>Dataset</code> class for pretraining BERT.
Before that,
we still need to define a helper function <code>_pad_bert_inputs</code>
to [<strong>append the special “&lt;pad&gt;” tokens to the inputs.</strong>]
Its argument <code>examples</code> contain the outputs from the helper functions <code>_get_nsp_data_from_paragraph</code> and <code>_get_mlm_data_from_tokens</code> for the two pretraining tasks.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def _pad_bert_inputs(examples, max_len, vocab):
    max_num_mlm_preds = round(max_len * 0.15)
    all_token_ids, all_segments, valid_lens,  = [], [], []
    all_pred_positions, all_mlm_weights, all_mlm_labels = [], [], []
    nsp_labels = []
    for (token_ids, pred_positions, mlm_pred_label_ids, segments,
         is_next) in examples:
        all_token_ids.append(np.array(token_ids + [vocab['&lt;pad&gt;']] * (
            max_len - len(token_ids)), dtype='int32'))
        all_segments.append(np.array(segments + [0] * (
            max_len - len(segments)), dtype='int32'))
        # `valid_lens` excludes count of '&lt;pad&gt;' tokens
        valid_lens.append(np.array(len(token_ids), dtype='float32'))
        all_pred_positions.append(np.array(pred_positions + [0] * (
            max_num_mlm_preds - len(pred_positions)), dtype='int32'))
        # Predictions of padded tokens will be filtered out in the loss via
        # multiplication of 0 weights
        all_mlm_weights.append(
            np.array([1.0] * len(mlm_pred_label_ids) + [0.0] * (
                max_num_mlm_preds - len(pred_positions)), dtype='float32'))
        all_mlm_labels.append(np.array(mlm_pred_label_ids + [0] * (
            max_num_mlm_preds - len(mlm_pred_label_ids)), dtype='int32'))
        nsp_labels.append(np.array(is_next))
    return (all_token_ids, all_segments, valid_lens, all_pred_positions,
            all_mlm_weights, all_mlm_labels, nsp_labels)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def _pad_bert_inputs(examples, max_len, vocab):
    max_num_mlm_preds = round(max_len * 0.15)
    all_token_ids, all_segments, valid_lens,  = [], [], []
    all_pred_positions, all_mlm_weights, all_mlm_labels = [], [], []
    nsp_labels = []
    for (token_ids, pred_positions, mlm_pred_label_ids, segments,
         is_next) in examples:
        all_token_ids.append(torch.tensor(token_ids + [vocab['&lt;pad&gt;']] * (
            max_len - len(token_ids)), dtype=torch.long))
        all_segments.append(torch.tensor(segments + [0] * (
            max_len - len(segments)), dtype=torch.long))
        # `valid_lens` excludes count of '&lt;pad&gt;' tokens
        valid_lens.append(torch.tensor(len(token_ids), dtype=torch.float32))
        all_pred_positions.append(torch.tensor(pred_positions + [0] * (
            max_num_mlm_preds - len(pred_positions)), dtype=torch.long))
        # Predictions of padded tokens will be filtered out in the loss via
        # multiplication of 0 weights
        all_mlm_weights.append(
            torch.tensor([1.0] * len(mlm_pred_label_ids) + [0.0] * (
                max_num_mlm_preds - len(pred_positions)),
                dtype=torch.float32))
        all_mlm_labels.append(torch.tensor(mlm_pred_label_ids + [0] * (
            max_num_mlm_preds - len(mlm_pred_label_ids)), dtype=torch.long))
        nsp_labels.append(torch.tensor(is_next, dtype=torch.long))
    return (all_token_ids, all_segments, valid_lens, all_pred_positions,
            all_mlm_weights, all_mlm_labels, nsp_labels)
</code></pre>
<p>Putting the helper functions for
generating training examples of the two pretraining tasks,
and the helper function for padding inputs together,
we customize the following <code>_WikiTextDataset</code> class as [<strong>the WikiText-2 dataset for pretraining BERT</strong>].
By implementing the <code>__getitem__ </code>function,
we can arbitrarily access the pretraining (masked language modeling and next sentence prediction) examples
generated from a pair of sentences from the WikiText-2 corpus.</p>
<p>The original BERT model uses WordPiece embeddings whose vocabulary size is 30000 :cite:<code>Wu.Schuster.Chen.ea.2016</code>.
The tokenization method of WordPiece is a slight modification of
the original byte pair encoding algorithm in :numref:<code>subsec_Byte_Pair_Encoding</code>.
For simplicity, we use the <code>d2l.tokenize</code> function for tokenization.
Infrequent tokens that appear less than five times are filtered out.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class _WikiTextDataset(gluon.data.Dataset):
    def __init__(self, paragraphs, max_len):
        # Input `paragraphs[i]` is a list of sentence strings representing a
        # paragraph; while output `paragraphs[i]` is a list of sentences
        # representing a paragraph, where each sentence is a list of tokens
        paragraphs = [d2l.tokenize(
            paragraph, token='word') for paragraph in paragraphs]
        sentences = [sentence for paragraph in paragraphs
                     for sentence in paragraph]
        self.vocab = d2l.Vocab(sentences, min_freq=5, reserved_tokens=[
            '&lt;pad&gt;', '&lt;mask&gt;', '&lt;cls&gt;', '&lt;sep&gt;'])
        # Get data for the next sentence prediction task
        examples = []
        for paragraph in paragraphs:
            examples.extend(_get_nsp_data_from_paragraph(
                paragraph, paragraphs, self.vocab, max_len))
        # Get data for the masked language model task
        examples = [(_get_mlm_data_from_tokens(tokens, self.vocab)
                      + (segments, is_next))
                     for tokens, segments, is_next in examples]
        # Pad inputs
        (self.all_token_ids, self.all_segments, self.valid_lens,
         self.all_pred_positions, self.all_mlm_weights,
         self.all_mlm_labels, self.nsp_labels) = _pad_bert_inputs(
            examples, max_len, self.vocab)

    def __getitem__(self, idx):
        return (self.all_token_ids[idx], self.all_segments[idx],
                self.valid_lens[idx], self.all_pred_positions[idx],
                self.all_mlm_weights[idx], self.all_mlm_labels[idx],
                self.nsp_labels[idx])

    def __len__(self):
        return len(self.all_token_ids)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class _WikiTextDataset(torch.utils.data.Dataset):
    def __init__(self, paragraphs, max_len):
        # Input `paragraphs[i]` is a list of sentence strings representing a
        # paragraph; while output `paragraphs[i]` is a list of sentences
        # representing a paragraph, where each sentence is a list of tokens
        paragraphs = [d2l.tokenize(
            paragraph, token='word') for paragraph in paragraphs]
        sentences = [sentence for paragraph in paragraphs
                     for sentence in paragraph]
        self.vocab = d2l.Vocab(sentences, min_freq=5, reserved_tokens=[
            '&lt;pad&gt;', '&lt;mask&gt;', '&lt;cls&gt;', '&lt;sep&gt;'])
        # Get data for the next sentence prediction task
        examples = []
        for paragraph in paragraphs:
            examples.extend(_get_nsp_data_from_paragraph(
                paragraph, paragraphs, self.vocab, max_len))
        # Get data for the masked language model task
        examples = [(_get_mlm_data_from_tokens(tokens, self.vocab)
                      + (segments, is_next))
                     for tokens, segments, is_next in examples]
        # Pad inputs
        (self.all_token_ids, self.all_segments, self.valid_lens,
         self.all_pred_positions, self.all_mlm_weights,
         self.all_mlm_labels, self.nsp_labels) = _pad_bert_inputs(
            examples, max_len, self.vocab)

    def __getitem__(self, idx):
        return (self.all_token_ids[idx], self.all_segments[idx],
                self.valid_lens[idx], self.all_pred_positions[idx],
                self.all_mlm_weights[idx], self.all_mlm_labels[idx],
                self.nsp_labels[idx])

    def __len__(self):
        return len(self.all_token_ids)
</code></pre>
<p>By using the <code>_read_wiki</code> function and the <code>_WikiTextDataset</code> class,
we define the following <code>load_data_wiki</code> to [<strong>download and WikiText-2 dataset
and generate pretraining examples</strong>] from it.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_wiki(batch_size, max_len):
    """Load the WikiText-2 dataset."""
    num_workers = d2l.get_dataloader_workers()
    data_dir = d2l.download_extract('wikitext-2', 'wikitext-2')
    paragraphs = _read_wiki(data_dir)
    train_set = _WikiTextDataset(paragraphs, max_len)
    train_iter = gluon.data.DataLoader(train_set, batch_size, shuffle=True,
                                       num_workers=num_workers)
    return train_iter, train_set.vocab
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_wiki(batch_size, max_len):
    """Load the WikiText-2 dataset."""
    num_workers = d2l.get_dataloader_workers()
    data_dir = d2l.download_extract('wikitext-2', 'wikitext-2')
    paragraphs = _read_wiki(data_dir)
    train_set = _WikiTextDataset(paragraphs, max_len)
    train_iter = torch.utils.data.DataLoader(train_set, batch_size,
                                        shuffle=True, num_workers=num_workers)
    return train_iter, train_set.vocab
</code></pre>
<p>Setting the batch size to 512 and the maximum length of a BERT input sequence to be 64,
we [<strong>print out the shapes of a minibatch of BERT pretraining examples</strong>].
Note that in each BERT input sequence,
$10$ ($64 \times 0.15$) positions are predicted for the masked language modeling task.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size, max_len = 512, 64
train_iter, vocab = load_data_wiki(batch_size, max_len)

for (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X,
     mlm_Y, nsp_y) in train_iter:
    print(tokens_X.shape, segments_X.shape, valid_lens_x.shape,
          pred_positions_X.shape, mlm_weights_X.shape, mlm_Y.shape,
          nsp_y.shape)
    break
</code></pre>
<p>In the end, let's take a look at the vocabulary size.
Even after filtering out infrequent tokens,
it is still over twice larger than that of the PTB dataset.</p>
<pre><code class="language-{.python .input}">#@tab all
len(vocab)
</code></pre>
<h2 id="summary-94"><a class="header" href="#summary-94">Summary</a></h2>
<ul>
<li>Comparing with the PTB dataset, the WikiText-2 dateset retains the original punctuation, case and numbers, and is over twice larger.</li>
<li>We can arbitrarily access the pretraining (masked language modeling and next sentence prediction) examples generated from a pair of sentences from the WikiText-2 corpus.</li>
</ul>
<h2 id="exercises-114"><a class="header" href="#exercises-114">Exercises</a></h2>
<ol>
<li>For simplicity, the period is used as the only delimiter for splitting sentences. Try other sentence splitting techniques, such as the spaCy and NLTK. Take NLTK as an example. You need to install NLTK first: <code>pip install nltk</code>. In the code, first <code>import nltk</code>. Then, download the Punkt sentence tokenizer: <code>nltk.download('punkt')</code>. To split sentences such as <code>sentences = 'This is great ! Why not ?'</code>, invoking <code>nltk.tokenize.sent_tokenize(sentences)</code> will return a list of two sentence strings: <code>['This is great !', 'Why not ?']</code>.</li>
<li>What is the vocabulary size if we do not filter out any infrequent token?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/389">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1496">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretraining-bert-1"><a class="header" href="#pretraining-bert-1">Pretraining BERT</a></h1>
<p>:label:<code>sec_bert-pretraining</code></p>
<p>With the BERT model implemented in :numref:<code>sec_bert</code>
and the pretraining examples generated from the WikiText-2 dataset in :numref:<code>sec_bert-dataset</code>, we will pretrain BERT on the WikiText-2 dataset in this section.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<p>To start, we load the WikiText-2 dataset as minibatches
of pretraining examples for masked language modeling and next sentence prediction.
The batch size is 512 and the maximum length of a BERT input sequence is 64.
Note that in the original BERT model, the maximum length is 512.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size, max_len = 512, 64
train_iter, vocab = d2l.load_data_wiki(batch_size, max_len)
</code></pre>
<h2 id="pretraining-bert-2"><a class="header" href="#pretraining-bert-2">Pretraining BERT</a></h2>
<p>The original BERT has two versions of different model sizes :cite:<code>Devlin.Chang.Lee.ea.2018</code>.
The base model ($\textrm{BERT}<em>{\textrm{BASE}}$) uses 12 layers (Transformer encoder blocks)
with 768 hidden units (hidden size) and 12 self-attention heads.
The large model ($\textrm{BERT}</em>{\textrm{LARGE}}$) uses 24 layers
with 1024 hidden units and 16 self-attention heads.
Notably, the former has 110 million parameters while the latter has 340 million parameters.
For demonstration with ease,
we define [<strong>a small BERT, using 2 layers, 128 hidden units, and 2 self-attention heads</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = d2l.BERTModel(len(vocab), num_hiddens=128, ffn_num_hiddens=256,
                    num_heads=2, num_blks=2, dropout=0.2)
devices = d2l.try_all_gpus()
net.initialize(init.Xavier(), ctx=devices)
loss = gluon.loss.SoftmaxCELoss()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = d2l.BERTModel(len(vocab), num_hiddens=128, 
                    ffn_num_hiddens=256, num_heads=2, num_blks=2, dropout=0.2)
devices = d2l.try_all_gpus()
loss = nn.CrossEntropyLoss()
</code></pre>
<p>Before defining the training loop,
we define a helper function <code>_get_batch_loss_bert</code>.
Given the shard of training examples,
this function [<strong>computes the loss for both the masked language modeling and next sentence prediction tasks</strong>].
Note that the final loss of BERT pretraining
is just the sum of both the masked language modeling loss
and the next sentence prediction loss.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def _get_batch_loss_bert(net, loss, vocab_size, tokens_X_shards,
                         segments_X_shards, valid_lens_x_shards,
                         pred_positions_X_shards, mlm_weights_X_shards,
                         mlm_Y_shards, nsp_y_shards):
    mlm_ls, nsp_ls, ls = [], [], []
    for (tokens_X_shard, segments_X_shard, valid_lens_x_shard,
         pred_positions_X_shard, mlm_weights_X_shard, mlm_Y_shard,
         nsp_y_shard) in zip(
        tokens_X_shards, segments_X_shards, valid_lens_x_shards,
        pred_positions_X_shards, mlm_weights_X_shards, mlm_Y_shards,
        nsp_y_shards):
        # Forward pass
        _, mlm_Y_hat, nsp_Y_hat = net(
            tokens_X_shard, segments_X_shard, valid_lens_x_shard.reshape(-1),
            pred_positions_X_shard)
        # Compute masked language model loss
        mlm_l = loss(
            mlm_Y_hat.reshape((-1, vocab_size)), mlm_Y_shard.reshape(-1),
            mlm_weights_X_shard.reshape((-1, 1)))
        mlm_l = mlm_l.sum() / (mlm_weights_X_shard.sum() + 1e-8)
        # Compute next sentence prediction loss
        nsp_l = loss(nsp_Y_hat, nsp_y_shard)
        nsp_l = nsp_l.mean()
        mlm_ls.append(mlm_l)
        nsp_ls.append(nsp_l)
        ls.append(mlm_l + nsp_l)
        npx.waitall()
    return mlm_ls, nsp_ls, ls
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def _get_batch_loss_bert(net, loss, vocab_size, tokens_X,
                         segments_X, valid_lens_x,
                         pred_positions_X, mlm_weights_X,
                         mlm_Y, nsp_y):
    # Forward pass
    _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X,
                                  valid_lens_x.reshape(-1),
                                  pred_positions_X)
    # Compute masked language model loss
    mlm_l = loss(mlm_Y_hat.reshape(-1, vocab_size), mlm_Y.reshape(-1)) *\
    mlm_weights_X.reshape(-1, 1)
    mlm_l = mlm_l.sum() / (mlm_weights_X.sum() + 1e-8)
    # Compute next sentence prediction loss
    nsp_l = loss(nsp_Y_hat, nsp_y)
    l = mlm_l + nsp_l
    return mlm_l, nsp_l, l
</code></pre>
<p>Invoking the two aforementioned helper functions,
the following <code>train_bert</code> function
defines the procedure to [<strong>pretrain BERT (<code>net</code>) on the WikiText-2 (<code>train_iter</code>) dataset</strong>].
Training BERT can take very long.
Instead of specifying the number of epochs for training
as in the <code>train_ch13</code> function (see :numref:<code>sec_image_augmentation</code>),
the input <code>num_steps</code> of the following function
specifies the number of iteration steps for training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train_bert(train_iter, net, loss, vocab_size, devices, num_steps):
    trainer = gluon.Trainer(net.collect_params(), 'adam',
                            {'learning_rate': 0.01})
    step, timer = 0, d2l.Timer()
    animator = d2l.Animator(xlabel='step', ylabel='loss',
                            xlim=[1, num_steps], legend=['mlm', 'nsp'])
    # Sum of masked language modeling losses, sum of next sentence prediction
    # losses, no. of sentence pairs, count
    metric = d2l.Accumulator(4)
    num_steps_reached = False
    while step &lt; num_steps and not num_steps_reached:
        for batch in train_iter:
            (tokens_X_shards, segments_X_shards, valid_lens_x_shards,
             pred_positions_X_shards, mlm_weights_X_shards,
             mlm_Y_shards, nsp_y_shards) = [gluon.utils.split_and_load(
                elem, devices, even_split=False) for elem in batch]
            timer.start()
            with autograd.record():
                mlm_ls, nsp_ls, ls = _get_batch_loss_bert(
                    net, loss, vocab_size, tokens_X_shards, segments_X_shards,
                    valid_lens_x_shards, pred_positions_X_shards,
                    mlm_weights_X_shards, mlm_Y_shards, nsp_y_shards)
            for l in ls:
                l.backward()
            trainer.step(1)
            mlm_l_mean = sum([float(l) for l in mlm_ls]) / len(mlm_ls)
            nsp_l_mean = sum([float(l) for l in nsp_ls]) / len(nsp_ls)
            metric.add(mlm_l_mean, nsp_l_mean, batch[0].shape[0], 1)
            timer.stop()
            animator.add(step + 1,
                         (metric[0] / metric[3], metric[1] / metric[3]))
            step += 1
            if step == num_steps:
                num_steps_reached = True
                break

    print(f'MLM loss {metric[0] / metric[3]:.3f}, '
          f'NSP loss {metric[1] / metric[3]:.3f}')
    print(f'{metric[2] / timer.sum():.1f} sentence pairs/sec on '
          f'{str(devices)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train_bert(train_iter, net, loss, vocab_size, devices, num_steps):
    net(*next(iter(train_iter))[:4])
    net = nn.DataParallel(net, device_ids=devices).to(devices[0])
    trainer = torch.optim.Adam(net.parameters(), lr=0.01)
    step, timer = 0, d2l.Timer()
    animator = d2l.Animator(xlabel='step', ylabel='loss',
                            xlim=[1, num_steps], legend=['mlm', 'nsp'])
    # Sum of masked language modeling losses, sum of next sentence prediction
    # losses, no. of sentence pairs, count
    metric = d2l.Accumulator(4)
    num_steps_reached = False
    while step &lt; num_steps and not num_steps_reached:
        for tokens_X, segments_X, valid_lens_x, pred_positions_X,\
            mlm_weights_X, mlm_Y, nsp_y in train_iter:
            tokens_X = tokens_X.to(devices[0])
            segments_X = segments_X.to(devices[0])
            valid_lens_x = valid_lens_x.to(devices[0])
            pred_positions_X = pred_positions_X.to(devices[0])
            mlm_weights_X = mlm_weights_X.to(devices[0])
            mlm_Y, nsp_y = mlm_Y.to(devices[0]), nsp_y.to(devices[0])
            trainer.zero_grad()
            timer.start()
            mlm_l, nsp_l, l = _get_batch_loss_bert(
                net, loss, vocab_size, tokens_X, segments_X, valid_lens_x,
                pred_positions_X, mlm_weights_X, mlm_Y, nsp_y)
            l.backward()
            trainer.step()
            metric.add(mlm_l, nsp_l, tokens_X.shape[0], 1)
            timer.stop()
            animator.add(step + 1,
                         (metric[0] / metric[3], metric[1] / metric[3]))
            step += 1
            if step == num_steps:
                num_steps_reached = True
                break

    print(f'MLM loss {metric[0] / metric[3]:.3f}, '
          f'NSP loss {metric[1] / metric[3]:.3f}')
    print(f'{metric[2] / timer.sum():.1f} sentence pairs/sec on '
          f'{str(devices)}')
</code></pre>
<p>We can plot both the masked language modeling loss and the next sentence prediction loss
during BERT pretraining.</p>
<pre><code class="language-{.python .input}">#@tab all
train_bert(train_iter, net, loss, len(vocab), devices, 50)
</code></pre>
<h2 id="representing-text-with-bert"><a class="header" href="#representing-text-with-bert">[<strong>Representing Text with BERT</strong>]</a></h2>
<p>After pretraining BERT,
we can use it to represent single text, text pairs, or any token in them.
The following function returns the BERT (<code>net</code>) representations for all tokens
in <code>tokens_a</code> and <code>tokens_b</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def get_bert_encoding(net, tokens_a, tokens_b=None):
    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)
    token_ids = np.expand_dims(np.array(vocab[tokens], ctx=devices[0]),
                               axis=0)
    segments = np.expand_dims(np.array(segments, ctx=devices[0]), axis=0)
    valid_len = np.expand_dims(np.array(len(tokens), ctx=devices[0]), axis=0)
    encoded_X, _, _ = net(token_ids, segments, valid_len)
    return encoded_X
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def get_bert_encoding(net, tokens_a, tokens_b=None):
    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)
    token_ids = torch.tensor(vocab[tokens], device=devices[0]).unsqueeze(0)
    segments = torch.tensor(segments, device=devices[0]).unsqueeze(0)
    valid_len = torch.tensor(len(tokens), device=devices[0]).unsqueeze(0)
    encoded_X, _, _ = net(token_ids, segments, valid_len)
    return encoded_X
</code></pre>
<p>[<strong>Consider the sentence "a crane is flying".</strong>]
Recall the input representation of BERT as discussed in :numref:<code>subsec_bert_input_rep</code>.
After inserting special tokens “&lt;cls&gt;” (used for classification)
and “&lt;sep&gt;” (used for separation),
the BERT input sequence has a length of six.
Since zero is the index of the “&lt;cls&gt;” token,
<code>encoded_text[:, 0, :]</code> is the BERT representation of the entire input sentence.
To evaluate the polysemy token "crane",
we also print out the first three elements of the BERT representation of the token.</p>
<pre><code class="language-{.python .input}">#@tab all
tokens_a = ['a', 'crane', 'is', 'flying']
encoded_text = get_bert_encoding(net, tokens_a)
# Tokens: '&lt;cls&gt;', 'a', 'crane', 'is', 'flying', '&lt;sep&gt;'
encoded_text_cls = encoded_text[:, 0, :]
encoded_text_crane = encoded_text[:, 2, :]
encoded_text.shape, encoded_text_cls.shape, encoded_text_crane[0][:3]
</code></pre>
<p>[<strong>Now consider a sentence pair
"a crane driver came" and "he just left".</strong>]
Similarly, <code>encoded_pair[:, 0, :]</code> is the encoded result of the entire sentence pair from the pretrained BERT.
Note that the first three elements of the polysemy token "crane" are different from those when the context is different.
This supports that BERT representations are context-sensitive.</p>
<pre><code class="language-{.python .input}">#@tab all
tokens_a, tokens_b = ['a', 'crane', 'driver', 'came'], ['he', 'just', 'left']
encoded_pair = get_bert_encoding(net, tokens_a, tokens_b)
# Tokens: '&lt;cls&gt;', 'a', 'crane', 'driver', 'came', '&lt;sep&gt;', 'he', 'just',
# 'left', '&lt;sep&gt;'
encoded_pair_cls = encoded_pair[:, 0, :]
encoded_pair_crane = encoded_pair[:, 2, :]
encoded_pair.shape, encoded_pair_cls.shape, encoded_pair_crane[0][:3]
</code></pre>
<p>In :numref:<code>chap_nlp_app</code>, we will fine-tune a pretrained BERT model
for downstream natural language processing applications.</p>
<h2 id="summary-95"><a class="header" href="#summary-95">Summary</a></h2>
<ul>
<li>The original BERT has two versions, where the base model has 110 million parameters and the large model has 340 million parameters.</li>
<li>After pretraining BERT, we can use it to represent single text, text pairs, or any token in them.</li>
<li>In the experiment, the same token has different BERT representation when their contexts are different. This supports that BERT representations are context-sensitive.</li>
</ul>
<h2 id="exercises-115"><a class="header" href="#exercises-115">Exercises</a></h2>
<ol>
<li>In the experiment, we can see that the masked language modeling loss is significantly higher than the next sentence prediction loss. Why?</li>
<li>Set the maximum length of a BERT input sequence to be 512 (same as the original BERT model). Use the configurations of the original BERT model such as $\textrm{BERT}_{\textrm{LARGE}}$. Do you encounter any error when running this section? Why?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/390">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1497">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-language-processing-applications"><a class="header" href="#natural-language-processing-applications">Natural Language Processing: Applications</a></h1>
<p>:label:<code>chap_nlp_app</code></p>
<p>We have seen how to represent tokens in text sequences and train their representations in :numref:<code>chap_nlp_pretrain</code>.
Such pretrained text representations can be fed to various models for different downstream natural language processing tasks.</p>
<p>In fact,
earlier chapters have already discussed some natural language processing applications
<em>without pretraining</em>,
just for explaining deep learning architectures.
For instance, in :numref:<code>chap_rnn</code>,
we have relied on RNNs to design language models to generate novella-like text.
In :numref:<code>chap_modern_rnn</code> and :numref:<code>chap_attention-and-transformers</code>,
we have also designed models based on RNNs and attention mechanisms for machine translation.</p>
<p>However, this book does not intend to cover all such applications in a comprehensive manner.
Instead,
our focus is on <em>how to apply (deep) representation learning of languages to addressing natural language processing problems</em>.
Given pretrained text representations,
this chapter will explore two
popular and representative
downstream natural language processing tasks:
sentiment analysis and natural language inference,
which analyze single text and relationships of text pairs, respectively.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nlp-map-app.svg" alt="Pretrained text representations can be fed to various deep learning architectures for different downstream natural language processing applications. This chapter focuses on how to design models for different downstream natural language processing applications." />
:label:<code>fig_nlp-map-app</code></p>
<p>As depicted in :numref:<code>fig_nlp-map-app</code>,
this chapter focuses on describing the basic ideas of designing natural language processing models using different types of deep learning architectures, such as MLPs, CNNs, RNNs, and attention.
Though it is possible to combine any pretrained text representations with any architecture for either application in :numref:<code>fig_nlp-map-app</code>,
we select a few representative combinations.
Specifically, we will explore popular architectures based on RNNs and CNNs for sentiment analysis.
For natural language inference, we choose attention and MLPs to demonstrate how to analyze text pairs.
In the end, we introduce how to fine-tune a pretrained BERT model
for a wide range of natural language processing applications,
such as on a sequence level (single text classification and text pair classification)
and a token level (text tagging and question answering).
As a concrete empirical case,
we will fine-tune BERT for natural language inference.</p>
<p>As we have introduced in :numref:<code>sec_bert</code>,
BERT requires minimal architecture changes
for a wide range of natural language processing applications.
However, this benefit comes at the cost of fine-tuning
a huge number of BERT parameters for the downstream applications.
When space or time is limited,
those crafted models based on MLPs, CNNs, RNNs, and attention
are more feasible.
In the following, we start by the sentiment analysis application
and illustrate the model design based on RNNs and CNNs, respectively.</p>
<pre><code class="language-toc">:maxdepth: 2

sentiment-analysis-and-dataset
sentiment-analysis-rnn
sentiment-analysis-cnn
natural-language-inference-and-dataset
natural-language-inference-attention
finetuning-bert
natural-language-inference-bert
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentiment-analysis-and-the-dataset"><a class="header" href="#sentiment-analysis-and-the-dataset">Sentiment Analysis and the Dataset</a></h1>
<p>:label:<code>sec_sentiment</code></p>
<p>With the proliferation of online social media
and review platforms,
a plethora of
opinionated data
has been logged,
bearing great potential for
supporting decision making processes.
<em>Sentiment analysis</em>
studies people's sentiments
in their produced text,
such as product reviews,
blog comments,
and
forum discussions.
It enjoys wide applications
to fields as diverse as
politics (e.g., analysis of public sentiments towards policies),
finance (e.g., analysis of sentiments of the market),
and
marketing (e.g., product research and brand management).</p>
<p>Since sentiments
can be categorized
as discrete polarities or scales (e.g., positive and negative),
we can consider
sentiment analysis
as a text classification task,
which transforms a varying-length text sequence
into a fixed-length text category.
In this chapter,
we will use Stanford's <a href="https://ai.stanford.edu/%7Eamaas/data/sentiment/">large movie review dataset</a>
for sentiment analysis.
It consists of a training set and a testing set,
either containing 25000 movie reviews downloaded from IMDb.
In both datasets,
there are equal number of
"positive" and "negative" labels,
indicating different sentiment polarities.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
import os
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
import os
</code></pre>
<h2 id="reading-the-dataset-12"><a class="header" href="#reading-the-dataset-12">Reading the Dataset</a></h2>
<p>First, download and extract this IMDb review dataset
in the path <code>../data/aclImdb</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
d2l.DATA_HUB['aclImdb'] = (d2l.DATA_URL + 'aclImdb_v1.tar.gz', 
                          '01ada507287d82875905620988597833ad4e0903')

data_dir = d2l.download_extract('aclImdb', 'aclImdb')
</code></pre>
<p>Next, read the training and test datasets. Each example is a review and its label: 1 for "positive" and 0 for "negative".</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def read_imdb(data_dir, is_train):
    """Read the IMDb review dataset text sequences and labels."""
    data, labels = [], []
    for label in ('pos', 'neg'):
        folder_name = os.path.join(data_dir, 'train' if is_train else 'test',
                                   label)
        for file in os.listdir(folder_name):
            with open(os.path.join(folder_name, file), 'rb') as f:
                review = f.read().decode('utf-8').replace('\n', '')
                data.append(review)
                labels.append(1 if label == 'pos' else 0)
    return data, labels

train_data = read_imdb(data_dir, is_train=True)
print('# trainings:', len(train_data[0]))
for x, y in zip(train_data[0][:3], train_data[1][:3]):
    print('label:', y, 'review:', x[:60])
</code></pre>
<h2 id="preprocessing-the-dataset"><a class="header" href="#preprocessing-the-dataset">Preprocessing the Dataset</a></h2>
<p>Treating each word as a token
and filtering out words that appear less than 5 times,
we create a vocabulary out of the training dataset.</p>
<pre><code class="language-{.python .input}">#@tab all
train_tokens = d2l.tokenize(train_data[0], token='word')
vocab = d2l.Vocab(train_tokens, min_freq=5, reserved_tokens=['&lt;pad&gt;'])
</code></pre>
<p>After tokenization,
let's plot the histogram of
review lengths in tokens.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.set_figsize()
d2l.plt.xlabel('# tokens per review')
d2l.plt.ylabel('count')
d2l.plt.hist([len(line) for line in train_tokens], bins=range(0, 1000, 50));
</code></pre>
<p>As we expected,
the reviews have varying lengths.
To process
a minibatch of such reviews at each time,
we set the length of each review to 500 with truncation and padding,
which is similar to
the preprocessing step
for the machine translation dataset
in :numref:<code>sec_machine_translation</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
num_steps = 500  # sequence length
train_features = d2l.tensor([d2l.truncate_pad(
    vocab[line], num_steps, vocab['&lt;pad&gt;']) for line in train_tokens])
print(train_features.shape)
</code></pre>
<h2 id="creating-data-iterators"><a class="header" href="#creating-data-iterators">Creating Data Iterators</a></h2>
<p>Now we can create data iterators.
At each iteration, a minibatch of examples are returned.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
train_iter = d2l.load_array((train_features, train_data[1]), 64)

for X, y in train_iter:
    print('X:', X.shape, ', y:', y.shape)
    break
print('# batches:', len(train_iter))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
train_iter = d2l.load_array((train_features, torch.tensor(train_data[1])), 64)

for X, y in train_iter:
    print('X:', X.shape, ', y:', y.shape)
    break
print('# batches:', len(train_iter))
</code></pre>
<h2 id="putting-it-all-together-5"><a class="header" href="#putting-it-all-together-5">Putting It All Together</a></h2>
<p>Last, we wrap up the above steps into the <code>load_data_imdb</code> function.
It returns training and test data iterators and the vocabulary of the IMDb review dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_imdb(batch_size, num_steps=500):
    """Return data iterators and the vocabulary of the IMDb review dataset."""
    data_dir = d2l.download_extract('aclImdb', 'aclImdb')
    train_data = read_imdb(data_dir, True)
    test_data = read_imdb(data_dir, False)
    train_tokens = d2l.tokenize(train_data[0], token='word')
    test_tokens = d2l.tokenize(test_data[0], token='word')
    vocab = d2l.Vocab(train_tokens, min_freq=5)
    train_features = np.array([d2l.truncate_pad(
        vocab[line], num_steps, vocab['&lt;pad&gt;']) for line in train_tokens])
    test_features = np.array([d2l.truncate_pad(
        vocab[line], num_steps, vocab['&lt;pad&gt;']) for line in test_tokens])
    train_iter = d2l.load_array((train_features, train_data[1]), batch_size)
    test_iter = d2l.load_array((test_features, test_data[1]), batch_size,
                               is_train=False)
    return train_iter, test_iter, vocab
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_imdb(batch_size, num_steps=500):
    """Return data iterators and the vocabulary of the IMDb review dataset."""
    data_dir = d2l.download_extract('aclImdb', 'aclImdb')
    train_data = read_imdb(data_dir, True)
    test_data = read_imdb(data_dir, False)
    train_tokens = d2l.tokenize(train_data[0], token='word')
    test_tokens = d2l.tokenize(test_data[0], token='word')
    vocab = d2l.Vocab(train_tokens, min_freq=5)
    train_features = torch.tensor([d2l.truncate_pad(
        vocab[line], num_steps, vocab['&lt;pad&gt;']) for line in train_tokens])
    test_features = torch.tensor([d2l.truncate_pad(
        vocab[line], num_steps, vocab['&lt;pad&gt;']) for line in test_tokens])
    train_iter = d2l.load_array((train_features, torch.tensor(train_data[1])),
                                batch_size)
    test_iter = d2l.load_array((test_features, torch.tensor(test_data[1])),
                               batch_size,
                               is_train=False)
    return train_iter, test_iter, vocab
</code></pre>
<h2 id="summary-96"><a class="header" href="#summary-96">Summary</a></h2>
<ul>
<li>Sentiment analysis studies people's sentiments in their produced text, which is considered as a text classification problem that transforms a varying-length text sequence
into a fixed-length text category.</li>
<li>After preprocessing, we can load Stanford's large movie review dataset (IMDb review dataset) into data iterators with a vocabulary.</li>
</ul>
<h2 id="exercises-116"><a class="header" href="#exercises-116">Exercises</a></h2>
<ol>
<li>What hyperparameters in this section can we modify to accelerate training sentiment analysis models?</li>
<li>Can you implement a function to load the dataset of <a href="https://snap.stanford.edu/data/web-Amazon.html">Amazon reviews</a> into data iterators and labels for sentiment analysis?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/391">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1387">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentiment-analysis-using-recurrent-neural-networks"><a class="header" href="#sentiment-analysis-using-recurrent-neural-networks">Sentiment Analysis: Using Recurrent Neural Networks</a></h1>
<p>:label:<code>sec_sentiment_rnn</code></p>
<p>Like word similarity and analogy tasks,
we can also apply pretrained word vectors
to sentiment analysis.
Since the IMDb review dataset
in :numref:<code>sec_sentiment</code>
is not very big,
using text representations
that were pretrained
on large-scale corpora
may reduce overfitting of the model.
As a specific example
illustrated in :numref:<code>fig_nlp-map-sa-rnn</code>,
we will represent each token
using the pretrained GloVe model,
and feed these token representations
into a multilayer bidirectional RNN
to obtain the text sequence representation,
which will
be transformed into
sentiment analysis outputs :cite:<code>Maas.Daly.Pham.ea.2011</code>.
For the same downstream application,
we will consider a different architectural
choice later.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nlp-map-sa-rnn.svg" alt="This section feeds pretrained GloVe to an RNN-based architecture for sentiment analysis." />
:label:<code>fig_nlp-map-sa-rnn</code></p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, init, np, npx
from mxnet.gluon import nn, rnn
npx.set_np()

batch_size = 64
train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn

batch_size = 64
train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
</code></pre>
<h2 id="representing-single-text-with-rnns"><a class="header" href="#representing-single-text-with-rnns">Representing Single Text with RNNs</a></h2>
<p>In text classifications tasks,
such as sentiment analysis,
a varying-length text sequence
will be transformed into fixed-length categories.
In the following <code>BiRNN</code> class,
while each token of a text sequence
gets its individual
pretrained GloVe
representation via the embedding layer
(<code>self.embedding</code>),
the entire sequence
is encoded by a bidirectional RNN (<code>self.encoder</code>).
More concretely,
the hidden states (at the last layer)
of the bidirectional LSTM
at both the initial and final time steps
are concatenated
as the representation of the text sequence.
This single text representation
is then transformed into output categories
by a fully connected layer (<code>self.decoder</code>)
with two outputs ("positive" and "negative").</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class BiRNN(nn.Block):
    def __init__(self, vocab_size, embed_size, num_hiddens,
                 num_layers, **kwargs):
        super(BiRNN, self).__init__(**kwargs)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        # Set `bidirectional` to True to get a bidirectional RNN
        self.encoder = rnn.LSTM(num_hiddens, num_layers=num_layers,
                                bidirectional=True, input_size=embed_size)
        self.decoder = nn.Dense(2)

    def forward(self, inputs):
        # The shape of `inputs` is (batch size, no. of time steps). Because
        # LSTM requires its input's first dimension to be the temporal
        # dimension, the input is transposed before obtaining token
        # representations. The output shape is (no. of time steps, batch size,
        # word vector dimension)
        embeddings = self.embedding(inputs.T)
        # Returns hidden states of the last hidden layer at different time
        # steps. The shape of `outputs` is (no. of time steps, batch size,
        # 2 * no. of hidden units)
        outputs = self.encoder(embeddings)
        # Concatenate the hidden states at the initial and final time steps as
        # the input of the fully connected layer. Its shape is (batch size,
        # 4 * no. of hidden units)
        encoding = np.concatenate((outputs[0], outputs[-1]), axis=1)
        outs = self.decoder(encoding)
        return outs
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class BiRNN(nn.Module):
    def __init__(self, vocab_size, embed_size, num_hiddens,
                 num_layers, **kwargs):
        super(BiRNN, self).__init__(**kwargs)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        # Set `bidirectional` to True to get a bidirectional RNN
        self.encoder = nn.LSTM(embed_size, num_hiddens, num_layers=num_layers,
                                bidirectional=True)
        self.decoder = nn.Linear(4 * num_hiddens, 2)

    def forward(self, inputs):
        # The shape of `inputs` is (batch size, no. of time steps). Because
        # LSTM requires its input's first dimension to be the temporal
        # dimension, the input is transposed before obtaining token
        # representations. The output shape is (no. of time steps, batch size,
        # word vector dimension)
        embeddings = self.embedding(inputs.T)
        self.encoder.flatten_parameters()
        # Returns hidden states of the last hidden layer at different time
        # steps. The shape of `outputs` is (no. of time steps, batch size,
        # 2 * no. of hidden units)
        outputs, _ = self.encoder(embeddings)
        # Concatenate the hidden states at the initial and final time steps as
        # the input of the fully connected layer. Its shape is (batch size,
        # 4 * no. of hidden units)
        encoding = torch.cat((outputs[0], outputs[-1]), dim=1) 
        outs = self.decoder(encoding)
        return outs
</code></pre>
<p>Let's construct a bidirectional RNN with two hidden layers to represent single text for sentiment analysis.</p>
<pre><code class="language-{.python .input}">#@tab all
embed_size, num_hiddens, num_layers, devices = 100, 100, 2, d2l.try_all_gpus()
net = BiRNN(len(vocab), embed_size, num_hiddens, num_layers)
</code></pre>
<pre><code class="language-{.python .input}">#@tab mxnet
net.initialize(init.Xavier(), ctx=devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def init_weights(module):
    if type(module) == nn.Linear:
        nn.init.xavier_uniform_(module.weight)
    if type(module) == nn.LSTM:
        for param in module._flat_weights_names:
            if "weight" in param:
                nn.init.xavier_uniform_(module._parameters[param])
net.apply(init_weights);
</code></pre>
<h2 id="loading-pretrained-word-vectors-1"><a class="header" href="#loading-pretrained-word-vectors-1">Loading Pretrained Word Vectors</a></h2>
<p>Below we load the pretrained 100-dimensional (needs to be consistent with <code>embed_size</code>) GloVe embeddings for tokens in the vocabulary.</p>
<pre><code class="language-{.python .input}">#@tab all
glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
</code></pre>
<p>Print the shape of the vectors
for all the tokens in the vocabulary.</p>
<pre><code class="language-{.python .input}">#@tab all
embeds = glove_embedding[vocab.idx_to_token]
embeds.shape
</code></pre>
<p>We use these pretrained
word vectors
to represent tokens in the reviews
and will not update
these vectors during training.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net.embedding.weight.set_data(embeds)
net.embedding.collect_params().setattr('grad_req', 'null')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net.embedding.weight.data.copy_(embeds)
net.embedding.weight.requires_grad = False
</code></pre>
<h2 id="training-and-evaluating-the-model"><a class="header" href="#training-and-evaluating-the-model">Training and Evaluating the Model</a></h2>
<p>Now we can train the bidirectional RNN for sentiment analysis.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lr, num_epochs = 0.01, 5
trainer = gluon.Trainer(net.collect_params(), 'adam', {'learning_rate': lr})
loss = gluon.loss.SoftmaxCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr, num_epochs = 0.01, 5
trainer = torch.optim.Adam(net.parameters(), lr=lr)
loss = nn.CrossEntropyLoss(reduction="none")
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<p>We define the following function to predict the sentiment of a text sequence using the trained model <code>net</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def predict_sentiment(net, vocab, sequence):
    """Predict the sentiment of a text sequence."""
    sequence = np.array(vocab[sequence.split()], ctx=d2l.try_gpu())
    label = np.argmax(net(sequence.reshape(1, -1)), axis=1)
    return 'positive' if label == 1 else 'negative'
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def predict_sentiment(net, vocab, sequence):
    """Predict the sentiment of a text sequence."""
    sequence = torch.tensor(vocab[sequence.split()], device=d2l.try_gpu())
    label = torch.argmax(net(sequence.reshape(1, -1)), dim=1)
    return 'positive' if label == 1 else 'negative'
</code></pre>
<p>Finally, let's use the trained model to predict the sentiment for two simple sentences.</p>
<pre><code class="language-{.python .input}">#@tab all
predict_sentiment(net, vocab, 'this movie is so great')
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
predict_sentiment(net, vocab, 'this movie is so bad')
</code></pre>
<h2 id="summary-97"><a class="header" href="#summary-97">Summary</a></h2>
<ul>
<li>Pretrained word vectors can represent individual tokens in a text sequence.</li>
<li>Bidirectional RNNs can represent a text sequence, such as via the concatenation of its hidden states at the initial and final time steps. This single text representation can be transformed into categories using a fully connected layer.</li>
</ul>
<h2 id="exercises-117"><a class="header" href="#exercises-117">Exercises</a></h2>
<ol>
<li>Increase the number of epochs. Can you improve the training and testing accuracies? How about tuning other hyperparameters?</li>
<li>Use larger pretrained word vectors, such as 300-dimensional GloVe embeddings. Does it improve classification accuracy?</li>
<li>Can we improve the classification accuracy by using the spaCy tokenization? You need to install spaCy (<code>pip install spacy</code>) and install the English package (<code>python -m spacy download en</code>). In the code, first, import spaCy (<code>import spacy</code>). Then, load the spaCy English package (<code>spacy_en = spacy.load('en')</code>). Finally, define the function <code>def tokenizer(text): return [tok.text for tok in spacy_en.tokenizer(text)]</code> and replace the original <code>tokenizer</code> function. Note the different forms of phrase tokens in GloVe and spaCy. For example, the phrase token "new york" takes the form of "new-york" in GloVe and the form of "new york" after the spaCy tokenization.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/392">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1424">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentiment-analysis-using-convolutional-neural-networks"><a class="header" href="#sentiment-analysis-using-convolutional-neural-networks">Sentiment Analysis: Using Convolutional Neural Networks</a></h1>
<p>:label:<code>sec_sentiment_cnn</code></p>
<p>In :numref:<code>chap_cnn</code>,
we investigated mechanisms
for processing
two-dimensional image data
with two-dimensional CNNs,
which were applied to
local features such as adjacent pixels.
Though originally
designed for computer vision,
CNNs are also widely used
for natural language processing.
Simply put,
just think of any text sequence
as a one-dimensional image.
In this way,
one-dimensional CNNs
can process local features
such as $n$-grams in text.</p>
<p>In this section,
we will use the <em>textCNN</em> model
to demonstrate
how to design a CNN architecture
for representing single text :cite:<code>Kim.2014</code>.
Compared with
:numref:<code>fig_nlp-map-sa-rnn</code>
that uses an RNN architecture with GloVe pretraining
for sentiment analysis,
the only difference in :numref:<code>fig_nlp-map-sa-cnn</code>
lies in
the choice of the architecture.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nlp-map-sa-cnn.svg" alt="This section feeds pretrained GloVe to a CNN-based architecture for sentiment analysis." />
:label:<code>fig_nlp-map-sa-cnn</code></p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()

batch_size = 64
train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn

batch_size = 64
train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
</code></pre>
<h2 id="one-dimensional-convolutions"><a class="header" href="#one-dimensional-convolutions">One-Dimensional Convolutions</a></h2>
<p>Before introducing the model,
let's see how a one-dimensional convolution works.
Bear in mind that it is just a special case
of a two-dimensional convolution
based on the cross-correlation operation.</p>
<p><img src="chapter_natural-language-processing-applications/../img/conv1d.svg" alt="One-dimensional cross-correlation operation. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: $0\times1+1\times2=2$." />
:label:<code>fig_conv1d</code></p>
<p>As shown in :numref:<code>fig_conv1d</code>,
in the one-dimensional case,
the convolution window
slides from left to right
across the input tensor.
During sliding,
the input subtensor (e.g., $0$ and $1$ in :numref:<code>fig_conv1d</code>) contained in the convolution window
at a certain position
and the kernel tensor (e.g., $1$ and $2$ in :numref:<code>fig_conv1d</code>) are multiplied elementwise.
The sum of these multiplications
gives the single scalar value (e.g., $0\times1+1\times2=2$ in :numref:<code>fig_conv1d</code>)
at the corresponding position of the output tensor.</p>
<p>We implement one-dimensional cross-correlation in the following <code>corr1d</code> function.
Given an input tensor <code>X</code>
and a kernel tensor <code>K</code>,
it returns the output tensor <code>Y</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def corr1d(X, K):
    w = K.shape[0]
    Y = d2l.zeros((X.shape[0] - w + 1))
    for i in range(Y.shape[0]):
        Y[i] = (X[i: i + w] * K).sum()
    return Y
</code></pre>
<p>We can construct the input tensor <code>X</code> and the kernel tensor <code>K</code> from :numref:<code>fig_conv1d</code> to validate the output of the above one-dimensional cross-correlation implementation.</p>
<pre><code class="language-{.python .input}">#@tab all
X, K = d2l.tensor([0, 1, 2, 3, 4, 5, 6]), d2l.tensor([1, 2])
corr1d(X, K)
</code></pre>
<p>For any
one-dimensional input with multiple channels,
the convolution kernel
needs to have the same number of input channels.
Then for each channel,
perform a cross-correlation operation on the one-dimensional tensor of the input and the one-dimensional tensor of the convolution kernel,
summing the results over all the channels
to produce the one-dimensional output tensor.
:numref:<code>fig_conv1d_channel</code> shows a one-dimensional cross-correlation operation with 3 input channels.</p>
<p><img src="chapter_natural-language-processing-applications/../img/conv1d-channel.svg" alt="One-dimensional cross-correlation operation with 3 input channels. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: $0\times1+1\times2+1\times3+2\times4+2\times(-1)+3\times(-3)=2$." />
:label:<code>fig_conv1d_channel</code></p>
<p>We can implement the one-dimensional cross-correlation operation for multiple input channels
and validate the results in :numref:<code>fig_conv1d_channel</code>.</p>
<pre><code class="language-{.python .input}">#@tab all
def corr1d_multi_in(X, K):
    # First, iterate through the 0th dimension (channel dimension) of `X` and
    # `K`. Then, add them together
    return sum(corr1d(x, k) for x, k in zip(X, K))

X = d2l.tensor([[0, 1, 2, 3, 4, 5, 6],
              [1, 2, 3, 4, 5, 6, 7],
              [2, 3, 4, 5, 6, 7, 8]])
K = d2l.tensor([[1, 2], [3, 4], [-1, -3]])
corr1d_multi_in(X, K)
</code></pre>
<p>Note that
multi-input-channel one-dimensional cross-correlations
are equivalent
to
single-input-channel
two-dimensional cross-correlations.
To illustrate,
an equivalent form of
the multi-input-channel one-dimensional cross-correlation
in :numref:<code>fig_conv1d_channel</code>
is
the
single-input-channel
two-dimensional cross-correlation
in :numref:<code>fig_conv1d_2d</code>,
where the height of the convolution kernel
has to be the same as that of the input tensor.</p>
<p><img src="chapter_natural-language-processing-applications/../img/conv1d-2d.svg" alt="Two-dimensional cross-correlation operation with a single input channel. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: $2\times(-1)+3\times(-3)+1\times3+2\times4+0\times1+1\times2=2$." />
:label:<code>fig_conv1d_2d</code></p>
<p>Both the outputs in :numref:<code>fig_conv1d</code> and :numref:<code>fig_conv1d_channel</code> have only one channel.
Same as two-dimensional convolutions with multiple output channels described in :numref:<code>subsec_multi-output-channels</code>,
we can also specify multiple output channels
for one-dimensional convolutions.</p>
<h2 id="max-over-time-pooling"><a class="header" href="#max-over-time-pooling">Max-Over-Time Pooling</a></h2>
<p>Similarly, we can use pooling
to extract the highest value
from sequence representations
as the most important feature
across time steps.
The <em>max-over-time pooling</em> used in textCNN
works like
the one-dimensional global max-pooling
:cite:<code>Collobert.Weston.Bottou.ea.2011</code>.
For a multi-channel input
where each channel stores values
at different time steps,
the output at each channel
is the maximum value
for that channel.
Note that
the max-over-time pooling
allows different numbers of time steps
at different channels.</p>
<h2 id="the-textcnn-model"><a class="header" href="#the-textcnn-model">The textCNN Model</a></h2>
<p>Using the one-dimensional convolution
and max-over-time pooling,
the textCNN model
takes individual pretrained token representations
as input,
then obtains and transforms sequence representations
for the downstream application.</p>
<p>For a single text sequence
with $n$ tokens represented by
$d$-dimensional vectors,
the width, height, and number of channels
of the input tensor
are $n$, $1$, and $d$, respectively.
The textCNN model transforms the input
into the output as follows:</p>
<ol>
<li>Define multiple one-dimensional convolution kernels and perform convolution operations separately on the inputs. Convolution kernels with different widths may capture local features among different numbers of adjacent tokens.</li>
<li>Perform max-over-time pooling on all the output channels, and then concatenate all the scalar pooling outputs as a vector.</li>
<li>Transform the concatenated vector into the output categories using the fully connected layer. Dropout can be used for reducing overfitting.</li>
</ol>
<p><img src="chapter_natural-language-processing-applications/../img/textcnn.svg" alt="The model architecture of textCNN." />
:label:<code>fig_conv1d_textcnn</code></p>
<p>:numref:<code>fig_conv1d_textcnn</code>
illustrates the model architecture of textCNN
with a concrete example.
The input is a sentence with 11 tokens,
where
each token is represented by a 6-dimensional vectors.
So we have a 6-channel input with width 11.
Define
two one-dimensional convolution kernels
of widths 2 and 4,
with 4 and 5 output channels, respectively.
They produce
4 output channels with width $11-2+1=10$
and 5 output channels with width $11-4+1=8$.
Despite different widths of these 9 channels,
the max-over-time pooling
gives a concatenated 9-dimensional vector,
which is finally transformed
into a 2-dimensional output vector
for binary sentiment predictions.</p>
<h3 id="defining-the-model-8"><a class="header" href="#defining-the-model-8">Defining the Model</a></h3>
<p>We implement the textCNN model in the following class.
Compared with the bidirectional RNN model in
:numref:<code>sec_sentiment_rnn</code>,
besides
replacing recurrent layers with convolutional layers,
we also use two embedding layers:
one with trainable weights and the other
with fixed weights.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class TextCNN(nn.Block):
    def __init__(self, vocab_size, embed_size, kernel_sizes, num_channels,
                 **kwargs):
        super(TextCNN, self).__init__(**kwargs)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        # The embedding layer not to be trained
        self.constant_embedding = nn.Embedding(vocab_size, embed_size)
        self.dropout = nn.Dropout(0.5)
        self.decoder = nn.Dense(2)
        # The max-over-time pooling layer has no parameters, so this instance
        # can be shared
        self.pool = nn.GlobalMaxPool1D()
        # Create multiple one-dimensional convolutional layers
        self.convs = nn.Sequential()
        for c, k in zip(num_channels, kernel_sizes):
            self.convs.add(nn.Conv1D(c, k, activation='relu'))

    def forward(self, inputs):
        # Concatenate two embedding layer outputs with shape (batch size, no.
        # of tokens, token vector dimension) along vectors
        embeddings = np.concatenate((
            self.embedding(inputs), self.constant_embedding(inputs)), axis=2)
        # Per the input format of one-dimensional convolutional layers,
        # rearrange the tensor so that the second dimension stores channels
        embeddings = embeddings.transpose(0, 2, 1)
        # For each one-dimensional convolutional layer, after max-over-time
        # pooling, a tensor of shape (batch size, no. of channels, 1) is
        # obtained. Remove the last dimension and concatenate along channels
        encoding = np.concatenate([
            np.squeeze(self.pool(conv(embeddings)), axis=-1)
            for conv in self.convs], axis=1)
        outputs = self.decoder(self.dropout(encoding))
        return outputs
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class TextCNN(nn.Module):
    def __init__(self, vocab_size, embed_size, kernel_sizes, num_channels,
                 **kwargs):
        super(TextCNN, self).__init__(**kwargs)
        self.embedding = nn.Embedding(vocab_size, embed_size)
        # The embedding layer not to be trained
        self.constant_embedding = nn.Embedding(vocab_size, embed_size)
        self.dropout = nn.Dropout(0.5)
        self.decoder = nn.Linear(sum(num_channels), 2)
        # The max-over-time pooling layer has no parameters, so this instance
        # can be shared
        self.pool = nn.AdaptiveAvgPool1d(1)
        self.relu = nn.ReLU()
        # Create multiple one-dimensional convolutional layers
        self.convs = nn.ModuleList()
        for c, k in zip(num_channels, kernel_sizes):
            self.convs.append(nn.Conv1d(2 * embed_size, c, k))

    def forward(self, inputs):
        # Concatenate two embedding layer outputs with shape (batch size, no.
        # of tokens, token vector dimension) along vectors
        embeddings = torch.cat((
            self.embedding(inputs), self.constant_embedding(inputs)), dim=2)
        # Per the input format of one-dimensional convolutional layers,
        # rearrange the tensor so that the second dimension stores channels
        embeddings = embeddings.permute(0, 2, 1)
        # For each one-dimensional convolutional layer, after max-over-time
        # pooling, a tensor of shape (batch size, no. of channels, 1) is
        # obtained. Remove the last dimension and concatenate along channels
        encoding = torch.cat([
            torch.squeeze(self.relu(self.pool(conv(embeddings))), dim=-1)
            for conv in self.convs], dim=1)
        outputs = self.decoder(self.dropout(encoding))
        return outputs
</code></pre>
<p>Let's create a textCNN instance.
It has 3 convolutional layers with kernel widths of 3, 4, and 5, all with 100 output channels.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
embed_size, kernel_sizes, nums_channels = 100, [3, 4, 5], [100, 100, 100]
devices = d2l.try_all_gpus()
net = TextCNN(len(vocab), embed_size, kernel_sizes, nums_channels)
net.initialize(init.Xavier(), ctx=devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
embed_size, kernel_sizes, nums_channels = 100, [3, 4, 5], [100, 100, 100]
devices = d2l.try_all_gpus()
net = TextCNN(len(vocab), embed_size, kernel_sizes, nums_channels)

def init_weights(module):
    if type(module) in (nn.Linear, nn.Conv1d):
        nn.init.xavier_uniform_(module.weight)

net.apply(init_weights);
</code></pre>
<h3 id="loading-pretrained-word-vectors-2"><a class="header" href="#loading-pretrained-word-vectors-2">Loading Pretrained Word Vectors</a></h3>
<p>Same as :numref:<code>sec_sentiment_rnn</code>,
we load pretrained 100-dimensional GloVe embeddings
as the initialized token representations.
These token representations (embedding weights)
will be trained in <code>embedding</code>
and fixed in <code>constant_embedding</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
embeds = glove_embedding[vocab.idx_to_token]
net.embedding.weight.set_data(embeds)
net.constant_embedding.weight.set_data(embeds)
net.constant_embedding.collect_params().setattr('grad_req', 'null')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
embeds = glove_embedding[vocab.idx_to_token]
net.embedding.weight.data.copy_(embeds)
net.constant_embedding.weight.data.copy_(embeds)
net.constant_embedding.weight.requires_grad = False
</code></pre>
<h3 id="training-and-evaluating-the-model-1"><a class="header" href="#training-and-evaluating-the-model-1">Training and Evaluating the Model</a></h3>
<p>Now we can train the textCNN model for sentiment analysis.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lr, num_epochs = 0.001, 5
trainer = gluon.Trainer(net.collect_params(), 'adam', {'learning_rate': lr})
loss = gluon.loss.SoftmaxCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr, num_epochs = 0.001, 5
trainer = torch.optim.Adam(net.parameters(), lr=lr)
loss = nn.CrossEntropyLoss(reduction="none")
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<p>Below we use the trained model to predict the sentiment for two simple sentences.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.predict_sentiment(net, vocab, 'this movie is so great')
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
d2l.predict_sentiment(net, vocab, 'this movie is so bad')
</code></pre>
<h2 id="summary-98"><a class="header" href="#summary-98">Summary</a></h2>
<ul>
<li>One-dimensional CNNs can process local features such as $n$-grams in text.</li>
<li>Multi-input-channel one-dimensional cross-correlations are equivalent to single-input-channel two-dimensional cross-correlations.</li>
<li>The max-over-time pooling allows different numbers of time steps at different channels.</li>
<li>The textCNN model transforms individual token representations into downstream application outputs using one-dimensional convolutional layers and max-over-time pooling layers.</li>
</ul>
<h2 id="exercises-118"><a class="header" href="#exercises-118">Exercises</a></h2>
<ol>
<li>Tune hyperparameters and compare the two architectures for sentiment analysis in :numref:<code>sec_sentiment_rnn</code> and in this section, such as in classification accuracy and computational efficiency.</li>
<li>Can you further improve the classification accuracy of the model by using the methods introduced in the exercises of :numref:<code>sec_sentiment_rnn</code>?</li>
<li>Add positional encoding in the input representations. Does it improve the classification accuracy?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/393">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1425">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-language-inference-and-the-dataset"><a class="header" href="#natural-language-inference-and-the-dataset">Natural Language Inference and the Dataset</a></h1>
<p>:label:<code>sec_natural-language-inference-and-dataset</code></p>
<p>In :numref:<code>sec_sentiment</code>, we discussed the problem of sentiment analysis.
This task aims to classify a single text sequence into predefined categories,
such as a set of sentiment polarities.
However, when there is a need to decide whether one sentence can be inferred form another,
or eliminate redundancy by identifying sentences that are semantically equivalent,
knowing how to classify one text sequence is insufficient.
Instead, we need to be able to reason over pairs of text sequences.</p>
<h2 id="natural-language-inference"><a class="header" href="#natural-language-inference">Natural Language Inference</a></h2>
<p><em>Natural language inference</em> studies whether a <em>hypothesis</em>
can be inferred from a <em>premise</em>, where both are a text sequence.
In other words, natural language inference determines the logical relationship between a pair of text sequences.
Such relationships usually fall into three types:</p>
<ul>
<li><em>Entailment</em>: the hypothesis can be inferred from the premise.</li>
<li><em>Contradiction</em>: the negation of the hypothesis can be inferred from the premise.</li>
<li><em>Neutral</em>: all the other cases.</li>
</ul>
<p>Natural language inference is also known as the recognizing textual entailment task.
For example, the following pair will be labeled as <em>entailment</em> because "showing affection" in the hypothesis can be inferred from "hugging one another" in the premise.</p>
<blockquote>
<p>Premise: Two women are hugging each other.</p>
</blockquote>
<blockquote>
<p>Hypothesis: Two women are showing affection.</p>
</blockquote>
<p>The following is an example of <em>contradiction</em> as "running the coding example" indicates "not sleeping" rather than "sleeping".</p>
<blockquote>
<p>Premise: A man is running the coding example from Dive into Deep Learning.</p>
</blockquote>
<blockquote>
<p>Hypothesis: The man is sleeping.</p>
</blockquote>
<p>The third example shows a <em>neutrality</em> relationship because neither "famous" nor "not famous" can be inferred from the fact that "are performing for us".</p>
<blockquote>
<p>Premise: The musicians are performing for us.</p>
</blockquote>
<blockquote>
<p>Hypothesis: The musicians are famous.</p>
</blockquote>
<p>Natural language inference has been a central topic for understanding natural language.
It enjoys wide applications ranging from
information retrieval to open-domain question answering.
To study this problem, we will begin by investigating a popular natural language inference benchmark dataset.</p>
<h2 id="the-stanford-natural-language-inference-snli-dataset"><a class="header" href="#the-stanford-natural-language-inference-snli-dataset">The Stanford Natural Language Inference (SNLI) Dataset</a></h2>
<p>[<strong>Stanford Natural Language Inference (SNLI) Corpus</strong>] is a collection of over 500000 labeled English sentence pairs :cite:<code>Bowman.Angeli.Potts.ea.2015</code>.
We download and store the extracted SNLI dataset in the path <code>../data/snli_1.0</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, np, npx
import os
import re

npx.set_np()

#@save
d2l.DATA_HUB['SNLI'] = (
    'https://nlp.stanford.edu/projects/snli/snli_1.0.zip',
    '9fcde07509c7e87ec61c640c1b2753d9041758e4')

data_dir = d2l.download_extract('SNLI')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
import os
import re

#@save
d2l.DATA_HUB['SNLI'] = (
    'https://nlp.stanford.edu/projects/snli/snli_1.0.zip',
    '9fcde07509c7e87ec61c640c1b2753d9041758e4')

data_dir = d2l.download_extract('SNLI')
</code></pre>
<h3 id="reading-the-dataset-13"><a class="header" href="#reading-the-dataset-13">[<strong>Reading the Dataset</strong>]</a></h3>
<p>The original SNLI dataset contains much richer information than what we really need in our experiments. Thus, we define a function <code>read_snli</code> to only extract part of the dataset, then return lists of premises, hypotheses, and their labels.</p>
<pre><code class="language-{.python .input}">#@tab all
#@save
def read_snli(data_dir, is_train):
    """Read the SNLI dataset into premises, hypotheses, and labels."""
    def extract_text(s):
        # Remove information that will not be used by us
        s = re.sub('\\(', '', s) 
        s = re.sub('\\)', '', s)
        # Substitute two or more consecutive whitespace with space
        s = re.sub('\\s{2,}', ' ', s)
        return s.strip()
    label_set = {'entailment': 0, 'contradiction': 1, 'neutral': 2}
    file_name = os.path.join(data_dir, 'snli_1.0_train.txt'
                             if is_train else 'snli_1.0_test.txt')
    with open(file_name, 'r') as f:
        rows = [row.split('\t') for row in f.readlines()[1:]]
    premises = [extract_text(row[1]) for row in rows if row[0] in label_set]
    hypotheses = [extract_text(row[2]) for row in rows if row[0] in label_set]
    labels = [label_set[row[0]] for row in rows if row[0] in label_set]
    return premises, hypotheses, labels
</code></pre>
<p>Now let's [<strong>print the first 3 pairs</strong>] of premise and hypothesis, as well as their labels ("0", "1", and "2" correspond to "entailment", "contradiction", and "neutral", respectively ).</p>
<pre><code class="language-{.python .input}">#@tab all
train_data = read_snli(data_dir, is_train=True)
for x0, x1, y in zip(train_data[0][:3], train_data[1][:3], train_data[2][:3]):
    print('premise:', x0)
    print('hypothesis:', x1)
    print('label:', y)
</code></pre>
<p>The training set has about 550000 pairs,
and the testing set has about 10000 pairs.
The following shows that
the three [<strong>labels "entailment", "contradiction", and "neutral" are balanced</strong>] in
both the training set and the testing set.</p>
<pre><code class="language-{.python .input}">#@tab all
test_data = read_snli(data_dir, is_train=False)
for data in [train_data, test_data]:
    print([[row for row in data[2]].count(i) for i in range(3)])
</code></pre>
<h3 id="defining-a-class-for-loading-the-dataset"><a class="header" href="#defining-a-class-for-loading-the-dataset">[<strong>Defining a Class for Loading the Dataset</strong>]</a></h3>
<p>Below we define a class for loading the SNLI dataset by inheriting from the <code>Dataset</code> class in Gluon. The argument <code>num_steps</code> in the class constructor specifies the length of a text sequence so that each minibatch of sequences will have the same shape.
In other words,
tokens after the first <code>num_steps</code> ones in longer sequence are trimmed, while special tokens “&lt;pad&gt;” will be appended to shorter sequences until their length becomes <code>num_steps</code>.
By implementing the <code>__getitem__</code> function, we can arbitrarily access the premise, hypothesis, and label with the index <code>idx</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
class SNLIDataset(gluon.data.Dataset):
    """A customized dataset to load the SNLI dataset."""
    def __init__(self, dataset, num_steps, vocab=None):
        self.num_steps = num_steps
        all_premise_tokens = d2l.tokenize(dataset[0])
        all_hypothesis_tokens = d2l.tokenize(dataset[1])
        if vocab is None:
            self.vocab = d2l.Vocab(all_premise_tokens + all_hypothesis_tokens,
                                   min_freq=5, reserved_tokens=['&lt;pad&gt;'])
        else:
            self.vocab = vocab
        self.premises = self._pad(all_premise_tokens)
        self.hypotheses = self._pad(all_hypothesis_tokens)
        self.labels = np.array(dataset[2])
        print('read ' + str(len(self.premises)) + ' examples')

    def _pad(self, lines):
        return np.array([d2l.truncate_pad(
            self.vocab[line], self.num_steps, self.vocab['&lt;pad&gt;'])
                         for line in lines])

    def __getitem__(self, idx):
        return (self.premises[idx], self.hypotheses[idx]), self.labels[idx]

    def __len__(self):
        return len(self.premises)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
class SNLIDataset(torch.utils.data.Dataset):
    """A customized dataset to load the SNLI dataset."""
    def __init__(self, dataset, num_steps, vocab=None):
        self.num_steps = num_steps
        all_premise_tokens = d2l.tokenize(dataset[0])
        all_hypothesis_tokens = d2l.tokenize(dataset[1])
        if vocab is None:
            self.vocab = d2l.Vocab(all_premise_tokens + all_hypothesis_tokens,
                                   min_freq=5, reserved_tokens=['&lt;pad&gt;'])
        else:
            self.vocab = vocab
        self.premises = self._pad(all_premise_tokens)
        self.hypotheses = self._pad(all_hypothesis_tokens)
        self.labels = torch.tensor(dataset[2])
        print('read ' + str(len(self.premises)) + ' examples')

    def _pad(self, lines):
        return torch.tensor([d2l.truncate_pad(
            self.vocab[line], self.num_steps, self.vocab['&lt;pad&gt;'])
                         for line in lines])

    def __getitem__(self, idx):
        return (self.premises[idx], self.hypotheses[idx]), self.labels[idx]

    def __len__(self):
        return len(self.premises)
</code></pre>
<h3 id="putting-it-all-together-6"><a class="header" href="#putting-it-all-together-6">[<strong>Putting It All Together</strong>]</a></h3>
<p>Now we can invoke the <code>read_snli</code> function and the <code>SNLIDataset</code> class to download the SNLI dataset and return <code>DataLoader</code> instances for both training and testing sets, together with the vocabulary of the training set.
It is noteworthy that we must use the vocabulary constructed from the training set
as that of the testing set.
As a result, any new token from the testing set will be unknown to the model trained on the training set.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def load_data_snli(batch_size, num_steps=50):
    """Download the SNLI dataset and return data iterators and vocabulary."""
    num_workers = d2l.get_dataloader_workers()
    data_dir = d2l.download_extract('SNLI')
    train_data = read_snli(data_dir, True)
    test_data = read_snli(data_dir, False)
    train_set = SNLIDataset(train_data, num_steps)
    test_set = SNLIDataset(test_data, num_steps, train_set.vocab)
    train_iter = gluon.data.DataLoader(train_set, batch_size, shuffle=True,
                                       num_workers=num_workers)
    test_iter = gluon.data.DataLoader(test_set, batch_size, shuffle=False,
                                      num_workers=num_workers)
    return train_iter, test_iter, train_set.vocab
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def load_data_snli(batch_size, num_steps=50):
    """Download the SNLI dataset and return data iterators and vocabulary."""
    num_workers = d2l.get_dataloader_workers()
    data_dir = d2l.download_extract('SNLI')
    train_data = read_snli(data_dir, True)
    test_data = read_snli(data_dir, False)
    train_set = SNLIDataset(train_data, num_steps)
    test_set = SNLIDataset(test_data, num_steps, train_set.vocab)
    train_iter = torch.utils.data.DataLoader(train_set, batch_size,
                                             shuffle=True,
                                             num_workers=num_workers)
    test_iter = torch.utils.data.DataLoader(test_set, batch_size,
                                            shuffle=False,
                                            num_workers=num_workers)
    return train_iter, test_iter, train_set.vocab
</code></pre>
<p>Here we set the batch size to 128 and sequence length to 50,
and invoke the <code>load_data_snli</code> function to get the data iterators and vocabulary.
Then we print the vocabulary size.</p>
<pre><code class="language-{.python .input}">#@tab all
train_iter, test_iter, vocab = load_data_snli(128, 50)
len(vocab)
</code></pre>
<p>Now we print the shape of the first minibatch.
Contrary to sentiment analysis,
we have two inputs <code>X[0]</code> and <code>X[1]</code> representing pairs of premises and hypotheses.</p>
<pre><code class="language-{.python .input}">#@tab all
for X, Y in train_iter:
    print(X[0].shape)
    print(X[1].shape)
    print(Y.shape)
    break
</code></pre>
<h2 id="summary-99"><a class="header" href="#summary-99">Summary</a></h2>
<ul>
<li>Natural language inference studies whether a hypothesis can be inferred from a premise, where both are a text sequence.</li>
<li>In natural language inference, relationships between premises and hypotheses include entailment, contradiction, and neutral.</li>
<li>Stanford Natural Language Inference (SNLI) Corpus is a popular benchmark dataset of natural language inference.</li>
</ul>
<h2 id="exercises-119"><a class="header" href="#exercises-119">Exercises</a></h2>
<ol>
<li>Machine translation has long been evaluated based on superficial $n$-gram matching between an output translation and a ground-truth translation. Can you design a measure for evaluating machine translation results by using natural language inference?</li>
<li>How can we change hyperparameters to reduce the vocabulary size?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/394">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1388">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-language-inference-using-attention"><a class="header" href="#natural-language-inference-using-attention">Natural Language Inference: Using Attention</a></h1>
<p>:label:<code>sec_natural-language-inference-attention</code></p>
<p>We introduced the natural language inference task and the SNLI dataset in :numref:<code>sec_natural-language-inference-and-dataset</code>. In view of many models that are based on complex and deep architectures, :citet:<code>Parikh.Tackstrom.Das.ea.2016</code> proposed to address natural language inference with attention mechanisms and called it a "decomposable attention model".
This results in a model without recurrent or convolutional layers, achieving the best result at the time on the SNLI dataset with much fewer parameters.
In this section, we will describe and implement this attention-based method (with MLPs) for natural language inference, as depicted in :numref:<code>fig_nlp-map-nli-attention</code>.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nlp-map-nli-attention.svg" alt="This section feeds pretrained GloVe to an architecture based on attention and MLPs for natural language inference." />
:label:<code>fig_nlp-map-nli-attention</code></p>
<h2 id="the-model-2"><a class="header" href="#the-model-2">The Model</a></h2>
<p>Simpler than preserving the order of tokens in premises and hypotheses,
we can just align tokens in one text sequence to every token in the other, and vice versa,
then compare and aggregate such information to predict the logical relationships
between premises and hypotheses.
Similar to alignment of tokens between source and target sentences in machine translation,
the alignment of tokens between premises and hypotheses
can be neatly accomplished by attention mechanisms.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nli-attention.svg" alt="Natural language inference using attention mechanisms." />
:label:<code>fig_nli_attention</code></p>
<p>:numref:<code>fig_nli_attention</code> depicts the natural language inference method using attention mechanisms.
At a high level, it consists of three jointly trained steps: attending, comparing, and aggregating.
We will illustrate them step by step in the following.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, init, np, npx
from mxnet.gluon import nn

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
from torch import nn
from torch.nn import functional as F
</code></pre>
<h3 id="attending"><a class="header" href="#attending">Attending</a></h3>
<p>The first step is to align tokens in one text sequence to each token in the other sequence.
Suppose that the premise is "i do need sleep" and the hypothesis is "i am tired".
Due to semantical similarity,
we may wish to align "i" in the hypothesis with "i" in the premise,
and align "tired" in the hypothesis with "sleep" in the premise.
Likewise, we may wish to align "i" in the premise with "i" in the hypothesis,
and align "need" and "sleep" in the premise with "tired" in the hypothesis.
Note that such alignment is <em>soft</em> using weighted average,
where ideally large weights are associated with the tokens to be aligned.
For ease of demonstration, :numref:<code>fig_nli_attention</code> shows such alignment in a <em>hard</em> way.</p>
<p>Now we describe the soft alignment using attention mechanisms in more detail.
Denote by $\mathbf{A} = (\mathbf{a}_1, \ldots, \mathbf{a}_m)$
and $\mathbf{B} = (\mathbf{b}_1, \ldots, \mathbf{b}_n)$ the premise and hypothesis,
whose number of tokens are $m$ and $n$, respectively,
where $\mathbf{a}_i, \mathbf{b}<em>j \in \mathbb{R}^{d}$ ($i = 1, \ldots, m, j = 1, \ldots, n$) is a $d$-dimensional word vector.
For soft alignment, we compute the attention weights $e</em>{ij} \in \mathbb{R}$ as</p>
<p>$$e_{ij} = f(\mathbf{a}_i)^\top f(\mathbf{b}_j),$$
:eqlabel:<code>eq_nli_e</code></p>
<p>where the function $f$ is an MLP defined in the following <code>mlp</code> function.
The output dimension of $f$ is specified by the <code>num_hiddens</code> argument of <code>mlp</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def mlp(num_hiddens, flatten):
    net = nn.Sequential()
    net.add(nn.Dropout(0.2))
    net.add(nn.Dense(num_hiddens, activation='relu', flatten=flatten))
    net.add(nn.Dropout(0.2))
    net.add(nn.Dense(num_hiddens, activation='relu', flatten=flatten))
    return net
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def mlp(num_inputs, num_hiddens, flatten):
    net = []
    net.append(nn.Dropout(0.2))
    net.append(nn.Linear(num_inputs, num_hiddens))
    net.append(nn.ReLU())
    if flatten:
        net.append(nn.Flatten(start_dim=1))
    net.append(nn.Dropout(0.2))
    net.append(nn.Linear(num_hiddens, num_hiddens))
    net.append(nn.ReLU())
    if flatten:
        net.append(nn.Flatten(start_dim=1))
    return nn.Sequential(*net)
</code></pre>
<p>It should be highlighted that, in :eqref:<code>eq_nli_e</code>
$f$ takes inputs $\mathbf{a}_i$ and $\mathbf{b}_j$ separately rather than takes a pair of them together as input.
This <em>decomposition</em> trick leads to only $m + n$ applications (linear complexity) of $f$ rather than $mn$ applications
(quadratic complexity).</p>
<p>Normalizing the attention weights in :eqref:<code>eq_nli_e</code>,
we compute the weighted average of all the token vectors in the hypothesis
to obtain representation of the hypothesis that is softly aligned with the token indexed by $i$ in the premise:</p>
<p>$$
\boldsymbol{\beta}<em>i = \sum</em>{j=1}^{n}\frac{\exp(e_{ij})}{ \sum_{k=1}^{n} \exp(e_{ik})} \mathbf{b}_j.
$$</p>
<p>Likewise, we compute soft alignment of premise tokens for each token indexed by $j$ in the hypothesis:</p>
<p>$$
\boldsymbol{\alpha}<em>j = \sum</em>{i=1}^{m}\frac{\exp(e_{ij})}{ \sum_{k=1}^{m} \exp(e_{kj})} \mathbf{a}_i.
$$</p>
<p>Below we define the <code>Attend</code> class to compute the soft alignment of hypotheses (<code>beta</code>) with input premises <code>A</code> and soft alignment of premises (<code>alpha</code>) with input hypotheses <code>B</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class Attend(nn.Block):
    def __init__(self, num_hiddens, **kwargs):
        super(Attend, self).__init__(**kwargs)
        self.f = mlp(num_hiddens=num_hiddens, flatten=False)

    def forward(self, A, B):
        # Shape of `A`/`B`: (b`atch_size`, no. of tokens in sequence A/B,
        # `embed_size`)
        # Shape of `f_A`/`f_B`: (`batch_size`, no. of tokens in sequence A/B,
        # `num_hiddens`)
        f_A = self.f(A)
        f_B = self.f(B)
        # Shape of `e`: (`batch_size`, no. of tokens in sequence A,
        # no. of tokens in sequence B)
        e = npx.batch_dot(f_A, f_B, transpose_b=True)
        # Shape of `beta`: (`batch_size`, no. of tokens in sequence A,
        # `embed_size`), where sequence B is softly aligned with each token
        # (axis 1 of `beta`) in sequence A
        beta = npx.batch_dot(npx.softmax(e), B)
        # Shape of `alpha`: (`batch_size`, no. of tokens in sequence B,
        # `embed_size`), where sequence A is softly aligned with each token
        # (axis 1 of `alpha`) in sequence B
        alpha = npx.batch_dot(npx.softmax(e.transpose(0, 2, 1)), A)
        return beta, alpha
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class Attend(nn.Module):
    def __init__(self, num_inputs, num_hiddens, **kwargs):
        super(Attend, self).__init__(**kwargs)
        self.f = mlp(num_inputs, num_hiddens, flatten=False)

    def forward(self, A, B):
        # Shape of `A`/`B`: (`batch_size`, no. of tokens in sequence A/B,
        # `embed_size`)
        # Shape of `f_A`/`f_B`: (`batch_size`, no. of tokens in sequence A/B,
        # `num_hiddens`)
        f_A = self.f(A)
        f_B = self.f(B)
        # Shape of `e`: (`batch_size`, no. of tokens in sequence A,
        # no. of tokens in sequence B)
        e = torch.bmm(f_A, f_B.permute(0, 2, 1))
        # Shape of `beta`: (`batch_size`, no. of tokens in sequence A,
        # `embed_size`), where sequence B is softly aligned with each token
        # (axis 1 of `beta`) in sequence A
        beta = torch.bmm(F.softmax(e, dim=-1), B)
        # Shape of `alpha`: (`batch_size`, no. of tokens in sequence B,
        # `embed_size`), where sequence A is softly aligned with each token
        # (axis 1 of `alpha`) in sequence B
        alpha = torch.bmm(F.softmax(e.permute(0, 2, 1), dim=-1), A)
        return beta, alpha
</code></pre>
<h3 id="comparing"><a class="header" href="#comparing">Comparing</a></h3>
<p>In the next step, we compare a token in one sequence with the other sequence that is softly aligned with that token.
Note that in soft alignment, all the tokens from one sequence, though with probably different attention weights, will be compared with a token in the other sequence.
For easy of demonstration, :numref:<code>fig_nli_attention</code> pairs tokens with aligned tokens in a <em>hard</em> way.
For example, suppose that the attending step determines that "need" and "sleep" in the premise are both aligned with "tired" in the hypothesis, the pair "tired--need sleep" will be compared.</p>
<p>In the comparing step, we feed the concatenation (operator $[\cdot, \cdot]$) of tokens from one sequence and aligned tokens from the other sequence into a function $g$ (an MLP):</p>
<p>$$\mathbf{v}_{A,i} = g([\mathbf{a}_i, \boldsymbol{\beta}<em>i]), i = 1, \ldots, m\ \mathbf{v}</em>{B,j} = g([\mathbf{b}_j, \boldsymbol{\alpha}_j]), j = 1, \ldots, n.$$</p>
<p>:eqlabel:<code>eq_nli_v_ab</code></p>
<p>In :eqref:<code>eq_nli_v_ab</code>, $\mathbf{v}<em>{A,i}$ is the comparison between token $i$ in the premise and all the hypothesis tokens that are softly aligned with token $i$;
while $\mathbf{v}</em>{B,j}$ is the comparison between token $j$ in the hypothesis and all the premise tokens that are softly aligned with token $j$.
The following <code>Compare</code> class defines such as comparing step.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class Compare(nn.Block):
    def __init__(self, num_hiddens, **kwargs):
        super(Compare, self).__init__(**kwargs)
        self.g = mlp(num_hiddens=num_hiddens, flatten=False)

    def forward(self, A, B, beta, alpha):
        V_A = self.g(np.concatenate([A, beta], axis=2))
        V_B = self.g(np.concatenate([B, alpha], axis=2))
        return V_A, V_B
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class Compare(nn.Module):
    def __init__(self, num_inputs, num_hiddens, **kwargs):
        super(Compare, self).__init__(**kwargs)
        self.g = mlp(num_inputs, num_hiddens, flatten=False)

    def forward(self, A, B, beta, alpha):
        V_A = self.g(torch.cat([A, beta], dim=2))
        V_B = self.g(torch.cat([B, alpha], dim=2))
        return V_A, V_B
</code></pre>
<h3 id="aggregating"><a class="header" href="#aggregating">Aggregating</a></h3>
<p>With two sets of comparison vectors $\mathbf{v}<em>{A,i}$ ($i = 1, \ldots, m$) and $\mathbf{v}</em>{B,j}$ ($j = 1, \ldots, n$) on hand,
in the last step we will aggregate such information to infer the logical relationship.
We begin by summing up both sets:</p>
<p>$$
\mathbf{v}<em>A = \sum</em>{i=1}^{m} \mathbf{v}<em>{A,i}, \quad \mathbf{v}<em>B = \sum</em>{j=1}^{n}\mathbf{v}</em>{B,j}.
$$</p>
<p>Next we feed the concatenation of both summarization results into function $h$ (an MLP) to obtain the classification result of the logical relationship:</p>
<p>$$
\hat{\mathbf{y}} = h([\mathbf{v}_A, \mathbf{v}_B]).
$$</p>
<p>The aggregation step is defined in the following <code>Aggregate</code> class.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class Aggregate(nn.Block):
    def __init__(self, num_hiddens, num_outputs, **kwargs):
        super(Aggregate, self).__init__(**kwargs)
        self.h = mlp(num_hiddens=num_hiddens, flatten=True)
        self.h.add(nn.Dense(num_outputs))

    def forward(self, V_A, V_B):
        # Sum up both sets of comparison vectors
        V_A = V_A.sum(axis=1)
        V_B = V_B.sum(axis=1)
        # Feed the concatenation of both summarization results into an MLP
        Y_hat = self.h(np.concatenate([V_A, V_B], axis=1))
        return Y_hat
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class Aggregate(nn.Module):
    def __init__(self, num_inputs, num_hiddens, num_outputs, **kwargs):
        super(Aggregate, self).__init__(**kwargs)
        self.h = mlp(num_inputs, num_hiddens, flatten=True)
        self.linear = nn.Linear(num_hiddens, num_outputs)

    def forward(self, V_A, V_B):
        # Sum up both sets of comparison vectors
        V_A = V_A.sum(dim=1)
        V_B = V_B.sum(dim=1)
        # Feed the concatenation of both summarization results into an MLP
        Y_hat = self.linear(self.h(torch.cat([V_A, V_B], dim=1)))
        return Y_hat
</code></pre>
<h3 id="putting-it-all-together-7"><a class="header" href="#putting-it-all-together-7">Putting It All Together</a></h3>
<p>By putting the attending, comparing, and aggregating steps together,
we define the decomposable attention model to jointly train these three steps.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class DecomposableAttention(nn.Block):
    def __init__(self, vocab, embed_size, num_hiddens, **kwargs):
        super(DecomposableAttention, self).__init__(**kwargs)
        self.embedding = nn.Embedding(len(vocab), embed_size)
        self.attend = Attend(num_hiddens)
        self.compare = Compare(num_hiddens)
        # There are 3 possible outputs: entailment, contradiction, and neutral
        self.aggregate = Aggregate(num_hiddens, 3)

    def forward(self, X):
        premises, hypotheses = X
        A = self.embedding(premises)
        B = self.embedding(hypotheses)
        beta, alpha = self.attend(A, B)
        V_A, V_B = self.compare(A, B, beta, alpha)
        Y_hat = self.aggregate(V_A, V_B)
        return Y_hat
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class DecomposableAttention(nn.Module):
    def __init__(self, vocab, embed_size, num_hiddens, num_inputs_attend=100,
                 num_inputs_compare=200, num_inputs_agg=400, **kwargs):
        super(DecomposableAttention, self).__init__(**kwargs)
        self.embedding = nn.Embedding(len(vocab), embed_size)
        self.attend = Attend(num_inputs_attend, num_hiddens)
        self.compare = Compare(num_inputs_compare, num_hiddens)
        # There are 3 possible outputs: entailment, contradiction, and neutral
        self.aggregate = Aggregate(num_inputs_agg, num_hiddens, num_outputs=3)

    def forward(self, X):
        premises, hypotheses = X
        A = self.embedding(premises)
        B = self.embedding(hypotheses)
        beta, alpha = self.attend(A, B)
        V_A, V_B = self.compare(A, B, beta, alpha)
        Y_hat = self.aggregate(V_A, V_B)
        return Y_hat
</code></pre>
<h2 id="training-and-evaluating-the-model-2"><a class="header" href="#training-and-evaluating-the-model-2">Training and Evaluating the Model</a></h2>
<p>Now we will train and evaluate the defined decomposable attention model on the SNLI dataset.
We begin by reading the dataset.</p>
<h3 id="reading-the-dataset-14"><a class="header" href="#reading-the-dataset-14">Reading the dataset</a></h3>
<p>We download and read the SNLI dataset using the function defined in :numref:<code>sec_natural-language-inference-and-dataset</code>. The batch size and sequence length are set to $256$ and $50$, respectively.</p>
<pre><code class="language-{.python .input}">#@tab all
batch_size, num_steps = 256, 50
train_iter, test_iter, vocab = d2l.load_data_snli(batch_size, num_steps)
</code></pre>
<h3 id="creating-the-model"><a class="header" href="#creating-the-model">Creating the Model</a></h3>
<p>We use the pretrained 100-dimensional GloVe embedding to represent the input tokens.
Thus, we predefine the dimension of vectors $\mathbf{a}_i$ and $\mathbf{b}_j$ in :eqref:<code>eq_nli_e</code> as 100.
The output dimension of functions $f$ in :eqref:<code>eq_nli_e</code> and $g$ in :eqref:<code>eq_nli_v_ab</code> is set to 200.
Then we create a model instance, initialize its parameters,
and load the GloVe embedding to initialize vectors of input tokens.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
embed_size, num_hiddens, devices = 100, 200, d2l.try_all_gpus()
net = DecomposableAttention(vocab, embed_size, num_hiddens)
net.initialize(init.Xavier(), ctx=devices)
glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
embeds = glove_embedding[vocab.idx_to_token]
net.embedding.weight.set_data(embeds)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
embed_size, num_hiddens, devices = 100, 200, d2l.try_all_gpus()
net = DecomposableAttention(vocab, embed_size, num_hiddens)
glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
embeds = glove_embedding[vocab.idx_to_token]
net.embedding.weight.data.copy_(embeds);
</code></pre>
<h3 id="training-and-evaluating-the-model-3"><a class="header" href="#training-and-evaluating-the-model-3">Training and Evaluating the Model</a></h3>
<p>In contrast to the <code>split_batch</code> function in :numref:<code>sec_multi_gpu</code> that takes single inputs such as text sequences (or images),
we define a <code>split_batch_multi_inputs</code> function to take multiple inputs such as premises and hypotheses in minibatches.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def split_batch_multi_inputs(X, y, devices):
    """Split multi-input `X` and `y` into multiple devices."""
    X = list(zip(*[gluon.utils.split_and_load(
        feature, devices, even_split=False) for feature in X]))
    return (X, gluon.utils.split_and_load(y, devices, even_split=False))
</code></pre>
<p>Now we can train and evaluate the model on the SNLI dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lr, num_epochs = 0.001, 4
trainer = gluon.Trainer(net.collect_params(), 'adam', {'learning_rate': lr})
loss = gluon.loss.SoftmaxCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices,
               split_batch_multi_inputs)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr, num_epochs = 0.001, 4
trainer = torch.optim.Adam(net.parameters(), lr=lr)
loss = nn.CrossEntropyLoss(reduction="none")
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<h3 id="using-the-model"><a class="header" href="#using-the-model">Using the Model</a></h3>
<p>Finally, define the prediction function to output the logical relationship between a pair of premise and hypothesis.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def predict_snli(net, vocab, premise, hypothesis):
    """Predict the logical relationship between the premise and hypothesis."""
    premise = np.array(vocab[premise], ctx=d2l.try_gpu())
    hypothesis = np.array(vocab[hypothesis], ctx=d2l.try_gpu())
    label = np.argmax(net([premise.reshape((1, -1)),
                           hypothesis.reshape((1, -1))]), axis=1)
    return 'entailment' if label == 0 else 'contradiction' if label == 1 \
            else 'neutral'
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def predict_snli(net, vocab, premise, hypothesis):
    """Predict the logical relationship between the premise and hypothesis."""
    net.eval()
    premise = torch.tensor(vocab[premise], device=d2l.try_gpu())
    hypothesis = torch.tensor(vocab[hypothesis], device=d2l.try_gpu())
    label = torch.argmax(net([premise.reshape((1, -1)),
                           hypothesis.reshape((1, -1))]), dim=1)
    return 'entailment' if label == 0 else 'contradiction' if label == 1 \
            else 'neutral'
</code></pre>
<p>We can use the trained model to obtain the natural language inference result for a sample pair of sentences.</p>
<pre><code class="language-{.python .input}">#@tab all
predict_snli(net, vocab, ['he', 'is', 'good', '.'], ['he', 'is', 'bad', '.'])
</code></pre>
<h2 id="summary-100"><a class="header" href="#summary-100">Summary</a></h2>
<ul>
<li>The decomposable attention model consists of three steps for predicting the logical relationships between premises and hypotheses: attending, comparing, and aggregating.</li>
<li>With attention mechanisms, we can align tokens in one text sequence to every token in the other, and vice versa. Such alignment is soft using weighted average, where ideally large weights are associated with the tokens to be aligned.</li>
<li>The decomposition trick leads to a more desirable linear complexity than quadratic complexity when computing attention weights.</li>
<li>We can use pretrained word vectors as the input representation for downstream natural language processing task such as natural language inference.</li>
</ul>
<h2 id="exercises-120"><a class="header" href="#exercises-120">Exercises</a></h2>
<ol>
<li>Train the model with other combinations of hyperparameters. Can you get better accuracy on the test set?</li>
<li>What are major drawbacks of the decomposable attention model for natural language inference?</li>
<li>Suppose that we want to get the level of semantical similarity (e.g., a continuous value between 0 and 1) for any pair of sentences. How shall we collect and label the dataset? Can you design a model with attention mechanisms?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/395">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1530">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fine-tuning-bert-for-sequence-level-and-token-level-applications"><a class="header" href="#fine-tuning-bert-for-sequence-level-and-token-level-applications">Fine-Tuning BERT for Sequence-Level and Token-Level Applications</a></h1>
<p>:label:<code>sec_finetuning-bert</code></p>
<p>In the previous sections of this chapter,
we have designed different models for natural language processing applications,
such as based on RNNs, CNNs, attention, and MLPs.
These models are helpful when there is space or time constraint,
however,
crafting a specific model for every natural language processing task
is practically infeasible.
In :numref:<code>sec_bert</code>,
we introduced a pretraining model, BERT,
that requires minimal architecture changes
for a wide range of natural language processing tasks.
On the one hand,
at the time of its proposal,
BERT improved the state of the art on various natural language processing tasks.
On the other hand,
as noted in :numref:<code>sec_bert-pretraining</code>,
the two versions of the original BERT model
come with 110 million and 340 million parameters.
Thus, when there are sufficient computational resources,
we may consider
fine-tuning BERT for downstream natural language processing applications.</p>
<p>In the following,
we generalize a subset of natural language processing applications
as sequence-level and token-level.
On the sequence level,
we introduce how to transform the BERT representation of the text input
to the output label
in single text classification
and text pair classification or regression.
On the token level, we will briefly introduce new applications
such as text tagging and question answering
and shed light on how BERT can represent their inputs and get transformed into output labels.
During fine-tuning,
the "minimal architecture changes" required by BERT across different applications
are the extra fully connected layers.
During supervised learning of a downstream application,
parameters of the extra layers are learned from scratch while
all the parameters in the pretrained BERT model are fine-tuned.</p>
<h2 id="single-text-classification"><a class="header" href="#single-text-classification">Single Text Classification</a></h2>
<p><em>Single text classification</em> takes a single text sequence as input and outputs its classification result.
Besides sentiment analysis that we have studied in this chapter,
the Corpus of Linguistic Acceptability (CoLA)
is also a dataset for single text classification,
judging whether a given sentence is grammatically acceptable or not :cite:<code>Warstadt.Singh.Bowman.2019</code>.
For instance, "I should study." is acceptable but "I should studying." is not.</p>
<p><img src="chapter_natural-language-processing-applications/../img/bert-one-seq.svg" alt="Fine-tuning BERT for single text classification applications, such as sentiment analysis and testing linguistic acceptability. Suppose that the input single text has six tokens." />
:label:<code>fig_bert-one-seq</code></p>
<p>:numref:<code>sec_bert</code> describes the input representation of BERT.
The BERT input sequence unambiguously represents both single text and text pairs,
where the special classification token
“&lt;cls&gt;” is used for sequence classification and
the special classification token
“&lt;sep&gt;” marks the end of single text or separates a pair of text.
As shown in :numref:<code>fig_bert-one-seq</code>,
in single text classification applications,
the BERT representation of the special classification token
“&lt;cls&gt;” encodes the information of the entire input text sequence.
As the representation of the input single text,
it will be fed into a small MLP consisting of fully connected (dense) layers
to output the distribution of all the discrete label values.</p>
<h2 id="text-pair-classification-or-regression"><a class="header" href="#text-pair-classification-or-regression">Text Pair Classification or Regression</a></h2>
<p>We have also examined natural language inference in this chapter.
It belongs to <em>text pair classification</em>,
a type of application classifying a pair of text.</p>
<p>Taking a pair of text as input but outputting a continuous value,
<em>semantic textual similarity</em> is a popular <em>text pair regression</em> task.
This task measures semantic similarity of sentences.
For instance, in the Semantic Textual Similarity Benchmark dataset,
the similarity score of a pair of sentences
is an ordinal scale ranging from 0 (no meaning overlap) to 5 (meaning equivalence) :cite:<code>Cer.Diab.Agirre.ea.2017</code>.
The goal is to predict these scores.
Examples from the Semantic Textual Similarity Benchmark dataset include (sentence 1, sentence 2, similarity score):</p>
<ul>
<li>"A plane is taking off.", "An air plane is taking off.", 5.000;</li>
<li>"A woman is eating something.", "A woman is eating meat.", 3.000;</li>
<li>"A woman is dancing.", "A man is talking.", 0.000.</li>
</ul>
<p><img src="chapter_natural-language-processing-applications/../img/bert-two-seqs.svg" alt="Fine-tuning BERT for text pair classification or regression applications, such as natural language inference and semantic textual similarity. Suppose that the input text pair has two and three tokens." />
:label:<code>fig_bert-two-seqs</code></p>
<p>Comparing with single text classification in :numref:<code>fig_bert-one-seq</code>,
fine-tuning BERT for text pair classification in :numref:<code>fig_bert-two-seqs</code>
is different in the input representation.
For text pair regression tasks such as semantic textual similarity,
trivial changes can be applied such as outputting a continuous label value
and using the mean squared loss: they are common for regression.</p>
<h2 id="text-tagging"><a class="header" href="#text-tagging">Text Tagging</a></h2>
<p>Now let's consider token-level tasks, such as <em>text tagging</em>,
where each token is assigned a label.
Among text tagging tasks,
<em>part-of-speech tagging</em> assigns each word a part-of-speech tag (e.g., adjective and determiner)
according to the role of the word in the sentence.
For example,
according to the Penn Treebank II tag set,
the sentence "John Smith 's car is new"
should be tagged as
"NNP (noun, proper singular) NNP POS (possessive ending) NN (noun, singular or mass) VB (verb, base form) JJ (adjective)".</p>
<p><img src="chapter_natural-language-processing-applications/../img/bert-tagging.svg" alt="Fine-tuning BERT for text tagging applications, such as part-of-speech tagging. Suppose that the input single text has six tokens." />
:label:<code>fig_bert-tagging</code></p>
<p>Fine-tuning BERT for text tagging applications
is illustrated in :numref:<code>fig_bert-tagging</code>.
Comparing with :numref:<code>fig_bert-one-seq</code>,
the only distinction lies in that
in text tagging, the BERT representation of <em>every token</em> of the input text
is fed into the same extra fully connected layers to output the label of the token,
such as a part-of-speech tag.</p>
<h2 id="question-answering"><a class="header" href="#question-answering">Question Answering</a></h2>
<p>As another token-level application,
<em>question answering</em> reflects capabilities of reading comprehension.
For example,
the Stanford Question Answering Dataset (SQuAD v1.1)
consists of reading passages and questions,
where the answer to every question
is just a segment of text (text span) from the passage that the question is about :cite:<code>Rajpurkar.Zhang.Lopyrev.ea.2016</code>.
To explain,
consider a passage
"Some experts report that a mask's efficacy is inconclusive. However, mask makers insist that their products, such as N95 respirator masks, can guard against the virus."
and a question "Who say that N95 respirator masks can guard against the virus?".
The answer should be the text span "mask makers" in the passage.
Thus, the goal in SQuAD v1.1 is to predict the start and end of the text span in the passage given a pair of question and passage.</p>
<p><img src="chapter_natural-language-processing-applications/../img/bert-qa.svg" alt="Fine-tuning BERT for question answering. Suppose that the input text pair has two and three tokens." />
:label:<code>fig_bert-qa</code></p>
<p>To fine-tune BERT for question answering,
the question and passage are packed as
the first and second text sequence, respectively,
in the input of BERT.
To predict the position of the start of the text span,
the same additional fully connected layer will transform
the BERT representation of any token from the passage of position $i$
into a scalar score $s_i$.
Such scores of all the passage tokens
are further transformed by the softmax operation
into a probability distribution,
so that each token position $i$ in the passage is assigned
a probability $p_i$ of being the start of the text span.
Predicting the end of the text span
is the same as above, except that
parameters in its additional fully connected layer
are independent from those for predicting the start.
When predicting the end,
any passage token of position $i$
is transformed by the same fully connected layer
into a scalar score $e_i$.
:numref:<code>fig_bert-qa</code>
depicts fine-tuning BERT for question answering.</p>
<p>For question answering,
the supervised learning's training objective is as straightforward as
maximizing the log-likelihoods of the ground-truth start and end positions.
When predicting the span,
we can compute the score $s_i + e_j$ for a valid span
from position $i$ to position $j$ ($i \leq j$),
and output the span with the highest score.</p>
<h2 id="summary-101"><a class="header" href="#summary-101">Summary</a></h2>
<ul>
<li>BERT requires minimal architecture changes (extra fully connected layers) for sequence-level and token-level natural language processing applications, such as single text classification (e.g., sentiment analysis and testing linguistic acceptability), text pair classification or regression (e.g., natural language inference and semantic textual similarity), text tagging (e.g., part-of-speech tagging), and question answering.</li>
<li>During supervised learning of a downstream application, parameters of the extra layers are learned from scratch while all the parameters in the pretrained BERT model are fine-tuned.</li>
</ul>
<h2 id="exercises-121"><a class="header" href="#exercises-121">Exercises</a></h2>
<ol>
<li>Let's design a search engine algorithm for news articles. When the system receives an query (e.g., "oil industry during the coronavirus outbreak"), it should return a ranked list of news articles that are most relevant to the query. Suppose that we have a huge pool of news articles and a large number of queries. To simplify the problem, suppose that the most relevant article has been labeled for each query. How can we apply negative sampling (see :numref:<code>subsec_negative-sampling</code>) and BERT in the algorithm design?</li>
<li>How can we leverage BERT in training language models?</li>
<li>Can we leverage BERT in machine translation?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/396">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-language-inference-fine-tuning-bert"><a class="header" href="#natural-language-inference-fine-tuning-bert">Natural Language Inference: Fine-Tuning BERT</a></h1>
<p>:label:<code>sec_natural-language-inference-bert</code></p>
<p>In earlier sections of this chapter,
we have designed an attention-based architecture
(in :numref:<code>sec_natural-language-inference-attention</code>)
for the natural language inference task
on the SNLI dataset (as described in :numref:<code>sec_natural-language-inference-and-dataset</code>).
Now we revisit this task by fine-tuning BERT.
As discussed in :numref:<code>sec_finetuning-bert</code>,
natural language inference is a sequence-level text pair classification problem,
and fine-tuning BERT only requires an additional MLP-based architecture,
as illustrated in :numref:<code>fig_nlp-map-nli-bert</code>.</p>
<p><img src="chapter_natural-language-processing-applications/../img/nlp-map-nli-bert.svg" alt="This section feeds pretrained BERT to an MLP-based architecture for natural language inference." />
:label:<code>fig_nlp-map-nli-bert</code></p>
<p>In this section,
we will download a pretrained small version of BERT,
then fine-tune it
for natural language inference on the SNLI dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
import json
import multiprocessing
from mxnet import gluon, np, npx
from mxnet.gluon import nn
import os

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import json
import multiprocessing
import torch
from torch import nn
import os
</code></pre>
<h2 id="loading-pretrained-bert"><a class="header" href="#loading-pretrained-bert">[<strong>Loading Pretrained BERT</strong>]</a></h2>
<p>We have explained how to pretrain BERT on the WikiText-2 dataset in
:numref:<code>sec_bert-dataset</code> and :numref:<code>sec_bert-pretraining</code>
(note that the original BERT model is pretrained on much bigger corpora).
As discussed in :numref:<code>sec_bert-pretraining</code>,
the original BERT model has hundreds of millions of parameters.
In the following,
we provide two versions of pretrained BERT:
"bert.base" is about as big as the original BERT base model that requires a lot of computational resources to fine-tune,
while "bert.small" is a small version to facilitate demonstration.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.DATA_HUB['bert.base'] = (d2l.DATA_URL + 'bert.base.zip',
                             '7b3820b35da691042e5d34c0971ac3edbd80d3f4')
d2l.DATA_HUB['bert.small'] = (d2l.DATA_URL + 'bert.small.zip',
                              'a4e718a47137ccd1809c9107ab4f5edd317bae2c')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
d2l.DATA_HUB['bert.base'] = (d2l.DATA_URL + 'bert.base.torch.zip',
                             '225d66f04cae318b841a13d32af3acc165f253ac')
d2l.DATA_HUB['bert.small'] = (d2l.DATA_URL + 'bert.small.torch.zip',
                              'c72329e68a732bef0452e4b96a1c341c8910f81f')
</code></pre>
<p>Either pretrained BERT model contains a "vocab.json" file that defines the vocabulary set
and a "pretrained.params" file of the pretrained parameters.
We implement the following <code>load_pretrained_model</code> function to [<strong>load pretrained BERT parameters</strong>].</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def load_pretrained_model(pretrained_model, num_hiddens, ffn_num_hiddens,
                          num_heads, num_blks, dropout, max_len, devices):
    data_dir = d2l.download_extract(pretrained_model)
    # Define an empty vocabulary to load the predefined vocabulary
    vocab = d2l.Vocab()
    vocab.idx_to_token = json.load(open(os.path.join(data_dir, 'vocab.json')))
    vocab.token_to_idx = {token: idx for idx, token in enumerate(
        vocab.idx_to_token)}
    bert = d2l.BERTModel(len(vocab), num_hiddens, ffn_num_hiddens, num_heads, 
                         num_blks, dropout, max_len)
    # Load pretrained BERT parameters
    bert.load_parameters(os.path.join(data_dir, 'pretrained.params'),
                         ctx=devices)
    return bert, vocab
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def load_pretrained_model(pretrained_model, num_hiddens, ffn_num_hiddens,
                          num_heads, num_blks, dropout, max_len, devices):
    data_dir = d2l.download_extract(pretrained_model)
    # Define an empty vocabulary to load the predefined vocabulary
    vocab = d2l.Vocab()
    vocab.idx_to_token = json.load(open(os.path.join(data_dir, 'vocab.json')))
    vocab.token_to_idx = {token: idx for idx, token in enumerate(
        vocab.idx_to_token)}
    bert = d2l.BERTModel(
        len(vocab), num_hiddens, ffn_num_hiddens=ffn_num_hiddens, num_heads=4,
        num_blks=2, dropout=0.2, max_len=max_len)
    # Load pretrained BERT parameters
    bert.load_state_dict(torch.load(os.path.join(data_dir,
                                                 'pretrained.params')))
    return bert, vocab
</code></pre>
<p>To facilitate demonstration on most of machines,
we will load and fine-tune the small version ("bert.small") of the pretrained BERT in this section.
In the exercise, we will show how to fine-tune the much larger "bert.base" to significantly improve the testing accuracy.</p>
<pre><code class="language-{.python .input}">#@tab all
devices = d2l.try_all_gpus()
bert, vocab = load_pretrained_model(
    'bert.small', num_hiddens=256, ffn_num_hiddens=512, num_heads=4,
    num_blks=2, dropout=0.1, max_len=512, devices=devices)
</code></pre>
<h2 id="the-dataset-for-fine-tuning-bert"><a class="header" href="#the-dataset-for-fine-tuning-bert">[<strong>The Dataset for Fine-Tuning BERT</strong>]</a></h2>
<p>For the downstream task natural language inference on the SNLI dataset,
we define a customized dataset class <code>SNLIBERTDataset</code>.
In each example,
the premise and hypothesis form a pair of text sequence
and is packed into one BERT input sequence as depicted in :numref:<code>fig_bert-two-seqs</code>.
Recall :numref:<code>subsec_bert_input_rep</code> that segment IDs
are used to distinguish the premise and the hypothesis in a BERT input sequence.
With the predefined maximum length of a BERT input sequence (<code>max_len</code>),
the last token of the longer of the input text pair keeps getting removed until
<code>max_len</code> is met.
To accelerate generation of the SNLI dataset
for fine-tuning BERT,
we use 4 worker processes to generate training or testing examples in parallel.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class SNLIBERTDataset(gluon.data.Dataset):
    def __init__(self, dataset, max_len, vocab=None):
        all_premise_hypothesis_tokens = [[
            p_tokens, h_tokens] for p_tokens, h_tokens in zip(
            *[d2l.tokenize([s.lower() for s in sentences])
              for sentences in dataset[:2]])]
        
        self.labels = np.array(dataset[2])
        self.vocab = vocab
        self.max_len = max_len
        (self.all_token_ids, self.all_segments,
         self.valid_lens) = self._preprocess(all_premise_hypothesis_tokens)
        print('read ' + str(len(self.all_token_ids)) + ' examples')

    def _preprocess(self, all_premise_hypothesis_tokens):
        pool = multiprocessing.Pool(4)  # Use 4 worker processes
        out = pool.map(self._mp_worker, all_premise_hypothesis_tokens)
        all_token_ids = [
            token_ids for token_ids, segments, valid_len in out]
        all_segments = [segments for token_ids, segments, valid_len in out]
        valid_lens = [valid_len for token_ids, segments, valid_len in out]
        return (np.array(all_token_ids, dtype='int32'),
                np.array(all_segments, dtype='int32'), 
                np.array(valid_lens))

    def _mp_worker(self, premise_hypothesis_tokens):
        p_tokens, h_tokens = premise_hypothesis_tokens
        self._truncate_pair_of_tokens(p_tokens, h_tokens)
        tokens, segments = d2l.get_tokens_and_segments(p_tokens, h_tokens)
        token_ids = self.vocab[tokens] + [self.vocab['&lt;pad&gt;']] \
                             * (self.max_len - len(tokens))
        segments = segments + [0] * (self.max_len - len(segments))
        valid_len = len(tokens)
        return token_ids, segments, valid_len

    def _truncate_pair_of_tokens(self, p_tokens, h_tokens):
        # Reserve slots for '&lt;CLS&gt;', '&lt;SEP&gt;', and '&lt;SEP&gt;' tokens for the BERT
        # input
        while len(p_tokens) + len(h_tokens) &gt; self.max_len - 3:
            if len(p_tokens) &gt; len(h_tokens):
                p_tokens.pop()
            else:
                h_tokens.pop()

    def __getitem__(self, idx):
        return (self.all_token_ids[idx], self.all_segments[idx],
                self.valid_lens[idx]), self.labels[idx]

    def __len__(self):
        return len(self.all_token_ids)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class SNLIBERTDataset(torch.utils.data.Dataset):
    def __init__(self, dataset, max_len, vocab=None):
        all_premise_hypothesis_tokens = [[
            p_tokens, h_tokens] for p_tokens, h_tokens in zip(
            *[d2l.tokenize([s.lower() for s in sentences])
              for sentences in dataset[:2]])]
        
        self.labels = torch.tensor(dataset[2])
        self.vocab = vocab
        self.max_len = max_len
        (self.all_token_ids, self.all_segments,
         self.valid_lens) = self._preprocess(all_premise_hypothesis_tokens)
        print('read ' + str(len(self.all_token_ids)) + ' examples')

    def _preprocess(self, all_premise_hypothesis_tokens):
        pool = multiprocessing.Pool(4)  # Use 4 worker processes
        out = pool.map(self._mp_worker, all_premise_hypothesis_tokens)
        all_token_ids = [
            token_ids for token_ids, segments, valid_len in out]
        all_segments = [segments for token_ids, segments, valid_len in out]
        valid_lens = [valid_len for token_ids, segments, valid_len in out]
        return (torch.tensor(all_token_ids, dtype=torch.long),
                torch.tensor(all_segments, dtype=torch.long), 
                torch.tensor(valid_lens))

    def _mp_worker(self, premise_hypothesis_tokens):
        p_tokens, h_tokens = premise_hypothesis_tokens
        self._truncate_pair_of_tokens(p_tokens, h_tokens)
        tokens, segments = d2l.get_tokens_and_segments(p_tokens, h_tokens)
        token_ids = self.vocab[tokens] + [self.vocab['&lt;pad&gt;']] \
                             * (self.max_len - len(tokens))
        segments = segments + [0] * (self.max_len - len(segments))
        valid_len = len(tokens)
        return token_ids, segments, valid_len

    def _truncate_pair_of_tokens(self, p_tokens, h_tokens):
        # Reserve slots for '&lt;CLS&gt;', '&lt;SEP&gt;', and '&lt;SEP&gt;' tokens for the BERT
        # input
        while len(p_tokens) + len(h_tokens) &gt; self.max_len - 3:
            if len(p_tokens) &gt; len(h_tokens):
                p_tokens.pop()
            else:
                h_tokens.pop()

    def __getitem__(self, idx):
        return (self.all_token_ids[idx], self.all_segments[idx],
                self.valid_lens[idx]), self.labels[idx]

    def __len__(self):
        return len(self.all_token_ids)
</code></pre>
<p>After downloading the SNLI dataset,
we [<strong>generate training and testing examples</strong>]
by instantiating the <code>SNLIBERTDataset</code> class.
Such examples will be read in minibatches during training and testing
of natural language inference.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Reduce `batch_size` if there is an out of memory error. In the original BERT
# model, `max_len` = 512
batch_size, max_len, num_workers = 512, 128, d2l.get_dataloader_workers()
data_dir = d2l.download_extract('SNLI')
train_set = SNLIBERTDataset(d2l.read_snli(data_dir, True), max_len, vocab)
test_set = SNLIBERTDataset(d2l.read_snli(data_dir, False), max_len, vocab)
train_iter = gluon.data.DataLoader(train_set, batch_size, shuffle=True,
                                   num_workers=num_workers)
test_iter = gluon.data.DataLoader(test_set, batch_size,
                                  num_workers=num_workers)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Reduce `batch_size` if there is an out of memory error. In the original BERT
# model, `max_len` = 512
batch_size, max_len, num_workers = 512, 128, d2l.get_dataloader_workers()
data_dir = d2l.download_extract('SNLI')
train_set = SNLIBERTDataset(d2l.read_snli(data_dir, True), max_len, vocab)
test_set = SNLIBERTDataset(d2l.read_snli(data_dir, False), max_len, vocab)
train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True,
                                   num_workers=num_workers)
test_iter = torch.utils.data.DataLoader(test_set, batch_size,
                                  num_workers=num_workers)
</code></pre>
<h2 id="fine-tuning-bert-1"><a class="header" href="#fine-tuning-bert-1">Fine-Tuning BERT</a></h2>
<p>As :numref:<code>fig_bert-two-seqs</code> indicates,
fine-tuning BERT for natural language inference
requires only an extra MLP consisting of two fully connected layers
(see <code>self.hidden</code> and <code>self.output</code> in the following <code>BERTClassifier</code> class).
[<strong>This MLP transforms the
BERT representation of the special “&lt;cls&gt;” token</strong>],
which encodes the information of both the premise and the hypothesis,
(<strong>into three outputs of natural language inference</strong>):
entailment, contradiction, and neutral.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class BERTClassifier(nn.Block):
    def __init__(self, bert):
        super(BERTClassifier, self).__init__()
        self.encoder = bert.encoder
        self.hidden = bert.hidden
        self.output = nn.Dense(3)

    def forward(self, inputs):
        tokens_X, segments_X, valid_lens_x = inputs
        encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x)
        return self.output(self.hidden(encoded_X[:, 0, :]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class BERTClassifier(nn.Module):
    def __init__(self, bert):
        super(BERTClassifier, self).__init__()
        self.encoder = bert.encoder
        self.hidden = bert.hidden
        self.output = nn.LazyLinear(3)

    def forward(self, inputs):
        tokens_X, segments_X, valid_lens_x = inputs
        encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x)
        return self.output(self.hidden(encoded_X[:, 0, :]))
</code></pre>
<p>In the following,
the pretrained BERT model <code>bert</code> is fed into the <code>BERTClassifier</code> instance <code>net</code> for
the downstream application.
In common implementations of BERT fine-tuning,
only the parameters of the output layer of the additional MLP (<code>net.output</code>) will be learned from scratch.
All the parameters of the pretrained BERT encoder (<code>net.encoder</code>) and the hidden layer of the additional MLP (<code>net.hidden</code>) will be fine-tuned.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net = BERTClassifier(bert)
net.output.initialize(ctx=devices)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net = BERTClassifier(bert)
</code></pre>
<p>Recall that
in :numref:<code>sec_bert</code>
both the <code>MaskLM</code> class and the <code>NextSentencePred</code> class
have parameters in their employed MLPs.
These parameters are part of those in the pretrained BERT model
<code>bert</code>, and thus part of parameters in <code>net</code>.
However, such parameters are only for computing
the masked language modeling loss
and the next sentence prediction loss
during pretraining.
These two loss functions are irrelevant to fine-tuning downstream applications,
thus the parameters of the employed MLPs in
<code>MaskLM</code> and <code>NextSentencePred</code> are not updated (staled) when BERT is fine-tuned.</p>
<p>To allow parameters with stale gradients,
the flag <code>ignore_stale_grad=True</code> is set in the <code>step</code> function of <code>d2l.train_batch_ch13</code>.
We use this function to train and evaluate the model <code>net</code> using the training set
(<code>train_iter</code>) and the testing set (<code>test_iter</code>) of SNLI.
Due to the limited computational resources, [<strong>the training</strong>] and testing accuracy
can be further improved: we leave its discussions in the exercises.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lr, num_epochs = 1e-4, 5
trainer = gluon.Trainer(net.collect_params(), 'adam', {'learning_rate': lr})
loss = gluon.loss.SoftmaxCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices,
               d2l.split_batch_multi_inputs)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lr, num_epochs = 1e-4, 5
trainer = torch.optim.Adam(net.parameters(), lr=lr)
loss = nn.CrossEntropyLoss(reduction='none')
net(next(iter(train_iter))[0])
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<h2 id="summary-102"><a class="header" href="#summary-102">Summary</a></h2>
<ul>
<li>We can fine-tune the pretrained BERT model for downstream applications, such as natural language inference on the SNLI dataset.</li>
<li>During fine-tuning, the BERT model becomes part of the model for the downstream application. Parameters that are only related to pretraining loss will not be updated during fine-tuning.</li>
</ul>
<h2 id="exercises-122"><a class="header" href="#exercises-122">Exercises</a></h2>
<ol>
<li>Fine-tune a much larger pretrained BERT model that is about as big as the original BERT base model if your computational resource allows. Set arguments in the <code>load_pretrained_model</code> function as: replacing 'bert.small' with 'bert.base', increasing values of <code>num_hiddens=256</code>, <code>ffn_num_hiddens=512</code>, <code>num_heads=4</code>, and <code>num_blks=2</code> to 768, 3072, 12, and 12, respectively. By increasing fine-tuning epochs (and possibly tuning other hyperparameters), can you get a testing accuracy higher than 0.86?</li>
<li>How to truncate a pair of sequences according to their ratio of length? Compare this pair truncation method and the one used in the <code>SNLIBERTDataset</code> class. What are their pros and cons?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/397">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1526">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reinforcement-learning-2"><a class="header" href="#reinforcement-learning-2">Reinforcement Learning</a></h1>
<p>:label:<code>chap_reinforcement_learning</code></p>
<p><strong>Pratik Chaudhari</strong> (<em>University of Pennsylvania and Amazon</em>), <strong>Rasool Fakoor</strong> (<em>Amazon</em>), and <strong>Kavosh Asadi</strong> (<em>Amazon</em>)</p>
<p>Reinforcement Learning (RL) is a suite of techniques that allows us to build machine learning systems that take decisions sequentially. For example, a package containing new clothes that you purchased from an online retailer arrives at your doorstep after a sequence of decisions, e.g., the retailer finding the clothes in the warehouse closest to your house, putting the clothes in a box, transporting the box via land or by air, and delivering it to your house within the city. There are many variables that affect the delivery of the package along the way, e.g., whether or not the clothes were available in the warehouse, how long it took to transport the box, whether it arrived in your city before the daily delivery truck left, etc. The key idea is that at each stage these variables that we do not often control affect the entire sequence of events in the future, e.g., if there were delays in packing the box in the warehouse the retailer may need to send the package via air instead of ground to ensure a timely delivery. Reinforcement Learning methods allow us to take the appropriate action at each stage of a sequential decision making problem in order to maximize some utility eventually, e.g., the timely delivery of the package to you.</p>
<p>Such sequential decision making problems are seen in numerous other places, e.g., while playing <a href="https://en.wikipedia.org/wiki/Go_(game)">Go</a> your current move determines the next moves and the opponent's moves are the variables that you cannot control... a sequence of moves eventually determines whether or not you win; the movies that Netflix recommends to you now determine what you watch, whether you like the movie or not is unknown to Netflix, eventually a sequence of movie recommendations determines how satisfied you are with Netflix. Reinforcement learning is being used today to develop effective solutions to these problems :cite:<code>mnih2013playing,Silver.Huang.Maddison.ea.2016</code>. The key distinction between reinforcement learning and standard deep learning is that in standard deep learning the prediction of a trained model on one test datum does not affect the predictions on a future test datum; in reinforcement learning decisions at future instants (in RL, decisions are also called actions) are affected by what decisions were made in the past.</p>
<p>In this chapter, we will develop the fundamentals of reinforcement learning and obtain hands-on experience in implementing some popular reinforcement learning methods. We will first develop a concept called a Markov Decision Process (MDP) which allows us to think of such sequential decision making problems. An algorithm called Value Iteration will be our first insight into solving reinforcement learning problems under the assumption that we know how the uncontrolled variables in an MDP (in RL, these controlled variables are called the environment) typically behave. Using the more general version of Value Iteration, an algorithm called Q-Learning, we will be able to take appropriate actions even when we do not necessarily have full knowledge of the environment. We will then study how to use deep networks for reinforcement learning problems by imitating the actions of an expert. And finally, we will develop a reinforcement learning method that uses a deep network to take actions in unknown environments. These techniques form the basis of more advanced RL algorithms that are used today in a variety of real-world applications, some of which we will point to in the chapter.</p>
<p><img src="chapter_reinforcement-learning/../img/RL_main.png" alt="Reinforcement Learning Structure" />
:width:<code>400px</code>
:label:<code>fig_rl_big</code></p>
<pre><code class="language-toc">:maxdepth: 2

mdp
value-iter
qlearning
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markov-decision-process-mdp"><a class="header" href="#markov-decision-process-mdp">Markov Decision Process (MDP)</a></h1>
<p>:label:<code>sec_mdp</code>
In this section, we will discuss how to formulate reinforcement learning problems using Markov decision processes (MDPs) and describe various components of MDPs in detail.</p>
<h2 id="definition-of-an-mdp"><a class="header" href="#definition-of-an-mdp">Definition of an MDP</a></h2>
<p>A Markov decision process (MDP) :cite:<code>BellmanMDP</code> is a model for how the state of a system evolves as different actions are applied to the system. A few different quantities come together to form an MDP.</p>
<p><img src="chapter_reinforcement-learning/../img/mdp.png" alt="A simple gridworld navigation task where the robot not only has to find its way to the goal location (shown as a green house) but also has to avoid trap locations (shown as red cross signs)." />
:width:<code>250px</code>
:label:<code>fig_mdp</code></p>
<ul>
<li>Let $\mathcal{S}$ be the set of states in the MDP. As a concrete example see :numref:<code>fig_mdp</code>, for a robot that is navigating a gridworld. In this case, $\mathcal{S}$ corresponds to the set of locations that the robot can be at any given timestep.</li>
<li>Let $\mathcal{A}$ be the set of actions that the robot can take at each state, e.g., "go forward", "turn right", "turn left", "stay at the same location", etc. Actions can change the current state of the robot to some other state within the set $\mathcal{S}$.</li>
<li>It may happen that we do not know how the robot moves <em>exactly</em> but only know it up to some approximation. We model this situation in reinforcement learning as follows: if the robot takes an action "go forward", there might be a small probability that it stays at the current state, another small probability that it "turns left", etc. Mathematically, this amounts to defining a "transition function" $T: \mathcal{S} \times \mathcal{A} \times \mathcal{S} \to [0,1]$ such that $T(s, a, s') = P(s' \mid s, a)$ using the conditional probability of reaching a state $s'$ given that the robot was at state $s$ and took an action $a$. The transition function is a probability distribution and we therefore have $\sum_{s' \in \mathcal{S}} T(s, a, s') = 1$ for all $s \in \mathcal{S}$ and $a \in \mathcal{A}$, i.e., the robot has to go to some state if it takes an action.</li>
<li>We now construct a notion of which actions are useful and which ones are not using the concept of a "reward" $r: \mathcal{S} \times \mathcal{A} \to \mathbb{R}$. We say that the robot gets a reward $r(s,a)$ if the robot takes an action $a$ at state $s$. If the reward $r(s, a)$ is large, this indicates that taking the action $a$ at state $s$ is more useful to achieving the goal of the robot, i.e., going to the green house. If the reward $r(s, a)$ is small, then action $a$ is less useful to achieving this goal. It is important to note that the reward is designed by the user (the person who creates the reinforcement learning algorithm) with the goal in mind.</li>
</ul>
<h2 id="return-and-discount-factor"><a class="header" href="#return-and-discount-factor">Return and Discount Factor</a></h2>
<p>The different components above together form a Markov decision process (MDP)
$$\textrm{MDP}: (\mathcal{S}, \mathcal{A}, T, r).$$</p>
<p>Let's now consider the situation when the robot starts at a particular state $s_0 \in \mathcal{S}$ and continues taking actions to result in a trajectory
$$\tau = (s_0, a_0, r_0, s_1, a_1, r_1, s_2, a_2, r_2, \ldots).$$</p>
<p>At each time step $t$ the robot is at a state $s_t$ and takes an action $a_t$ which results in a reward $r_t = r(s_t, a_t)$. The <em>return</em> of a trajectory is the total reward obtained by the robot along such a trajectory
$$R(\tau) = r_0 + r_1 + r_2 + \cdots.$$</p>
<p>The goal in reinforcement learning is to find a trajectory that has the largest <em>return</em>.</p>
<p>Think of the situation when the robot continues to travel in the gridworld without ever reaching the goal location. The sequence of states and actions in a trajectory can be infinitely long in this case and the <em>return</em> of any such infinitely long trajectory will be infinite. In order to keep the reinforcement learning formulation meaningful even for such trajectories, we introduce the notion of a discount factor $\gamma &lt; 1$. We write the discounted <em>return</em> as
$$R(\tau) = r_0 + \gamma r_1 + \gamma^2 r_2 + \cdots = \sum_{t=0}^\infty \gamma^t r_t.$$</p>
<p>Note that if $\gamma$ is very small, the rewards earned by the robot in the far future, say $t = 1000$, are heavily discounted by the factor $\gamma^{1000}$. This encourages the robot to select short trajectories that achieve its goal, namely that of going to the green house in the gridwold example (see :numref:<code>fig_mdp</code>). For large values of the discount factor, say $\gamma = 0.99$, the robot is encouraged to <em>explore</em> and then find the best trajectory to go to the goal location.</p>
<h2 id="discussion-of-the-markov-assumption"><a class="header" href="#discussion-of-the-markov-assumption">Discussion of the Markov Assumption</a></h2>
<p>Let us think of a new robot where the state $s_t$ is the location as above but the action $a_t$ is the acceleration that the robot applies to its wheels instead of an abstract command like "go forward". If this robot has some non-zero velocity at state $s_t$, then the next location $s_{t+1}$ is a function of the past location $s_t$, the acceleration $a_t$, also the velocity of the robot at time $t$ which is proportional to $s_t - s_{t-1}$. This indicates that we should have</p>
<p>$$s_{t+1} = \textrm{some function}(s_t, a_t, s_{t-1});$$</p>
<p>the "some function" in our case would be Newton's law of motion. This is quite different from our transition function that simply depends upon $s_t$ and $a_t$.</p>
<p>Markov systems are all systems where the next state $s_{t+1}$ is only a function of the current state $s_t$ and the action $a_t$ taken at the current state. In Markov systems, the next state does not depend on which actions were taken in the past or the states that the robot was at in the past. For example, the new robot that has acceleration as the action above is not Markovian because the next location $s_{t+1}$ depends upon the previous state $s_{t-1}$ through the velocity. It may seem that Markovian nature of a system is a restrictive assumption, but it is not so. Markov Decision Processes are still capable of modeling a very large class of real systems. For example, for our new robot, if we chose our state $s_t$ to the tuple $(\textrm{location}, \textrm{velocity})$ then the system is Markovian because its next state $(\textrm{location}<em>{t+1}, \textrm{velocity}</em>{t+1})$ depends only upon the current state $(\textrm{location}_t, \textrm{velocity}_t)$ and the action at the current state $a_t$.</p>
<h2 id="summary-103"><a class="header" href="#summary-103">Summary</a></h2>
<p>The reinforcement learning problem is typically modeled using Markov Decision Processes. A Markov decision process (MDP) is defined by a tuple of four entities $(\mathcal{S}, \mathcal{A}, T, r)$ where $\mathcal{S}$ is the state space, $\mathcal{A}$ is the action space, $T$ is the transition function that encodes the transition probabilities of the MDP and $r$ is the immediate reward obtained by taking action at a particular state.</p>
<h2 id="exercises-123"><a class="header" href="#exercises-123">Exercises</a></h2>
<ol>
<li>Suppose that we want to design an MDP to model <a href="https://www.gymlibrary.dev/environments/classic_control/mountain_car/">MountainCar</a> problem.
<ol>
<li>What would be the set of states?</li>
<li>What would be the set of actions?</li>
<li>What would be the possible reward functions?</li>
</ol>
</li>
<li>How would you design an MDP for an Atari game like <a href="https://www.gymlibrary.dev/environments/atari/pong/">Pong game</a>?</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12084">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
#required_libs("setuptools==66", "wheel==0.38.4", "gym==0.21.0")
</code></pre>
<h1 id="value-iteration"><a class="header" href="#value-iteration">Value Iteration</a></h1>
<p>:label:<code>sec_valueiter</code></p>
<p>In this section we will discuss how to pick the best action for the robot at each state to maximize the <em>return</em> of the trajectory. We will describe an algorithm called Value Iteration and implement it for a simulated robot that travels over a frozen lake.</p>
<h2 id="stochastic-policy"><a class="header" href="#stochastic-policy">Stochastic Policy</a></h2>
<p>A stochastic policy denoted as $\pi(a \mid s)$ (policy for short) is a conditional distribution over the actions $a \in \mathcal{A}$ given the state $s \in \mathcal{S}$, $\pi(a \mid s) \equiv P(a \mid s)$. As an example, if the robot has four actions $\mathcal{A}=$ {go left, go down, go right, go up}. The policy at a state $s \in \mathcal{S}$ for such a set of actions $\mathcal{A}$ is a categorical distribution where the probabilities of the four actions could be $[0.4, 0.2, 0.1, 0.3]$; at some other state $s' \in \mathcal{S}$ the probabilities $\pi(a \mid s')$ of the same four actions could be $[0.1, 0.1, 0.2, 0.6]$. Note that we should have $\sum_a \pi(a \mid s) = 1$ for any state $s$. A deterministic policy is a special case of a stochastic policy in that the distribution $\pi(a \mid s)$ only gives non-zero probability to one particular action, e.g., $[1, 0, 0, 0]$ for our example with four actions.</p>
<p>To make the notation less cumbersome, we will often write $\pi(s)$ as the conditional distribution instead of $\pi(a \mid s)$.</p>
<h2 id="value-function"><a class="header" href="#value-function">Value Function</a></h2>
<p>Imagine now that the robot starts at a state $s_0$ and at each time instant, it first samples an action from the policy $a_t \sim \pi(s_t)$ and takes this action to result in the next state $s_{t+1}$. The trajectory $\tau = (s_0, a_0, r_0, s_1, a_1, r_1, \ldots)$, can be different depending upon which particular action $a_t$ is sampled at intermediate instants. We define the average <em>return</em> $R(\tau) = \sum_{t=0}^\infty \gamma^t r(s_t, a_t)$ of all such trajectories
$$V^\pi(s_0) = E_{a_t \sim \pi(s_t)} \Big[ R(\tau) \Big] = E_{a_t \sim \pi(s_t)} \Big[ \sum_{t=0}^\infty \gamma^t r(s_t, a_t) \Big],$$</p>
<p>where $s_{t+1} \sim P(s_{t+1} \mid s_t, a_t)$ is the next state of the robot and $r(s_t, a_t)$ is the instantaneous reward obtained by taking action $a_t$ in state $s_t$ at time $t$. This is called the "value function" for the policy $\pi$. In simple words, the value of a state $s_0$ for a policy $\pi$, denoted by $V^\pi(s_0)$, is the expected $\gamma$-discounted <em>return</em> obtained by the robot if it begins at state $s_0$ and takes actions from the policy $\pi$ at each time instant.</p>
<p>We next break down the trajectory into two stages (i) the first stage which corresponds to $s_0 \to s_1$ upon taking the action $a_0$, and (ii) a second stage which is the trajectory $\tau' = (s_1, a_1, r_1, \ldots)$ thereafter. The key idea behind all algorithms in reinforcement learning is that the value of state $s_0$ can be written as the average reward obtained in the first stage and the value function averaged over all possible next states $s_1$. This is quite intuitive and arises from our Markov assumption: the average return from the current state is the sum of the average return from the next state and the average reward of going to the next state. Mathematically, we write the two stages as</p>
<p>$$V^\pi(s_0) = r(s_0, a_0) + \gamma\ E_{a_0 \sim \pi(s_0)} \Big[ E_{s_1 \sim P(s_1 \mid s_0, a_0)} \Big[ V^\pi(s_1) \Big] \Big].$$
:eqlabel:<code>eq_dynamic_programming</code></p>
<p>This decomposition is very powerful: it is the foundation of the principle of dynamic programming upon which all reinforcement learning algorithms are based. Notice that the second stage gets two expectations, one over the choices of the action $a_0$ taken in the first stage using the stochastic policy and another over the possible states $s_1$ obtained from the chosen action. We can write :eqref:<code>eq_dynamic_programming</code> using the transition probabilities in the Markov decision process (MDP) as</p>
<p>$$V^\pi(s) = \sum_{a \in \mathcal{A}} \pi(a \mid s) \Big[ r(s,  a) + \gamma\  \sum_{s' \in \mathcal{S}} P(s' \mid s, a) V^\pi(s') \Big];\ \textrm{for all } s \in \mathcal{S}.$$
:eqlabel:<code>eq_dynamic_programming_val</code></p>
<p>An important thing to notice here is that the above identity holds for all states $s \in \mathcal{S}$ because we can think of any trajectory that begins at that state and break down the trajectory into two stages.</p>
<h2 id="action-value-function"><a class="header" href="#action-value-function">Action-Value Function</a></h2>
<p>In implementations, it is often useful to maintain a quantity called the "action value" function which is a closely related quantity to the value function. This is defined to be the average <em>return</em> of a trajectory that begins at $s_0$ but when the action of the first stage is fixed to be $a_0$</p>
<p>$$Q^\pi(s_0, a_0) = r(s_0, a_0) + E_{a_t \sim \pi(s_t)} \Big[ \sum_{t=1}^\infty \gamma^t r(s_t, a_t) \Big],$$</p>
<p>note that the summation inside the expectation is from $t=1,\ldots, \infty$ because the reward of the first stage is fixed in this case. We can again break down the trajectory into two parts and write</p>
<p>$$Q^\pi(s, a) = r(s, a) + \gamma \sum_{s' \in \mathcal{S}} P(s' \mid s, a) \sum_{a' \in \mathcal{A}} \pi(a' \mid s')\ Q^\pi(s', a');\ \textrm{ for all } s \in \mathcal{S}, a \in \mathcal{A}.$$
:eqlabel:<code>eq_dynamic_programming_q</code></p>
<p>This version is the analog of :eqref:<code>eq_dynamic_programming_val</code> for the action value function.</p>
<h2 id="optimal-stochastic-policy"><a class="header" href="#optimal-stochastic-policy">Optimal Stochastic Policy</a></h2>
<p>Both the value function and the action-value function depend upon the policy that the robot chooses. We will next think of the "optimal policy" that achieves the maximal average <em>return</em>
$$\pi^* = \underset{\pi}{\mathrm{argmax}} V^\pi(s_0).$$</p>
<p>Of all possible stochastic policies that the robot could have taken, the optimal policy $\pi^<em>$  achieves the largest average discounted <em>return</em> for trajectories starting from state $s_0$. Let us denote the value function and the action-value function of the optimal policy as $V^</em> \equiv V^{\pi^<em>}$ and $Q^</em> \equiv Q^{\pi^*}$.</p>
<p>Let us observe that for a deterministic policy where there is only one action that is possible under the policy at any given state. This gives us</p>
<p>$$\pi^<em>(s) = \underset{a \in \mathcal{A}}{\mathrm{argmax}} \Big[ r(s, a) + \gamma \sum_{s' \in \mathcal{S}} P(s' \mid s, a)\ V^</em>(s') \Big].$$</p>
<p>A good mnemonic to remember this is that the optimal action at state $s$ (for a deterministic policy) is the one that maximizes the sum of reward $r(s, a)$ from the first stage and the average <em>return</em> of the trajectories starting from the next sate $s'$, averaged over all possible next states $s'$ from the second stage.</p>
<h2 id="principle-of-dynamic-programming"><a class="header" href="#principle-of-dynamic-programming">Principle of Dynamic Programming</a></h2>
<p>Our developement in the previous section in :eqref:<code>eq_dynamic_programming</code> or :eqref:<code>eq_dynamic_programming_q</code> can be turned into an algorithm to compute the optimal value function $V^<em>$ or the action-value function $Q^</em>$, respectively. Observe that
$$ V^<em>(s) = \sum_{a \in \mathcal{A}} \pi^</em>(a \mid s) \Big[ r(s,  a) + \gamma\  \sum_{s' \in \mathcal{S}} P(s' \mid s, a) V^*(s') \Big];\ \textrm{for all } s \in \mathcal{S}.$$</p>
<p>For a deterministic optimal policy $\pi^*$, since there is only one action that can be taken at state $s$, we can also write</p>
<p>$$V^<em>(s) = \mathrm{argmax}<em>{a \in \mathcal{A}} \Big{ r(s,a) + \gamma \sum</em>{s' \in \mathcal{S}} P(s' \mid s, a) V^</em>(s') \Big}$$</p>
<p>for all states $s \in \mathcal{S}$. This identity is called the "principle of dynamic programming" :cite:<code>BellmanDPPaper,BellmanDPBook</code>. It was formulated by Richard Bellman in 1950s and we can remember it as "the remainder of an optimal trajectory is also optimal".</p>
<h2 id="value-iteration-1"><a class="header" href="#value-iteration-1">Value Iteration</a></h2>
<p>We can turn the principle of dynamic programming into an algorithm for finding the optimal value function called value iteration. The key idea behind value iteration is to think of this identity as a set of constraints that tie together $V^*(s)$ at different states $s \in \mathcal{S}$. We initialize the value function to some arbitrary values $V_0(s)$ for all states $s \in \mathcal{S}$. At the $k^{\textrm{th}}$ iteration, the Value Iteration algorithm updates the value function as</p>
<p>$$V_{k+1}(s) = \max_{a \in \mathcal{A}} \Big{ r(s,  a) + \gamma\  \sum_{s' \in \mathcal{S}} P(s' \mid s, a) V_k(s') \Big};\ \textrm{for all } s \in \mathcal{S}.$$</p>
<p>It turns out that as $k \to \infty$ the value function estimated by the Value Iteration algorithm converges to the optimal value function irrespective of the initialization $V_0$,
$$V^*(s) = \lim_{k \to \infty} V_k(s);\ \textrm{for all states } s \in \mathcal{S}.$$</p>
<p>The same Value Iteration algorithm can be equivalently written using the action-value function as
$$Q_{k+1}(s, a) = r(s, a) + \gamma \max_{a' \in \mathcal{A}} \sum_{s' \in \mathcal{S}} P(s' \mid s, a) Q_k (s', a');\ \textrm{ for all } s \in \mathcal{S}, a \in \mathcal{A}.$$</p>
<p>In this case we initialize $Q_0(s, a)$ to some arbitrary values for all $s \in \mathcal{S}$ and $a \in \mathcal{A}$. Again we have $Q^*(s, a) = \lim_{k \to \infty} Q_k(s, a)$ for all $s \in \mathcal{S}$ and $a \in \mathcal{A}$.</p>
<h2 id="policy-evaluation"><a class="header" href="#policy-evaluation">Policy Evaluation</a></h2>
<p>Value Iteration enables us to compute the optimal value function, i.e., $V^{\pi^<em>}$ of the optimal deterministic policy $\pi^</em>$. We can also use similar iterative updates to compute the value function associated with any other, potentially stochastic, policy $\pi$. We again initialize $V^\pi_0(s)$ to some arbitrary values for all states $s \in \mathcal{S}$ and at the $k^{\textrm{th}}$ iteration, perform the updates</p>
<p>$$    V^\pi_{k+1}(s) = \sum_{a \in \mathcal{A}} \pi(a \mid s) \Big[ r(s,  a) + \gamma\  \sum_{s' \in \mathcal{S}} P(s' \mid s, a) V^\pi_k(s') \Big];\ \textrm{for all } s \in \mathcal{S}.$$</p>
<p>This algorithm is known as policy evaluation and is useful to compute the value function given the policy. Again, it turns out that as $k \to \infty$ these updates converge to the correct value function irrespective of the initialization $V_0$,</p>
<p>$$V^\pi(s) = \lim_{k \to \infty} V^\pi_k(s);\ \textrm{for all states } s \in \mathcal{S}.$$</p>
<p>The algorithm for computing the action-value function $Q^\pi(s, a)$ of a policy $\pi$ is analogous.</p>
<h2 id="implementation-of-value-iteration"><a class="header" href="#implementation-of-value-iteration">Implementation of Value Iteration</a></h2>
<p>:label:<code>subsec_valueitercode</code>
We next show how to implement Value Iteration for a navigation problem called FrozenLake from <a href="https://gym.openai.com">Open AI Gym</a>. We first need to setup the enviroment as shown in the following code.</p>
<pre><code class="language-{.python .input}">%%tab all

%matplotlib inline
import numpy as np
import random
from d2l import torch as d2l

seed = 0  # Random number generator seed
gamma = 0.95  # Discount factor
num_iters = 10  # Number of iterations
random.seed(seed)  # Set the random seed to ensure results can be reproduced
np.random.seed(seed)

# Now set up the environment
env_info = d2l.make_env('FrozenLake-v1', seed=seed)
</code></pre>
<p>In the FrozenLake environment, the robot moves on a $4 \times 4$ grid (these are the states) with actions that are "up" ($\uparrow$), "down" ($\rightarrow$), "left" ($\leftarrow$), and "right" ($\rightarrow$). The environment contains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of which are unknown to the robot. To keep the problem simple, we assume the robot has reliable actions, i.e. $P(s' \mid s, a) = 1$ for all $s \in \mathcal{S}, a \in \mathcal{A}$. If the robot reaches the goal, the trial ends and the robot receives a reward of $1$ irrespective of the action; the reward at any other state is $0$ for all actions. The objective of the robot is to learn a policy that reaches the goal location (G) from a given start location (S) (this is $s_0$) to maximize the <em>return</em>.</p>
<p>The following function implements Value Iteration, where <code>env_info</code> contains MDP and environment related information and <code>gamma</code> is the discount factor:</p>
<pre><code class="language-{.python .input}">%%tab all

def value_iteration(env_info, gamma, num_iters):
    env_desc = env_info['desc']  # 2D array shows what each item means
    prob_idx = env_info['trans_prob_idx']
    nextstate_idx = env_info['nextstate_idx']
    reward_idx = env_info['reward_idx']
    num_states = env_info['num_states']
    num_actions = env_info['num_actions']
    mdp = env_info['mdp']

    V  = np.zeros((num_iters + 1, num_states))
    Q  = np.zeros((num_iters + 1, num_states, num_actions))
    pi = np.zeros((num_iters + 1, num_states))

    for k in range(1, num_iters + 1):
        for s in range(num_states):
            for a in range(num_actions):
                # Calculate \sum_{s'} p(s'\mid s,a) [r + \gamma v_k(s')]
                for pxrds in mdp[(s,a)]:
                    # mdp(s,a): [(p1,next1,r1,d1),(p2,next2,r2,d2),..]
                    pr = pxrds[prob_idx]  # p(s'\mid s,a)
                    nextstate = pxrds[nextstate_idx]  # Next state
                    reward = pxrds[reward_idx]  # Reward
                    Q[k,s,a] += pr * (reward + gamma * V[k - 1, nextstate])
            # Record max value and max action
            V[k,s] = np.max(Q[k,s,:])
            pi[k,s] = np.argmax(Q[k,s,:])
    d2l.show_value_function_progress(env_desc, V[:-1], pi[:-1])

value_iteration(env_info=env_info, gamma=gamma, num_iters=num_iters)
</code></pre>
<p>The above pictures show the policy (the arrow indicates the action) and value function (the change in color shows how the value function changes over time from the initial value shown by dark color to the optimal value shown by light colors.). As we see, Value Iteration finds the optimal value function after 10 iterations and the goal state (G) can be reached starting from any state as long as it is not an H cell. Another interesting aspect of the implementation is that in addition to finding the optimal value function, we also automatically found the optimal policy $\pi^*$ corresponding to this value function.</p>
<h2 id="summary-104"><a class="header" href="#summary-104">Summary</a></h2>
<p>The main idea behind the Value Iteration algorithm is to use the principle of dynamic programming to find the optimal average return obtained from a given state. Note that implementing the Value Iteration algorithm requires that we know the Markov decision process (MDP), e.g., the transition and reward functions, completely.</p>
<h2 id="exercises-124"><a class="header" href="#exercises-124">Exercises</a></h2>
<ol>
<li>Try increasing the grid size to $8 \times 8$. Compared with $4 \times 4$ grid, how many iterations does it take to find the optimal value function?</li>
<li>What is the computational complexity of the Value Iteration algorithm?</li>
<li>Run the Value Iteration algorithm again with $\gamma$ (i.e. "gamma" in the above code) when it equals to $0$, $0.5$, and $1$ and analyze its results.</li>
<li>How does the value of $\gamma$ affect the number of iterations taken by Value Iteration to converge? What happens when $\gamma=1$?</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12005">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
#required_libs("setuptools==66", "wheel==0.38.4", "gym==0.21.0")
</code></pre>
<h1 id="q-learning"><a class="header" href="#q-learning">Q-Learning</a></h1>
<p>:label:<code>sec_qlearning</code></p>
<p>In the previous section, we discussed the Value Iteration algorithm which requires accessing the complete Markov decision process (MDP), e.g., the transition and reward functions. In this section, we will look at Q-Learning :cite:<code>Watkins.Dayan.1992</code> which is an algorithm to learn the value function without necessarily knowing the MDP. This algorithm embodies the central idea behind reinforcement learning: it will enable the robot to obtain its own data.</p>
<!-- , instead of relying upon the expert. -->
<h2 id="the-q-learning-algorithm"><a class="header" href="#the-q-learning-algorithm">The Q-Learning Algorithm</a></h2>
<p>Recall that value iteration for the action-value function in :ref:<code>sec_valueiter</code> corresponds to the update</p>
<p>$$Q_{k+1}(s, a) = r(s, a) + \gamma \sum_{s' \in \mathcal{S}} P(s' \mid s, a) \max_{a' \in \mathcal{A}} Q_k (s', a'); \ \textrm{for all } s \in \mathcal{S} \textrm{ and } a \in \mathcal{A}.$$</p>
<p>As we discussed, implementing this algorithm requires knowing the MDP, specifically the transition function $P(s' \mid s, a)$. The key idea behind Q-Learning is to replace the summation over all $s' \in \mathcal{S}$ in the above expression by a summation over the states visited by the robot. This allows us to subvert the need to know the transition function.</p>
<h2 id="an-optimization-problem-underlying-q-learning"><a class="header" href="#an-optimization-problem-underlying-q-learning">An Optimization Problem Underlying Q-Learning</a></h2>
<p>Let us imagine that the robot uses a policy $\pi_e(a \mid s)$ to take actions. Just like the previous chapter, it collects a dataset of $n$ trajectories of $T$ timesteps each ${ (s_t^i, a_t^i)<em>{t=0,\ldots,T-1}}</em>{i=1,\ldots, n}$. Recall that value iteration is really a set of constraints that ties together the action-value $Q^*(s, a)$ of different states and actions to each other. We can implement an approximate version of value iteration using the data that the robot has collected using $\pi_e$ as</p>
<p>$$\hat{Q} = \min_Q \underbrace{\frac{1}{nT} \sum_{i=1}^n \sum_{t=0}^{T-1} (Q(s_t^i, a_t^i) - r(s_t^i, a_t^i) - \gamma \max_{a'} Q(s_{t+1}^i, a'))^2}_{\stackrel{\textrm{def}}{=} \ell(Q)}.$$
:eqlabel:<code>q_learning_optimization_problem</code></p>
<p>Let us first observe the similarities and differences between this expression and value iteration above. If the robot's policy $\pi_e$ were equal to the optimal policy $\pi^*$, and if it collected an infinite amount of data, then this optimization problem would be identical to the optimization problem underlying value iteration. But while value iteration requires us to know $P(s' \mid s, a)$, the optimization objective does not have this term. We have not cheated: as the robot uses the policy $\pi_e$ to take an action $a_t^i$ at state $s_t^i$, the next state $s_{t+1}^i$ is a sample drawn from the transition function. So the optimization objective also has access to the transition function, but implicitly in terms of the data collected by the robot.</p>
<p>The variables of our optimization problem are $Q(s, a)$ for all $s \in \mathcal{S}$ and $a \in \mathcal{A}$. We can minimize the objective using gradient descent. For every pair $(s_t^i, a_t^i)$ in our dataset, we can write</p>
<p>$$\begin{aligned}Q(s_t^i, a_t^i) &amp;\leftarrow Q(s_t^i, a_t^i) - \alpha \nabla_{Q(s_t^i,a_t^i)} \ell(Q) \&amp;=(1 - \alpha) Q(s_t^i,a_t^i) - \alpha \Big( r(s_t^i, a_t^i) + \gamma \max_{a'} Q(s_{t+1}^i, a') \Big),\end{aligned}$$
:eqlabel:<code>q_learning</code></p>
<p>where $\alpha$ is the learning rate. Typically in real problems, when the robot reaches the goal location, the trajectories end. The value of such a terminal state is zero because the robot does not take any further actions beyond this state. We should modify our update to handle such states as</p>
<p>$$Q(s_t^i, a_t^i) =(1 - \alpha) Q(s_t^i,a_t^i) - \alpha \Big( r(s_t^i, a_t^i) + \gamma (1 - \mathbb{1}<em>{s</em>{t+1}^i \textrm{ is terminal}} )\max_{a'} Q(s_{t+1}^i, a') \Big).$$</p>
<p>where $\mathbb{1}<em>{s</em>{t+1}^i \textrm{ is terminal}}$ is an indicator variable that is one if $s_{t+1}^i$ is a terminal state and zero otherwise. The value of state-action tuples $(s, a)$ that are not a part of the dataset is set to $-\infty$. This algorithm is known as Q-Learning.</p>
<p>Given the solution of these updates $\hat{Q}$, which is an approximation of the optimal value function $Q^*$, we can obtain the optimal deterministic policy corresponding to this value function easily using</p>
<p>$$\hat{\pi}(s) = \mathrm{argmax}_{a} \hat{Q}(s, a).$$</p>
<p>There can be situations when there are multiple deterministic policies that correspond to the same optimal value function; such ties can be broken arbitrarily because they have the same value function.</p>
<h2 id="exploration-in-q-learning"><a class="header" href="#exploration-in-q-learning">Exploration in Q-Learning</a></h2>
<p>The policy used by the robot to collect data $\pi_e$ is critical to ensure that Q-Learning works well. Afterall, we have replaced the expectation over $s'$ using the transition function $P(s' \mid s, a)$ using the data collected by the robot. If the policy $\pi_e$ does not reach diverse parts of the state-action space, then it is easy to imagine our estimate $\hat{Q}$ will be a poor approximation of the optimal $Q^<em>$. It is also important to note that in such a situation, the estimate of $Q^</em>$ at <em>all states</em> $s \in \mathcal{S}$ will be bad, not just the ones visited by $\pi_e$. This is because the Q-Learning objective (or value iteration) is a constraint that ties together the value of all state-action pairs. It is therefore critical to pick the correct policy $\pi_e$ to collect data.</p>
<p>We can mitigate this concern by picking a completely random policy $\pi_e$ that samples actions uniformly randomly from $\mathcal{A}$. Such a policy would visit all states, but it will take a large number of trajectories before it does so.</p>
<p>We thus arrive at the second key idea in Q-Learning, namely exploration. Typical implementations of Q-Learning tie together the current estimate of $Q$ and the policy $\pi_e$ to set</p>
<p>$$\pi_e(a \mid s) = \begin{cases}\mathrm{argmax}_{a'} \hat{Q}(s, a') &amp; \textrm{with prob. } 1-\epsilon \ \textrm{uniform}(\mathcal{A}) &amp; \textrm{with prob. } \epsilon,\end{cases}$$
:eqlabel:<code>epsilon_greedy</code></p>
<p>where $\epsilon$ is called the "exploration parameter" and is chosen by the user. The policy $\pi_e$ is called an exploration policy. This particular $\pi_e$ is called an $\epsilon$-greedy exploration policy because it chooses the optimal action (under the current estimate $\hat{Q}$) with probability $1-\epsilon$ but explores randomly with the remainder probability $\epsilon$. We can also use the so-called softmax exploration policy</p>
<p>$$\pi_e(a \mid s) = \frac{e^{\hat{Q}(s, a)/T}}{\sum_{a'} e^{\hat{Q}(s, a')/T}};$$</p>
<p>where the hyper-parameter $T$ is called temperature. A large value of $\epsilon$ in $\epsilon$-greedy policy functions similarly to a large value of temperature $T$ for the softmax policy.</p>
<p>It is important to note that when we pick an exploration that depends upon the current estimate of the action-value function $\hat{Q}$, we need to resolve the optimization problem periodically. Typical implementations of Q-Learning make one mini-batch update using a few state-action pairs in the collected dataset (typically the ones collected from the previous timestep of the robot) after taking every action using $\pi_e$.</p>
<h2 id="the-self-correcting-property-of-q-learning"><a class="header" href="#the-self-correcting-property-of-q-learning">The "Self-correcting" Property of Q-Learning</a></h2>
<p>The dataset collected by the robot during Q-Learning grows with time. Both the exploration policy $\pi_e$ and the estimate $\hat{Q}$ evolve as the robot collects more data. This gives us a key insight into why Q-Learning works well. Consider a state $s$: if a particular action $a$ has a large value under the current estimate $\hat{Q}(s,a)$, then both the $\epsilon$-greedy and the softmax exploration policies have a larger probability of picking this action. If this action actually is <em>not</em> the ideal action, then the future states that arise from this action will have poor rewards. The next update of the Q-Learning objective will therefore reduce the value $\hat{Q}(s,a)$, which will reduce the probability of picking this action the next time the robot visits state $s$. Bad actions, e.g., ones whose value is overestimated in $\hat{Q}(s,a)$, are explored by the robot but their value is correct in the next update of the Q-Learning objective. Good actions, e.g., whose value $\hat{Q}(s, a)$ is large, are explored more often by the robot and thereby reinforced. This property can be used to show that Q-Learning can converge to the optimal policy even if it begins with a random policy $\pi_e$ :cite:<code>Watkins.Dayan.1992</code>.</p>
<p>This ability to not only collect new data but also collect the right kind of data is the central feature of reinforcement learning algorithms, and this is what distinguishes them from supervised learning. Q-Learning, using deep neural networks (which we will see in the DQN chapeter later), is responsible for the resurgence of reinforcement learning :cite:<code>mnih2013playing</code>.</p>
<h2 id="implementation-of-q-learning"><a class="header" href="#implementation-of-q-learning">Implementation of Q-Learning</a></h2>
<p>We now show how to implement Q-Learning on FrozenLake from <a href="https://gym.openai.com">Open AI Gym</a>. Note this is the same setup as we consider in :ref:<code>sec_valueiter</code> experiment.</p>
<pre><code class="language-{.python .input}">%%tab all

%matplotlib inline
import numpy as np
import random
from d2l import torch as d2l

seed = 0  # Random number generator seed
gamma = 0.95  # Discount factor
num_iters = 256  # Number of iterations
alpha   = 0.9  # Learing rate
epsilon = 0.9  # Epsilon in epsilion gready algorithm
random.seed(seed)  # Set the random seed
np.random.seed(seed)

# Now set up the environment
env_info = d2l.make_env('FrozenLake-v1', seed=seed)
</code></pre>
<p>In the FrozenLake environment, the robot moves on a $4 \times 4$ grid (these are the states) with actions that are "up" ($\uparrow$), "down" ($\rightarrow$), "left" ($\leftarrow$), and "right" ($\rightarrow$). The environment contains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of which are unknown to the robot. To keep the problem simple, we assume the robot has reliable actions, i.e. $P(s' \mid s, a) = 1$ for all $s \in \mathcal{S}, a \in \mathcal{A}$. If the robot reaches the goal, the trial ends and the robot receives a reward of $1$ irrespective of the action; the reward at any other state is $0$ for all actions. The objective of the robot is to learn a policy that reaches the goal location (G) from a given start location (S) (this is $s_0$) to maximize the <em>return</em>.</p>
<p>We first implement $\epsilon$-greedy method as follows:</p>
<pre><code class="language-{.python .input}">%%tab all

def e_greedy(env, Q, s, epsilon):
    if random.random() &lt; epsilon:
        return env.action_space.sample()

    else:
        return np.argmax(Q[s,:])

</code></pre>
<p>We are now ready to implement Q-learning:</p>
<pre><code class="language-{.python .input}">%%tab all

def q_learning(env_info, gamma, num_iters, alpha, epsilon):
    env_desc = env_info['desc']  # 2D array specifying what each grid item means
    env = env_info['env']  # 2D array specifying what each grid item means
    num_states = env_info['num_states']
    num_actions = env_info['num_actions']

    Q  = np.zeros((num_states, num_actions))
    V  = np.zeros((num_iters + 1, num_states))
    pi = np.zeros((num_iters + 1, num_states))

    for k in range(1, num_iters + 1):
        # Reset environment
        state, done = env.reset(), False
        while not done:
            # Select an action for a given state and acts in env based on selected action
            action = e_greedy(env, Q, state, epsilon)
            next_state, reward, done, _ = env.step(action)

            # Q-update:
            y = reward + gamma * np.max(Q[next_state,:])
            Q[state, action] = Q[state, action] + alpha * (y - Q[state, action])

            # Move to the next state
            state = next_state
        # Record max value and max action for visualization purpose only
        for s in range(num_states):
            V[k,s]  = np.max(Q[s,:])
            pi[k,s] = np.argmax(Q[s,:])
    d2l.show_Q_function_progress(env_desc, V[:-1], pi[:-1])

q_learning(env_info=env_info, gamma=gamma, num_iters=num_iters, alpha=alpha, epsilon=epsilon)

</code></pre>
<p>This result shows that Q-learning can find the optimal solution for this problem roughly after 250 iterations. However, when we compare this result with the Value Iteration algorithm's result (see :ref:<code>subsec_valueitercode</code>), we can see that the Value Iteration algorithm needs way fewer iterations to find the optimal solution for this problem. This happens because the Value Iteration algorithm has access to the full MDP whereas Q-learning does not.</p>
<h2 id="summary-105"><a class="header" href="#summary-105">Summary</a></h2>
<p>Q-learning is one of the most fundamental reinforcement-learning algorithms. It has been at the epicenter of the recent success of reinforcement learning, most notably in learning to play video games :cite:<code>mnih2013playing</code>. Implementing Q-learning does not require that we know the Markov decision process (MDP), e.g., the transition and reward functions, completely.</p>
<h2 id="exercises-125"><a class="header" href="#exercises-125">Exercises</a></h2>
<ol>
<li>Try increasing the grid size to $8 \times 8$. Compared with $4 \times 4$ grid, how many iterations does it take to find the optimal value function?</li>
<li>Run the Q-learning algorithm again with $\gamma$ (i.e. "gamma" in the above code) when it equals to $0$, $0.5$, and $1$ and analyze its results.</li>
<li>Run the Q-learning algorithm again with $\epsilon$ (i.e. "epsilon" in the above code) when it equals to $0$, $0.5$, and $1$ and analyze its results.</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12103">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaussian-processes"><a class="header" href="#gaussian-processes">Gaussian Processes</a></h1>
<p>:label:<code>chap_gp</code></p>
<p><strong>Andrew Gordon Wilson</strong> (<em>New York University and Amazon</em>)</p>
<p>Gaussian processes (GPs) are ubitiquous. You have already encountered many examples of GPs without realizing it. Any model that is linear in its parameters with a Gaussian distribution over the parameters is a Gaussian process. This class spans discrete models, including random walks, and autoregressive processes, as well as continuous models, including Bayesian linear regression models, polynomials, Fourier series, radial basis functions, and even neural networks with an infinite number of hidden units. There is a running joke that "everything is a special case of a Gaussian process".</p>
<p>Learning about Gaussian processes is important for three reasons: (1) they provide a <em>function space</em> perspective of modelling, which makes understanding a variety of model classes, including deep neural networks, much more approachable; (2) they have an extraordinary range of applications where they are state-of-the-art, including active learning, hyperparameter learning, auto-ML, and spatiotemporal regression; (3) over the last few years, algorithmic advances have made Gaussian processes increasingly scalable and relevant, harmonizing with deep learning through frameworks such as <a href="https://gpytorch.ai">GPyTorch</a> :cite:<code>Gardner.Pleiss.Weinberger.Bindel.Wilson.2018</code>. Indeed, GPs and and deep neural networks are not competing approaches, but highly complementary, and can be combined to great effect. These algorithmic advances are not just relevant to Gaussian processes, but provide a foundation in numerical methods that is broadly useful in deep learning.</p>
<p>In this chapter, we introduce Gaussian processes. In the introductory notebook, we start by reasoning intuitively about what Gaussian processes are and how they directly model functions. In the priors notebook, we focus on how to specify Gaussian process priors. We directly connect the tradiational weight-space approach to modelling to function space, which will help us reason about constructing and understanding machine learning models, including deep neural networks. We then introduce popular covariance functions, also known as <em>kernels</em>, which control the generalization properties of a Gaussian process. A GP with a given kernel defines a prior over functions. In the inference notebook, we will show how to use data to infer a <em>posterior</em>, in order to make predictions. This notebook contains from-scratch code for making predictions with a Gaussian process, as well as an introduction to GPyTorch. In upcoming notebooks, we will introduce the numerics behind Gaussian processes, which is useful for scaling Gaussian processes but also a powerful general foundation for deep learning, and advanced use-cases such as hyperparameter tuning in deep learning. Our examples will make use of GPyTorch, which makes Gaussian processes scale, and is closely integrated with deep learning functionality and PyTorch.</p>
<pre><code class="language-toc">:maxdepth: 2

gp-intro
gp-priors
gp-inference
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-gaussian-processes"><a class="header" href="#introduction-to-gaussian-processes">Introduction to Gaussian Processes</a></h1>
<p>In many cases, machine learning amounts to estimating parameters from data. These parameters are often numerous and relatively uninterpretable --- such as the weights of a neural network. Gaussian processes, by contrast, provide a mechanism for directly reasoning about the high-level properties of functions that could fit our data. For example, we may have a sense of whether these functions are quickly varying, periodic, involve conditional independencies, or translation invariance. Gaussian processes enable us to easily incorporate these properties into our model, by directly specifying a Gaussian distribution over the function values that could fit our data.</p>
<p>Let's get a feel for how Gaussian processes operate, by starting with some examples.</p>
<p>Suppose we observe the following dataset, of regression targets (outputs), $y$, indexed by inputs, $x$. As an example, the targets could be changes in carbon dioxide concentrations, and the inputs could be the times at which these targets have been recorded. What are some features of the data? How quickly does it seem to varying? Do we have data points collected at regular intervals, or are there missing inputs? How would you imagine filling in the missing regions, or forecasting up until $x=25$?</p>
<p><img src="chapter_gaussian-processes/../img/gp-observed-data.svg" alt="Observed data." /></p>
<p>In order to fit the data with a Gaussian process, we start by specifying a prior distribution over what types of functions we might believe to be reasonable. Here we show several sample functions from a Gaussian process. Does this prior look reasonable? Note here we are not looking for functions that fit our dataset, but instead for specifying reasonable high-level properties of the solutions, such as how quickly they vary with inputs. Note that we will see code for reproducing all of the plots in this notebook, in the next notebooks on priors and inference.</p>
<p><img src="chapter_gaussian-processes/../img/gp-sample-prior-functions.svg" alt="Sample prior functions that we may want to represent with our model." /></p>
<p>Once we condition on data, we can use this prior to infer a posterior distribution over functions that could fit the data. Here we show sample posterior functions.</p>
<p><img src="chapter_gaussian-processes/../img/gp-sample-posterior-functions.svg" alt="Sample posterior functions, once we have observed the data." /></p>
<p>We see that each of these functions are entirely consistent with our data, perfectly running through each observation. In order to use these posterior samples to make predictions, we can average the values of every possible sample function from the posterior, to create the curve below, in thick blue. Note that we do not actually have to take an infinite number of samples to compute this expectation; as we will see later, we can compute the expectation in closed form.</p>
<p><img src="chapter_gaussian-processes/../img/gp-posterior-samples.svg" alt="Posterior samples, alongside posterior mean, which can be used for point predictions, in blue." /></p>
<p>We may also want a representation of uncertainty, so we know how confident we should be in our predictions. Intuitively, we should have more uncertainty where there is more variability in the sample posterior functions, as this tells us there are many more possible values the true function could take. This type of uncertainty is called <em>epistemic uncertainty</em>, which is the <em>reducible uncertainty</em> associated with lack of information. As we acquire more data, this type of uncertainty disappears, as there will be increasingly fewer solutions consistent with what we observe. Like with the posterior mean, we can compute the posterior variance (the variability of these functions in the posterior) in closed form. With shade, we show two times the posterior standard deviation on either side of the mean, creating a <em>credible interval</em> that has a 95% probability of containing the true value of the function for any input $x$.</p>
<p><img src="chapter_gaussian-processes/../img/gp-posterior-samples-95.svg" alt="Posterior samples, including 95% credible set." /></p>
<p>The plot looks somewhat cleaner if we remove the posterior samples, simply visualizing the data, posterior mean, and 95% credible set. Notice how the uncertainty grows away from the data, a property of epistemic uncertainty.</p>
<p><img src="chapter_gaussian-processes/../img/gp-point-predictions.svg" alt="Point predictions, and credible set." /></p>
<p>The properties of the Gaussian process that we used to fit the data are strongly controlled by what's called a <em>covariance function</em>, also known as a <em>kernel</em>. The covariance function we used is called the <em>RBF (Radial Basis Function) kernel</em>, which has the form
$$ k_{\textrm{RBF}}(x,x') = \textrm{Cov}(f(x),f(x')) = a^2 \exp\left(-\frac{1}{2\ell^2}||x-x'||^2\right) $$</p>
<p>The <em>hyperparameters</em> of this kernel are interpretable. The <em>amplitude</em> parameter $a$ controls the vertical scale over which the function is varying, and the <em>length-scale</em> parameter
$\ell$
controls the rate of variation (the wiggliness) of the function. Larger $a$ means larger function values, and larger
$\ell$
means more slowly varying functions. Let's see what happens to our sample prior and posterior functions as we vary $a$ and
$\ell$.</p>
<p>The <em>length-scale</em> has a particularly pronounced effect on the predictions and uncertainty of a GP. At
$||x-x'|| = \ell$
, the covariance between a pair of function values is $a^2\exp(-0.5)$. At larger distances than
$\ell$
, the values of the function values becomes nearly uncorrelated. This means that if we want to make a prediction at a point $x_*$, then function values with inputs $x$ such that
$||x-x'||&gt;\ell$
will not have a strong effect on our predictions.</p>
<p>Let's see how changing the lengthscale affects sample prior and posterior functions, and credible sets. The above fits use a length-scale of $2$. Let's now consider
$\ell = 0.1, 0.5, 2, 5, 10$
. A length-scale of $0.1$ is very small relative to the range of the input domain we are considering, $25$. For example, the values of the function at $x=5$ and $x=10$ will have essentially no correlation at such a length-scale. On the other hand, for a length-scale of $10$, the function values at these inputs will be highly correlated. Note that the vertical scale changes in the following figures.</p>
<p><img src="chapter_gaussian-processes/../img/gp-priorpoint1.svg" alt="priorpoint1" />
<img src="chapter_gaussian-processes/../img/gp-postpoint1.svg" alt="postpoint1" /></p>
<p><img src="chapter_gaussian-processes/../img/gp-priorpoint5.svg" alt="priorpoint5" />
<img src="chapter_gaussian-processes/../img/gp-postpoint5.svg" alt="postpoint5" /></p>
<p><img src="chapter_gaussian-processes/../img/gp-prior2.svg" alt="prior2" />
<img src="chapter_gaussian-processes/../img/gp-post2.svg" alt="post2" /></p>
<p><img src="chapter_gaussian-processes/../img/gp-prior5.svg" alt="prior5" />
<img src="chapter_gaussian-processes/../img/gp-post5.svg" alt="post5" /></p>
<p>Notice as the length-scale increases the 'wiggliness' of the functions decrease, and our uncertainty decreases. If the length-scale is small, the uncertainty will quickly increase as we move away from the data, as the datapoints become less informative about the function values.</p>
<p>Now, let's vary the amplitude parameter, holding the length-scale fixed at $2$. Note the vertical scale is held fixed for the prior samples, and varies for the posterior samples, so you can clearly see both the increasing scale of the function, and the fits to the data.</p>
<p><img src="chapter_gaussian-processes/../img/gp-priorap1.svg" alt="priorap1" />
<img src="chapter_gaussian-processes/../img/gp-postapoint1.svg" alt="postapoint1" /></p>
<p><img src="chapter_gaussian-processes/../img/gp-priora2.svg" alt="priora2" />
<img src="chapter_gaussian-processes/../img/gp-posta2.svg" alt="posta2" /></p>
<p><img src="chapter_gaussian-processes/../img/gp-priora8.svg" alt="priora8" />
<img src="chapter_gaussian-processes/../img/gp-posta8.svg" alt="posta8" /></p>
<p>We see the amplitude parameter affects the scale of the function, but not the rate of variation. At this point, we also have the sense that the generalization performance of our procedure will depend on having reasonable values for these hyperparameters. Values of $\ell=2$ and $a=1$ appeared to provide reasonable fits, while some of the other values did not. Fortunately, there is a robust and automatic way to specify these hyperparameters, using what is called the <em>marginal likelihood</em>, which we will return to in the notebook on inference.</p>
<p>So what is a GP, really? As we started, a GP simply says that any collection of function values
$f(x_1),\dots,f(x_n)$,
indexed by any collection of inputs
$x_1,\dots,x_n$
has a joint multivariate Gaussian distribution. The mean vector $\mu$ of this distribution is given by a <em>mean function</em>, which is typically taken to be a constant or zero. The covariance matrix of this distribution is given by the <em>kernel</em> evaluated at all pairs of the inputs $x$.</p>
<p>$$\begin{bmatrix}f(x) \f(x_1) \ \vdots \ f(x_n) \end{bmatrix}\sim \mathcal{N}\left(\mu, \begin{bmatrix}k(x,x) &amp; k(x, x_1) &amp; \dots &amp; k(x,x_n) \ k(x_1,x) &amp; k(x_1,x_1) &amp; \dots &amp; k(x_1,x_n) \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ k(x_n, x) &amp; k(x_n, x_1) &amp; \dots &amp; k(x_n,x_n) \end{bmatrix}\right)$$
:eqlabel:<code>eq_gp_prior</code></p>
<p>Equation :eqref:<code>eq_gp_prior</code> specifies a GP prior. We can compute the conditional distribution of $f(x)$ for any $x$ given $f(x_1), \dots, f(x_n)$, the function values we have observed. This conditional distribution is called the <em>posterior</em>, and it is what we use to make predictions.</p>
<p>In particular,</p>
<p>$$f(x) | f(x_1), \dots, f(x_n) \sim \mathcal{N}(m,s^2)$$</p>
<p>where</p>
<p>$$m = k(x,x_{1:n}) k(x_{1:n},x_{1:n})^{-1} f(x_{1:n})$$</p>
<p>$$s^2 = k(x,x) - k(x,x_{1:n})k(x_{1:n},x_{1:n})^{-1}k(x,x_{1:n})$$</p>
<p>where $k(x,x_{1:n})$ is a $1 \times n$ vector formed by evaluating $k(x,x_{i})$ for $i=1,\dots,n$ and $k(x_{1:n},x_{1:n})$ is an $n \times n$ matrix formed by evaluating $k(x_i,x_j)$ for $i,j = 1,\dots,n$. $m$ is what we can use as a point predictor for any $x$, and $s^2$ is what we use for uncertainty: if we want to create an interval with a 95% probability that $f(x)$ is in the interval, we would use $m \pm 2s$. The predictive means and uncertainties for all the above figures were created using these equations. The observed data points were given by
$f(x_1), \dots, f(x_n)$
and chose a fine grained set of $x$ points to make predictions.</p>
<p>Let's suppose we observe a single datapoint, $f(x_1)$, and we want to determine the value of $f(x)$ at some $x$. Because $f(x)$ is described by a Gaussian process, we know the joint distribution over
$(f(x), f(x_1))$
is Gaussian:</p>
<p>$$
\begin{bmatrix}
f(x) \
f(x_1) \
\end{bmatrix}
\sim
\mathcal{N}\left(\mu,
\begin{bmatrix}
k(x,x) &amp; k(x, x_1) \
k(x_1,x) &amp; k(x_1,x_1)
\end{bmatrix}
\right)
$$</p>
<p>The off-diagonal expression $k(x,x_1) = k(x_1,x)$
tells us how correlated the function values will be --- how strongly determined $f(x)$
will be from $f(x_1)$.
We have seen already that if we use a large length-scale, relative to the distance between $x$ and $x_1$,
$||x-x_1||$, then the function values will be highly correlated. We can visualize the process of determining $f(x)$ from $f(x_1)$ both in the space of functions, and in the joint distribution over $f(x_1), f(x)$. Let's initially consider an $x$ such that $k(x,x_1) = 0.9$, and $k(x,x)=1$, meaning that the value of $f(x)$ is moderately correlated with the value of $f(x_1)$. In the joint distribution, the contours of constant probability will be relatively narrow ellipses.</p>
<p>Suppose we observe $f(x_1) = 1.2$.
To condition on this value of $f(x_1)$,
we can draw a horizontal line at $1.2$ on our plot of the density, and see that the value of $f(x)$
is mostly constrained to $[0.64,1.52]$. We have also drawn this plot in function space, showing the observed
point $f(x_1)$ in orange, and 1 standard deviation of the Gaussian process predictive distribution for $f(x)$
in blue, about the mean value of $1.08$.</p>
<p><img src="https://user-images.githubusercontent.com/6753639/206867364-b4707db5-0c2e-4ae4-a412-8292bca4d08d.svg" alt="Contours of constant probability of a bivariate Gaussian density over $f(x_1)$ and $f(x)$ with $k(x,x_1) = 0.9$." />
<img src="https://user-images.githubusercontent.com/6753639/206867367-3815720c-93c8-4b4b-80e7-296db1d3553b.svg" alt="Gaussian process predictive distribution in function space at $f(x)$, with $k(x,x_1) = 0.9$." /></p>
<p>Now suppose we have a stronger correlation, $k(x,x_1) = 0.95$.
Now the ellipses have narrowed further, and the value of $f(x)$
is even more strongly determined by $f(x_1)$. Drawing a horizontal line at $1.2$, we see the contours for $f(x)$
support values mostly within $[0.83, 1.45]$. Again, we also show the plot in function space, with one standard
deviation about the mean predictive value of $1.14$.</p>
<p><img src="https://user-images.githubusercontent.com/6753639/206867797-20e42783-31de-4c50-8103-e9441ba6d0a9.svg" alt="Contours of constant probability of a bivariate Gaussian density over $f(x_1)$ and $f(x)$ with $k(x,x_1) = 0.95$." />
<img src="https://user-images.githubusercontent.com/6753639/206867800-d9fc7add-649d-492c-8848-cab07c8fb83e.svg" alt="Gaussian process predictive distribution in function space at $f(x)$, with $k(x,x_1)$ = 0.95." /></p>
<p>We see that the posterior mean predictor of our Gaussian process is closer to $1.2$, because there is now a stronger correlation. We also see that our uncertainty (the error bars) have somewhat decreased. Despite the strong correlation between these function values, our uncertainty is still righly quite large, because we have only observed a single data point!</p>
<p>This procedure can give us a posterior on $f(x)$ for any $x$, for any number of points we have observed. Suppose we observe $f(x_1), f(x_2)$. We now visualize the posterior for $f(x)$ at a particular $x=x'$ in function space. The exact distribution for $f(x)$ is given by the above equations. $f(x)$ is Gaussian distributed, with mean</p>
<p>$$m = k(x,x_{1:3}) k(x_{1:3},x_{1:3})^{-1} f(x_{1:3})$$</p>
<p>and variance</p>
<p>$$s^2 = k(x,x) - k(x,x_{1:3})k(x_{1:3},x_{1:3})^{-1}k(x,x_{1:3})$$</p>
<p>In this introductory notebook, we have been considering <em>noise free</em> observations. As we will see, it is easy to include observation noise. If we assume that the data are generated from a latent noise free function $f(x)$ plus iid Gaussian noise
$\epsilon(x) \sim \mathcal{N}(0,\sigma^2)$
with variance $\sigma^2$, then our covariance function simply becomes
$k(x_i,x_j) \to k(x_i,x_j) + \delta_{ij}\sigma^2$,
where $\delta_{ij} = 1$ if $i=j$ and $0$ otherwise.</p>
<p>We have already started getting some intuition about how we can use a Gaussian process to specify a prior and posterior over solutions, and how the kernel function affects the properties of these solutions. In the following notebooks, we will precisely show how to specify a Gaussian process prior, introduce and derive various kernel functions, and then go through the mechanics of how to automatically learn kernel hyperparameters, and form a Gaussian process posterior to make predictions. While it takes time and practice to get used to concepts such as a "distributions over functions", the actual mechanics of finding the GP predictive equations is actually quite simple --- making it easy to get practice to form an intuitive understanding of these concepts.</p>
<h2 id="summary-106"><a class="header" href="#summary-106">Summary</a></h2>
<p>In typical machine learning, we specify a function with some free parameters (such as a neural network and its weights), and we focus on estimating those parameters, which may not be interpretable. With a Gaussian process, we instead reason about distributions over functions directly, which enables us to reason about the high-level properties of the solutions. These properties are controlled by a covariance function (kernel), which often has a few highly interpretable hyperparameters. These hyperparameters include the <em>length-scale</em>, which controls how rapidly (how wiggily) the functions are. Another hyperparameter is the amplitude, which controls the vertical scale over which our functions are varying.
Representing many different functions that can fit the data, and combining them all together into a predictive distribution, is a distinctive feature of Bayesian methods. Because there is a greater amount of variability between possible solutions far away from the data, our uncertainty intuitively grows as we move from the data.</p>
<p>A Gaussian process represents a distribution over functions by specifying a multivariate normal (Gaussian) distribution over all possible function values. It is possible to easily manipulate Gaussian distributions to find the distribution of one function value based on the values of any set of other values. In other words, if we observe a set of points, then we can condition on these points and infer a distribution over what the value of the function might look like at any other input. How we model the correlations between these points is determined by the covariance function and is what defines the generalization properties of the Gaussian process. While it takes time to get used to Gaussian processes, they are easy to work with, have many applications, and help us understand and develop other model classes, like neural networks.</p>
<h2 id="exercises-126"><a class="header" href="#exercises-126">Exercises</a></h2>
<ol>
<li>What is the difference between epistemic uncertainty versus observation uncertainty?</li>
<li>Besides rate of variation and amplitude, what other properties of functions might we want to consider, and what would be real-world examples of functions that have those properties?</li>
<li>The RBF covariance function we considered says that covariances (and correlations) between observations decrease with their distance in the input space (times, spatial locations, etc.). Is this a reasonable assumption? Why or why not?</li>
<li>Is a sum of two Gaussian variables Gaussian? Is a product of two Gaussian variables Gaussian? If (a,b) have a joint Gaussian distribution, is a|b (a given b) Gaussian? Is a Gaussian?</li>
<li>Repeat the exercise where we observe a data point at $f(x_1) = 1.2$, but now suppose we additionally observe $f(x_2) = 1.4$. Let $k(x,x_1) = 0.9$, and $k(x,x_2) = 0.8$. Will we be more or less certain about the value of $f(x)$, than when we had only observed $f(x_1)$? What is the mean and 95% credible set for our value of $f(x)$ now?</li>
<li>Do you think increasing our estimate of observation noise would increase or decrease our estimate of the length-scale of the ground truth function?</li>
<li>As we move away from the data, suppose the uncertainty in our predictive distribution increases to a point, then stops increasing. Why might that happen?</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12115">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['pytorch'])
</code></pre>
<h1 id="gaussian-process-priors"><a class="header" href="#gaussian-process-priors">Gaussian Process Priors</a></h1>
<p>Understanding Gaussian processes (GPs) is important for reasoning about model construction and generalization, and for achieving state-of-the-art performance in a variety of applications, including active learning, and hyperparameter tuning in deep learning. GPs are everywhere, and it is in our interests to know what they are and how we can use them.</p>
<p>In this section, we introduce Gaussian process <em>priors</em> over functions. In the next notebook, we show how to use these priors to do <em>posterior inference</em> and make predictions. The next section can be viewed as "GPs in a nutshell", quickly giving what you need to apply Gaussian processes in practice.</p>
<pre><code class="language-{.python .input}">from d2l import torch as d2l
import numpy as np
from scipy.spatial import distance_matrix

d2l.set_figsize()
</code></pre>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>A Gaussian process is defined as <em>a collection of random variables, any finite number of which have a joint Gaussian distribution</em>. If a function $f(x)$ is a Gaussian process, with <em>mean function</em> $m(x)$ and <em>covariance function</em> or <em>kernel</em> $k(x,x')$, $f(x) \sim \mathcal{GP}(m, k)$, then any collection of function values queried at any collection of input points $x$ (times, spatial locations, image pixels, etc.), has a joint multivariate Gaussian distribution with mean vector $\mu$ and covariance matrix $K$: $f(x_1),\dots,f(x_n) \sim \mathcal{N}(\mu, K)$, where $\mu_i = E[f(x_i)] = m(x_i)$ and $K_{ij} = \textrm{Cov}(f(x_i),f(x_j)) = k(x_i,x_j)$.</p>
<p>This definition may seem abstract and inaccessible, but Gaussian processes are in fact very simple objects. Any function</p>
<p>$$f(x) = w^{\top} \phi(x) = \langle w, \phi(x) \rangle,$$ :eqlabel:<code>eq_gp-function</code></p>
<p>with $w$ drawn from a Gaussian (normal) distribution, and $\phi$ being any vector of basis functions, for example $\phi(x) = (1, x, x^2, ..., x^d)^{\top}$,
is a Gaussian process. Moreover, any Gaussian process f(x) can be expressed in the form of equation :eqref:<code>eq_gp-function</code>. Let's consider a few concrete examples, to begin getting acquainted with Gaussian processes, after which we can appreciate how simple and useful they really are.</p>
<h2 id="a-simple-gaussian-process"><a class="header" href="#a-simple-gaussian-process">A Simple Gaussian Process</a></h2>
<p>Suppose $f(x) = w_0 + w_1 x$, and $w_0, w_1 \sim \mathcal{N}(0,1)$, with $w_0, w_1, x$ all in one dimension. We can equivalently write this function as the inner product $f(x) = (w_0, w_1)(1, x)^{\top}$. In :eqref:<code>eq_gp-function</code> above, $w = (w_0, w_1)^{\top}$ and $\phi(x) = (1,x)^{\top}$.</p>
<p>For any $x$, $f(x)$ is a sum of two Gaussian random variables. Since Gaussians are closed under addition, $f(x)$ is also a Gaussian random variable for any $x$. In fact, we can compute for any particular $x$ that $f(x)$ is $\mathcal{N}(0,1+x^2)$. Similarly, the joint distribution for any collection of function values, $(f(x_1),\dots,f(x_n))$, for any collection of inputs $x_1,\dots,x_n$, is a multivariate Gaussian distribution. Therefore $f(x)$ is a Gaussian process.</p>
<p>In short, $f(x)$ is a <em>random function</em>, or a <em>distribution over functions</em>. We can gain some insights into this distribution by repeatedly sampling values for $w_0, w_1$, and visualizing the corresponding functions $f(x)$, which are straight lines with slopes and different intercepts, as follows:</p>
<pre><code class="language-{.python .input}">def lin_func(x, n_sample):
    preds = np.zeros((n_sample, x.shape[0]))
    for ii in range(n_sample):
        w = np.random.normal(0, 1, 2)
        y = w[0] + w[1] * x
        preds[ii, :] = y
    return preds

x_points = np.linspace(-5, 5, 50)
outs = lin_func(x_points, 10)
lw_bd = -2 * np.sqrt((1 + x_points ** 2))
up_bd = 2 * np.sqrt((1 + x_points ** 2))

d2l.plt.fill_between(x_points, lw_bd, up_bd, alpha=0.25)
d2l.plt.plot(x_points, np.zeros(len(x_points)), linewidth=4, color='black')
d2l.plt.plot(x_points, outs.T)
d2l.plt.xlabel("x", fontsize=20)
d2l.plt.ylabel("f(x)", fontsize=20)
d2l.plt.show()
</code></pre>
<p>If $w_0$ and $w_1$ are instead drawn from $\mathcal{N}(0,\alpha^2)$, how do you imagine varying $\alpha$ affects the distribution over functions?</p>
<h2 id="from-weight-space-to-function-space"><a class="header" href="#from-weight-space-to-function-space">From Weight Space to Function Space</a></h2>
<p>In the plot above, we saw how a distribution over parameters in a model induces a distribution over functions. While we often have ideas about the functions we want to model --- whether they're smooth, periodic, quickly varying, etc. --- it is relatively tedious to reason about the parameters, which are largely uninterpretable. Fortunately, Gaussian processes provide an easy mechanism to reason <em>directly</em> about functions. Since a Gaussian distribution is entirely defined by its first two moments, its mean and covariance matrix, a Gaussian process by extension is defined by its mean function and covariance function.</p>
<p>In the above example, the mean function</p>
<p>$$m(x) = E[f(x)] = E[w_0 + w_1x] = E[w_0] + E[w_1]x = 0+0 = 0.$$</p>
<p>Similarly, the covariance function is</p>
<p>$$k(x,x') = \textrm{Cov}(f(x),f(x')) = E[f(x)f(x')]-E[f(x)]E[f(x')] = E[w_0^2 + w_0w_1x' + w_1w_0x + w_1^2xx'] = 1 + xx'.$$</p>
<p>Our distribution over functions can now be directly specified and sampled from, without needing to sample from the distribution over parameters. For example, to draw from $f(x)$, we can simply form our multivariate Gaussian distribution associated with any collection of $x$ we want to query, and sample from it directly. We will begin to see just how advantageous this formulation will be.</p>
<p>First, we note that essentially the same derivation for the simple straight line model above can be applied to find the mean and covariance function for <em>any</em> model of the form $f(x) = w^{\top} \phi(x)$, with $w \sim \mathcal{N}(u,S)$. In this case, the mean function $m(x) = u^{\top}\phi(x)$, and the covariance function $k(x,x') = \phi(x)^{\top}S\phi(x')$. Since $\phi(x)$ can represent a vector of any non-linear basis functions, we are considering a very general model class, including models with an even an <em>infinite</em> number of parameters.</p>
<h2 id="the-radial-basis-function-rbf-kernel"><a class="header" href="#the-radial-basis-function-rbf-kernel">The Radial Basis Function (RBF) Kernel</a></h2>
<p>The <em>radial basis function</em> (RBF) kernel is the most popular covariance function for Gaussian processes, and kernel machines in general.
This kernel has the form $k_{\textrm{RBF}}(x,x') = a^2\exp\left(-\frac{1}{2\ell^2}||x-x'||^2\right)$, where $a$ is an amplitude parameter, and $\ell$ is a <em>lengthscale</em> hyperparameter.</p>
<p>Let's derive this kernel starting from weight space. Consider the function</p>
<p>$$f(x) = \sum_{i=1}^J w_i \phi_i(x), w_i  \sim \mathcal{N}\left(0,\frac{\sigma^2}{J}\right), \phi_i(x) = \exp\left(-\frac{(x-c_i)^2}{2\ell^2 }\right).$$</p>
<p>$f(x)$ is a sum of radial basis functions, with width $\ell$, centred at the points $c_i$, as shown in the following figure.</p>
<p>We can recognize $f(x)$ as having the form $w^{\top} \phi(x)$, where $w = (w_1,\dots,w_J)^{\top}$ and $\phi(x)$ is a vector containing each of the radial basis functions. The covariance function of this Gaussian process is then</p>
<p>$$k(x,x') = \frac{\sigma^2}{J} \sum_{i=1}^{J} \phi_i(x)\phi_i(x').$$</p>
<p>Now let's consider what happens as we take the number of parameters (and basis functions) to infinity. Let $c_J = \log J$, $c_1 = -\log J$, and $c_{i+1}-c_{i} = \Delta c = 2\frac{\log J}{J}$, and $J \to \infty$. The covariance function becomes the Riemann sum:</p>
<p>$$k(x,x') = \lim_{J \to \infty} \frac{\sigma^2}{J} \sum_{i=1}^{J} \phi_i(x)\phi_i(x') = \int_{c_0}^{c_\infty} \phi_c(x)\phi_c(x') dc.$$</p>
<p>By setting $c_0 = -\infty$ and $c_\infty = \infty$, we spread the infinitely many basis functions across the whole real line, each
a distance $\Delta c \to 0$ apart:</p>
<p>$$k(x,x') = \int_{-\infty}^{\infty} \exp(-\frac{(x-c)^2}{2\ell^2}) \exp(-\frac{(x'-c)^2}{2\ell^2 }) dc = \sqrt{\pi}\ell \sigma^2 \exp(-\frac{(x-x')^2}{2(\sqrt{2} \ell)^2}) \propto k_{\textrm{RBF}}(x,x').$$</p>
<p>It is worth taking a moment to absorb what we have done here. By moving into the function space representation, we have derived how to represent a model with an <em>infinite</em> number of parameters, using a finite amount of computation. A Gaussian process with an RBF kernel is a <em>universal approximator</em>, capable of representing any continuous function to arbitrary precision. We can intuitively see why from the above derivation. We can collapse each radial basis function to a point mass taking $\ell \to 0$, and give each point mass any height we wish.</p>
<p>So a Gaussian process with an RBF kernel is a model with an infinite number of parameters and much more flexibility than any finite neural network. Perhaps all the fuss about <em>overparametrized</em> neural networks is misplaced. As we will see, GPs with RBF kernels do not overfit, and in fact provide especially compelling generalization performance on small datasets. Moreover, the examples in :cite:<code>zhang2021understanding</code>, such as the ability to fit images with random labels perfectly, but still generalize well on structured problems, (can be perfectly reproduced using Gaussian processes) :cite:<code>wilson2020bayesian</code>. Neural networks are not as distinct as we make them out to be.</p>
<p>We can build further intuition about Gaussian processes with RBF kernels, and hyperparameters such as <em>length-scale</em>, by sampling directly from the distribution over functions. As before, this involves a simple procedure:</p>
<ol>
<li>Choose the input $x$ points we want to query the GP: $x_1,\dots,x_n$.</li>
<li>Evaluate $m(x_i)$, $i = 1,\dots,n$, and $k(x_i,x_j)$ for $i,j = 1,\dots,n$ to respectively form the mean vector and covariance matrix $\mu$ and $K$, where $(f(x_1),\dots,f(x_n)) \sim \mathcal{N}(\mu, K)$.</li>
<li>Sample from this multivariate Gaussian distribution to obtain the sample function values.</li>
<li>Sample more times to visualize more sample functions queried at those points.</li>
</ol>
<p>We illustrate this process in the figure below.</p>
<pre><code class="language-{.python .input}">def rbfkernel(x1, x2, ls=4.):  #@save
    dist = distance_matrix(np.expand_dims(x1, 1), np.expand_dims(x2, 1))
    return np.exp(-(1. / ls / 2) * (dist ** 2))

x_points = np.linspace(0, 5, 50)
meanvec = np.zeros(len(x_points))
covmat = rbfkernel(x_points,x_points, 1)

prior_samples= np.random.multivariate_normal(meanvec, covmat, size=5);
d2l.plt.plot(x_points, prior_samples.T, alpha=0.5)
d2l.plt.show()
</code></pre>
<h2 id="the-neural-network-kernel"><a class="header" href="#the-neural-network-kernel">The Neural Network Kernel</a></h2>
<p>Research on Gaussian processes in machine learning was triggered by research on neural networks. Radford Neal was pursuing ever larger Bayesian neural networks, ultimately showing in 1994 (later published in 1996, as it was one of the most infamous NeurIPS rejections) that such networks with an infinite number of hidden units become Gaussian processes with particular kernel functions :cite:<code>neal1996bayesian</code>. Interest in this derivation has re-surfaced, with ideas like the neural tangent kernel being used to investigate the generalization properties of neural networks :cite:<code>matthews2018gaussian</code> :cite:<code>novak2018bayesian</code>. We can derive the neural network kernel as follows.</p>
<p>Consider a neural network function $f(x)$ with one hidden layer:</p>
<p>$$f(x) = b + \sum_{i=1}^{J} v_i h(x; u_i).$$</p>
<p>$b$ is a bias, $v_i$ are the hidden to output weights, $h$ is any bounded hidden unit transfer function, $u_i$ are the input to hidden weights, and $J$ is the number of hidden units. Let $b$ and $v_i$ be independent with zero mean and variances $\sigma_b^2$ and $\sigma_v^2/J$, respectively, and let the $u_i$ have independent identical distributions. We can then use the central limit theorem to show that any collection of function values $f(x_1),\dots,f(x_n)$ has a joint multivariate Gaussian distribution.</p>
<p>The mean and covariance function of the corresponding Gaussian process are:</p>
<p>$$m(x) = E[f(x)] = 0$$</p>
<p>$$k(x,x') = \textrm{cov}[f(x),f(x')] = E[f(x)f(x')] = \sigma_b^2 + \frac{1}{J} \sum_{i=1}^{J} \sigma_v^2 E[h_i(x; u_i)h_i(x'; u_i)]$$</p>
<p>In some cases, we can essentially evaluate this covariance function in closed form. Let $h(x; u) = \textrm{erf}(u_0 + \sum_{j=1}^{P} u_j x_j)$, where $\textrm{erf}(z) = \frac{2}{\sqrt{\pi}} \int_{0}^{z} e^{-t^2} dt$, and $u \sim \mathcal{N}(0,\Sigma)$. Then $k(x,x') = \frac{2}{\pi} \textrm{sin}(\frac{2 \tilde{x}^{\top} \Sigma \tilde{x}'}{\sqrt{(1 + 2 \tilde{x}^{\top} \Sigma \tilde{x})(1 + 2 \tilde{x}'^{\top} \Sigma \tilde{x}')}})$.</p>
<p>The RBF kernel is <em>stationary</em>, meaning that it is <em>translation invariant</em>, and therefore can be written as a function of $\tau = x-x'$. Intuitively, stationarity means that the high-level properties of the function, such as rate of variation, do not change as we move in input space. The neural network kernel, however, is <em>non-stationary</em>. Below, we show sample functions from a Gaussian process with this kernel. We can see that the function looks qualitatively different near the origin.</p>
<h2 id="summary-107"><a class="header" href="#summary-107">Summary</a></h2>
<p>The first step in performing Bayesian inference involves specifying a prior. Gaussian processes can be used to specify a whole prior over functions. Starting from a traditional "weight space" view of modelling, we can induce a prior over functions by starting with the functional form of a model, and introducing a distribution over its parameters. We can alternatively specify a prior distribution directly in function space, with properties controlled by a kernel. The function-space approach has many advantages. We can build models that actually correspond to an infinite number of parameters, but use a finite amount of computation! Moreover, while these models have a great amount of flexibility, they also make strong assumptions about what types of functions are a priori likely, leading to relatively good generalization on small datasets.</p>
<p>The assumptions of models in function space are intuitively controlled by kernels, which often encode higher level properties of functions, such as smoothness and periodicity. Many kernels are stationary, meaning that they are translation invariant. Functions drawn from a Gaussian process with a stationary kernel have roughly the same high-level properties (such as rate of variation) regardless of where we look in the input space.</p>
<p>Gaussian processes are a relatively general model class, containing many examples of models we are already familiar with, including polynomials, Fourier series, and so on, as long as we have a Gaussian prior over the parameters. They also include neural networks with an infinite number of parameters, even without Gaussian distributions over the parameters. This connection, discovered by Radford Neal, triggered machine learning researchers to move away from neural networks, and towards Gaussian processes.</p>
<h2 id="exercises-127"><a class="header" href="#exercises-127">Exercises</a></h2>
<ol>
<li>
<p>Draw sample prior functions from a GP with an Ornstein-Uhlenbeck (OU) kernel, $k_{\textrm{OU}}(x,x') = \exp\left(-\frac{1}{2\ell}||x - x'|\right)$. If you fix the lengthscale $\ell$ to be the same, how do these functions look different than sample functions from a GP with an RBF kernel?</p>
</li>
<li>
<p>How does changing the <em>amplitude</em> $a^2$ of the RBF kernel affect the distribution over functions?</p>
</li>
<li>
<p>Suppose we form $u(x) = f(x) + 2g(x)$, where $f(x) \sim \mathcal{GP}(m_1,k_1)$ and $g(x) \sim \mathcal{GP}(m_2,k_2)$. Is $u(x)$ a Gaussian process, and if so, what is its mean and covariance function?</p>
</li>
<li>
<p>Suppose we form $g(x) = a(x)f(x)$, where $f(x) \sim \mathcal{GP}(0,k)$ and $a(x) = x^2$. Is $g(x)$ a Gaussian process, and if so, what is its mean and covariance function? What is the effect of $a(x)$? What do sample functions drawn from $g(x)$ look like?</p>
</li>
<li>
<p>Suppose we form $u(x) = f(x)g(x)$, where $f(x) \sim \mathcal{GP}(m_1,k_1)$ and $g(x) \sim \mathcal{GP}(m_2,k_2)$. Is $u(x)$ a Gaussian process, and if so, what is its mean and covariance function?</p>
</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12116">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
#required_libs("gpytorch")
</code></pre>
<h1 id="gaussian-process-inference"><a class="header" href="#gaussian-process-inference">Gaussian Process Inference</a></h1>
<p>In this section, we will show how to perform posterior inference and make predictions using the GP priors we introduced in the last section. We will start with regression, where we can perform inference in <em>closed form</em>. This is a "GPs in a nutshell" section to quickly get up and running with Gaussian processes in practice. We'll start coding all the basic operations from scratch, and then introduce <a href="https://gpytorch.ai/">GPyTorch</a>, which will make working with state-of-the-art Gaussian processes and integration with deep neural networks much more convenient. We will consider these more advanced topics in depth in the next section. In that section, we will also consider settings where approximate inference is required --- classification, point processes, or any non-Gaussian likelihoods.</p>
<h2 id="posterior-inference-for-regression"><a class="header" href="#posterior-inference-for-regression">Posterior Inference for Regression</a></h2>
<p>An <em>observation</em> model relates the function we want to learn, $f(x)$, to our observations $y(x)$, both indexed by some input $x$. In classification, $x$ could be the pixels of an image, and $y$ could be the associated class label. In regression, $y$ typically represents a continuous output, such as a land surface temperature, a sea-level, a $CO_2$ concentration, etc.</p>
<p>In regression, we often assume the outputs are given by a latent noise-free function $f(x)$ plus i.i.d. Gaussian noise $\epsilon(x)$:</p>
<p>$$y(x) = f(x) + \epsilon(x),$$
:eqlabel:<code>eq_gp-regression</code></p>
<p>with $\epsilon(x) \sim \mathcal{N}(0,\sigma^2)$. Let $\mathbf{y} = y(X) = (y(x_1),\dots,y(x_n))^{\top}$ be a vector of our training observations, and $\textbf{f} = (f(x_1),\dots,f(x_n))^{\top}$ be a vector of the latent noise-free function values, queried at the training inputs $X = {x_1, \dots, x_n}$.</p>
<p>We will assume $f(x) \sim \mathcal{GP}(m,k)$, which means that any collection of function values $\textbf{f}$ has a joint multivariate Gaussian distribution, with mean vector $\mu_i = m(x_i)$ and covariance matrix $K_{ij} = k(x_i,x_j)$. The RBF kernel $k(x_i,x_j) = a^2 \exp\left(-\frac{1}{2\ell^2}||x_i-x_j||^2\right)$ would be a standard choice of covariance function. For notational simplicity, we will assume the mean function $m(x)=0$; our derivations can easily be generalized later on.</p>
<p>Suppose we want to make predictions at a set of inputs $$X_* = x_{<em>1},x_{<em>2},\dots,x_{<em>m}.$$ Then we want to find $x^2$ and $p(\mathbf{f}_</em> | \mathbf{y}, X)$. In the regression setting, we can conveniently find this distribution by using Gaussian identities, after finding the joint distribution over $\mathbf{f}_</em> = f(X_</em>)$ and $\mathbf{y}$.</p>
<p>If we evaluate equation :eqref:<code>eq_gp-regression</code> at the training inputs $X$, we have $\mathbf{y} = \mathbf{f} + \mathbf{\epsilon}$. By the definition of a Gaussian process (see last section), $\mathbf{f} \sim \mathcal{N}(0,K(X,X))$ where $K(X,X)$ is an $n \times n$ matrix formed by evaluating our covariance function (aka <em>kernel</em>) at all possible pairs of inputs $x_i, x_j \in X$. $\mathbf{\epsilon}$ is simply a vector comprised of iid samples from $\mathcal{N}(0,\sigma^2)$ and thus has distribution $\mathcal{N}(0,\sigma^2I)$. $\mathbf{y}$ is therefore a sum of two independent multivariate Gaussian variables, and thus has distribution $\mathcal{N}(0, K(X,X) + \sigma^2I)$. One can also show that $\textrm{cov}(\mathbf{f}<em>*, \mathbf{y}) = \textrm{cov}(\mathbf{y},\mathbf{f}</em><em>)^{\top} = K(X_</em>,X)$ where $K(X_*,X)$ is an $m \times n$ matrix formed by evaluating the kernel at all pairs of test and training inputs.</p>
<p>$$
\begin{bmatrix}
\mathbf{y} \
\mathbf{f}<em>*
\end{bmatrix}
\sim
\mathcal{N}\left(0,
\mathbf{A} = \begin{bmatrix}
K(X,X)+\sigma^2I &amp; K(X,X</em><em>) \
K(X_</em>,X) &amp; K(X_<em>,X_</em>)
\end{bmatrix}
\right)
$$</p>
<p>We can then use standard Gaussian identities to find the conditional distribution from the joint distribution (see, e.g., Bishop Chapter 2),
$\mathbf{f}<em>* | \mathbf{y}, X, X</em>* \sim \mathcal{N}(m_<em>,S_</em>)$, where $m_* = K(X_<em>,X)[K(X,X)+\sigma^2I]^{-1}\textbf{y}$, and $S = K(X_</em>,X_<em>) - K(X_</em>,X)[K(X,X)+\sigma^2I]^{-1}K(X,X_*)$.</p>
<p>Typically, we do not need to make use of the full predictive covariance matrix $S$, and instead use the diagonal of $S$ for uncertainty about each prediction. Often for this reason we write the predictive distribution for a single test point $x_*$, rather than a collection of test points.</p>
<p>The kernel matrix has parameters $\theta$ that we also wish to estimate, such the amplitude $a$ and lengthscale $\ell$ of the RBF kernel above. For these purposes we use the <em>marginal likelihood</em>, $p(\textbf{y} | \theta, X)$, which we already derived in working out the marginal distributions to find the joint distribution over $\textbf{y},\textbf{f}_*$. As we will see, the marginal likelihood compartmentalizes into model fit and model complexity terms, and automatically encodes a notion of Occam's razor for learning hyperparameters. For a full discussion, see MacKay Ch. 28 :cite:<code>mackay2003information</code>, and Rasmussen and Williams Ch. 5 :cite:<code>rasmussen2006gaussian</code>.</p>
<pre><code class="language-{.python .input}">from d2l import torch as d2l
import numpy as np
from scipy.spatial import distance_matrix
from scipy import optimize
import matplotlib.pyplot as plt
import math
import torch
import gpytorch
import os

d2l.set_figsize()
</code></pre>
<h2 id="equations-for-making-predictions-and-learning-kernel-hyperparameters-in-gp-regression"><a class="header" href="#equations-for-making-predictions-and-learning-kernel-hyperparameters-in-gp-regression">Equations for Making Predictions and Learning Kernel Hyperparameters in GP Regression</a></h2>
<p>We list here the equations you will use for learning hyperparameters and making predictions in Gaussian process regression. Again, we assume a vector of regression targets $\textbf{y}$, indexed by inputs $X = {x_1,\dots,x_n}$, and we wish to make a prediction at a test input $x_<em>$. We assume i.i.d. additive zero-mean Gaussian noise with variance $\sigma^2$. We use a Gaussian process prior $f(x) \sim \mathcal{GP}(m,k)$ for the latent noise-free function, with mean function $m$ and kernel function $k$. The kernel itself has parameters $\theta$ that we want to learn. For example, if we use an RBF kernel, $k(x_i,x_j) = a^2\exp\left(-\frac{1}{2\ell^2}||x-x'||^2\right)$, we want to learn $\theta = {a^2, \ell^2}$. Let $K(X,X)$ represent an $n \times n$ matrix corresponding to evaluating the kernel for all possible pairs of $n$ training inputs. Let $K(x_</em>,X)$ represent a $1 \times n$ vector formed by evaluating $k(x_*, x_i)$, $i=1,\dots,n$. Let $\mu$ be a mean vector formed by evaluating the mean function $m(x)$ at every training points $x$.</p>
<p>Typically in working with Gaussian processes, we follow a two-step procedure.</p>
<ol>
<li>Learn kernel hyperparameters $\hat{\theta}$ by maximizing the marginal likelihood with respect to these hyperparameters.</li>
<li>Use the predictive mean as a point predictor, and 2 times the predictive standard deviation to form a 95% credible set, conditioning on these learned hyperparameters $\hat{\theta}$.</li>
</ol>
<p>The log marginal likelihood is simply a log Gaussian density, which has the form:
$$\log p(\textbf{y} | \theta, X) = -\frac{1}{2}\textbf{y}^{\top}[K_{\theta}(X,X) + \sigma^2I]^{-1}\textbf{y} - \frac{1}{2}\log|K_{\theta}(X,X)| + c$$</p>
<p>The predictive distribution has the form:
$$p(y_* | x_<em>, \textbf{y}, \theta) = \mathcal{N}(a_</em>,v_<em>)$$
$$a_</em> = k_{\theta}(x_<em>,X)[K_{\theta}(X,X)+\sigma^2I]^{-1}(\textbf{y}-\mu) + \mu$$
$$v_</em> = k_{\theta}(x_<em>,x_</em>) - K_{\theta}(x_<em>,X)[K_{\theta}(X,X)+\sigma^2I]^{-1}k_{\theta}(X,x_</em>)$$</p>
<h2 id="interpreting-equations-for-learning-and-predictions"><a class="header" href="#interpreting-equations-for-learning-and-predictions">Interpreting Equations for Learning and Predictions</a></h2>
<p>There are some key points to note about the predictive distributions for Gaussian processes:</p>
<ul>
<li>
<p>Despite the flexibility of the model class, it is possible to do <em>exact</em> Bayesian inference for GP regression in <em>closed form</em>. Aside from learning the kernel hyperparameters, there is no <em>training</em>. We can write down exactly what equations we want to use to make predictions. Gaussian processes are relatively exceptional in this respect, and it has greatly contributed to their convenience, versatility, and continued popularity.</p>
</li>
<li>
<p>The predictive mean $a_<em>$ is a linear combination of the training targets $\textbf{y}$, weighted by the kernel $k_{\theta}(x_</em>,X)[K_{\theta}(X,X)+\sigma^2I]^{-1}$. As we will see, the kernel (and its hyperparameters) thus plays a crucial role in the generalization properties of the model.</p>
</li>
<li>
<p>The predictive mean explicitly depends on the target values $\textbf{y}$ but the predictive variance does not. The predictive uncertainty instead grows as the test input $x_*$ moves away from the target locations $X$, as governed by the kernel function. However, uncertainty will implicitly depend on the values of the targets $\textbf{y}$ through the kernel hyperparameters $\theta$, which are learned from the data.</p>
</li>
<li>
<p>The marginal likelihood compartmentalizes into model fit and model complexity (log determinant) terms. The marginal likelihood tends to select for hyperparameters that provide the simplest fits that are still consistent with the data.</p>
</li>
<li>
<p>The key computational bottlenecks come from solving a linear system and computing a log determinant over an $n \times n$ symmetric positive definite matrix $K(X,X)$ for $n$ training points. Naively, these operations each incur $\mathcal{O}(n^3)$ computations, as well as $\mathcal{O}(n^2)$ storage for each entry of the kernel (covariance) matrix, often starting with a Cholesky decomposition. Historically, these bottlenecks have limited GPs to problems with fewer than about 10,000 training points, and have given GPs a reputation for "being slow" that has been inaccurate now for almost a decade. In advanced topics, we will discuss how GPs can be scaled to problems with millions of points.</p>
</li>
<li>
<p>For popular choices of kernel functions, $K(X,X)$ is often close to singular, which can cause numerical issues when performing Cholesky decompositions or other operations intended to solve linear systems. Fortunately, in regression we are often working with $K_{\theta}(X,X)+\sigma^2I$, such that the noise variance $\sigma^2$ gets added to the diagonal of $K(X,X)$, significantly improving its conditioning. If the noise variance is small, or we are doing noise free regression, it is common practice to add a small amount of "jitter" to the diagonal, on the order of $10^{-6}$, to improve conditioning.</p>
</li>
</ul>
<h2 id="worked-example-from-scratch"><a class="header" href="#worked-example-from-scratch">Worked Example from Scratch</a></h2>
<p>Let's create some regression data, and then fit the data with a GP, implementing every step from scratch.
We'll sample data from
$$y(x) = \sin(x) + \frac{1}{2}\sin(4x) + \epsilon,$$ with $\epsilon \sim \mathcal{N}(0,\sigma^2)$. The noise free function we wish to find is $f(x) = \sin(x) + \frac{1}{2}\sin(4x)$. We'll start by using a noise standard deviation $\sigma = 0.25$.</p>
<pre><code class="language-{.python .input}">def data_maker1(x, sig):
    return np.sin(x) + 0.5 * np.sin(4 * x) + np.random.randn(x.shape[0]) * sig

sig = 0.25
train_x, test_x = np.linspace(0, 5, 50), np.linspace(0, 5, 500)
train_y, test_y = data_maker1(train_x, sig=sig), data_maker1(test_x, sig=0.)

d2l.plt.scatter(train_x, train_y)
d2l.plt.plot(test_x, test_y)
d2l.plt.xlabel("x", fontsize=20)
d2l.plt.ylabel("Observations y", fontsize=20)
d2l.plt.show()
</code></pre>
<p>Here we see the noisy observations as circles, and the noise-free function in blue that we wish to find.</p>
<p>Now, let's specify a GP prior over the latent noise-free function, $f(x)\sim \mathcal{GP}(m,k)$. We'll use a mean function $m(x) = 0$, and an RBF covariance function (kernel)
$$k(x_i,x_j) = a^2\exp\left(-\frac{1}{2\ell^2}||x-x'||^2\right).$$</p>
<pre><code class="language-{.python .input}">mean = np.zeros(test_x.shape[0])
cov = d2l.rbfkernel(test_x, test_x, ls=0.2)
</code></pre>
<p>We have started with a length-scale of 0.2. Before we fit the data, it is important to consider whether we have specified a reasonable prior. Let's visualize some sample functions from this prior, as well as the 95% credible set (we believe there's a 95% chance that the true function is within this region).</p>
<pre><code class="language-{.python .input}">prior_samples = np.random.multivariate_normal(mean=mean, cov=cov, size=5)
d2l.plt.plot(test_x, prior_samples.T, color='black', alpha=0.5)
d2l.plt.plot(test_x, mean, linewidth=2.)
d2l.plt.fill_between(test_x, mean - 2 * np.diag(cov), mean + 2 * np.diag(cov), 
                 alpha=0.25)
d2l.plt.show()
</code></pre>
<p>Do these samples look reasonable? Are the high-level properties of the functions aligned with the type of data we are trying to model?</p>
<p>Now let's form the mean and variance of the posterior predictive distribution at any arbitrary test point $x_*$.</p>
<p>$$
\bar{f}<em>{*} = K(x, x</em>*)^T (K(x, x) + \sigma^2 I)^{-1}y
$$</p>
<p>$$
V(f_{<em>}) = K(x_</em>, x_<em>) - K(x, x_</em>)^T (K(x, x) + \sigma^2 I)^{-1}K(x, x_*)
$$</p>
<p>Before we make predictions, we should learn our kernel hyperparameters $\theta$ and noise variance $\sigma^2$. Let's initialize our length-scale at 0.75, as our prior functions looked too quickly varying compared to the data we are fitting. We'll also guess a noise standard deviation $\sigma$ of 0.75.</p>
<p>In order to learn these parameters, we will maximize the marginal likelihood with respect to these parameters.</p>
<p>$$
\log p(y | X) = \log \int p(y | f, X)p(f | X)df
$$
$$
\log p(y | X) = -\frac{1}{2}y^T(K(x, x) + \sigma^2 I)^{-1}y - \frac{1}{2}\log |K(x, x) + \sigma^2 I| - \frac{n}{2}\log 2\pi
$$</p>
<p>Perhaps our prior functions were too quickly varying. Let's guess a length-scale of 0.4. We'll also guess a noise standard deviation of 0.75. These are simply hyperparameter initializations --- we will learn these parameters from the marginal likelihood.</p>
<pre><code class="language-{.python .input}">ell_est = 0.4
post_sig_est = 0.5

def neg_MLL(pars):
    K = d2l.rbfkernel(train_x, train_x, ls=pars[0])
    kernel_term = -0.5 * train_y @ \
        np.linalg.inv(K + pars[1] ** 2 * np.eye(train_x.shape[0])) @ train_y
    logdet = -0.5 * np.log(np.linalg.det(K + pars[1] ** 2 * \
                                         np.eye(train_x.shape[0])))
    const = -train_x.shape[0] / 2. * np.log(2 * np.pi)
    
    return -(kernel_term + logdet + const)


learned_hypers = optimize.minimize(neg_MLL, x0=np.array([ell_est,post_sig_est]), 
                                   bounds=((0.01, 10.), (0.01, 10.)))
ell = learned_hypers.x[0]
post_sig_est = learned_hypers.x[1]
</code></pre>
<p>In this instance, we learn a length-scale of 0.299, and a noise standard deviation of 0.24. Note that the learned noise is extremely close to the true noise, which helps indicate that our GP is a very well-specified to this problem.</p>
<p>In general, it is crucial to put careful thought into selecting the kernel and initializing the hyperparameters. While marginal likelihood optimization can be relatively robust to initialization, it is not immune to poor initializations. Try running the above script with a variety of initializations and see what results you find.</p>
<p>Now, let's make predictions with these learned hypers.</p>
<pre><code class="language-{.python .input}">K_x_xstar = d2l.rbfkernel(train_x, test_x, ls=ell)
K_x_x = d2l.rbfkernel(train_x, train_x, ls=ell)
K_xstar_xstar = d2l.rbfkernel(test_x, test_x, ls=ell)

post_mean = K_x_xstar.T @ np.linalg.inv((K_x_x + \
                post_sig_est ** 2 * np.eye(train_x.shape[0]))) @ train_y
post_cov = K_xstar_xstar - K_x_xstar.T @ np.linalg.inv((K_x_x + \
                post_sig_est ** 2 * np.eye(train_x.shape[0]))) @ K_x_xstar

lw_bd = post_mean - 2 * np.sqrt(np.diag(post_cov))
up_bd = post_mean + 2 * np.sqrt(np.diag(post_cov))

d2l.plt.scatter(train_x, train_y)
d2l.plt.plot(test_x, test_y, linewidth=2.)
d2l.plt.plot(test_x, post_mean, linewidth=2.)
d2l.plt.fill_between(test_x, lw_bd, up_bd, alpha=0.25)
d2l.plt.legend(['Observed Data', 'True Function', 'Predictive Mean', '95% Set on True Func'])
d2l.plt.show()
</code></pre>
<p>We see the posterior mean in orange almost perfectly matches the true noise free function! Note that the 95% credible set we are showing is for the latent <em>noise free</em> (true) function, and not the data points. We see that this credible set entirely contains the true function, and does not seem overly wide or narrow. We would not want nor expect it to contain the data points. If we wish to have a credible set for the observations, we should compute</p>
<pre><code class="language-{.python .input}">lw_bd_observed = post_mean - 2 * np.sqrt(np.diag(post_cov) + post_sig_est ** 2)
up_bd_observed = post_mean + 2 * np.sqrt(np.diag(post_cov) + post_sig_est ** 2)
</code></pre>
<p>There are two sources of uncertainty, <em>epistemic</em> uncertainty, representing <em>reducible</em> uncertainty, and <em>aleatoric</em> or <em>irreducible</em> uncertainty. The <em>epistemic</em> uncertainty here represents uncertainty about the true values of the noise free function. This uncertainty should grow as we move away from the data points, as away from the data there are a greater variety of function values consistent with our data. As we observe more and more data, our beliefs about the true function become more confident, and the epistemic uncertainty disappears. The <em>aleatoric</em> uncertainty in this instance is the observation noise, since the data are given to us with this noise, and it cannot be reduced.</p>
<p>The <em>epistemic</em> uncertainty in the data is captured by variance of the latent noise free function np.diag(post_cov). The <em>aleatoric</em> uncertainty is captured by the noise variance post_sig_est**2.</p>
<p>Unfortunately, people are often careless about how they represent uncertainty, with many papers showing error bars that are completely undefined, no clear sense of whether we are visualizing epistemic or aleatoric uncertainty or both, and confusing noise variances with noise standard deviations, standard deviations with standard errors, confidence intervals with credible sets, and so on. Without being precise about what the uncertainty represents, it is essentially meaningless.</p>
<p>In the spirit of playing close attention to what our uncertainty represents, it is crucial to note that we are taking <em>two times</em> the <em>square root</em> of our variance estimate for the noise free function. Since our predictive distribution is Gaussian, this quantity enables us to form a 95% credible set, representing our beliefs about the interval which is 95% likely to contain the ground truth function. The noise <em>variance</em> is living on a completely different scale, and is much less interpretable.</p>
<p>Finally, let's take a look at 20 posterior samples. These samples tell us what types of functions we believe might fit our data, a posteriori.</p>
<pre><code class="language-{.python .input}">post_samples = np.random.multivariate_normal(post_mean, post_cov, size=20)
d2l.plt.scatter(train_x, train_y)
d2l.plt.plot(test_x, test_y, linewidth=2.)
d2l.plt.plot(test_x, post_mean, linewidth=2.)
d2l.plt.plot(test_x, post_samples.T, color='gray', alpha=0.25)
d2l.plt.fill_between(test_x, lw_bd, up_bd, alpha=0.25)
plt.legend(['Observed Data', 'True Function', 'Predictive Mean', 'Posterior Samples'])
d2l.plt.show()
</code></pre>
<p>In basic regression applications, it is most common to use the posterior predictive mean and standard deviation as a point predictor and metric for uncertainty, respectively. In more advanced applications, such as Bayesian optimization with Monte Carlo acquisition functions, or Gaussian processes for model-based RL, it often necessary to take posterior samples. However, even if not strictly required in the basic applications, these samples give us more intuition about the fit we have for the data, and are often useful to include in visualizations.</p>
<h2 id="making-life-easy-with-gpytorch"><a class="header" href="#making-life-easy-with-gpytorch">Making Life Easy with GPyTorch</a></h2>
<p>As we have seen, it is actually pretty easy to implement basic Gaussian process regression entirely from scratch. However, as soon as we want to explore a variety of kernel choices, consider approximate inference (which is needed even for classification), combine GPs with neural networks, or even have a dataset larger than about 10,000 points, then an implementation from scratch becomes unwieldy and cumbersome. Some of the most effective methods for scalable GP inference, such as SKI (also known as KISS-GP), can require hundreds of lines of code implementing advanced numerical linear algebra routines.</p>
<p>In these cases, the <em>GPyTorch</em> library will make our lives a lot easier. We'll be discussing GPyTorch more in future notebooks on Gaussian process numerics, and advanced methods. The GPyTorch library contains <a href="https://github.com/cornellius-gp/gpytorch/tree/master/examples">many examples</a>. To get a feel for the package, we will walk through the <a href="https://github.com/cornellius-gp/gpytorch/blob/master/examples/01_Exact_GPs/Simple_GP_Regression.ipynb">simple regression example</a>, showing how it can be adapted to reproduce our above results using GPyTorch. This may seem like a lot of code to simply reproduce the basic regression above, and in a sense, it is. But we can immediately use a variety of kernels, scalable inference techniques, and approximate inference, by only changing a few lines of code from below, instead of writing potentially thousands of lines of new code.</p>
<pre><code class="language-{.python .input}"># First let's convert our data into tensors for use with PyTorch
train_x = torch.tensor(train_x)
train_y = torch.tensor(train_y)
test_y = torch.tensor(test_y)

# We are using exact GP inference with a zero mean and RBF kernel
class ExactGPModel(gpytorch.models.ExactGP):
    def __init__(self, train_x, train_y, likelihood):
        super(ExactGPModel, self).__init__(train_x, train_y, likelihood)
        self.mean_module = gpytorch.means.ZeroMean()
        self.covar_module = gpytorch.kernels.ScaleKernel(
            gpytorch.kernels.RBFKernel())
    
    def forward(self, x):
        mean_x = self.mean_module(x)
        covar_x = self.covar_module(x)
        return gpytorch.distributions.MultivariateNormal(mean_x, covar_x)
</code></pre>
<p>This code block puts the data in the right format for GPyTorch, and specifies that we are using exact inference, as well
the mean function (zero) and kernel function (RBF) that we want to use. We can use any other kernel very easily, by
calling, for instance, gpytorch.kernels.matern_kernel(), or gpyotrch.kernels.spectral_mixture_kernel(). So far, we have
only discussed exact inference, where it is possible to infer a predictive distribution without making any approximations.
For Gaussian processes, we can only perform exact inference when we have a Gaussian likelihood; more specifically, when we
assume that our observations are generated as a noise-free function represented by a Gaussian process, plus Gaussian noise.
In future notebooks, we will consider other settings, such as classification, where we cannot make these assumptions.</p>
<pre><code class="language-{.python .input}"># Initialize Gaussian likelihood
likelihood = gpytorch.likelihoods.GaussianLikelihood()
model = ExactGPModel(train_x, train_y, likelihood)
training_iter = 50
# Find optimal model hyperparameters
model.train()
likelihood.train()
# Use the adam optimizer, includes GaussianLikelihood parameters
optimizer = torch.optim.Adam(model.parameters(), lr=0.1)  
# Set our loss as the negative log GP marginal likelihood
mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model)
</code></pre>
<p>Here, we explicitly specify the likelihood we want to use (Gaussian), the objective we will use for training kernel hyperparameters (here, the marginal likelihood), and the procedure we we want to use for optimizing that objective (in this case, Adam). We note that while we are using Adam, which is a "stochastic" optimizer, in this case, it is full-batch Adam. Because the marginal likelihood does not factorize over data instances, we cannot use an optimizer over "mini-batches" of data and be guaranteed convergence. Other optimizers, such as L-BFGS, are also supported by GPyTorch. Unlike in standard deep learning, doing a good job of optimizing the marginal likelihood corresponds strongly with good generalization, which often inclines us towards powerful optimizers like L-BFGS, assuming they are not prohibitively expensive.</p>
<pre><code class="language-{.python .input}">for i in range(training_iter):
    # Zero gradients from previous iteration
    optimizer.zero_grad()
    # Output from model
    output = model(train_x)
    # Calc loss and backprop gradients
    loss = -mll(output, train_y)
    loss.backward()
    if i % 10 == 0:
        print(f'Iter {i+1:d}/{training_iter:d} - Loss: {loss.item():.3f} '
              f'squared lengthscale: '
              f'{model.covar_module.base_kernel.lengthscale.item():.3f} '
              f'noise variance: {model.likelihood.noise.item():.3f}')
    optimizer.step()
</code></pre>
<p>Here we actually run the optimization procedure, outputting the values of the loss every 10 iterations.</p>
<pre><code class="language-{.python .input}"># Get into evaluation (predictive posterior) mode
test_x = torch.tensor(test_x)
model.eval()
likelihood.eval()
observed_pred = likelihood(model(test_x)) 
</code></pre>
<p>The above codeblock enables us to make predictions on our test inputs.</p>
<pre><code class="language-{.python .input}">with torch.no_grad():
    # Initialize plot
    f, ax = d2l.plt.subplots(1, 1, figsize=(4, 3))
    # Get upper and lower bounds for 95\% credible set (in this case, in
    # observation space)
    lower, upper = observed_pred.confidence_region()
    ax.scatter(train_x.numpy(), train_y.numpy())
    ax.plot(test_x.numpy(), test_y.numpy(), linewidth=2.)
    ax.plot(test_x.numpy(), observed_pred.mean.numpy(), linewidth=2.)
    ax.fill_between(test_x.numpy(), lower.numpy(), upper.numpy(), alpha=0.25)
    ax.set_ylim([-1.5, 1.5])
    ax.legend(['True Function', 'Predictive Mean', 'Observed Data',
               '95% Credible Set'])
</code></pre>
<p>Finally, we plot the fit.</p>
<p>We see the fits are virtually identical. A few things to note: GPyTorch is working with <em>squared</em> length-scales and observation noise. For example, our learned noise standard deviation in the for scratch code is about 0.283. The noise variance found by GPyTorch is $0.81 \approx 0.283^2$. In the GPyTorch plot, we also show the credible set in the <em>observation space</em> rather than the latent function space, to demonstrate that they indeed cover the observed datapoints.</p>
<h2 id="summary-108"><a class="header" href="#summary-108">Summary</a></h2>
<p>We can combine a Gaussian process prior with data to form a posterior, which we use to make predictions. We can also form a marginal likelihood, which is useful for automatic learning of kernel hyperparameters, which control properties such as the rate of variation of the Gaussian process. The mechanics of forming the posterior and learning kernel hyperparameters for regression are simple, involving about a dozen lines of code. This notebook is a good reference for any reader wanting to quickly get "up and running" with Gaussian processes. We also introduced the GPyTorch library. Although the GPyTorch code for basic regression is relatively long, it can be trivially modified for other kernel functions, or more advanced functionality we will discuss in future notebooks, such as scalable inference, or non-Gaussian likelihoods for classification.</p>
<h2 id="exercises-128"><a class="header" href="#exercises-128">Exercises</a></h2>
<ol>
<li>We have emphasized the importance of <em>learning</em> kernel hyperparameters, and the effect of hyperparameters and kernels on the generalization properties of Gaussian processes. Try skipping the step where we learn hypers, and instead guess a variety of length-scales and noise variances, and check their effect on predictions. What happens when you use a large length-scale? A small length-scale? A large noise variance? A small noise variance?</li>
<li>We have said that the marginal likelihood is not a convex objective, but that hyperparameters like length-scale and noise variance can be reliably estimated in GP regression. This is generally true --- in fact, the marginal likelihood is <em>much</em> better at learning length-scale hyperparameters than conventional approaches in spatial statistics, which involve fitting empirical autocorrelation functions ("covariograms"). Arguably, the biggest contribution from machine learning to Gaussian process research, at least before recent work on scalable inference, was the introduction of the marginal lkelihood for hyperparameter learning.</li>
</ol>
<p><em>However</em>, different pairings of even these parameters provide interpretably different plausible explanations for many datasets, leading to local optima in our objective. If we use a large length-scale, then we assume the true underlying function is slowly varying. If the observed data <em>are</em> varying significantly, then the only we can plausibly have a large length-scale is with a large noise-variance. If we use a small length-scale, on the  other hand, our fit will be very sensitive to the variations in the data, leaving little room to explain variations with noise (aleatoric uncertainty).</p>
<p>Try seeing if you can find these local optima: initialize with very large length-scale with large noise, and small length-scales with small noise. Do you converge to different solutions?</p>
<ol start="3">
<li>
<p>We have said that a fundamental advantage of Bayesian methods is in naturally representing <em>epistemic</em> uncertainty. In the above example, we cannot fully see the effects of epistemic uncertainty. Try instead to predict with <code>test_x = np.linspace(0, 10, 1000)</code>. What happens to the 95% credible set as your predictions move beyond the data? Does it cover the true function in that interval? What happens if you only visualize aleatoric uncertainty in that region?</p>
</li>
<li>
<p>Try running the above example, but instead with 10,000, 20,000 and 40,000 training points, and measure the runtimes. How does the training time scale? Alternatively, how do the runtimes scale with the number of test points? Is it different for the predictive mean and the predictive variance? Answer this question both by theoretically working out the training and testing time complexities, and by running the code above with a different number of points.</p>
</li>
<li>
<p>Try running the GPyTorch example with different covariance functions, such as the Matern kernel. How do the results change? How about the spectral mixture kernel, found in the GPyTorch library? Are some easier to train the marginal likelihood than others? Are some more valuable for long-range versus short-range predictions?</p>
</li>
<li>
<p>In our GPyTorch example, we plotted the predictive distribution including observation noise, while in our "from scratch" example, we only included epistemic uncertainty. Re-do the GPyTorch example, but this time only plotting epistemic uncertainty, and compare to the from-scratch results. Do the predictive distributions now look the same?  (They should.)</p>
</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12117">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hyperparameter-optimization"><a class="header" href="#hyperparameter-optimization">Hyperparameter Optimization</a></h1>
<p>:label:<code>chap_hyperopt</code></p>
<p><strong>Aaron Klein</strong> (<em>Amazon</em>), <strong>Matthias Seeger</strong> (<em>Amazon</em>), and <strong>Cedric Archambeau</strong> (<em>Amazon</em>)</p>
<p>The performance of every machine learning model depends on its hyperparameters.
They control the learning algorithm or the structure of the underlying
statistical model. However, there is no general way to choose hyperparameters
in practice. Instead, hyperparameters are often set in a trial-and-error manner
or sometimes left to their default values by practitioners, leading to
suboptimal generalization.</p>
<p>Hyperparameter optimization provides a systematic approach to this problem, by
casting it as an optimization problem: a good set of hyperparameters should (at
least) minimize a validation error. Compared to most other optimization problems
arising in machine learning, hyperparameter optimization is a nested one, where
each iteration requires training and validating a machine learning model.</p>
<p>In this chapter, we will first introduce the basics of hyperparameter
optimization. We will also present some recent advancements that improve the
overall efficiency of hyperparameter optimization by exploiting cheap-to-evaluate
proxies of the original objective function. At the end of this chapter, you
should be able to apply state-of-the-art hyperparameter optimization techniques
to optimize the hyperparameter of your own machine learning algorithm.</p>
<pre><code class="language-toc">:maxdepth: 2

hyperopt-intro
hyperopt-api
rs-async.md
sh-intro
sh-async
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
</code></pre>
<h1 id="what-is-hyperparameter-optimization"><a class="header" href="#what-is-hyperparameter-optimization">What Is Hyperparameter Optimization?</a></h1>
<p>:label:<code>sec_what_is_hpo</code></p>
<p>As we have seen in the previous chapters, deep neural networks come with a
large number of parameters or weights that are learned during training. On
top of these, every neural network has additional <em>hyperparameters</em> that need
to be configured by the user. For example, to ensure that stochastic gradient
descent converges to a local optimum of the training loss
(see :numref:<code>chap_optimization</code>), we have to adjust the learning rate and batch
size. To avoid overfitting on training datasets,
we might have to set regularization parameters, such as weight decay
(see :numref:<code>sec_weight_decay</code>) or dropout (see :numref:<code>sec_dropout</code>). We can
define the capacity and inductive bias of the model by setting the number of
layers and number of units or filters per layer (i.e., the effective number
of weights).</p>
<p>Unfortunately, we cannot simply adjust these hyperparameters by minimizing the
training loss, because this would lead to overfitting on the training data. For
example, setting regularization parameters, such as dropout or weight decay
to zero leads to a small training loss, but might hurt the generalization
performance.</p>
<p><img src="chapter_hyperparameter-optimization/../img/ml_workflow.svg" alt="Typical workflow in machine learning that consists of training the model multiple times with different hyperparameters." />
:label:<code>ml_workflow</code></p>
<p>Without a different form of automation, hyperparameters have to be set manually
in a trial-and-error fashion, in what amounts to a time-consuming and difficult
part of machine learning workflows. For example, consider training
a ResNet (see :numref:<code>sec_resnet</code>) on CIFAR-10, which requires more than 2 hours
on an Amazon Elastic Cloud Compute (EC2) <code>g4dn.xlarge</code> instance. Even just
trying ten hyperparameter configurations in sequence, this would already take us
roughly one day. To make matters worse, hyperparameters are usually not directly
transferable across architectures and datasets
:cite:<code>feurer-arxiv22,wistuba-ml18,bardenet-icml13a</code>, and need to be re-optimized
for every new task. Also, for most hyperparameters, there are no rule-of-thumbs,
and expert knowledge is required to find sensible values.</p>
<p><em>Hyperparameter optimization (HPO)</em> algorithms are designed to tackle this
problem in a principled and automated fashion :cite:<code>feurer-automlbook18a</code>, by
framing it as a global optimization problem. The default objective is the error
on a hold-out validation dataset, but could in principle be any other business
metric. It can be combined with or constrained by secondary objectives, such as
training time, inference time, or model complexity.</p>
<p>Recently, hyperparameter optimization has been extended to <em>neural architecture
search (NAS)</em> :cite:<code>elsken-arxiv18a,wistuba-arxiv19</code>, where the goal is to find
entirely new neural network architectures. Compared to classical HPO, NAS is even
more expensive in terms of computation and requires additional efforts to remain
feasible in practice. Both, HPO and NAS can be considered as sub-fields of
AutoML :cite:<code>hutter-book19a</code>, which aims to automate the entire ML pipeline.</p>
<p>In this section we will introduce HPO and show how we can automatically find
the best hyperparameters of the logistic regression example introduced in
:numref:<code>sec_softmax_concise</code>.</p>
<h2 id="the-optimization-problem"><a class="header" href="#the-optimization-problem">The Optimization Problem</a></h2>
<p>:label:<code>sec_definition_hpo</code></p>
<p>We will start with a simple toy problem: searching for the learning rate of the
multi-class logistic regression model <code>SoftmaxRegression</code> from
:numref:<code>sec_softmax_concise</code> to minimize the validation error on the Fashion
MNIST dataset. While other hyperparameters like batch size or number of epochs
are also worth tuning, we focus on learning rate alone for simplicity.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import numpy as np
import torch
from torch import nn
from scipy import stats
</code></pre>
<p>Before we can run HPO, we first need to define two ingredients: the objective
function and the configuration space.</p>
<h3 id="the-objective-function"><a class="header" href="#the-objective-function">The Objective Function</a></h3>
<p>The performance of a learning algorithm can be seen as a function
$f: \mathcal{X} \rightarrow \mathbb{R}$ that maps from the hyperparameter space
$\mathbf{x} \in \mathcal{X}$ to the validation loss. For every evaluation of
$f(\mathbf{x})$, we have to train and validate our machine learning model, which
can be time and compute intensive in the case of deep neural networks trained on
large datasets. Given our criterion $f(\mathbf{x})$ our goal is to find
$\mathbf{x}<em>{\star} \in \mathrm{argmin}</em>{\mathbf{x} \in \mathcal{X}} f(\mathbf{x})$.</p>
<p>There is no simple way to compute gradients of $f$ with respect to $\mathbf{x}$,
because it would require to propagate the gradient through the entire training
process. While there is recent work :cite:<code>maclaurin-icml15,franceschi-icml17a</code>
to drive HPO by approximate "hypergradients", none of the existing approaches
are competitive with the state-of-the-art yet, and we will not discuss them
here. Furthermore, the computational burden of evaluating $f$ requires HPO
algorithms to approach the global optimum with as few samples as possible.</p>
<p>The training of neural networks is stochastic (e.g., weights are randomly
initialized, mini-batches are randomly sampled), so that our observations will
be noisy: $y \sim f(\mathbf{x}) + \epsilon$, where we usually assume that the
$\epsilon \sim N(0, \sigma)$ observation noise is Gaussian distributed.</p>
<p>Faced with all these challenges, we usually try to identify a small set of well
performing hyperparameter configurations quickly, instead of hitting the global
optima exactly. However, due to large computational demands of most neural
networks models, even this can take days or weeks of compute. We will explore
in :numref:<code>sec_mf_hpo</code> how we can speed-up the optimization process by either
distributing the search or using cheaper-to-evaluate approximations of the
objective function.</p>
<p>We begin with a method for computing the validation error of a model.</p>
<pre><code class="language-{.python .input  n=8}">%%tab pytorch
class HPOTrainer(d2l.Trainer):  #@save
    def validation_error(self):
        self.model.eval()
        accuracy = 0
        val_batch_idx = 0
        for batch in self.val_dataloader:
            with torch.no_grad():
                x, y = self.prepare_batch(batch)
                y_hat = self.model(x)
                accuracy += self.model.accuracy(y_hat, y)
            val_batch_idx += 1
        return 1 -  accuracy / val_batch_idx
</code></pre>
<p>We optimize validation error with respect to the hyperparameter configuration
<code>config</code>, consisting of the <code>learning_rate</code>. For each evaluation, we train our
model for <code>max_epochs</code> epochs, then compute and return its validation error:</p>
<pre><code class="language-{.python .input  n=5}">%%tab pytorch
def hpo_objective_softmax_classification(config, max_epochs=8):
    learning_rate = config["learning_rate"]
    trainer = d2l.HPOTrainer(max_epochs=max_epochs)
    data = d2l.FashionMNIST(batch_size=16)
    model = d2l.SoftmaxRegression(num_outputs=10, lr=learning_rate)
    trainer.fit(model=model, data=data)
    return d2l.numpy(trainer.validation_error())
</code></pre>
<h3 id="the-configuration-space"><a class="header" href="#the-configuration-space">The Configuration Space</a></h3>
<p>:label:<code>sec_intro_config_spaces</code></p>
<p>Along with the objective function $f(\mathbf{x})$, we also need to define the
feasible set $\mathbf{x} \in \mathcal{X}$ to optimize over, known as
<em>configuration space</em> or <em>search space</em>. For our logistic regression example,
we will use:</p>
<pre><code class="language-{.python .input  n=6}">config_space = {"learning_rate": stats.loguniform(1e-4, 1)}
</code></pre>
<p>Here we use the use the <code>loguniform</code> object from SciPy, which represents a
uniform distribution between -4 and -1 in the logarithmic space. This object
allows us to sample random variables from this distribution.</p>
<p>Each hyperparameter has a data type, such as <code>float</code> for <code>learning_rate</code>, as
well as a closed bounded range (i.e., lower and upper bounds). We usually assign
a prior distribution (e.g, uniform or log-uniform) to each hyperparameter to
sample from. Some positive parameters, such as <code>learning_rate</code>, are best
represented on a logarithmic scale as optimal values can differ by several
orders of magnitude, while others, such as momentum, come with linear scale.</p>
<p>Below we show a simple example of a configuration space consisting of typical
hyperparameters of a multi-layer perceptron including their type and standard
ranges.</p>
<p>: Example configuration space of multi-layer perceptron
:label:<code>tab_example_configspace</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Type</th><th style="text-align: center">Hyperparameter Ranges</th><th style="text-align: center">log-scale</th></tr></thead><tbody>
<tr><td style="text-align: center">learning rate</td><td style="text-align: center">float</td><td style="text-align: center">$[10^{-6},10^{-1}]$</td><td style="text-align: center">yes</td></tr>
<tr><td style="text-align: center">batch size</td><td style="text-align: center">integer</td><td style="text-align: center">$[8,256]$</td><td style="text-align: center">yes</td></tr>
<tr><td style="text-align: center">momentum</td><td style="text-align: center">float</td><td style="text-align: center">$[0,0.99]$</td><td style="text-align: center">no</td></tr>
<tr><td style="text-align: center">activation function</td><td style="text-align: center">categorical</td><td style="text-align: center">${\textrm{tanh}, \textrm{relu}}$</td><td style="text-align: center">-</td></tr>
<tr><td style="text-align: center">number of units</td><td style="text-align: center">integer</td><td style="text-align: center">$[32, 1024]$</td><td style="text-align: center">yes</td></tr>
<tr><td style="text-align: center">number of layers</td><td style="text-align: center">integer</td><td style="text-align: center">$[1, 6]$</td><td style="text-align: center">no</td></tr>
</tbody></table>
</div>
<p>In general, the structure of the configuration space $\mathcal{X}$ can be complex
and it can be quite different from $\mathbb{R}^d$. In practice, some
hyperparameters may depend on the value of others. For example, assume we try
to tune the number of layers for a multi-layer perceptron, and for each layer
the number of units. The number of units of the $l\textrm{-th}$ layer is
relevant only if the network has at least $l+1$ layers. These advanced HPO
problems are beyond the scope of this chapter. We refer the interested reader
to :cite:<code>hutter-lion11a,jenatton-icml17a,baptista-icml18a</code>.</p>
<p>The configuration space plays an important role for hyperparameter optimization,
since no algorithms can find something that is not included in the configuration
space. On the other hand, if the ranges are too large, the computation budget
to find well performing configurations might become infeasible.</p>
<h2 id="random-search"><a class="header" href="#random-search">Random Search</a></h2>
<p>:label:<code>sec_rs</code></p>
<p><em>Random search</em> is the first hyperparameter optimization algorithm we will
consider. The main idea of random search is to independently sample from the
configuration space until a predefined budget (e.g maximum
number of iterations) is exhausted, and to return the best observed
configuration. All evaluations can be executed independently in parallel (see
:numref:<code>sec_rs_async</code>), but here we use a sequential loop for simplicity.</p>
<pre><code class="language-{.python .input  n=7}">errors, values = [], []
num_iterations = 5

for i in range(num_iterations):
    learning_rate = config_space["learning_rate"].rvs()
    print(f"Trial {i}: learning_rate = {learning_rate}")
    y = hpo_objective_softmax_classification({"learning_rate": learning_rate})
    print(f"    validation_error = {y}")
    values.append(learning_rate)
    errors.append(y)
</code></pre>
<p>The best learning rate is then simply the one with the lowest validation error.</p>
<pre><code class="language-{.python .input  n=7}">best_idx = np.argmin(errors)
print(f"optimal learning rate = {values[best_idx]}")
</code></pre>
<p>Due to its simplicity and generality, random search is one of the most frequently
used HPO algorithms. It does not require any sophisticated implementation and
can be applied to any configuration space as long as we can define some
probability distribution for each hyperparameter.</p>
<p>Unfortunately random search also comes with a few shortcomings. First, it does
not adapt the sampling distribution based on the previous observations it
collected so far. Hence, it is equally likely to sample a poorly performing
configuration than a better performing configuration. Second, the same amount
of resources are spent for all configurations, even though some may show poor
initial performance and are less likely to outperform previously seen
configurations.</p>
<p>In the next sections we will look at more sample efficient hyperparameter
optimization algorithms that overcome the shortcomings of random search by
using a model to guide the search. We will also look at algorithms that
automatically stop the evaluation process of poorly performing configurations
to speed up the optimization process.</p>
<h2 id="summary-109"><a class="header" href="#summary-109">Summary</a></h2>
<p>In this section we introduced hyperparameter optimization (HPO) and how we can
phrase it as a global optimization by defining a configuration space and an
objective function. We also implemented our first HPO algorithm, random search,
and applied it on a simple softmax classification problem.</p>
<p>While random search is very simple, it is the better alternative to grid
search, which simply evaluates a fixed set of hyperparameters. Random search
somewhat mitigates the curse of dimensionality :cite:<code>bellman-science66</code>, and
can be far more efficient than grid search if the criterion most strongly
depends on a small subset of the hyperparameters.</p>
<h2 id="exercises-129"><a class="header" href="#exercises-129">Exercises</a></h2>
<ol>
<li>In this chapter, we optimize the validation error of a model after training on a disjoint training set. For simplicity, our code uses <code>Trainer.val_dataloader</code>, which maps to a loader around <code>FashionMNIST.val</code>.
<ol>
<li>Convince yourself (by looking at the code) that this means we use the original FashionMNIST training set (60000 examples) for training, and the original <em>test set</em> (10000 examples) for validation.</li>
<li>Why could this practice be problematic? Hint: Re-read :numref:<code>sec_generalization_basics</code>, especially about <em>model selection</em>.</li>
<li>What should we have done instead?</li>
</ol>
</li>
<li>We stated above that hyperparameter optimization by gradient descent is very hard to do. Consider a small problem, such as training a two-layer perceptron on the FashionMNIST dataset (:numref:<code>sec_mlp-implementation</code>) with a batch size of 256. We would like to tune the learning rate of SGD in order to minimize a validation metric after one epoch of training.
<ol>
<li>Why cannot we use validation <em>error</em> for this purpose? What metric on the validation set would you use?</li>
<li>Sketch (roughly) the computational graph of the validation metric after training for one epoch. You may assume that initial weights and hyperparameters (such as learning rate) are input nodes to this graph. Hint: Re-read about computational graphs in :numref:<code>sec_backprop</code>.</li>
<li>Give a rough estimate of the number of floating point values you need to store during a forward pass on this graph. Hint: FashionMNIST has 60000 cases. Assume the required memory is dominated by the activations after each layer, and look up the layer widths in :numref:<code>sec_mlp-implementation</code>.</li>
<li>Apart from the sheer amount of compute and storage required, what other issues would gradient-based hyperparameter optimization run into? Hint: Re-read about vanishing and exploding gradients in :numref:<code>sec_numerical_stability</code>.</li>
<li><em>Advanced</em>: Read :cite:<code>maclaurin-icml15</code> for an elegant (yet still somewhat unpractical) approach to gradient-based HPO.</li>
</ol>
</li>
<li>Grid search is another HPO baseline, where we define an equi-spaced grid for each hyperparameter, then iterate over the (combinatorial) Cartesian product in order to suggest configurations.
<ol>
<li>We stated above that random search can be much more efficient than grid search for HPO on a sizable number of hyperparameters, if the criterion most strongly depends on a small subset of the hyperparameters. Why is this? Hint: Read :cite:<code>bergstra2011algorithms</code>.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12090">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input  n=1}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
</code></pre>
<h1 id="hyperparameter-optimization-api"><a class="header" href="#hyperparameter-optimization-api">Hyperparameter Optimization API</a></h1>
<p>:label:<code>sec_api_hpo</code></p>
<p>Before we dive into the methodology, we will first discuss a basic code
structure that allows us to efficiently implement various HPO algorithms. In
general, all HPO algorithms considered here need to implement two decision
making primitives, <em>searching</em> and <em>scheduling</em>. First, they need to sample new
hyperparameter configurations, which often involves some kind of search over the
configuration space. Second, for each configuration, an HPO algorithm needs to
schedule its evaluation and decide how many resources to allocate for it. Once
we start to evaluate a configuration, we will refer to it as a <em>trial</em>. We map
these decisions to two classes, <code>HPOSearcher</code> and <code>HPOScheduler</code>. On top of that,
we also provide a <code>HPOTuner</code> class that executes the optimization process.</p>
<p>This concept of scheduler and searcher is also implemented in popular HPO
libraries, such as Syne Tune :cite:<code>salinas-automl22</code>, Ray Tune
:cite:<code>liaw-arxiv18</code> or Optuna :cite:<code>akiba-sigkdd19</code>.</p>
<pre><code class="language-{.python .input  n=2}">%%tab pytorch
import time
from d2l import torch as d2l
from scipy import stats
</code></pre>
<h2 id="searcher"><a class="header" href="#searcher">Searcher</a></h2>
<p>Below we define a base class for searchers, which provides a new candidate
configuration through the <code>sample_configuration</code> function. A simple way to
implement this function would be to sample configurations uniformly at random,
as we did for random search in :numref:<code>sec_what_is_hpo</code>. More sophisticated
algorithms, such as Bayesian optimization, will make these
decisions based on the performance of previous trials. As a result, these
algorithms are able to sample more promising candidates over time. We add the
<code>update</code> function in order to update the history of previous trials, which can
then be exploited to improve our sampling distribution.</p>
<pre><code class="language-{.python .input  n=3}">%%tab pytorch
class HPOSearcher(d2l.HyperParameters):  #@save
    def sample_configuration() -&gt; dict:
        raise NotImplementedError

    def update(self, config: dict, error: float, additional_info=None):
        pass
</code></pre>
<p>The following code shows how to implement our random search optimizer from the
previous section in this API. As a slight extension, we allow the user to
prescribe the first configuration to be evaluated via <code>initial_config</code>, while
subsequent ones are drawn at random.</p>
<pre><code class="language-{.python .input  n=4}">%%tab pytorch
class RandomSearcher(HPOSearcher):  #@save
    def __init__(self, config_space: dict, initial_config=None):
        self.save_hyperparameters()

    def sample_configuration(self) -&gt; dict:
        if self.initial_config is not None:
            result = self.initial_config
            self.initial_config = None
        else:
            result = {
                name: domain.rvs()
                for name, domain in self.config_space.items()
            }
        return result
</code></pre>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p>Beyond sampling configurations for new trials, we also need to decide when and
for how long to run a trial. In practice, all these decisions are done by the
<code>HPOScheduler</code>, which delegates the choice of new configurations to a
<code>HPOSearcher</code>. The <code>suggest</code> method is called whenever some resource for training
becomes available. Apart from invoking <code>sample_configuration</code> of a searcher, it
may also decide upon parameters like <code>max_epochs</code> (i.e., how long to train the
model for). The <code>update</code> method is called whenever a trial returns a new
observation.</p>
<pre><code class="language-{.python .input  n=5}">%%tab pytorch
class HPOScheduler(d2l.HyperParameters):  #@save
    def suggest(self) -&gt; dict:
        raise NotImplementedError
    
    def update(self, config: dict, error: float, info=None):
        raise NotImplementedError
</code></pre>
<p>To implement random search, but also other HPO algorithms, we only need a basic
scheduler that schedules a new configuration every time new resources become
available.</p>
<pre><code class="language-{.python .input  n=6}">%%tab pytorch
class BasicScheduler(HPOScheduler):  #@save
    def __init__(self, searcher: HPOSearcher):
        self.save_hyperparameters()

    def suggest(self) -&gt; dict:
        return self.searcher.sample_configuration()

    def update(self, config: dict, error: float, info=None):
        self.searcher.update(config, error, additional_info=info)
</code></pre>
<h2 id="tuner"><a class="header" href="#tuner">Tuner</a></h2>
<p>Finally, we need a component that runs the scheduler/searcher and does some
book-keeping of the results. The following code implements a sequential
execution of the HPO trials that evaluates one training job after the next and
will serve as a basic example. We will later use <em>Syne Tune</em> for more scalable
distributed HPO cases.</p>
<pre><code class="language-{.python .input  n=7}">%%tab pytorch
class HPOTuner(d2l.HyperParameters):  #@save
    def __init__(self, scheduler: HPOScheduler, objective: callable):
        self.save_hyperparameters()
        # Bookeeping results for plotting
        self.incumbent = None
        self.incumbent_error = None
        self.incumbent_trajectory = []
        self.cumulative_runtime = []
        self.current_runtime = 0
        self.records = []

    def run(self, number_of_trials):
        for i in range(number_of_trials):
            start_time = time.time()
            config = self.scheduler.suggest()
            print(f"Trial {i}: config = {config}")
            error = self.objective(**config)
            error = float(d2l.numpy(error.cpu()))
            self.scheduler.update(config, error)
            runtime = time.time() - start_time
            self.bookkeeping(config, error, runtime)
            print(f"    error = {error}, runtime = {runtime}")
</code></pre>
<h2 id="bookkeeping-the-performance-of-hpo-algorithms"><a class="header" href="#bookkeeping-the-performance-of-hpo-algorithms">Bookkeeping the Performance of HPO Algorithms</a></h2>
<p>With any HPO algorithm, we are mostly interested in the best performing
configuration (called <em>incumbent</em>) and its validation error after a given
wall-clock time. This is why we track <code>runtime</code> per iteration, which includes
both the time to run an evaluation (call of <code>objective</code>) and the time to
make a decision (call of <code>scheduler.suggest</code>). In the sequel, we will plot
<code>cumulative_runtime</code> against <code>incumbent_trajectory</code> in  order to visualize the
<em>any-time performance</em> of the HPO algorithm defined in  terms of <code>scheduler</code>
(and <code>searcher</code>). This allows us to quantify not only how well the configuration
found by an optimizer works, but also how quickly an optimizer is able to find it.</p>
<pre><code class="language-{.python .input  n=8}">%%tab pytorch
@d2l.add_to_class(HPOTuner)  #@save
def bookkeeping(self, config: dict, error: float, runtime: float):
    self.records.append({"config": config, "error": error, "runtime": runtime})
    # Check if the last hyperparameter configuration performs better 
    # than the incumbent
    if self.incumbent is None or self.incumbent_error &gt; error:
        self.incumbent = config
        self.incumbent_error = error
    # Add current best observed performance to the optimization trajectory
    self.incumbent_trajectory.append(self.incumbent_error)
    # Update runtime
    self.current_runtime += runtime
    self.cumulative_runtime.append(self.current_runtime)
</code></pre>
<h2 id="example-optimizing-the-hyperparameters-of-a-convolutional-neural-network"><a class="header" href="#example-optimizing-the-hyperparameters-of-a-convolutional-neural-network">Example: Optimizing the Hyperparameters of a Convolutional Neural Network</a></h2>
<p>We now use our new implementation of random search to optimize the
<em>batch size</em> and <em>learning rate</em> of the <code>LeNet</code> convolutional neural network
from :numref:<code>sec_lenet</code>. We being by defining the objective function, which
will once more be validation error.</p>
<pre><code class="language-{.python .input  n=9}">%%tab pytorch
def hpo_objective_lenet(learning_rate, batch_size, max_epochs=10):  #@save
    model = d2l.LeNet(lr=learning_rate, num_classes=10)
    trainer = d2l.HPOTrainer(max_epochs=max_epochs, num_gpus=1)
    data = d2l.FashionMNIST(batch_size=batch_size)
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
    trainer.fit(model=model, data=data)
    validation_error = trainer.validation_error()
    return validation_error
</code></pre>
<p>We also need to define the configuration space. Moreover, the first configuration
to be evaluated is the default setting used in :numref:<code>sec_lenet</code>.</p>
<pre><code class="language-{.python .input  n=10}">config_space = {
    "learning_rate": stats.loguniform(1e-2, 1),
    "batch_size": stats.randint(32, 256),
}
initial_config = {
    "learning_rate": 0.1,
    "batch_size": 128,
}
</code></pre>
<p>Now we can start our random search:</p>
<pre><code class="language-{.python .input}">searcher = RandomSearcher(config_space, initial_config=initial_config)
scheduler = BasicScheduler(searcher=searcher)
tuner = HPOTuner(scheduler=scheduler, objective=hpo_objective_lenet)
tuner.run(number_of_trials=5)
</code></pre>
<p>Below we plot the optimization trajectory of the incumbent to get the any-time
performance of random search:</p>
<pre><code class="language-{.python .input  n=11}">board = d2l.ProgressBoard(xlabel="time", ylabel="error")
for time_stamp, error in zip(
    tuner.cumulative_runtime, tuner.incumbent_trajectory
):
    board.draw(time_stamp, error, "random search", every_n=1)
</code></pre>
<h2 id="comparing-hpo-algorithms"><a class="header" href="#comparing-hpo-algorithms">Comparing HPO Algorithms</a></h2>
<p>Just as with training algorithms or model architectures, it is important to
understand how to best compare different HPO algorithms. Each HPO run depends
on two major sources of randomness: the random effects of the training process,
such as random weight initialization or mini-batch ordering, and the intrinsic
randomness of the HPO algorithm itself, such as the random sampling of random
search. Hence, when comparing different algorithms, it is crucial to run each
experiment several times and report statistics, such as mean or median, across
a population of multiple repetitions of an algorithm based on different seeds
of the random number generator.</p>
<p>To illustrate this, we compare random search (see :numref:<code>sec_rs</code>) and Bayesian
optimization :cite:<code>snoek-nips12</code> on tuning the hyperparameters of a feed-forward
neural network. Each algorithm was evaluated
$50$ times with a different random seed. The solid line indicates the average
performance of the incumbent across these $50$ repetitions and the dashed line
the standard deviation. We can see that random search and Bayesian optimization
perform roughly the same up to ~1000 seconds, but Bayesian optimization can
make use of the past observation to identify better configurations and thus
quickly outperforms random search afterwards.</p>
<p><img src="chapter_hyperparameter-optimization/../img/example_anytime_performance.svg" alt="Example any-time performance plot to compare two algorithms A and B." />
:label:<code>example_anytime_performance</code></p>
<h2 id="summary-110"><a class="header" href="#summary-110">Summary</a></h2>
<p>This section laid out a simple, yet flexible interface to implement various HPO
algorithms that we will look at in this chapter. Similar interfaces can be found
in popular open-source HPO frameworks. We also looked at how we can compare HPO
algorithms, and potential pitfall one needs to be aware.</p>
<h2 id="exercises-130"><a class="header" href="#exercises-130">Exercises</a></h2>
<ol>
<li>The goal of this exercise is to implement the objective function for a slightly more challenging HPO problem, and to run more realistic experiments. We will use the two hidden layer MLP <code>DropoutMLP</code> implemented in :numref:<code>sec_dropout</code>.
<ol>
<li>Code up the objective function, which should depend on all hyperparameters of the model and <code>batch_size</code>. Use <code>max_epochs=50</code>. GPUs do not help here, so <code>num_gpus=0</code>. Hint: Modify <code>hpo_objective_lenet</code>.</li>
<li>Choose a sensible search space, where <code>num_hiddens_1</code>, <code>num_hiddens_2</code> are integers in $[8, 1024]$, and dropout values lie in $[0, 0.95]$, while <code>batch_size</code> lies in $[16, 384]$. Provide code for <code>config_space</code>, using sensible distributions from <code>scipy.stats</code>.</li>
<li>Run random search on this example with <code>number_of_trials=20</code> and plot the results. Make sure to first evaluate the default configuration of :numref:<code>sec_dropout</code>, which is <code>initial_config = {'num_hiddens_1': 256, 'num_hiddens_2': 256, 'dropout_1': 0.5, 'dropout_2': 0.5, 'lr': 0.1, 'batch_size': 256}</code>.</li>
</ol>
</li>
<li>In this exercise, you will implement a new searcher (subclass of <code>HPOSearcher</code>) which makes decisions based on past data. It depends on parameters <code>probab_local</code>, <code>num_init_random</code>. Its <code>sample_configuration</code> method works as follows. For the first <code>num_init_random</code> calls, do the same as <code>RandomSearcher.sample_configuration</code>. Otherwise, with probability <code>1 - probab_local</code>, do the same as <code>RandomSearcher.sample_configuration</code>. Otherwise, pick the configuration which attained the smallest validation error so far, select one of its hyperparameters at random, and sample its value randomly like in <code>RandomSearcher.sample_configuration</code>, but leave all other values the same. Return this configuration, which is identical to the best configuration so far, except in this one hyperparameter.
<ol>
<li>Code up this new <code>LocalSearcher</code>. Hint: Your searcher requires <code>config_space</code> as argument at construction. Feel free to use a member of type <code>RandomSearcher</code>. You will also have to implement the <code>update</code> method.</li>
<li>Re-run the experiment from the previous exercise, but using your new searcher instead of <code>RandomSearcher</code>. Experiment with different values for <code>probab_local</code>, <code>num_init_random</code>. However, note that a proper comparison between different HPO methods requires repeating experiments several times, and ideally considering a number of benchmark tasks.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12092">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
#required_libs("syne-tune[gpsearchers]==0.3.2")
</code></pre>
<h1 id="asynchronous-random-search"><a class="header" href="#asynchronous-random-search">Asynchronous Random Search</a></h1>
<p>:label:<code>sec_rs_async</code></p>
<p>As we have seen in the previous :numref:<code>sec_api_hpo</code>, we might have to wait
hours or even days before random search returns a good hyperparameter
configuration, because of the expensive evaluation of hyperparameter
configurations. In practice, we have often access to a pool of resources such as
multiple GPUs on the same machine or multiple machines with a single GPU. This
begs the question: <em>How do we efficiently distribute random search?</em></p>
<p>In general, we distinguish between synchronous and asynchronous parallel
hyperparameter optimization (see :numref:<code>distributed_scheduling</code>). In the
synchronous setting, we wait for all concurrently running trials to finish,
before we start the next batch. Consider configuration spaces that contain
hyperparameters such as the number of filters or number of layers of a deep
neural network. Hyperparameter configurations that contain a larger number of
layers of filters will naturally take more time to finish, and all other trials
in the same batch will have to wait at synchronisation points (grey area in
:numref:<code>distributed_scheduling</code>) before we can continue the optimization
process.</p>
<p>In the asynchronous setting we immediately schedule a new trial as soon as resources
become available. This will optimally exploit our resources, since we can avoid any
synchronisation overhead. For random search, each new hyperparameter configuration
is chosen independently of all others, and in particular without exploiting
observations from any prior evaluation. This means we can trivially parallelize random
search asynchronously. This is not straight-forward with more sophisticated methods
that make decision based on previous observations (see :numref:<code>sec_sh_async</code>).
While we need access to more resources than in the sequential setting, asynchronous
random search exhibits a linear speed-up, in that a certain performance is reached
$K$ times faster if $K$ trials can be run in parallel.</p>
<p><img src="chapter_hyperparameter-optimization/../img/distributed_scheduling.svg" alt="Distributing the hyperparameter optimization process either synchronously or asynchronously. Compared to the sequential setting, we can reduce the overall wall-clock time while keep the total compute constant. Synchronous scheduling might lead to idling workers in the case of stragglers." />
:label:<code>distributed_scheduling</code></p>
<p>In this notebook, we will look at asynchronous random search that, where trials are
executed in multiple python processes on the same machine. Distributed job scheduling
and execution is difficult to implement from scratch. We will use <em>Syne Tune</em>
:cite:<code>salinas-automl22</code>, which provides us with a simple interface for asynchronous
HPO. Syne Tune is designed to be run with different execution back-ends, and the
interested reader is invited to study its simple APIs in order to learn more about
distributed HPO.</p>
<pre><code class="language-{.python .input}">from d2l import torch as d2l
import logging
logging.basicConfig(level=logging.INFO)
from syne_tune.config_space import loguniform, randint
from syne_tune.backend.python_backend import PythonBackend
from syne_tune.optimizer.baselines import RandomSearch
from syne_tune import Tuner, StoppingCriterion
from syne_tune.experiments import load_experiment
</code></pre>
<h2 id="objective-function"><a class="header" href="#objective-function">Objective Function</a></h2>
<p>First, we have to define a new objective function such that it now returns the
performance back to Syne Tune via the <code>report</code> callback.</p>
<pre><code class="language-{.python .input  n=34}">def hpo_objective_lenet_synetune(learning_rate, batch_size, max_epochs):
    from d2l import torch as d2l    
    from syne_tune import Reporter

    model = d2l.LeNet(lr=learning_rate, num_classes=10)
    trainer = d2l.HPOTrainer(max_epochs=1, num_gpus=1)
    data = d2l.FashionMNIST(batch_size=batch_size)
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
    report = Reporter() 
    for epoch in range(1, max_epochs + 1):
        if epoch == 1:
            # Initialize the state of Trainer
            trainer.fit(model=model, data=data) 
        else:
            trainer.fit_epoch()
        validation_error = d2l.numpy(trainer.validation_error().cpu())
        report(epoch=epoch, validation_error=float(validation_error))
</code></pre>
<p>Note that the <code>PythonBackend</code> of Syne Tune requires dependencies to be imported
inside the function definition.</p>
<h2 id="asynchronous-scheduler"><a class="header" href="#asynchronous-scheduler">Asynchronous Scheduler</a></h2>
<p>First, we define the number of workers that evaluate trials concurrently. We
also need to specify how long we want to run random search, by defining an
upper limit on the total wall-clock time.</p>
<pre><code class="language-{.python .input  n=37}">n_workers = 2  # Needs to be &lt;= the number of available GPUs

max_wallclock_time = 12 * 60  # 12 minutes
</code></pre>
<p>Next, we state which metric we want to optimize and whether we want to minimize or
maximize this metric. Namely, <code>metric</code> needs to correspond to the argument name
passed to the <code>report</code> callback.</p>
<pre><code class="language-{.python .input  n=38}">mode = "min"
metric = "validation_error"
</code></pre>
<p>We use the configuration space from our previous example. In Syne Tune, this
dictionary can also be used to pass constant attributes to the training script.
We make use of this feature in order to pass <code>max_epochs</code>. Moreover, we specify
the first configuration to be evaluated in <code>initial_config</code>.</p>
<pre><code class="language-{.python .input  n=39}">config_space = {
    "learning_rate": loguniform(1e-2, 1),
    "batch_size": randint(32, 256),
    "max_epochs": 10,
}
initial_config = {
    "learning_rate": 0.1,
    "batch_size": 128,
}
</code></pre>
<p>Next, we need to specify the back-end for job executions. Here we just consider
the distribution on a local machine where parallel jobs are executed as
sub-processes. However, for large scale HPO, we could run this also on a cluster
or cloud environment, where each trial consumes a full instance.</p>
<pre><code class="language-{.python .input  n=40}">trial_backend = PythonBackend(
    tune_function=hpo_objective_lenet_synetune,
    config_space=config_space,
)
</code></pre>
<p>We can now create the scheduler for asynchronous random search, which is similar
in behaviour to our <code>BasicScheduler</code> from :numref:<code>sec_api_hpo</code>.</p>
<pre><code class="language-{.python .input  n=41}">scheduler = RandomSearch(
    config_space,
    metric=metric,
    mode=mode,
    points_to_evaluate=[initial_config],
)
</code></pre>
<p>Syne Tune also features a <code>Tuner</code>, where the main experiment loop and
bookkeeping is centralized, and interactions between scheduler and back-end are
mediated.</p>
<pre><code class="language-{.python .input  n=42}">stop_criterion = StoppingCriterion(max_wallclock_time=max_wallclock_time)

tuner = Tuner(
    trial_backend=trial_backend,
    scheduler=scheduler, 
    stop_criterion=stop_criterion,
    n_workers=n_workers,
    print_update_interval=int(max_wallclock_time * 0.6),
)
</code></pre>
<p>Let us run our distributed HPO experiment. According to our stopping criterion,
it will run for about 12 minutes.</p>
<pre><code class="language-{.python .input  n=43}">tuner.run()
</code></pre>
<p>The logs of all evaluated hyperparameter configurations are stored for further
analysis. At any time during the tuning job, we can easily get the results
obtained so far and plot the incumbent trajectory.</p>
<pre><code class="language-{.python .input  n=46}">d2l.set_figsize()
tuning_experiment = load_experiment(tuner.name)
tuning_experiment.plot()
</code></pre>
<h2 id="visualize-the-asynchronous-optimization-process"><a class="header" href="#visualize-the-asynchronous-optimization-process">Visualize the Asynchronous Optimization Process</a></h2>
<p>Below we visualize how the learning curves of every trial (each color in the plot represents a trial) evolve during the
asynchronous optimization process. At any point in time, there are as many trials
running concurrently as we have workers. Once a trial finishes, we immediately
start the next trial, without waiting for the other trials to finish. Idle time
of workers is reduced to a minimum with asynchronous scheduling.</p>
<pre><code class="language-{.python .input  n=45}">d2l.set_figsize([6, 2.5])
results = tuning_experiment.results

for trial_id in results.trial_id.unique():
    df = results[results["trial_id"] == trial_id]
    d2l.plt.plot(
        df["st_tuner_time"],
        df["validation_error"],
        marker="o"
    )
    
d2l.plt.xlabel("wall-clock time")
d2l.plt.ylabel("objective function")
</code></pre>
<h2 id="summary-111"><a class="header" href="#summary-111">Summary</a></h2>
<p>We can reduce the waiting time for random search substantially by distribution
trials across parallel resources. In general, we distinguish between synchronous
scheduling and asynchronous scheduling. Synchronous scheduling means that we
sample a new batch of hyperparameter configurations once the previous batch
finished. If we have a stragglers - trials that takes more time to finish than
other trials - our workers need to wait at synchronization points. Asynchronous
scheduling evaluates a new hyperparameter configurations as soon as resources
become available, and, hence, ensures that all workers are busy at any point in
time. While random search is easy to distribute asynchronously and does not
require any change of the actual algorithm, other methods require some additional
modifications.</p>
<h2 id="exercises-131"><a class="header" href="#exercises-131">Exercises</a></h2>
<ol>
<li>Consider the <code>DropoutMLP</code> model implemented in :numref:<code>sec_dropout</code>, and used in Exercise 1 of :numref:<code>sec_api_hpo</code>.
<ol>
<li>Implement an objective function <code>hpo_objective_dropoutmlp_synetune</code> to be used with Syne Tune. Make sure that your function reports the validation error after every epoch.</li>
<li>Using the setup of Exercise 1 in :numref:<code>sec_api_hpo</code>, compare random search to Bayesian optimization. If you use SageMaker, feel free to use Syne Tune's benchmarking facilities in order to run experiments in parallel. Hint: Bayesian optimization is provided as <code>syne_tune.optimizer.baselines.BayesianOptimization</code>.</li>
<li>For this exercise, you need to run on an instance with at least 4 CPU cores. For one of the methods used above (random search, Bayesian optimization), run experiments with <code>n_workers=1</code>, <code>n_workers=2</code>, <code>n_workers=4</code>, and compare results (incumbent trajectories). At least for random search, you should observe linear scaling with respect to the number of workers. Hint: For robust results, you may have to average over several repetitions each.</li>
</ol>
</li>
<li><em>Advanced</em>. The goal of this exercise is to implement a new scheduler in Syne Tune.
<ol>
<li>Create a virtual environment containing both the <a href="https://github.com/d2l-ai/d2l-en/blob/master/INFO.md#installation-for-developers">d2lbook</a> and <a href="https://syne-tune.readthedocs.io/en/latest/getting_started.html">syne-tune</a> sources.</li>
<li>Implement the <code>LocalSearcher</code> from Exercise 2 in :numref:<code>sec_api_hpo</code> as a new searcher in Syne Tune. Hint: Read <a href="https://syne-tune.readthedocs.io/en/latest/tutorials/developer/README.html">this tutorial</a>. Alternatively, you may follow this <a href="https://syne-tune.readthedocs.io/en/latest/examples.html#launch-hpo-experiment-with-home-made-scheduler">example</a>.</li>
<li>Compare your new <code>LocalSearcher</code> with <code>RandomSearch</code> on the <code>DropoutMLP</code> benchmark.</li>
</ol>
</li>
</ol>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12093">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
</code></pre>
<h1 id="multi-fidelity-hyperparameter-optimization"><a class="header" href="#multi-fidelity-hyperparameter-optimization">Multi-Fidelity Hyperparameter Optimization</a></h1>
<p>:label:<code>sec_mf_hpo</code></p>
<p>Training neural networks can be expensive even on moderate size datasets.
Depending on the configuration space (:numref:<code>sec_intro_config_spaces</code>),
hyperparameter optimization requires tens to hundreds of function evaluations
to find a well-performing hyperparameter configuration. As we have seen in
:numref:<code>sec_rs_async</code>, we can significantly speed up the overall wall-clock
time of HPO by exploiting parallel resources, but this does not reduce the total
amount of compute required.</p>
<p>In this section, we will show how the evaluation of hyperparameter configurations
can be sped up. Methods such as random search allocate the same amount of
resources (e.g., number of epochs, training data points) to each hyperparameter
evaluation. :numref:<code>img_samples_lc</code> depicts learning curves of a set of neural
networks trained with different hyperparameter configurations. After a few epochs we are
already able to visually distinguish between well-performing and suboptimal
configurations. However, the learning curves are noisy, and we might still require
the full amount of 100 epochs to identify the best performing one.</p>
<p><img src="chapter_hyperparameter-optimization/../img/samples_lc.svg" alt="Learning curves of random hyperparameter configurations" />
:label:<code>img_samples_lc</code></p>
<p>Multi-fidelity hyperparameter optimization allocates more resources
to promising configurations and stop evaluations of poorly performing ones early.
This speeds up the optimization process, since we can try a larger number of
configurations for the same total amount of resources.</p>
<p>More formally, we expand our definition in :numref:<code>sec_definition_hpo</code>,
such that our objective function $f(\mathbf{x}, r)$ gets an additional input
$r \in [r_{\mathrm{min}}, r_{max}]$, specifying the amount of resources that we are
willing to spend for the evaluation of configuration $\mathbf{x}$. We assume that
the error $f(\mathbf{x}, r)$ decreases with $r$, whereas the computational
cost $c(\mathbf{x}, r)$ increases. Typically, $r$ represents the number of
epochs for training the neural network, but it could also be the training
subset size or the number of cross-validation folds.</p>
<pre><code class="language-{.python .input}">%%tab pytorch
from d2l import torch as d2l
import numpy as np
from scipy import stats
from collections import defaultdict
d2l.set_figsize()
</code></pre>
<h2 id="successive-halving"><a class="header" href="#successive-halving">Successive Halving</a></h2>
<p>:label:<code>sec_mf_hpo_sh</code></p>
<p>One of the simplest ways to adapt random search to the multi-fidelity setting is
<em>successive halving</em> :cite:<code>jamieson-aistats16,karnin-icml13</code>. The basic
idea is to start with $N$ configurations, for example randomly sampled from the
configuration space, and to train each of them for $r_{\mathrm{min}}$ epochs only. We
then discard a fraction of the worst performing trials and train the remaining
ones for longer. Iterating this process, fewer trials run for longer, until at
least one trial reaches $r_{max}$ epochs.</p>
<p>More formally, consider a minimum budget $r_{\mathrm{min}}$ (for example 1 epoch), a maximum
budget $r_{max}$, for example <code>max_epochs</code> in our previous example, and a halving
constant $\eta\in{2, 3, \dots}$. For simplicity, assume that
$r_{max} = r_{\mathrm{min}} \eta^K$, with $K \in \mathbb{I}$ . The number of initial
configurations is then $N = \eta^K$. Let us define the set of rungs
$\mathcal{R} = { r_{\mathrm{min}}, r_{\mathrm{min}}\eta, r_{\mathrm{min}}\eta^2, \dots, r_{max} }$.</p>
<p>One round of successive halving proceeds as follows. We start with running $N$
trials until the first rung $r_{\mathrm{min}}$. Sorting the validation errors, we keep
the top $1 / \eta$ fraction (which amounts to $\eta^{K-1}$ configurations) and
discard all the rest. The surviving trials are trained for the next rung
($r_{\mathrm{min}}\eta$ epochs), and the process is repeated. At each rung, a
$1 / \eta$ fraction of trials survives and their training continues with a
$\eta$ times larger budget. With this particular choice of $N$, only a single
trial will be trained to the full budget $r_{max}$. Once such a round of
successive halving is done, we start the next one with a new set of initial
configurations, iterating until the total budget is spent.</p>
<p><img src="chapter_hyperparameter-optimization/../img/sh.svg" alt="Learning curves of random hyperparameter configurations." /></p>
<p>We subclass the <code>HPOScheduler</code> base class from :numref:<code>sec_api_hpo</code> in order to
implement successive halving, allowing for a generic <code>HPOSearcher</code> object to
sample configurations (which, in our example below, will be a <code>RandomSearcher</code>).
Additionally, the user has to pass the minimum resource $r_{\mathrm{min}}$, the maximum
resource $r_{max}$ and $\eta$ as input. Inside our scheduler, we maintain a
queue of configurations that still need to be evaluated for the current rung
$r_i$. We update the queue every time we jump to the next rung.</p>
<pre><code class="language-{.python .input  n=2}">class SuccessiveHalvingScheduler(d2l.HPOScheduler):  #@save
    def __init__(self, searcher, eta, r_min, r_max, prefact=1):
        self.save_hyperparameters()
        # Compute K, which is later used to determine the number of configurations
        self.K = int(np.log(r_max / r_min) / np.log(eta))
        # Define the rungs
        self.rung_levels = [r_min * eta ** k for k in range(self.K + 1)]
        if r_max not in self.rung_levels:
            # The final rung should be r_max
            self.rung_levels.append(r_max)
            self.K += 1
        # Bookkeeping
        self.observed_error_at_rungs = defaultdict(list)
        self.all_observed_error_at_rungs = defaultdict(list)
        # Our processing queue
        self.queue = []
</code></pre>
<p>In the beginning our queue is empty, and we fill it with
$n = \textrm{prefact} \cdot \eta^{K}$ configurations, which are first evaluated on
the smallest rung $r_{\mathrm{min}}$. Here, $\textrm{prefact}$ allows us to reuse our
code in a different context. For the purpose of this section, we fix
$\textrm{prefact} = 1$. Every time resources become available and the <code>HPOTuner</code>
object queries the <code>suggest</code> function, we return an element from the queue. Once
we finish one round of successive halving, which means that we evaluated all
surviving configurations on the highest resource level $r_{max}$ and our queue
is empty, we start the entire process again with a new, randomly sampled set
of configurations.</p>
<pre><code class="language-{.python .input  n=12}">%%tab pytorch
@d2l.add_to_class(SuccessiveHalvingScheduler)  #@save
def suggest(self):
    if len(self.queue) == 0:
        # Start a new round of successive halving
        # Number of configurations for the first rung:
        n0 = int(self.prefact * self.eta ** self.K)
        for _ in range(n0):
            config = self.searcher.sample_configuration()
            config["max_epochs"] = self.r_min  # Set r = r_min
            self.queue.append(config)
    # Return an element from the queue
    return self.queue.pop()
</code></pre>
<p>When we collected a new data point, we first update the searcher module.
Afterwards we check if we already collect all data points on the current rung.
If so, we sort all configurations and push the top $\frac{1}{\eta}$
configurations into the queue.</p>
<pre><code class="language-{.python .input  n=4}">%%tab pytorch
@d2l.add_to_class(SuccessiveHalvingScheduler)  #@save
def update(self, config: dict, error: float, info=None):
    ri = int(config["max_epochs"])  # Rung r_i
    # Update our searcher, e.g if we use Bayesian optimization later
    self.searcher.update(config, error, additional_info=info)
    self.all_observed_error_at_rungs[ri].append((config, error))
    if ri &lt; self.r_max:
        # Bookkeeping
        self.observed_error_at_rungs[ri].append((config, error))
        # Determine how many configurations should be evaluated on this rung
        ki = self.K - self.rung_levels.index(ri)
        ni = int(self.prefact * self.eta ** ki)
        # If we observed all configuration on this rung r_i, we estimate the
        # top 1 / eta configuration, add them to queue and promote them for
        # the next rung r_{i+1}
        if len(self.observed_error_at_rungs[ri]) &gt;= ni:
            kiplus1 = ki - 1
            niplus1 = int(self.prefact * self.eta ** kiplus1)
            best_performing_configurations = self.get_top_n_configurations(
                rung_level=ri, n=niplus1
            )
            riplus1 = self.rung_levels[self.K - kiplus1]  # r_{i+1}
            # Queue may not be empty: insert new entries at the beginning
            self.queue = [
                dict(config, max_epochs=riplus1)
                for config in best_performing_configurations
            ] + self.queue
            self.observed_error_at_rungs[ri] = []  # Reset
</code></pre>
<p>Configurations are sorted based on their observed performance on the current
rung.</p>
<pre><code class="language-{.python .input  n=4}">%%tab pytorch

@d2l.add_to_class(SuccessiveHalvingScheduler)  #@save
def get_top_n_configurations(self, rung_level, n):
    rung = self.observed_error_at_rungs[rung_level]
    if not rung:
        return []
    sorted_rung = sorted(rung, key=lambda x: x[1])
    return [x[0] for x in sorted_rung[:n]]
</code></pre>
<p>Let us see how successive halving is doing on our neural network example. We
will use $r_{\mathrm{min}} = 2$, $\eta = 2$, $r_{max} = 10$, so that rung levels are
$2, 4, 8, 10$.</p>
<pre><code class="language-{.python .input  n=5}">min_number_of_epochs = 2
max_number_of_epochs = 10
eta = 2
num_gpus=1

config_space = {
    "learning_rate": stats.loguniform(1e-2, 1),
    "batch_size": stats.randint(32, 256),
}
initial_config = {
    "learning_rate": 0.1,
    "batch_size": 128,
}
</code></pre>
<p>We just replace the scheduler with our new <code>SuccessiveHalvingScheduler</code>.</p>
<pre><code class="language-{.python .input  n=14}">searcher = d2l.RandomSearcher(config_space, initial_config=initial_config)
scheduler = SuccessiveHalvingScheduler(
    searcher=searcher,
    eta=eta,
    r_min=min_number_of_epochs,
    r_max=max_number_of_epochs,
)
tuner = d2l.HPOTuner(
    scheduler=scheduler,
    objective=d2l.hpo_objective_lenet,
)
tuner.run(number_of_trials=30)
</code></pre>
<p>We can visualize the learning curves of all configurations that we evaluated.
Most of the configurations are stopped early and only the better performing
configurations survive until $r_{max}$. Compare this to vanilla random search,
which would allocate $r_{max}$ to every configuration.</p>
<pre><code class="language-{.python .input  n=19}">for rung_index, rung in scheduler.all_observed_error_at_rungs.items():
    errors = [xi[1] for xi in rung]
    d2l.plt.scatter([rung_index] * len(errors), errors)
d2l.plt.xlim(min_number_of_epochs - 0.5, max_number_of_epochs + 0.5)
d2l.plt.xticks(
    np.arange(min_number_of_epochs, max_number_of_epochs + 1),
    np.arange(min_number_of_epochs, max_number_of_epochs + 1)
)
d2l.plt.ylabel("validation error")
d2l.plt.xlabel("epochs")
</code></pre>
<p>Finally, note some slight complexity in our implementation of
<code>SuccessiveHalvingScheduler</code>. Say that a worker is free to run a job, and
<code>suggest</code> is called when the current rung has almost been completely filled, but
another worker is still busy with an evaluation. Since we lack the metric value
from this worker, we cannot determine the top $1 / \eta$ fraction to open up
the next rung. On the other hand, we want to assign a job to our free worker,
so it does not remain idle. Our solution is to start a new round of successive
halving and assign our worker to the first trial there. However, once a rung is
completed in <code>update</code>, we make sure to insert new configurations at the
beginning of the queue, so they take precedence over configurations from the
next round.</p>
<h2 id="summary-112"><a class="header" href="#summary-112">Summary</a></h2>
<p>In this section, we introduced the concept of multi-fidelity hyperparameter
optimization, where we assume to have access to cheap-to-evaluate approximations
of the objective function, such as validation error after a certain number of
epochs of training as proxy to validation error after the full number of epochs.
Multi-fidelity hyperparameter optimization allows to reduce the overall
computation of the HPO instead of just reducing the wall-clock time.</p>
<p>We implemented and evaluated successive halving, a simple yet efficient
multi-fidelity HPO algorithm.</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12094">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(["pytorch"])
#required_libs("syne-tune[gpsearchers]==0.3.2")
</code></pre>
<h1 id="asynchronous-successive-halving"><a class="header" href="#asynchronous-successive-halving">Asynchronous Successive Halving</a></h1>
<p>:label:<code>sec_sh_async</code></p>
<p>As we have seen in :numref:<code>sec_rs_async</code>, we can accelerate HPO by
distributing the evaluation of hyperparameter configurations across either
multiple instances or multiples CPUs / GPUs on a single instance. However,
compared to random search, it is not straightforward to run
successive halving (SH) asynchronously in a distributed setting. Before we can
decide which configuration to run next, we first have to collect all
observations at the current rung level. This requires to
synchronize workers at each rung level. For example, for the lowest rung level
$r_{\mathrm{min}}$, we first have to evaluate all $N = \eta^K$ configurations, before we
can promote the $\frac{1}{\eta}$ of them to the next rung level.</p>
<p>In any distributed system, synchronization typically implies idle time for workers.
First, we often observe high variations in training time across hyperparameter
configurations. For example, assuming the number of filters per layer is a
hyperparameter, then networks with less filters finish training faster than
networks with more filters, which implies idle worker time due to stragglers.
Moreover, the number of slots in a rung level is not always a multiple of the number
of workers, in which case some workers may even sit idle for a full batch.</p>
<p>Figure :numref:<code>synchronous_sh</code> shows the scheduling of synchronous SH with $\eta=2$
for four different trials with two workers. We start with evaluating Trial-0 and
Trial-1 for one epoch and immediately continue with the next two trials once they
are finished. We first have to wait until Trial-2 finishes, which takes
substantially more time than the other trials, before we can promote the best two
trials, i.e., Trial-0 and Trial-3 to the next rung level. This causes idle time for
Worker-1. Then, we continue with Rung 1. Also, here Trial-3 takes longer than Trial-0,
which leads to an additional ideling time of Worker-0. Once, we reach Rung-2, only
the best trial, Trial-0, remains which occupies only one worker. To avoid that
Worker-1 idles during that time, most implementaitons of SH continue already with
the next round, and start evaluating new trials (e.g Trial-4) on the first rung.</p>
<p><img src="chapter_hyperparameter-optimization/../img/sync_sh.svg" alt="Synchronous successive halving with two workers." />
:label:<code>synchronous_sh</code></p>
<p>Asynchronous successive halving (ASHA) :cite:<code>li-arxiv18</code> adapts SH to the asynchronous
parallel scenario. The main idea of ASHA is to promote configurations to the next rung
level as soon as we collected at least $\eta$ observations on the current rung level.
This decision rule may lead to suboptimal promotions: configurations can be promoted to the
next rung level, which in hindsight do not compare favourably against most others
at the same rung level. On the other hand, we get rid of all synchronization points
this way. In practice, such suboptimal initial promotions have only a modest impact on
performance, not only because the ranking of hyperparameter configurations is often
fairly consistent across rung levels, but also because rungs grow over time and
reflect the distribution of metric values at this level better and better. If a
worker is free, but no configuration can be promoted, we start a new configuration
with $r = r_{\mathrm{min}}$, i.e the first rung level.</p>
<p>:numref:<code>asha</code> shows the scheduling of the same configurations for ASHA. Once Trial-1
finishes, we collect the results of two trials (i.e Trial-0 and Trial-1) and
immediately promote the better of them (Trial-0) to the next rung level. After Trial-0
finishes on rung 1, there are too few trials there in order to support a further
promotion. Hence, we continue with rung 0 and evaluate Trial-3. Once Trial-3 finishes,
Trial-2 is still pending. At this point we have 3 trials evaluated on rung 0 and one
trial evaluated already on rung 1. Since Trial-3 performs worse than Trial-0 at rung 0,
and $\eta=2$, we cannot promote any new trial yet, and Worker-1 starts Trial-4 from
scratch instead. However, once Trial-2 finishes and
scores worse than Trial-3, the latter is promoted towards rung 1. Afterwards, we
collected 2 evaluations on rung 1, which means we can now promote Trial-0 towards
rung 2. At the same time, Worker-1 continues with evaluating new trials (i.e.,
Trial-5) on rung 0.</p>
<p><img src="chapter_hyperparameter-optimization/../img/asha.svg" alt="Asynchronous successive halving (ASHA) with two workers." />
:label:<code>asha</code></p>
<pre><code class="language-{.python .input}">from d2l import torch as d2l
import logging
logging.basicConfig(level=logging.INFO)
import matplotlib.pyplot as plt
from syne_tune.config_space import loguniform, randint
from syne_tune.backend.python_backend import PythonBackend
from syne_tune.optimizer.baselines import ASHA
from syne_tune import Tuner, StoppingCriterion
from syne_tune.experiments import load_experiment
</code></pre>
<h2 id="objective-function-1"><a class="header" href="#objective-function-1">Objective Function</a></h2>
<p>We will use <em>Syne Tune</em> with the same objective function as in
:numref:<code>sec_rs_async</code>.</p>
<pre><code class="language-{.python .input  n=54}">def hpo_objective_lenet_synetune(learning_rate, batch_size, max_epochs):
    from d2l import torch as d2l
    from syne_tune import Reporter

    model = d2l.LeNet(lr=learning_rate, num_classes=10)
    trainer = d2l.HPOTrainer(max_epochs=1, num_gpus=1)
    data = d2l.FashionMNIST(batch_size=batch_size)
    model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn)
    report = Reporter()
    for epoch in range(1, max_epochs + 1):
        if epoch == 1:
            # Initialize the state of Trainer
            trainer.fit(model=model, data=data)
        else:
            trainer.fit_epoch()
        validation_error = d2l.numpy(trainer.validation_error().cpu())
        report(epoch=epoch, validation_error=float(validation_error))
</code></pre>
<p>We will also use the same configuration space as before:</p>
<pre><code class="language-{.python .input  n=55}">min_number_of_epochs = 2
max_number_of_epochs = 10
eta = 2

config_space = {
    "learning_rate": loguniform(1e-2, 1),
    "batch_size": randint(32, 256),
    "max_epochs": max_number_of_epochs,
}
initial_config = {
    "learning_rate": 0.1,
    "batch_size": 128,
}
</code></pre>
<h2 id="asynchronous-scheduler-1"><a class="header" href="#asynchronous-scheduler-1">Asynchronous Scheduler</a></h2>
<p>First, we define the number of workers that evaluate trials concurrently. We
also need to specify how long we want to run random search, by defining an
upper limit on the total wall-clock time.</p>
<pre><code class="language-{.python .input  n=56}">n_workers = 2  # Needs to be &lt;= the number of available GPUs
max_wallclock_time = 12 * 60  # 12 minutes
</code></pre>
<p>The code for running ASHA is a simple variation of what we did for asynchronous
random search.</p>
<pre><code class="language-{.python .input  n=56}">mode = "min"
metric = "validation_error"
resource_attr = "epoch"

scheduler = ASHA(
    config_space,
    metric=metric,
    mode=mode,
    points_to_evaluate=[initial_config],
    max_resource_attr="max_epochs",
    resource_attr=resource_attr,
    grace_period=min_number_of_epochs,
    reduction_factor=eta,
)
</code></pre>
<p>Here, <code>metric</code> and <code>resource_attr</code> specify the key names used with the <code>report</code>
callback, and <code>max_resource_attr</code> denotes which input to the objective function
corresponds to $r_{\mathrm{max}}$. Moreover, <code>grace_period</code> provides $r_{\mathrm{min}}$, and
<code>reduction_factor</code> is $\eta$. We can run Syne Tune as before (this will
take about 12 minutes):</p>
<pre><code class="language-{.python .input  n=57}">trial_backend = PythonBackend(
    tune_function=hpo_objective_lenet_synetune,
    config_space=config_space,
)

stop_criterion = StoppingCriterion(max_wallclock_time=max_wallclock_time)
tuner = Tuner(
    trial_backend=trial_backend,
    scheduler=scheduler,
    stop_criterion=stop_criterion,
    n_workers=n_workers,
    print_update_interval=int(max_wallclock_time * 0.6),
)
tuner.run()
</code></pre>
<p>Note that we are running a variant of ASHA where underperforming trials are
stopped early. This is different to our implementation in
:numref:<code>sec_mf_hpo_sh</code>, where each training job is started with a fixed
<code>max_epochs</code>. In the latter case, a well-performing trial which reaches the
full 10 epochs, first needs to train 1, then 2, then 4, then 8 epochs, each
time starting from scratch. This type of pause-and-resume scheduling can be
implemented efficiently by checkpointing the training state after each epoch,
but we avoid this extra complexity here. After the experiment has finished,
we can retrieve and plot results.</p>
<pre><code class="language-{.python .input  n=59}">d2l.set_figsize()
e = load_experiment(tuner.name)
e.plot()
</code></pre>
<h2 id="visualize-the-optimization-process"><a class="header" href="#visualize-the-optimization-process">Visualize the Optimization Process</a></h2>
<p>Once more, we visualize the learning curves of every trial (each color in the plot represents a trial). Compare this to
asynchronous random search in :numref:<code>sec_rs_async</code>. As we have seen for
successive halving in :numref:<code>sec_mf_hpo</code>, most of the trials are stopped
at 1 or 2 epochs ($r_{\mathrm{min}}$ or $\eta * r_{\mathrm{min}}$). However, trials do not stop
at the same point, because they require different amount of time per epoch. If
we ran standard successive halving instead of ASHA, we would need to synchronize
our workers, before we can promote configurations to the next rung level.</p>
<pre><code class="language-{.python .input  n=60}">d2l.set_figsize([6, 2.5])
results = e.results
for trial_id in results.trial_id.unique():
    df = results[results["trial_id"] == trial_id]
    d2l.plt.plot(
        df["st_tuner_time"],
        df["validation_error"],
        marker="o"
    )
d2l.plt.xlabel("wall-clock time")
d2l.plt.ylabel("objective function")
</code></pre>
<h2 id="summary-113"><a class="header" href="#summary-113">Summary</a></h2>
<p>Compared to random search, successive halving is not quite as trivial to run in
an asynchronous distributed setting. To avoid synchronisation points, we promote
configurations as quickly as possible to the next rung level, even if this means
promoting some wrong ones. In practice, this usually does not hurt much, and the
gains of asynchronous versus synchronous scheduling are usually much higher
than the loss of the suboptimal decision making.</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/12101">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generative-adversarial-networks"><a class="header" href="#generative-adversarial-networks">Generative Adversarial Networks</a></h1>
<p>:label:<code>chap_gans</code></p>
<pre><code class="language-toc">:maxdepth: 2

gan
dcgan
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generative-adversarial-networks-1"><a class="header" href="#generative-adversarial-networks-1">Generative Adversarial Networks</a></h1>
<p>:label:<code>sec_basic_gan</code></p>
<p>Throughout most of this book, we have talked about how to make predictions. In some form or another, we used deep neural networks to learn mappings from data examples to labels. This kind of learning is called discriminative learning, as in, we'd like to be able to discriminate between photos of cats and photos of dogs. Classifiers and regressors are both examples of discriminative learning. And neural networks trained by backpropagation have upended everything we thought we knew about discriminative learning on large complicated datasets. Classification accuracies on high-res images have gone from useless to human-level (with some caveats) in just 5-6 years. We will spare you another spiel about all the other discriminative tasks where deep neural networks do astoundingly well.</p>
<p>But there is more to machine learning than just solving discriminative tasks. For example, given a large dataset, without any labels, we might want to learn a model that concisely captures the characteristics of this data. Given such a model, we could sample synthetic data examples that resemble the distribution of the training data. For example, given a large corpus of photographs of faces, we might want to be able to generate a new photorealistic image that looks like it might plausibly have come from the same dataset. This kind of learning is called generative modeling.</p>
<p>Until recently, we had no method that could synthesize novel photorealistic images. But the success of deep neural networks for discriminative learning opened up new possibilities. One big trend over the last three years has been the application of discriminative deep nets to overcome challenges in problems that we do not generally think of as supervised learning problems. The recurrent neural network language models are one example of using a discriminative network (trained to predict the next character) that once trained can act as a generative model.</p>
<p>In 2014, a breakthrough paper introduced Generative adversarial networks (GANs) :cite:<code>Goodfellow.Pouget-Abadie.Mirza.ea.2014</code>, a clever new way to leverage the power of discriminative models to get good generative models. At their heart, GANs rely on the idea that a data generator is good if we cannot tell fake data apart from real data. In statistics, this is called a two-sample test - a test to answer the question whether datasets $X={x_1,\ldots, x_n}$ and $X'={x'_1,\ldots, x'_n}$ were drawn from the same distribution. The main difference between most statistics papers and GANs is that the latter use this idea in a constructive way. In other words, rather than just training a model to say "hey, these two datasets do not look like they came from the same distribution", they use the <a href="https://en.wikipedia.org/wiki/Two-sample_hypothesis_testing">two-sample test</a> to provide training signals to a generative model. This allows us to improve the data generator until it generates something that resembles the real data. At the very least, it needs to fool the classifier even if our classifier is a state of the art deep neural network.</p>
<p><img src="chapter_generative-adversarial-networks/../img/gan.svg" alt="Generative Adversarial Networks" />
:label:<code>fig_gan</code></p>
<p>The GAN architecture is illustrated in :numref:<code>fig_gan</code>.
As you can see, there are two pieces in GAN architecture - first off, we need a device (say, a deep network but it really could be anything, such as a game rendering engine) that might potentially be able to generate data that looks just like the real thing. If we are dealing with images, this needs to generate images. If we are dealing with speech, it needs to generate audio sequences, and so on. We call this the generator network. The second component is the discriminator network. It attempts to distinguish fake and real data from each other. Both networks are in competition with each other. The generator network attempts to fool the discriminator network. At that point, the discriminator network adapts to the new fake data. This information, in turn is used to improve the generator network, and so on.</p>
<p>The discriminator is a binary classifier to distinguish if the input $x$ is real (from real data) or fake (from the generator). Typically, the discriminator outputs a scalar prediction $o\in\mathbb R$ for input $\mathbf x$, such as using a fully connected layer with hidden size 1, and then applies sigmoid function to obtain the predicted probability $D(\mathbf x) = 1/(1+e^{-o})$. Assume the label $y$ for the true data is $1$ and $0$ for the fake data. We train the discriminator to minimize the cross-entropy loss, <em>i.e.</em>,</p>
<p>$$ \min_D { - y \log D(\mathbf x) - (1-y)\log(1-D(\mathbf x)) },$$</p>
<p>For the generator, it first draws some parameter $\mathbf z\in\mathbb R^d$ from a source of randomness, <em>e.g.</em>, a normal distribution $\mathbf z \sim \mathcal{N} (0, 1)$. We often call $\mathbf z$ as the latent variable.
It then applies a function to generate $\mathbf x'=G(\mathbf z)$. The goal of the generator is to fool the discriminator to classify $\mathbf x'=G(\mathbf z)$ as true data, <em>i.e.</em>, we want $D( G(\mathbf z)) \approx 1$.
In other words, for a given discriminator $D$, we update the parameters of the generator $G$ to maximize the cross-entropy loss when $y=0$, <em>i.e.</em>,</p>
<p>$$ \max_G { - (1-y) \log(1-D(G(\mathbf z))) } = \max_G { - \log(1-D(G(\mathbf z))) }.$$</p>
<p>If the generator does a perfect job, then $D(\mathbf x')\approx 1$, so the above loss is near 0, which results in the gradients that are too small to make good progress for the discriminator. So commonly, we minimize the following loss:</p>
<p>$$ \min_G { - y \log(D(G(\mathbf z))) } = \min_G { - \log(D(G(\mathbf z))) }, $$</p>
<p>which is just feeding $\mathbf x'=G(\mathbf z)$ into the discriminator but giving label $y=1$.</p>
<p>To sum up, $D$ and $G$ are playing a "minimax" game with the comprehensive objective function:</p>
<p>$$\min_D \max_G { -E_{x \sim \textrm{Data}} \log D(\mathbf x) - E_{z \sim \textrm{Noise}} \log(1 - D(G(\mathbf z))) }.$$</p>
<p>Many of the GANs applications are in the context of images. As a demonstration purpose, we are going to content ourselves with fitting a much simpler distribution first. We will illustrate what happens if we use GANs to build the world's most inefficient estimator of parameters for a Gaussian. Let's get started.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, gluon, init, np, npx
from mxnet.gluon import nn
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<h2 id="generate-some-real-data"><a class="header" href="#generate-some-real-data">Generate Some "Real" Data</a></h2>
<p>Since this is going to be the world's lamest example, we simply generate data drawn from a Gaussian.</p>
<pre><code class="language-{.python .input}">#@tab mxnet, pytorch
X = d2l.normal(0.0, 1, (1000, 2))
A = d2l.tensor([[1, 2], [-0.1, 0.5]])
b = d2l.tensor([1, 2])
data = d2l.matmul(X, A) + b
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
X = d2l.normal((1000, 2), 0.0, 1)
A = d2l.tensor([[1, 2], [-0.1, 0.5]])
b = d2l.tensor([1, 2], tf.float32)
data = d2l.matmul(X, A) + b
</code></pre>
<p>Let's see what we got. This should be a Gaussian shifted in some rather arbitrary way with mean $b$ and covariance matrix $A^TA$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet, pytorch
d2l.set_figsize()
d2l.plt.scatter(d2l.numpy(data[:100, 0]), d2l.numpy(data[:100, 1]));
print(f'The covariance matrix is\n{d2l.matmul(A.T, A)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
d2l.set_figsize()
d2l.plt.scatter(d2l.numpy(data[:100, 0]), d2l.numpy(data[:100, 1]));
print(f'The covariance matrix is\n{tf.matmul(A, A, transpose_a=True)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab all
batch_size = 8
data_iter = d2l.load_array((data,), batch_size)
</code></pre>
<h2 id="generator"><a class="header" href="#generator">Generator</a></h2>
<p>Our generator network will be the simplest network possible - a single layer linear model. This is since we will be driving that linear network with a Gaussian data generator. Hence, it literally only needs to learn the parameters to fake things perfectly.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net_G = nn.Sequential()
net_G.add(nn.Dense(2))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net_G = nn.Sequential(nn.Linear(2, 2))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
net_G = tf.keras.layers.Dense(2)
</code></pre>
<h2 id="discriminator"><a class="header" href="#discriminator">Discriminator</a></h2>
<p>For the discriminator we will be a bit more discriminating: we will use an MLP with 3 layers to make things a bit more interesting.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
net_D = nn.Sequential()
net_D.add(nn.Dense(5, activation='tanh'),
          nn.Dense(3, activation='tanh'),
          nn.Dense(1))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
net_D = nn.Sequential(
    nn.Linear(2, 5), nn.Tanh(),
    nn.Linear(5, 3), nn.Tanh(),
    nn.Linear(3, 1))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
net_D = tf.keras.models.Sequential([
    tf.keras.layers.Dense(5, activation="tanh", input_shape=(2,)),
    tf.keras.layers.Dense(3, activation="tanh"),
    tf.keras.layers.Dense(1)
])
</code></pre>
<h2 id="training-31"><a class="header" href="#training-31">Training</a></h2>
<p>First we define a function to update the discriminator.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def update_D(X, Z, net_D, net_G, loss, trainer_D):
    """Update discriminator."""
    batch_size = X.shape[0]
    ones = np.ones((batch_size,), ctx=X.ctx)
    zeros = np.zeros((batch_size,), ctx=X.ctx)
    with autograd.record():
        real_Y = net_D(X)
        fake_X = net_G(Z)
        # Do not need to compute gradient for `net_G`, detach it from
        # computing gradients.
        fake_Y = net_D(fake_X.detach())
        loss_D = (loss(real_Y, ones) + loss(fake_Y, zeros)) / 2
    loss_D.backward()
    trainer_D.step(batch_size)
    return float(loss_D.sum())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def update_D(X, Z, net_D, net_G, loss, trainer_D):
    """Update discriminator."""
    batch_size = X.shape[0]
    ones = torch.ones((batch_size,), device=X.device)
    zeros = torch.zeros((batch_size,), device=X.device)
    trainer_D.zero_grad()
    real_Y = net_D(X)
    fake_X = net_G(Z)
    # Do not need to compute gradient for `net_G`, detach it from
    # computing gradients.
    fake_Y = net_D(fake_X.detach())
    loss_D = (loss(real_Y, ones.reshape(real_Y.shape)) +
              loss(fake_Y, zeros.reshape(fake_Y.shape))) / 2
    loss_D.backward()
    trainer_D.step()
    return loss_D
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
def update_D(X, Z, net_D, net_G, loss, optimizer_D):
    """Update discriminator."""
    batch_size = X.shape[0]
    ones = tf.ones((batch_size,)) # Labels corresponding to real data
    zeros = tf.zeros((batch_size,)) # Labels corresponding to fake data
    # Do not need to compute gradient for `net_G`, so it is outside GradientTape
    fake_X = net_G(Z)
    with tf.GradientTape() as tape:
        real_Y = net_D(X)
        fake_Y = net_D(fake_X)
        # We multiply the loss by batch_size to match PyTorch's BCEWithLogitsLoss
        loss_D = (loss(ones, tf.squeeze(real_Y)) + loss(
            zeros, tf.squeeze(fake_Y))) * batch_size / 2
    grads_D = tape.gradient(loss_D, net_D.trainable_variables)
    optimizer_D.apply_gradients(zip(grads_D, net_D.trainable_variables))
    return loss_D
</code></pre>
<p>The generator is updated similarly. Here we reuse the cross-entropy loss but change the label of the fake data from $0$ to $1$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
def update_G(Z, net_D, net_G, loss, trainer_G):
    """Update generator."""
    batch_size = Z.shape[0]
    ones = np.ones((batch_size,), ctx=Z.ctx)
    with autograd.record():
        # We could reuse `fake_X` from `update_D` to save computation
        fake_X = net_G(Z)
        # Recomputing `fake_Y` is needed since `net_D` is changed
        fake_Y = net_D(fake_X)
        loss_G = loss(fake_Y, ones)
    loss_G.backward()
    trainer_G.step(batch_size)
    return float(loss_G.sum())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
def update_G(Z, net_D, net_G, loss, trainer_G):
    """Update generator."""
    batch_size = Z.shape[0]
    ones = torch.ones((batch_size,), device=Z.device)
    trainer_G.zero_grad()
    # We could reuse `fake_X` from `update_D` to save computation
    fake_X = net_G(Z)
    # Recomputing `fake_Y` is needed since `net_D` is changed
    fake_Y = net_D(fake_X)
    loss_G = loss(fake_Y, ones.reshape(fake_Y.shape))
    loss_G.backward()
    trainer_G.step()
    return loss_G
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
def update_G(Z, net_D, net_G, loss, optimizer_G):
    """Update generator."""
    batch_size = Z.shape[0]
    ones = tf.ones((batch_size,))
    with tf.GradientTape() as tape:
        # We could reuse `fake_X` from `update_D` to save computation
        fake_X = net_G(Z)
        # Recomputing `fake_Y` is needed since `net_D` is changed
        fake_Y = net_D(fake_X)
        # We multiply the loss by batch_size to match PyTorch's BCEWithLogits loss
        loss_G = loss(ones, tf.squeeze(fake_Y)) * batch_size
    grads_G = tape.gradient(loss_G, net_G.trainable_variables)
    optimizer_G.apply_gradients(zip(grads_G, net_G.trainable_variables))
    return loss_G
</code></pre>
<p>Both the discriminator and the generator performs a binary logistic regression with the cross-entropy loss. We use Adam to smooth the training process. In each iteration, we first update the discriminator and then the generator. We visualize both losses and generated examples.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data):
    loss = gluon.loss.SigmoidBCELoss()
    net_D.initialize(init=init.Normal(0.02), force_reinit=True)
    net_G.initialize(init=init.Normal(0.02), force_reinit=True)
    trainer_D = gluon.Trainer(net_D.collect_params(),
                              'adam', {'learning_rate': lr_D})
    trainer_G = gluon.Trainer(net_G.collect_params(),
                              'adam', {'learning_rate': lr_G})
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs], nrows=2, figsize=(5, 5),
                            legend=['discriminator', 'generator'])
    animator.fig.subplots_adjust(hspace=0.3)
    for epoch in range(num_epochs):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3)  # loss_D, loss_G, num_examples
        for X in data_iter:
            batch_size = X.shape[0]
            Z = np.random.normal(0, 1, size=(batch_size, latent_dim))
            metric.add(update_D(X, Z, net_D, net_G, loss, trainer_D),
                       update_G(Z, net_D, net_G, loss, trainer_G),
                       batch_size)
        # Visualize generated examples
        Z = np.random.normal(0, 1, size=(100, latent_dim))
        fake_X = net_G(Z).asnumpy()
        animator.axes[1].cla()
        animator.axes[1].scatter(data[:, 0], data[:, 1])
        animator.axes[1].scatter(fake_X[:, 0], fake_X[:, 1])
        animator.axes[1].legend(['real', 'generated'])
        # Show the losses
        loss_D, loss_G = metric[0]/metric[2], metric[1]/metric[2]
        animator.add(epoch + 1, (loss_D, loss_G))
    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data):
    loss = nn.BCEWithLogitsLoss(reduction='sum')
    for w in net_D.parameters():
        nn.init.normal_(w, 0, 0.02)
    for w in net_G.parameters():
        nn.init.normal_(w, 0, 0.02)
    trainer_D = torch.optim.Adam(net_D.parameters(), lr=lr_D)
    trainer_G = torch.optim.Adam(net_G.parameters(), lr=lr_G)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs], nrows=2, figsize=(5, 5),
                            legend=['discriminator', 'generator'])
    animator.fig.subplots_adjust(hspace=0.3)
    for epoch in range(num_epochs):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3)  # loss_D, loss_G, num_examples
        for (X,) in data_iter:
            batch_size = X.shape[0]
            Z = torch.normal(0, 1, size=(batch_size, latent_dim))
            metric.add(update_D(X, Z, net_D, net_G, loss, trainer_D),
                       update_G(Z, net_D, net_G, loss, trainer_G),
                       batch_size)
        # Visualize generated examples
        Z = torch.normal(0, 1, size=(100, latent_dim))
        fake_X = net_G(Z).detach().numpy()
        animator.axes[1].cla()
        animator.axes[1].scatter(data[:, 0], data[:, 1])
        animator.axes[1].scatter(fake_X[:, 0], fake_X[:, 1])
        animator.axes[1].legend(['real', 'generated'])
        # Show the losses
        loss_D, loss_G = metric[0]/metric[2], metric[1]/metric[2]
        animator.add(epoch + 1, (loss_D, loss_G))
    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data):
    loss = tf.keras.losses.BinaryCrossentropy(
        from_logits=True, reduction=tf.keras.losses.Reduction.SUM)
    for w in net_D.trainable_variables:
        w.assign(tf.random.normal(mean=0, stddev=0.02, shape=w.shape))
    for w in net_G.trainable_variables:
        w.assign(tf.random.normal(mean=0, stddev=0.02, shape=w.shape))
    optimizer_D = tf.keras.optimizers.Adam(learning_rate=lr_D)
    optimizer_G = tf.keras.optimizers.Adam(learning_rate=lr_G)
    animator = d2l.Animator(
        xlabel="epoch", ylabel="loss", xlim=[1, num_epochs], nrows=2,
        figsize=(5, 5), legend=["discriminator", "generator"])
    animator.fig.subplots_adjust(hspace=0.3)
    for epoch in range(num_epochs):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3)  # loss_D, loss_G, num_examples
        for (X,) in data_iter:
            batch_size = X.shape[0]
            Z = tf.random.normal(
                mean=0, stddev=1, shape=(batch_size, latent_dim))
            metric.add(update_D(X, Z, net_D, net_G, loss, optimizer_D),
                       update_G(Z, net_D, net_G, loss, optimizer_G),
                       batch_size)
        # Visualize generated examples
        Z = tf.random.normal(mean=0, stddev=1, shape=(100, latent_dim))
        fake_X = net_G(Z)
        animator.axes[1].cla()
        animator.axes[1].scatter(data[:, 0], data[:, 1])
        animator.axes[1].scatter(fake_X[:, 0], fake_X[:, 1])
        animator.axes[1].legend(["real", "generated"])

        # Show the losses
        loss_D, loss_G = metric[0] / metric[2], metric[1] / metric[2]
        animator.add(epoch + 1, (loss_D, loss_G))

    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec')
</code></pre>
<p>Now we specify the hyperparameters to fit the Gaussian distribution.</p>
<pre><code class="language-{.python .input}">#@tab all
lr_D, lr_G, latent_dim, num_epochs = 0.05, 0.005, 2, 20
train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G,
      latent_dim, d2l.numpy(data[:100]))
</code></pre>
<h2 id="summary-114"><a class="header" href="#summary-114">Summary</a></h2>
<ul>
<li>Generative adversarial networks (GANs) composes of two deep networks, the generator and the discriminator.</li>
<li>The generator generates the image as much closer to the true image as possible to fool the discriminator, via maximizing the cross-entropy loss, <em>i.e.</em>, $\max \log(D(\mathbf{x'}))$.</li>
<li>The discriminator tries to distinguish the generated images from the true images, via minimizing the cross-entropy loss, <em>i.e.</em>, $\min - y \log D(\mathbf{x}) - (1-y)\log(1-D(\mathbf{x}))$.</li>
</ul>
<h2 id="exercises-132"><a class="header" href="#exercises-132">Exercises</a></h2>
<ul>
<li>Does an equilibrium exist where the generator wins, <em>i.e.</em> the discriminator ends up unable to distinguish the two distributions on finite samples?</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/408">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1082">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deep-convolutional-generative-adversarial-networks"><a class="header" href="#deep-convolutional-generative-adversarial-networks">Deep Convolutional Generative Adversarial Networks</a></h1>
<p>:label:<code>sec_dcgan</code></p>
<p>In :numref:<code>sec_basic_gan</code>, we introduced the basic ideas behind how GANs work. We showed that they can draw samples from some simple, easy-to-sample distribution, like a uniform or normal distribution, and transform them into samples that appear to match the distribution of some dataset. And while our example of matching a 2D Gaussian distribution got the point across, it is not especially exciting.</p>
<p>In this section, we will demonstrate how you can use GANs to generate photorealistic images. We will be basing our models on the deep convolutional GANs (DCGAN) introduced in :citet:<code>Radford.Metz.Chintala.2015</code>. We will borrow the convolutional architecture that have proven so successful for discriminative computer vision problems and show how via GANs, they can be leveraged to generate photorealistic images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from mxnet import gluon, init, np, npx
from mxnet.gluon import nn
from d2l import mxnet as d2l

npx.set_np()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch
import torchvision
from torch import nn
import warnings
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<h2 id="the-pokemon-dataset"><a class="header" href="#the-pokemon-dataset">The Pokemon Dataset</a></h2>
<p>The dataset we will use is a collection of Pokemon sprites obtained from <a href="https://pokemondb.net/sprites">pokemondb</a>. First download, extract and load this dataset.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
#@save
d2l.DATA_HUB['pokemon'] = (d2l.DATA_URL + 'pokemon.zip',
                           'c065c0e2593b8b161a2d7873e42418bf6a21106c')

data_dir = d2l.download_extract('pokemon')
pokemon = gluon.data.vision.datasets.ImageFolderDataset(data_dir)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
#@save
d2l.DATA_HUB['pokemon'] = (d2l.DATA_URL + 'pokemon.zip',
                           'c065c0e2593b8b161a2d7873e42418bf6a21106c')

data_dir = d2l.download_extract('pokemon')
pokemon = torchvision.datasets.ImageFolder(data_dir)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
#@save
d2l.DATA_HUB['pokemon'] = (d2l.DATA_URL + 'pokemon.zip',
                           'c065c0e2593b8b161a2d7873e42418bf6a21106c')

data_dir = d2l.download_extract('pokemon')
batch_size = 256
pokemon = tf.keras.preprocessing.image_dataset_from_directory(
    data_dir, batch_size=batch_size, image_size=(64, 64))
</code></pre>
<p>We resize each image into $64\times 64$. The <code>ToTensor</code> transformation will project the pixel value into $[0, 1]$, while our generator will use the tanh function to obtain outputs in $[-1, 1]$. Therefore we normalize the data with $0.5$ mean and $0.5$ standard deviation to match the value range.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
batch_size = 256
transformer = gluon.data.vision.transforms.Compose([
    gluon.data.vision.transforms.Resize(64),
    gluon.data.vision.transforms.ToTensor(),
    gluon.data.vision.transforms.Normalize(0.5, 0.5)
])
data_iter = gluon.data.DataLoader(
    pokemon.transform_first(transformer), batch_size=batch_size,
    shuffle=True, num_workers=d2l.get_dataloader_workers())
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
batch_size = 256
transformer = torchvision.transforms.Compose([
    torchvision.transforms.Resize((64, 64)),
    torchvision.transforms.ToTensor(),
    torchvision.transforms.Normalize(0.5, 0.5)
])
pokemon.transform = transformer
data_iter = torch.utils.data.DataLoader(
    pokemon, batch_size=batch_size,
    shuffle=True, num_workers=d2l.get_dataloader_workers())
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def transform_func(X):
    X = X / 255.
    X = (X - 0.5) / (0.5)
    return X

# For TF&gt;=2.4 use `num_parallel_calls = tf.data.AUTOTUNE`
data_iter = pokemon.map(lambda x, y: (transform_func(x), y),
                        num_parallel_calls=tf.data.experimental.AUTOTUNE)
data_iter = data_iter.cache().shuffle(buffer_size=1000).prefetch(
    buffer_size=tf.data.experimental.AUTOTUNE)
</code></pre>
<p>Let's visualize the first 20 images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
d2l.set_figsize((4, 4))
for X, y in data_iter:
    imgs = X[:20,:,:,:].transpose(0, 2, 3, 1)/2+0.5
    d2l.show_images(imgs, num_rows=4, num_cols=5)
    break
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
warnings.filterwarnings('ignore')
d2l.set_figsize((4, 4))
for X, y in data_iter:
    imgs = X[:20,:,:,:].permute(0, 2, 3, 1)/2+0.5
    d2l.show_images(imgs, num_rows=4, num_cols=5)
    break
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
d2l.set_figsize(figsize=(4, 4))
for X, y in data_iter.take(1):
    imgs = X[:20, :, :, :] / 2 + 0.5
    d2l.show_images(imgs, num_rows=4, num_cols=5)
</code></pre>
<h2 id="the-generator"><a class="header" href="#the-generator">The Generator</a></h2>
<p>The generator needs to map the noise variable $\mathbf z\in\mathbb R^d$, a length-$d$ vector, to a RGB image with width and height to be $64\times 64$ . In :numref:<code>sec_fcn</code> we introduced the fully convolutional network that uses transposed convolution layer (refer to :numref:<code>sec_transposed_conv</code>) to enlarge input size. The basic block of the generator contains a transposed convolution layer followed by the batch normalization and ReLU activation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class G_block(nn.Block):
    def __init__(self, channels, kernel_size=4,
                 strides=2, padding=1, **kwargs):
        super(G_block, self).__init__(**kwargs)
        self.conv2d_trans = nn.Conv2DTranspose(
            channels, kernel_size, strides, padding, use_bias=False)
        self.batch_norm = nn.BatchNorm()
        self.activation = nn.Activation('relu')

    def forward(self, X):
        return self.activation(self.batch_norm(self.conv2d_trans(X)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class G_block(nn.Module):
    def __init__(self, out_channels, in_channels=3, kernel_size=4, strides=2,
                 padding=1, **kwargs):
        super(G_block, self).__init__(**kwargs)
        self.conv2d_trans = nn.ConvTranspose2d(in_channels, out_channels,
                                kernel_size, strides, padding, bias=False)
        self.batch_norm = nn.BatchNorm2d(out_channels)
        self.activation = nn.ReLU()

    def forward(self, X):
        return self.activation(self.batch_norm(self.conv2d_trans(X)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
class G_block(tf.keras.layers.Layer):
    def __init__(self, out_channels, kernel_size=4, strides=2, padding="same",
                 **kwargs):
        super().__init__(**kwargs)
        self.conv2d_trans = tf.keras.layers.Conv2DTranspose(
            out_channels, kernel_size, strides, padding, use_bias=False)
        self.batch_norm = tf.keras.layers.BatchNormalization()
        self.activation = tf.keras.layers.ReLU()

    def call(self, X):
        return self.activation(self.batch_norm(self.conv2d_trans(X)))
</code></pre>
<p>In default, the transposed convolution layer uses a $k_h = k_w = 4$ kernel, a $s_h = s_w = 2$ strides, and a $p_h = p_w = 1$ padding. With a input shape of $n_h^{'} \times n_w^{'} = 16 \times 16$, the generator block will double input's width and height.</p>
<p>$$
\begin{aligned}
n_h^{'} \times n_w^{'} &amp;= [(n_h k_h - (n_h-1)(k_h-s_h)- 2p_h] \times [(n_w k_w - (n_w-1)(k_w-s_w)- 2p_w]\
&amp;= [(k_h + s_h (n_h-1)- 2p_h] \times [(k_w + s_w (n_w-1)- 2p_w]\
&amp;= [(4 + 2 \times (16-1)- 2 \times 1] \times [(4 + 2 \times (16-1)- 2 \times 1]\
&amp;= 32 \times 32 .\
\end{aligned}
$$</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.zeros((2, 3, 16, 16))
g_blk = G_block(20)
g_blk.initialize()
g_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.zeros((2, 3, 16, 16))
g_blk = G_block(20)
g_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.zeros((2, 16, 16, 3))  # Channel last convention
g_blk = G_block(20)
g_blk(x).shape
</code></pre>
<p>If changing the transposed convolution layer to a $4\times 4$ kernel, $1\times 1$ strides and zero padding. With a input size of $1 \times 1$, the output will have its width and height increased by 3 respectively.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.zeros((2, 3, 1, 1))
g_blk = G_block(20, strides=1, padding=0)
g_blk.initialize()
g_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.zeros((2, 3, 1, 1))
g_blk = G_block(20, strides=1, padding=0)
g_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.zeros((2, 1, 1, 3))
# `padding="valid"` corresponds to no padding
g_blk = G_block(20, strides=1, padding="valid")
g_blk(x).shape
</code></pre>
<p>The generator consists of four basic blocks that increase input's both width and height from 1 to 32. At the same time, it first projects the latent variable into $64\times 8$ channels, and then halve the channels each time. At last, a transposed convolution layer is used to generate the output. It further doubles the width and height to match the desired $64\times 64$ shape, and reduces the channel size to $3$. The tanh activation function is applied to project output values into the $(-1, 1)$ range.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
n_G = 64
net_G = nn.Sequential()
net_G.add(G_block(n_G*8, strides=1, padding=0),  # Output: (64 * 8, 4, 4)
          G_block(n_G*4),  # Output: (64 * 4, 8, 8)
          G_block(n_G*2),  # Output: (64 * 2, 16, 16)
          G_block(n_G),    # Output: (64, 32, 32)
          nn.Conv2DTranspose(
              3, kernel_size=4, strides=2, padding=1, use_bias=False,
              activation='tanh'))  # Output: (3, 64, 64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
n_G = 64
net_G = nn.Sequential(
    G_block(in_channels=100, out_channels=n_G*8,
            strides=1, padding=0),                  # Output: (64 * 8, 4, 4)
    G_block(in_channels=n_G*8, out_channels=n_G*4), # Output: (64 * 4, 8, 8)
    G_block(in_channels=n_G*4, out_channels=n_G*2), # Output: (64 * 2, 16, 16)
    G_block(in_channels=n_G*2, out_channels=n_G),   # Output: (64, 32, 32)
    nn.ConvTranspose2d(in_channels=n_G, out_channels=3,
                       kernel_size=4, stride=2, padding=1, bias=False),
    nn.Tanh())  # Output: (3, 64, 64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
n_G = 64
net_G = tf.keras.Sequential([
    # Output: (4, 4, 64 * 8)
    G_block(out_channels=n_G*8, strides=1, padding="valid"),
    G_block(out_channels=n_G*4), # Output: (8, 8, 64 * 4)
    G_block(out_channels=n_G*2), # Output: (16, 16, 64 * 2)
    G_block(out_channels=n_G), # Output: (32, 32, 64)
    # Output: (64, 64, 3)
    tf.keras.layers.Conv2DTranspose(
        3, kernel_size=4, strides=2, padding="same", use_bias=False,
        activation="tanh")
])
</code></pre>
<p>Generate a 100 dimensional latent variable to verify the generator's output shape.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.zeros((1, 100, 1, 1))
net_G.initialize()
net_G(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.zeros((1, 100, 1, 1))
net_G(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.zeros((1, 1, 1, 100))
net_G(x).shape
</code></pre>
<h2 id="discriminator-1"><a class="header" href="#discriminator-1">Discriminator</a></h2>
<p>The discriminator is a normal convolutional network network except that it uses a leaky ReLU as its activation function. Given $\alpha \in[0, 1]$, its definition is</p>
<p>$$\textrm{leaky ReLU}(x) = \begin{cases}x &amp; \textrm{if}\ x &gt; 0\ \alpha x &amp;\textrm{otherwise}\end{cases}.$$</p>
<p>As it can be seen, it is normal ReLU if $\alpha=0$, and an identity function if $\alpha=1$. For $\alpha \in (0, 1)$, leaky ReLU is a nonlinear function that give a non-zero output for a negative input. It aims to fix the "dying ReLU" problem that a neuron might always output a negative value and therefore cannot make any progress since the gradient of ReLU is 0.</p>
<pre><code class="language-{.python .input}">#@tab mxnet,pytorch
alphas = [0, .2, .4, .6, .8, 1]
x = d2l.arange(-2, 1, 0.1)
Y = [d2l.numpy(nn.LeakyReLU(alpha)(x)) for alpha in alphas]
d2l.plot(d2l.numpy(x), Y, 'x', 'y', alphas)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
alphas = [0, .2, .4, .6, .8, 1]
x = tf.range(-2, 1, 0.1)
Y = [tf.keras.layers.LeakyReLU(alpha)(x).numpy() for alpha in alphas]
d2l.plot(x.numpy(), Y, 'x', 'y', alphas)
</code></pre>
<p>The basic block of the discriminator is a convolution layer followed by a batch normalization layer and a leaky ReLU activation. The hyperparameters of the convolution layer are similar to the transpose convolution layer in the generator block.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
class D_block(nn.Block):
    def __init__(self, channels, kernel_size=4, strides=2,
                 padding=1, alpha=0.2, **kwargs):
        super(D_block, self).__init__(**kwargs)
        self.conv2d = nn.Conv2D(
            channels, kernel_size, strides, padding, use_bias=False)
        self.batch_norm = nn.BatchNorm()
        self.activation = nn.LeakyReLU(alpha)

    def forward(self, X):
        return self.activation(self.batch_norm(self.conv2d(X)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
class D_block(nn.Module):
    def __init__(self, out_channels, in_channels=3, kernel_size=4, strides=2,
                padding=1, alpha=0.2, **kwargs):
        super(D_block, self).__init__(**kwargs)
        self.conv2d = nn.Conv2d(in_channels, out_channels, kernel_size,
                                strides, padding, bias=False)
        self.batch_norm = nn.BatchNorm2d(out_channels)
        self.activation = nn.LeakyReLU(alpha, inplace=True)

    def forward(self, X):
        return self.activation(self.batch_norm(self.conv2d(X)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
class D_block(tf.keras.layers.Layer):
    def __init__(self, out_channels, kernel_size=4, strides=2, padding="same",
                 alpha=0.2, **kwargs):
        super().__init__(**kwargs)
        self.conv2d = tf.keras.layers.Conv2D(out_channels, kernel_size,
                                             strides, padding, use_bias=False)
        self.batch_norm = tf.keras.layers.BatchNormalization()
        self.activation = tf.keras.layers.LeakyReLU(alpha)

    def call(self, X):
        return self.activation(self.batch_norm(self.conv2d(X)))
</code></pre>
<p>A basic block with default settings will halve the width and height of the inputs, as we demonstrated in :numref:<code>sec_padding</code>. For example, given a input shape $n_h = n_w = 16$, with a kernel shape $k_h = k_w = 4$, a stride shape $s_h = s_w = 2$, and a padding shape $p_h = p_w = 1$, the output shape will be:</p>
<p>$$
\begin{aligned}
n_h^{'} \times n_w^{'} &amp;= \lfloor(n_h-k_h+2p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+2p_w+s_w)/s_w\rfloor\
&amp;= \lfloor(16-4+2\times 1+2)/2\rfloor \times \lfloor(16-4+2\times 1+2)/2\rfloor\
&amp;= 8 \times 8 .\
\end{aligned}
$$</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.zeros((2, 3, 16, 16))
d_blk = D_block(20)
d_blk.initialize()
d_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.zeros((2, 3, 16, 16))
d_blk = D_block(20)
d_blk(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.zeros((2, 16, 16, 3))
d_blk = D_block(20)
d_blk(x).shape
</code></pre>
<p>The discriminator is a mirror of the generator.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
n_D = 64
net_D = nn.Sequential()
net_D.add(D_block(n_D),   # Output: (64, 32, 32)
          D_block(n_D*2),  # Output: (64 * 2, 16, 16)
          D_block(n_D*4),  # Output: (64 * 4, 8, 8)
          D_block(n_D*8),  # Output: (64 * 8, 4, 4)
          nn.Conv2D(1, kernel_size=4, use_bias=False))  # Output: (1, 1, 1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
n_D = 64
net_D = nn.Sequential(
    D_block(n_D),  # Output: (64, 32, 32)
    D_block(in_channels=n_D, out_channels=n_D*2),  # Output: (64 * 2, 16, 16)
    D_block(in_channels=n_D*2, out_channels=n_D*4),  # Output: (64 * 4, 8, 8)
    D_block(in_channels=n_D*4, out_channels=n_D*8),  # Output: (64 * 8, 4, 4)
    nn.Conv2d(in_channels=n_D*8, out_channels=1,
              kernel_size=4, bias=False))  # Output: (1, 1, 1)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
n_D = 64
net_D = tf.keras.Sequential([
    D_block(n_D), # Output: (32, 32, 64)
    D_block(out_channels=n_D*2), # Output: (16, 16, 64 * 2)
    D_block(out_channels=n_D*4), # Output: (8, 8, 64 * 4)
    D_block(out_channels=n_D*8), # Outupt: (4, 4, 64 * 64)
    # Output: (1, 1, 1)
    tf.keras.layers.Conv2D(1, kernel_size=4, use_bias=False)
])
</code></pre>
<p>It uses a convolution layer with output channel $1$ as the last layer to obtain a single prediction value.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.zeros((1, 3, 64, 64))
net_D.initialize()
net_D(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.zeros((1, 3, 64, 64))
net_D(x).shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.zeros((1, 64, 64, 3))
net_D(x).shape
</code></pre>
<h2 id="training-32"><a class="header" href="#training-32">Training</a></h2>
<p>Compared to the basic GAN in :numref:<code>sec_basic_gan</code>, we use the same learning rate for both generator and discriminator since they are similar to each other. In addition, we change $\beta_1$ in Adam (:numref:<code>sec_adam</code>) from $0.9$ to $0.5$. It decreases the smoothness of the momentum, the exponentially weighted moving average of past gradients, to take care of the rapid changing gradients because the generator and the discriminator fight with each other. Besides, the random generated noise <code>Z</code>, is a 4-D tensor and we are using GPU to accelerate the computation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def train(net_D, net_G, data_iter, num_epochs, lr, latent_dim,
          device=d2l.try_gpu()):
    loss = gluon.loss.SigmoidBCELoss()
    net_D.initialize(init=init.Normal(0.02), force_reinit=True, ctx=device)
    net_G.initialize(init=init.Normal(0.02), force_reinit=True, ctx=device)
    trainer_hp = {'learning_rate': lr, 'beta1': 0.5}
    trainer_D = gluon.Trainer(net_D.collect_params(), 'adam', trainer_hp)
    trainer_G = gluon.Trainer(net_G.collect_params(), 'adam', trainer_hp)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs], nrows=2, figsize=(5, 5),
                            legend=['discriminator', 'generator'])
    animator.fig.subplots_adjust(hspace=0.3)
    for epoch in range(1, num_epochs + 1):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3)  # loss_D, loss_G, num_examples
        for X, _ in data_iter:
            batch_size = X.shape[0]
            Z = np.random.normal(0, 1, size=(batch_size, latent_dim, 1, 1))
            X, Z = X.as_in_ctx(device), Z.as_in_ctx(device),
            metric.add(d2l.update_D(X, Z, net_D, net_G, loss, trainer_D),
                       d2l.update_G(Z, net_D, net_G, loss, trainer_G),
                       batch_size)
        # Show generated examples
        Z = np.random.normal(0, 1, size=(21, latent_dim, 1, 1), ctx=device)
        # Normalize the synthetic data to N(0, 1)
        fake_x = net_G(Z).transpose(0, 2, 3, 1) / 2 + 0.5
        imgs = np.concatenate(
            [np.concatenate([fake_x[i * 7 + j] for j in range(7)], axis=1)
             for i in range(len(fake_x)//7)], axis=0)
        animator.axes[1].cla()
        animator.axes[1].imshow(imgs.asnumpy())
        # Show the losses
        loss_D, loss_G = metric[0] / metric[2], metric[1] / metric[2]
        animator.add(epoch, (loss_D, loss_G))
    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec on {str(device)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def train(net_D, net_G, data_iter, num_epochs, lr, latent_dim,
          device=d2l.try_gpu()):
    loss = nn.BCEWithLogitsLoss(reduction='sum')
    for w in net_D.parameters():
        nn.init.normal_(w, 0, 0.02)
    for w in net_G.parameters():
        nn.init.normal_(w, 0, 0.02)
    net_D, net_G = net_D.to(device), net_G.to(device)
    trainer_hp = {'lr': lr, 'betas': [0.5,0.999]}
    trainer_D = torch.optim.Adam(net_D.parameters(), **trainer_hp)
    trainer_G = torch.optim.Adam(net_G.parameters(), **trainer_hp)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs], nrows=2, figsize=(5, 5),
                            legend=['discriminator', 'generator'])
    animator.fig.subplots_adjust(hspace=0.3)
    for epoch in range(1, num_epochs + 1):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3)  # loss_D, loss_G, num_examples
        for X, _ in data_iter:
            batch_size = X.shape[0]
            Z = torch.normal(0, 1, size=(batch_size, latent_dim, 1, 1))
            X, Z = X.to(device), Z.to(device)
            metric.add(d2l.update_D(X, Z, net_D, net_G, loss, trainer_D),
                       d2l.update_G(Z, net_D, net_G, loss, trainer_G),
                       batch_size)
        # Show generated examples
        Z = torch.normal(0, 1, size=(21, latent_dim, 1, 1), device=device)
        # Normalize the synthetic data to N(0, 1)
        fake_x = net_G(Z).permute(0, 2, 3, 1) / 2 + 0.5
        imgs = torch.cat(
            [torch.cat([
                fake_x[i * 7 + j].cpu().detach() for j in range(7)], dim=1)
             for i in range(len(fake_x)//7)], dim=0)
        animator.axes[1].cla()
        animator.axes[1].imshow(imgs)
        # Show the losses
        loss_D, loss_G = metric[0] / metric[2], metric[1] / metric[2]
        animator.add(epoch, (loss_D, loss_G))
    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec on {str(device)}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def train(net_D, net_G, data_iter, num_epochs, lr, latent_dim,
          device=d2l.try_gpu()):
    loss = tf.keras.losses.BinaryCrossentropy(
        from_logits=True, reduction=tf.keras.losses.Reduction.SUM)

    for w in net_D.trainable_variables:
        w.assign(tf.random.normal(mean=0, stddev=0.02, shape=w.shape))
    for w in net_G.trainable_variables:
        w.assign(tf.random.normal(mean=0, stddev=0.02, shape=w.shape))

    optimizer_hp = {"lr": lr, "beta_1": 0.5, "beta_2": 0.999}
    optimizer_D = tf.keras.optimizers.Adam(**optimizer_hp)
    optimizer_G = tf.keras.optimizers.Adam(**optimizer_hp)

    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[1, num_epochs], nrows=2, figsize=(5, 5),
                            legend=['discriminator', 'generator'])
    animator.fig.subplots_adjust(hspace=0.3)

    for epoch in range(1, num_epochs + 1):
        # Train one epoch
        timer = d2l.Timer()
        metric = d2l.Accumulator(3) # loss_D, loss_G, num_examples
        for X, _ in data_iter:
            batch_size = X.shape[0]
            Z = tf.random.normal(mean=0, stddev=1,
                                 shape=(batch_size, 1, 1, latent_dim))
            metric.add(d2l.update_D(X, Z, net_D, net_G, loss, optimizer_D),
                       d2l.update_G(Z, net_D, net_G, loss, optimizer_G),
                       batch_size)

        # Show generated examples
        Z = tf.random.normal(mean=0, stddev=1, shape=(21, 1, 1, latent_dim))
        # Normalize the synthetic data to N(0, 1)
        fake_x = net_G(Z) / 2 + 0.5
        imgs = tf.concat([tf.concat([fake_x[i * 7 + j] for j in range(7)],
                                    axis=1)
                          for i in range(len(fake_x) // 7)], axis=0)
        animator.axes[1].cla()
        animator.axes[1].imshow(imgs)
        # Show the losses
        loss_D, loss_G = metric[0] / metric[2], metric[1] / metric[2]
        animator.add(epoch, (loss_D, loss_G))
    print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, '
          f'{metric[2] / timer.stop():.1f} examples/sec on {str(device._device_name)}')
</code></pre>
<p>We train the model with a small number of epochs just for demonstration.
For better performance,
the variable <code>num_epochs</code> can be set to a larger number.</p>
<pre><code class="language-{.python .input}">#@tab mxnet, pytorch
latent_dim, lr, num_epochs = 100, 0.005, 20
train(net_D, net_G, data_iter, num_epochs, lr, latent_dim)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
latent_dim, lr, num_epochs = 100, 0.0005, 40
train(net_D, net_G, data_iter, num_epochs, lr, latent_dim)
</code></pre>
<h2 id="summary-115"><a class="header" href="#summary-115">Summary</a></h2>
<ul>
<li>DCGAN architecture has four convolutional layers for the Discriminator and four "fractionally-strided" convolutional layers for the Generator.</li>
<li>The Discriminator is a 4-layer strided convolutions with batch normalization (except its input layer) and leaky ReLU activations.</li>
<li>Leaky ReLU is a nonlinear function that give a non-zero output for a negative input. It aims to fix the “dying ReLU” problem and helps the gradients flow easier through the architecture.</li>
</ul>
<h2 id="exercises-133"><a class="header" href="#exercises-133">Exercises</a></h2>
<ol>
<li>What will happen if we use standard ReLU activation rather than leaky ReLU?</li>
<li>Apply DCGAN on Fashion-MNIST and see which category works well and which does not.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/409">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1083">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommender-systems-1"><a class="header" href="#recommender-systems-1">Recommender Systems</a></h1>
<p>:label:<code>chap_recsys</code></p>
<p><strong>Shuai Zhang</strong> (<em>Amazon</em>), <strong>Aston Zhang</strong> (<em>Amazon</em>), and <strong>Yi Tay</strong> (<em>Google</em>)</p>
<p>Recommender systems are widely employed in industry and are ubiquitous in our daily lives. These systems are utilized in a number of areas such as online shopping sites (e.g., amazon.com), music/movie services site (e.g., Netflix and Spotify), mobile application stores (e.g., IOS app store and google play), online advertising, just to name a few.</p>
<p>The major goal of recommender systems is to help users discover relevant items such as movies to watch, text to read or products to buy, so as to create a delightful user experience. Moreover, recommender systems are among the most powerful machine learning systems that online retailers implement in order to drive incremental revenue. Recommender systems are replacements of search engines by reducing the efforts in proactive searches and surprising users with offers they never searched for. Many companies managed to position themselves ahead of their competitors with the help of more effective recommender systems. As such, recommender systems are central to not only our everyday lives but also highly indispensable in some industries.</p>
<p>In this chapter, we will cover the fundamentals and advancements of recommender systems, along with exploring some common fundamental techniques for building recommender systems with different data sources available and their implementations. Specifically, you will learn how to predict the rating a user might give to a prospective item, how to generate a recommendation list of items and how to predict the click-through rate from abundant features. These tasks are commonplace in real-world applications. By studying this chapter, you will get hands-on experience pertaining to solving real world recommendation problems with not only classical methods but the more advanced deep learning based models as well.</p>
<pre><code class="language-toc">:maxdepth: 2

recsys-intro
movielens
mf
autorec
ranking
neumf
seqrec
ctr
fm
deepfm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-recommender-systems"><a class="header" href="#overview-of-recommender-systems">Overview of Recommender Systems</a></h1>
<p>In the last decade, the Internet has evolved into a platform for large-scale online services, which profoundly changed the way we communicate, read news, buy products, and watch movies.  In the meanwhile, the unprecedented number of items (we use the term <em>item</em> to refer to movies, news, books, and products.) offered online requires a system that can help us discover items that we preferred. Recommender systems are therefore powerful information filtering tools that can facilitate personalized services and provide tailored experience to individual users. In short, recommender systems play a pivotal role in utilizing the wealth of data available to make choices manageable. Nowadays, recommender systems are at the core of a number of online services providers such as Amazon, Netflix, and YouTube. Recall the example of Deep learning books recommended by Amazon in :numref:<code>subsec_recommender_systems</code>. The benefits of employing recommender systems are two-folds: On the one hand, it can largely reduce users' effort in finding items and alleviate the issue of information overload. On the other hand, it can add business value to  online
service providers and is an important source of revenue.  This chapter will introduce the fundamental concepts, classic models and recent advances with deep learning in the field of recommender systems, together with implemented examples.</p>
<p><img src="chapter_recommender-systems/../img/rec-intro.svg" alt="Illustration of the Recommendation Process" /></p>
<h2 id="collaborative-filtering"><a class="header" href="#collaborative-filtering">Collaborative Filtering</a></h2>
<p>We start the journey with the important concept in recommender systems---collaborative filtering
(CF), which was first coined by the Tapestry system :cite:<code>Goldberg.Nichols.Oki.ea.1992</code>, referring to "people collaborate to help one another perform the filtering process  in order to handle the large amounts of email and messages posted to newsgroups". This term has been enriched with more senses. In a broad sense, it is the process of
filtering for information or patterns using techniques involving collaboration among multiple users, agents, and data sources. CF has many forms and numerous CF methods proposed since its advent.</p>
<p>Overall, CF techniques can be categorized into: memory-based CF, model-based CF, and their hybrid :cite:<code>Su.Khoshgoftaar.2009</code>. Representative memory-based CF techniques are nearest neighbor-based CF such as user-based CF and item-based CF :cite:<code>Sarwar.Karypis.Konstan.ea.2001</code>.  Latent factor models such as matrix factorization are examples of model-based CF.  Memory-based CF has limitations in dealing with sparse and large-scale data since it computes the similarity values based on common items.  Model-based methods become more popular with its
better capability in dealing with sparsity and scalability.  Many model-based CF approaches can be extended with neural networks, leading to more flexible and scalable models with the computation acceleration in deep learning :cite:<code>Zhang.Yao.Sun.ea.2019</code>.  In general, CF only uses the user-item interaction data to make predictions and recommendations. Besides CF, content-based and context-based recommender systems are also useful in incorporating the content descriptions of items/users and contextual signals such as timestamps and locations.  Obviously, we may need to adjust the model types/structures when different input data is available.</p>
<h2 id="explicit-feedback-and-implicit-feedback"><a class="header" href="#explicit-feedback-and-implicit-feedback">Explicit Feedback and Implicit Feedback</a></h2>
<p>To learn the preference of users, the system shall collect feedback from them.  The feedback can be either explicit or implicit :cite:<code>Hu.Koren.Volinsky.2008</code>. For example, <a href="https://www.imdb.com/">IMDb</a> collects star ratings ranging from one to ten stars for movies. YouTube provides the thumbs-up and thumbs-down buttons for users to show their preferences.  It is apparent that gathering explicit feedback requires users to indicate their interests proactively.  Nonetheless, explicit feedback is not always readily available as many users may be reluctant to rate products. Relatively speaking, implicit feedback is often readily available since it is mainly concerned with modeling implicit behavior such as user clicks. As such, many recommender systems are centered on implicit feedback which indirectly reflects user's opinion through observing user behavior.  There are diverse forms of implicit feedback including purchase history, browsing history, watches and even mouse movements. For example, a user that purchased many books by the same author probably likes that author.   Note that implicit feedback is inherently noisy.  We can only <em>guess</em> their preferences and true motives. A user watched a movie does not necessarily indicate a positive view of that movie.</p>
<h2 id="recommendation-tasks"><a class="header" href="#recommendation-tasks">Recommendation Tasks</a></h2>
<p>A number of recommendation tasks have been investigated in the past decades.  Based on the domain of applications, there are movies recommendation, news recommendations, point-of-interest recommendation :cite:<code>Ye.Yin.Lee.ea.2011</code> and so forth.  It is also possible to differentiate the tasks based on the types of feedback and input data, for example, the rating prediction task aims to predict the explicit ratings. Top-$n$ recommendation (item ranking) ranks all items for each user personally based on the implicit feedback. If time-stamp information is also included, we can build sequence-aware recommendation :cite:<code>Quadrana.Cremonesi.Jannach.2018</code>.  Another popular task is called click-through rate prediction, which is also based on implicit feedback, but various categorical features can be utilized. Recommending for new users and recommending new items to existing users are called cold-start recommendation :cite:<code>Schein.Popescul.Ungar.ea.2002</code>.</p>
<h2 id="summary-116"><a class="header" href="#summary-116">Summary</a></h2>
<ul>
<li>Recommender systems are important for individual users and industries. Collaborative filtering is a key concept in recommendation.</li>
<li>There are two types of feedbacks: implicit feedback and explicit feedback.  A number of recommendation tasks have been explored during the last decade.</li>
</ul>
<h2 id="exercises-134"><a class="header" href="#exercises-134">Exercises</a></h2>
<ol>
<li>Can you explain how recommender systems influence your daily life?</li>
<li>What interesting recommendation tasks do you think can be investigated?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/398">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-movielens-dataset"><a class="header" href="#the-movielens-dataset">The MovieLens Dataset</a></h1>
<p>There are a number of datasets that are available for recommendation research. Amongst them, the <a href="https://movielens.org/">MovieLens</a> dataset is probably one of the more popular ones. MovieLens is a non-commercial web-based movie recommender system. It is created in 1997 and run by GroupLens, a research lab at the University of Minnesota, in order to gather movie rating data for research purposes.  MovieLens data has been critical for several research studies including personalized recommendation and social psychology.</p>
<h2 id="getting-the-data"><a class="header" href="#getting-the-data">Getting the Data</a></h2>
<p>The MovieLens dataset is hosted by the <a href="https://grouplens.org/datasets/movielens/">GroupLens</a> website. Several versions are available. We will use the MovieLens 100K dataset :cite:<code>Herlocker.Konstan.Borchers.ea.1999</code>.  This dataset is comprised of $100,000$ ratings, ranging from 1 to 5 stars, from 943 users on 1682 movies. It has been cleaned up so that each user has rated at least 20 movies. Some simple demographic information such as age, gender, genres for the users and items are also available.  We can download the <a href="http://files.grouplens.org/datasets/movielens/ml-100k.zip">ml-100k.zip</a> and extract the <code>u.data</code> file, which contains all the $100,000$ ratings in the csv format. There are many other files in the folder, a detailed description for each file can be found in the <a href="http://files.grouplens.org/datasets/movielens/ml-100k-README.txt">README</a> file of the dataset.</p>
<p>To begin with, let's import the packages required to run this section's experiments.</p>
<pre><code class="language-{.python .input  n=1}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, np
import os
import pandas as pd
</code></pre>
<p>Then, we download the MovieLens 100k dataset and load the interactions as <code>DataFrame</code>.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
#@save
d2l.DATA_HUB['ml-100k'] = (
    'https://files.grouplens.org/datasets/movielens/ml-100k.zip',
    'cd4dcac4241c8a4ad7badc7ca635da8a69dddb83')

#@save
def read_data_ml100k():
    data_dir = d2l.download_extract('ml-100k')
    names = ['user_id', 'item_id', 'rating', 'timestamp']
    data = pd.read_csv(os.path.join(data_dir, 'u.data'), sep='\t',
                       names=names, engine='python')
    num_users = data.user_id.unique().shape[0]
    num_items = data.item_id.unique().shape[0]
    return data, num_users, num_items
</code></pre>
<h2 id="statistics-of-the-dataset"><a class="header" href="#statistics-of-the-dataset">Statistics of the Dataset</a></h2>
<p>Let's load up the data and inspect the first five records manually. It is an effective way to learn the data structure and verify that they have been loaded properly.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
data, num_users, num_items = read_data_ml100k()
sparsity = 1 - len(data) / (num_users * num_items)
print(f'number of users: {num_users}, number of items: {num_items}')
print(f'matrix sparsity: {sparsity:f}')
print(data.head(5))
</code></pre>
<p>We can see that each line consists of four columns, including "user id" 1-943, "item id" 1-1682, "rating" 1-5 and "timestamp". We can construct an interaction matrix of size $n \times m$, where $n$ and $m$ are the number of users and the number of items respectively. This dataset only records the existing ratings, so we can also call it rating matrix and we will use interaction matrix and rating matrix interchangeably in case that the values of this matrix represent exact ratings. Most of the values in the rating matrix are unknown as users have not rated the majority of movies. We also show the sparsity of this dataset. The sparsity is defined as <code>1 - number of nonzero entries / ( number of users * number of items)</code>. Clearly, the interaction matrix is extremely sparse (i.e., sparsity = 93.695%). Real world datasets may suffer from a greater extent of sparsity and has been a long-standing challenge in building recommender systems. A viable solution is to use additional side information such as user/item features to alleviate the sparsity.</p>
<p>We then plot the distribution of the count of different ratings. As expected, it appears to be a normal distribution, with most ratings centered at 3-4.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
d2l.plt.hist(data['rating'], bins=5, ec='black')
d2l.plt.xlabel('Rating')
d2l.plt.ylabel('Count')
d2l.plt.title('Distribution of Ratings in MovieLens 100K')
d2l.plt.show()
</code></pre>
<h2 id="splitting-the-dataset"><a class="header" href="#splitting-the-dataset">Splitting the dataset</a></h2>
<p>We split the dataset into training and test sets. The following function provides two split modes including <code>random</code> and <code>seq-aware</code>. In the <code>random</code> mode, the function splits the 100k interactions randomly without considering timestamp and uses the 90% of the data as training samples and the rest 10% as test samples by default. In the <code>seq-aware</code> mode, we leave out the item that a user rated most recently for test, and users' historical interactions as training set.  User historical interactions are sorted from oldest to newest based on timestamp. This mode will be used in the sequence-aware recommendation section.</p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
#@save
def split_data_ml100k(data, num_users, num_items,
                      split_mode='random', test_ratio=0.1):
    """Split the dataset in random mode or seq-aware mode."""
    if split_mode == 'seq-aware':
        train_items, test_items, train_list = {}, {}, []
        for line in data.itertuples():
            u, i, rating, time = line[1], line[2], line[3], line[4]
            train_items.setdefault(u, []).append((u, i, rating, time))
            if u not in test_items or test_items[u][-1] &lt; time:
                test_items[u] = (i, rating, time)
        for u in range(1, num_users + 1):
            train_list.extend(sorted(train_items[u], key=lambda k: k[3]))
        test_data = [(key, *value) for key, value in test_items.items()]
        train_data = [item for item in train_list if item not in test_data]
        train_data = pd.DataFrame(train_data)
        test_data = pd.DataFrame(test_data)
    else:
        mask = [True if x == 1 else False for x in np.random.uniform(
            0, 1, (len(data))) &lt; 1 - test_ratio]
        neg_mask = [not x for x in mask]
        train_data, test_data = data[mask], data[neg_mask]
    return train_data, test_data
</code></pre>
<p>Note that it is good practice to use a validation set in practice, apart from only a test set. However, we omit that for the sake of brevity. In this case, our test set can be regarded as our held-out validation set.</p>
<h2 id="loading-the-data"><a class="header" href="#loading-the-data">Loading the data</a></h2>
<p>After dataset splitting, we will convert the training set and test set into lists and dictionaries/matrix for the sake of convenience. The following function reads the dataframe line by line and enumerates the index of users/items start from zero. The function then returns lists of users, items, ratings and a dictionary/matrix that records the interactions. We can specify the type of feedback to either <code>explicit</code> or <code>implicit</code>.</p>
<pre><code class="language-{.python .input  n=6}">#@tab mxnet
#@save
def load_data_ml100k(data, num_users, num_items, feedback='explicit'):
    users, items, scores = [], [], []
    inter = np.zeros((num_items, num_users)) if feedback == 'explicit' else {}
    for line in data.itertuples():
        user_index, item_index = int(line[1] - 1), int(line[2] - 1)
        score = int(line[3]) if feedback == 'explicit' else 1
        users.append(user_index)
        items.append(item_index)
        scores.append(score)
        if feedback == 'implicit':
            inter.setdefault(user_index, []).append(item_index)
        else:
            inter[item_index, user_index] = score
    return users, items, scores, inter
</code></pre>
<p>Afterwards, we put the above steps together and it will be used in the next section. The results are wrapped with <code>Dataset</code> and <code>DataLoader</code>. Note that the <code>last_batch</code> of <code>DataLoader</code> for training data is set to the <code>rollover</code> mode (The remaining samples are rolled over to the next epoch.) and orders are shuffled.</p>
<pre><code class="language-{.python .input  n=7}">#@tab mxnet
#@save
def split_and_load_ml100k(split_mode='seq-aware', feedback='explicit',
                          test_ratio=0.1, batch_size=256):
    data, num_users, num_items = read_data_ml100k()
    train_data, test_data = split_data_ml100k(
        data, num_users, num_items, split_mode, test_ratio)
    train_u, train_i, train_r, _ = load_data_ml100k(
        train_data, num_users, num_items, feedback)
    test_u, test_i, test_r, _ = load_data_ml100k(
        test_data, num_users, num_items, feedback)
    train_set = gluon.data.ArrayDataset(
        np.array(train_u), np.array(train_i), np.array(train_r))
    test_set = gluon.data.ArrayDataset(
        np.array(test_u), np.array(test_i), np.array(test_r))
    train_iter = gluon.data.DataLoader(
        train_set, shuffle=True, last_batch='rollover',
        batch_size=batch_size)
    test_iter = gluon.data.DataLoader(
        test_set, batch_size=batch_size)
    return num_users, num_items, train_iter, test_iter
</code></pre>
<h2 id="summary-117"><a class="header" href="#summary-117">Summary</a></h2>
<ul>
<li>MovieLens datasets are widely used for recommendation research. It is public available and free to use.</li>
<li>We define functions to download and preprocess the MovieLens 100k dataset for further use in later sections.</li>
</ul>
<h2 id="exercises-135"><a class="header" href="#exercises-135">Exercises</a></h2>
<ul>
<li>What other similar recommendation datasets can you find?</li>
<li>Go through the <a href="https://movielens.org/">https://movielens.org/</a> site for more information about MovieLens.</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/399">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix-factorization"><a class="header" href="#matrix-factorization">Matrix Factorization</a></h1>
<p>Matrix Factorization :cite:<code>Koren.Bell.Volinsky.2009</code> is a well-established algorithm in the recommender systems literature. The first version of matrix factorization model is proposed by Simon Funk in a famous <a href="https://sifter.org/%7Esimon/journal/20061211.html">blog
post</a> in which he described the idea of factorizing the interaction matrix. It then became widely known due to the Netflix contest which was held in 2006. At that time, Netflix, a media-streaming and video-rental company, announced a contest to improve its recommender system performance. The best team that can improve on the Netflix baseline, i.e., Cinematch), by 10 percent would win a one million USD prize.  As such, this contest attracted
a lot of attention to the field of recommender system research. Subsequently, the grand prize was won by the BellKor's Pragmatic Chaos team, a combined team of BellKor, Pragmatic Theory, and BigChaos (you do not need to worry about these algorithms now). Although the final score was the result of an ensemble solution (i.e., a combination of many algorithms), the matrix factorization algorithm played a critical role in the final blend. The technical report of the Netflix Grand Prize solution :cite:<code>Toscher.Jahrer.Bell.2009</code> provides a detailed introduction to the adopted model. In this section, we will dive into the details of the matrix factorization model and its implementation.</p>
<h2 id="the-matrix-factorization-model"><a class="header" href="#the-matrix-factorization-model">The Matrix Factorization Model</a></h2>
<p>Matrix factorization is a class of collaborative filtering models. Specifically, the model factorizes the user-item interaction matrix (e.g., rating matrix) into the product of two lower-rank matrices, capturing the low-rank structure of the user-item interactions.</p>
<p>Let $\mathbf{R} \in \mathbb{R}^{m \times n}$ denote the interaction matrix with $m$ users and $n$ items, and the values of $\mathbf{R}$ represent explicit ratings. The user-item interaction will be factorized into a user latent matrix $\mathbf{P} \in \mathbb{R}^{m \times k}$ and an item latent matrix $\mathbf{Q} \in \mathbb{R}^{n \times k}$, where $k \ll m, n$, is the latent factor size. Let $\mathbf{p}_u$ denote the $u^\textrm{th}$ row of $\mathbf{P}$ and $\mathbf{q}_i$ denote the $i^\textrm{th}$ row of $\mathbf{Q}$.  For a given item $i$, the elements of $\mathbf{q}_i$ measure the extent to which the item possesses those characteristics such as the genres and languages of a movie. For a given user $u$, the elements of $\mathbf{p}_u$ measure the extent of interest the user has in items' corresponding characteristics. These latent factors might measure obvious dimensions as mentioned in those examples or are completely uninterpretable. The predicted ratings can be estimated by</p>
<p>$$\hat{\mathbf{R}} = \mathbf{PQ}^\top$$</p>
<p>where $\hat{\mathbf{R}}\in \mathbb{R}^{m \times n}$ is the predicted rating matrix which has the same shape as $\mathbf{R}$. One major problem of this prediction rule is that users/items biases can not be modeled. For example, some users tend to give higher ratings or some items always get lower ratings due to poorer quality. These biases are commonplace in real-world applications. To capture these biases, user specific and item specific bias terms are introduced. Specifically, the predicted rating user $u$ gives to item $i$ is calculated by</p>
<p>$$
\hat{\mathbf{R}}_{ui} = \mathbf{p}_u\mathbf{q}^\top_i + b_u + b_i
$$</p>
<p>Then, we train the matrix factorization model by minimizing the mean squared error between predicted rating scores and real rating scores.  The objective function is defined as follows:</p>
<p>$$
\underset{\mathbf{P}, \mathbf{Q}, b}{\mathrm{argmin}} \sum_{(u, i) \in \mathcal{K}} | \mathbf{R}<em>{ui} -
\hat{\mathbf{R}}</em>{ui} |^2 + \lambda (| \mathbf{P} |^2_F + | \mathbf{Q}
|^2_F + b_u^2 + b_i^2 )
$$</p>
<p>where $\lambda$ denotes the regularization rate. The regularizing term $\lambda (| \mathbf{P} |^2_F + | \mathbf{Q}
|^2_F + b_u^2 + b_i^2 )$ is used to avoid over-fitting by penalizing the magnitude of the parameters. The $(u, i)$ pairs for which $\mathbf{R}<em>{ui}$ is known are stored in the set
$\mathcal{K}={(u, i) \mid \mathbf{R}</em>{ui} \textrm{ is known}}$. The model parameters can be learned with an optimization algorithm, such as Stochastic Gradient Descent and Adam.</p>
<p>An intuitive illustration of the matrix factorization model is shown below:</p>
<p><img src="chapter_recommender-systems/../img/rec-mf.svg" alt="Illustration of matrix factorization model" /></p>
<p>In the rest of this section, we will explain the implementation of matrix factorization and train the model on the MovieLens dataset.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
import mxnet as mx
npx.set_np()
</code></pre>
<h2 id="model-implementation"><a class="header" href="#model-implementation">Model Implementation</a></h2>
<p>First, we implement the matrix factorization model described above. The user and item latent factors can be created with the <code>nn.Embedding</code>. The <code>input_dim</code> is the number of items/users and the <code>output_dim</code> is the dimension of the latent factors $k$.  We can also use <code>nn.Embedding</code> to create the user/item biases by setting the <code>output_dim</code> to one. In the <code>forward</code> function, user and item ids are used to look up the embeddings.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
class MF(nn.Block):
    def __init__(self, num_factors, num_users, num_items, **kwargs):
        super(MF, self).__init__(**kwargs)
        self.P = nn.Embedding(input_dim=num_users, output_dim=num_factors)
        self.Q = nn.Embedding(input_dim=num_items, output_dim=num_factors)
        self.user_bias = nn.Embedding(num_users, 1)
        self.item_bias = nn.Embedding(num_items, 1)

    def forward(self, user_id, item_id):
        P_u = self.P(user_id)
        Q_i = self.Q(item_id)
        b_u = self.user_bias(user_id)
        b_i = self.item_bias(item_id)
        outputs = (P_u * Q_i).sum(axis=1) + np.squeeze(b_u) + np.squeeze(b_i)
        return outputs.flatten()
</code></pre>
<h2 id="evaluation-measures"><a class="header" href="#evaluation-measures">Evaluation Measures</a></h2>
<p>We then implement the RMSE (root-mean-square error) measure, which is commonly used to measure the differences between rating scores predicted by the model and the actually observed ratings (ground truth) :cite:<code>Gunawardana.Shani.2015</code>. RMSE is defined as:</p>
<p>$$
\textrm{RMSE} = \sqrt{\frac{1}{|\mathcal{T}|}\sum_{(u, i) \in \mathcal{T}}(\mathbf{R}<em>{ui} -\hat{\mathbf{R}}</em>{ui})^2}
$$</p>
<p>where $\mathcal{T}$ is the set consisting of pairs of users and items that you want to evaluate on. $|\mathcal{T}|$ is the size of this set. We can use the RMSE function provided by <code>mx.metric</code>.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
def evaluator(net, test_iter, devices):
    rmse = mx.metric.RMSE()  # Get the RMSE
    rmse_list = []
    for idx, (users, items, ratings) in enumerate(test_iter):
        u = gluon.utils.split_and_load(users, devices, even_split=False)
        i = gluon.utils.split_and_load(items, devices, even_split=False)
        r_ui = gluon.utils.split_and_load(ratings, devices, even_split=False)
        r_hat = [net(u, i) for u, i in zip(u, i)]
        rmse.update(labels=r_ui, preds=r_hat)
        rmse_list.append(rmse.get()[1])
    return float(np.mean(np.array(rmse_list)))
</code></pre>
<h2 id="training-and-evaluating-the-model-4"><a class="header" href="#training-and-evaluating-the-model-4">Training and Evaluating the Model</a></h2>
<p>In the training function, we adopt the $\ell_2$ loss with weight decay. The weight decay mechanism has the same effect as the $\ell_2$ regularization.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
#@save
def train_recsys_rating(net, train_iter, test_iter, loss, trainer, num_epochs,
                        devices=d2l.try_all_gpus(), evaluator=None,
                        **kwargs):
    timer = d2l.Timer()
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0, 2],
                            legend=['train loss', 'test RMSE'])
    for epoch in range(num_epochs):
        metric, l = d2l.Accumulator(3), 0.
        for i, values in enumerate(train_iter):
            timer.start()
            input_data = []
            values = values if isinstance(values, list) else [values]
            for v in values:
                input_data.append(gluon.utils.split_and_load(v, devices))
            train_feat = input_data[:-1] if len(values) &gt; 1 else input_data
            train_label = input_data[-1]
            with autograd.record():
                preds = [net(*t) for t in zip(*train_feat)]
                ls = [loss(p, s) for p, s in zip(preds, train_label)]
            [l.backward() for l in ls]
            l += sum([l.asnumpy() for l in ls]).mean() / len(devices)
            trainer.step(values[0].shape[0])
            metric.add(l, values[0].shape[0], values[0].size)
            timer.stop()
        if len(kwargs) &gt; 0:  # It will be used in section AutoRec
            test_rmse = evaluator(net, test_iter, kwargs['inter_mat'],
                                  devices)
        else:
            test_rmse = evaluator(net, test_iter, devices)
        train_l = l / (i + 1)
        animator.add(epoch + 1, (train_l, test_rmse))
    print(f'train loss {metric[0] / metric[1]:.3f}, '
          f'test RMSE {test_rmse:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec '
          f'on {str(devices)}')
</code></pre>
<p>Finally, let's put all things together and train the model. Here, we set the latent factor dimension to 30.</p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
devices = d2l.try_all_gpus()
num_users, num_items, train_iter, test_iter = d2l.split_and_load_ml100k(
    test_ratio=0.1, batch_size=512)
net = MF(30, num_users, num_items)
net.initialize(ctx=devices, force_reinit=True, init=mx.init.Normal(0.01))
lr, num_epochs, wd, optimizer = 0.002, 20, 1e-5, 'adam'
loss = gluon.loss.L2Loss()
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {"learning_rate": lr, 'wd': wd})
train_recsys_rating(net, train_iter, test_iter, loss, trainer, num_epochs,
                    devices, evaluator)
</code></pre>
<p>Below, we use the trained model to predict the rating that a user (ID 20) might give to an item (ID 30).</p>
<pre><code class="language-{.python .input  n=6}">#@tab mxnet
scores = net(np.array([20], dtype='int', ctx=devices[0]),
             np.array([30], dtype='int', ctx=devices[0]))
scores
</code></pre>
<h2 id="summary-118"><a class="header" href="#summary-118">Summary</a></h2>
<ul>
<li>The matrix factorization model is widely used in recommender systems.  It can be used to predict ratings that a user might give to an item.</li>
<li>We can implement and train matrix factorization for recommender systems.</li>
</ul>
<h2 id="exercises-136"><a class="header" href="#exercises-136">Exercises</a></h2>
<ul>
<li>Vary the size of latent factors. How does the size of latent factors influence the model performance?</li>
<li>Try different optimizers, learning rates, and weight decay rates.</li>
<li>Check the predicted rating scores of other users for a specific movie.</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/400">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autorec-rating-prediction-with-autoencoders"><a class="header" href="#autorec-rating-prediction-with-autoencoders">AutoRec: Rating Prediction with Autoencoders</a></h1>
<p>Although the matrix factorization model achieves decent performance on the rating prediction task, it is essentially a linear model. Thus, such models are not capable of capturing complex nonlinear and intricate relationships that may be predictive of users' preferences. In this section, we introduce a nonlinear neural network collaborative filtering model, AutoRec :cite:<code>Sedhain.Menon.Sanner.ea.2015</code>. It identifies collaborative filtering (CF) with an autoencoder architecture and aims to integrate nonlinear transformations into CF on the basis of explicit feedback. Neural networks have been proven to be capable of approximating any continuous function, making it suitable to address the limitation of matrix factorization and enrich the expressiveness of matrix factorization.</p>
<p>On the one hand, AutoRec has the same structure as an autoencoder which consists of an input layer, a hidden layer, and a reconstruction (output) layer.  An autoencoder is a neural network that learns to copy its input to its output in order to code the inputs into the hidden (and usually low-dimensional) representations. In AutoRec, instead of explicitly embedding users/items into low-dimensional space, it uses the column/row of the interaction matrix as input, then reconstructs the interaction matrix in the output layer.</p>
<p>On the other hand, AutoRec differs from a traditional autoencoder: rather than learning the hidden representations, AutoRec focuses on learning/reconstructing the output layer. It uses a partially observed interaction matrix as input, aiming to reconstruct a completed rating matrix. In the meantime, the missing entries of the input are filled in the output layer via reconstruction for the purpose of recommendation.</p>
<p>There are two variants of AutoRec: user-based and item-based. For brevity, here we only introduce the item-based AutoRec. User-based AutoRec can be derived accordingly.</p>
<h2 id="model-8"><a class="header" href="#model-8">Model</a></h2>
<p>Let $\mathbf{R}_{*i}$ denote the $i^\textrm{th}$ column of the rating matrix, where unknown ratings are set to zeros by default. The neural architecture is defined as:</p>
<p>$$
h(\mathbf{R}<em>{*i}) = f(\mathbf{W} \cdot g(\mathbf{V} \mathbf{R}</em>{*i} + \mu) + b)
$$</p>
<p>where $f(\cdot)$ and $g(\cdot)$ represent activation functions, $\mathbf{W}$ and $\mathbf{V}$ are weight matrices, $\mu$ and $b$ are biases. Let $h( \cdot )$ denote the whole network of AutoRec. The output $h(\mathbf{R}_{*i})$ is the reconstruction of the $i^\textrm{th}$ column of the rating matrix.</p>
<p>The following objective function aims to minimize the reconstruction error:</p>
<p>$$
\underset{\mathbf{W},\mathbf{V},\mu, b}{\mathrm{argmin}} \sum_{i=1}^M{\parallel \mathbf{R}<em>{*i} - h(\mathbf{R}</em>{*i})\parallel_{\mathcal{O}}^2} +\lambda(| \mathbf{W} |_F^2 + | \mathbf{V}|_F^2)
$$</p>
<p>where $| \cdot |_{\mathcal{O}}$ means only the contribution of observed ratings are considered, that is, only weights that are associated with observed inputs are updated during back-propagation.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
import mxnet as mx

npx.set_np()
</code></pre>
<h2 id="implementing-the-model"><a class="header" href="#implementing-the-model">Implementing the Model</a></h2>
<p>A typical autoencoder consists of an encoder and a decoder. The encoder projects the input to hidden representations and the decoder maps the hidden layer to the reconstruction layer. We follow this practice and create the encoder and decoder with fully connected layers. The activation of encoder is set to <code>sigmoid</code> by default and no activation is applied for decoder. Dropout is included after the encoding transformation to reduce over-fitting. The gradients of unobserved inputs are masked out to ensure that only observed ratings contribute to the model learning process.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
class AutoRec(nn.Block):
    def __init__(self, num_hidden, num_users, dropout=0.05):
        super(AutoRec, self).__init__()
        self.encoder = nn.Dense(num_hidden, activation='sigmoid',
                                use_bias=True)
        self.decoder = nn.Dense(num_users, use_bias=True)
        self.dropout = nn.Dropout(dropout)

    def forward(self, input):
        hidden = self.dropout(self.encoder(input))
        pred = self.decoder(hidden)
        if autograd.is_training():  # Mask the gradient during training
            return pred * np.sign(input)
        else:
            return pred
</code></pre>
<h2 id="reimplementing-the-evaluator"><a class="header" href="#reimplementing-the-evaluator">Reimplementing the Evaluator</a></h2>
<p>Since the input and output have been changed, we need to reimplement the evaluation function, while we still use RMSE as the accuracy measure.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
def evaluator(network, inter_matrix, test_data, devices):
    scores = []
    for values in inter_matrix:
        feat = gluon.utils.split_and_load(values, devices, even_split=False)
        scores.extend([network(i).asnumpy() for i in feat])
    recons = np.array([item for sublist in scores for item in sublist])
    # Calculate the test RMSE
    rmse = np.sqrt(np.sum(np.square(test_data - np.sign(test_data) * recons))
                   / np.sum(np.sign(test_data)))
    return float(rmse)
</code></pre>
<h2 id="training-and-evaluating-the-model-5"><a class="header" href="#training-and-evaluating-the-model-5">Training and Evaluating the Model</a></h2>
<p>Now, let's train and evaluate AutoRec on the MovieLens dataset. We can clearly see that the test RMSE is lower than the matrix factorization model, confirming the effectiveness of neural networks in the rating prediction task.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
devices = d2l.try_all_gpus()
# Load the MovieLens 100K dataset
df, num_users, num_items = d2l.read_data_ml100k()
train_data, test_data = d2l.split_data_ml100k(df, num_users, num_items)
_, _, _, train_inter_mat = d2l.load_data_ml100k(train_data, num_users,
                                                num_items)
_, _, _, test_inter_mat = d2l.load_data_ml100k(test_data, num_users,
                                               num_items)
train_iter = gluon.data.DataLoader(train_inter_mat, shuffle=True,
                                   last_batch="rollover", batch_size=256,
                                   num_workers=d2l.get_dataloader_workers())
test_iter = gluon.data.DataLoader(np.array(train_inter_mat), shuffle=False,
                                  last_batch="keep", batch_size=1024,
                                  num_workers=d2l.get_dataloader_workers())
# Model initialization, training, and evaluation
net = AutoRec(500, num_users)
net.initialize(ctx=devices, force_reinit=True, init=mx.init.Normal(0.01))
lr, num_epochs, wd, optimizer = 0.002, 25, 1e-5, 'adam'
loss = gluon.loss.L2Loss()
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {"learning_rate": lr, 'wd': wd})
d2l.train_recsys_rating(net, train_iter, test_iter, loss, trainer, num_epochs,
                        devices, evaluator, inter_mat=test_inter_mat)
</code></pre>
<h2 id="summary-119"><a class="header" href="#summary-119">Summary</a></h2>
<ul>
<li>We can frame the matrix factorization algorithm with autoencoders, while integrating non-linear layers and dropout regularization.</li>
<li>Experiments on the MovieLens 100K dataset show that AutoRec achieves superior performance than matrix factorization.</li>
</ul>
<h2 id="exercises-137"><a class="header" href="#exercises-137">Exercises</a></h2>
<ul>
<li>Vary the hidden dimension of AutoRec to see its impact on the model performance.</li>
<li>Try to add more hidden layers. Is it helpful to improve the model performance?</li>
<li>Can you find a better combination of decoder and encoder activation functions?</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/401">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="personalized-ranking-for-recommender-systems"><a class="header" href="#personalized-ranking-for-recommender-systems">Personalized Ranking for Recommender Systems</a></h1>
<p>In the former sections, only explicit feedback was considered and models were trained and tested on observed ratings.  There are two demerits of such methods: First, most feedback is not explicit but implicit in real-world scenarios, and explicit feedback can be more expensive to collect.  Second, non-observed user-item pairs which may be predictive for users' interests are totally ignored, making these methods unsuitable for cases where ratings are not missing at random but because of users' preferences.  Non-observed user-item pairs are a  mixture of real negative feedback (users are not interested in the items) and missing values (the user might interact with the items in the future). We simply ignore the non-observed pairs in matrix factorization and AutoRec. Clearly, these models are incapable of distinguishing between observed and non-observed pairs and are usually not suitable for personalized ranking tasks.</p>
<p>To this end, a class of recommendation models targeting at generating ranked recommendation lists from implicit feedback have gained popularity. In general, personalized ranking models can be optimized with pointwise, pairwise or listwise approaches. Pointwise approaches considers a single interaction at a time and train a classifier or a regressor to predict individual preferences. Matrix factorization and AutoRec are optimized with pointwise objectives. Pairwise approaches consider a pair of items for each user and aim to approximate the optimal ordering for that pair. Usually, pairwise approaches are more suitable for the ranking task because predicting relative order is reminiscent to the nature of ranking. Listwise approaches approximate the ordering of the entire list of items, for example, direct optimizing the ranking measures such as Normalized Discounted Cumulative Gain (<a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain">NDCG</a>). However, listwise approaches are more complex and compute-intensive than pointwise or pairwise approaches. In this section, we will introduce two pairwise objectives/losses, Bayesian Personalized Ranking loss and Hinge loss, and their respective implementations.</p>
<h2 id="bayesian-personalized-ranking-loss-and-its-implementation"><a class="header" href="#bayesian-personalized-ranking-loss-and-its-implementation">Bayesian Personalized Ranking Loss and its Implementation</a></h2>
<p>Bayesian personalized ranking (BPR) :cite:<code>Rendle.Freudenthaler.Gantner.ea.2009</code> is a pairwise personalized ranking loss that is derived from the maximum posterior estimator. It has been widely used in many existing recommendation models. The training data of BPR consists of both positive and negative pairs (missing values). It assumes that the user prefers the positive item over all other non-observed items.</p>
<p>In formal, the training data is constructed by tuples in the form of $(u, i, j)$, which represents that the user $u$ prefers the item $i$ over the item $j$. The Bayesian formulation of BPR which aims to maximize the posterior probability is given below:</p>
<p>$$
p(\Theta \mid &gt;_u )  \propto  p(&gt;_u \mid \Theta) p(\Theta)
$$</p>
<p>Where $\Theta$ represents the parameters of an arbitrary recommendation model, $&gt;_u$ represents the desired personalized total ranking of all items for user $u$. We can formulate the maximum posterior estimator to derive the generic optimization criterion for the personalized ranking task.</p>
<p>$$
\begin{aligned}
\textrm{BPR-OPT} : &amp;= \ln p(\Theta \mid &gt;<em>u) \
&amp; \propto \ln p(&gt;<em>u \mid \Theta) p(\Theta) \
&amp;= \ln \prod</em>{(u, i, j \in D)} \sigma(\hat{y}</em>{ui} - \hat{y}<em>{uj}) p(\Theta) \
&amp;= \sum</em>{(u, i, j \in D)} \ln \sigma(\hat{y}<em>{ui} - \hat{y}</em>{uj}) + \ln p(\Theta) \
&amp;= \sum_{(u, i, j \in D)} \ln \sigma(\hat{y}<em>{ui} - \hat{y}</em>{uj}) - \lambda_\Theta |\Theta |^2
\end{aligned}
$$</p>
<p>where $D \stackrel{\textrm{def}}{=} {(u, i, j) \mid i \in I^+<em>u \wedge j \in I \backslash I^+<em>u }$ is the training set, with $I^+<em>u$ denoting the items the user $u$ liked, $I$ denoting all items, and $I \backslash I^+<em>u$ indicating all other items excluding items the user liked. $\hat{y}</em>{ui}$ and $\hat{y}</em>{uj}$ are the predicted scores of the user $u$ to item $i$ and $j$, respectively. The prior $p(\Theta)$ is a normal distribution with zero mean and variance-covariance matrix $\Sigma</em>\Theta$. Here, we let $\Sigma</em>\Theta = \lambda_\Theta I$.</p>
<p><img src="chapter_recommender-systems/../img/rec-ranking.svg" alt="Illustration of Bayesian Personalized Ranking" />
We will implement the base class  <code>mxnet.gluon.loss.Loss</code> and override the <code>forward</code> method to construct the Bayesian personalized ranking loss. We begin by importing the Loss class and the np module.</p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
from mxnet import gluon, np, npx
npx.set_np()
</code></pre>
<p>The implementation of BPR loss is as follows.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
#@save
class BPRLoss(gluon.loss.Loss):
    def __init__(self, weight=None, batch_axis=0, **kwargs):
        super(BPRLoss, self).__init__(weight=None, batch_axis=0, **kwargs)

    def forward(self, positive, negative):
        distances = positive - negative
        loss = - np.sum(np.log(npx.sigmoid(distances)), 0, keepdims=True)
        return loss
</code></pre>
<h2 id="hinge-loss-and-its-implementation"><a class="header" href="#hinge-loss-and-its-implementation">Hinge Loss and its Implementation</a></h2>
<p>The Hinge loss for ranking has different form to the <a href="https://mxnet.incubator.apache.org/api/python/gluon/loss.html#mxnet.gluon.loss.HingeLoss">hinge loss</a> provided within the gluon library that is often used in classifiers such as SVMs.  The loss used for ranking in recommender systems has the following form.</p>
<p>$$
\sum_{(u, i, j \in D)} \max( m - \hat{y}<em>{ui} + \hat{y}</em>{uj}, 0)
$$</p>
<p>where $m$ is the safety margin size. It aims to push negative items away from positive items. Similar to BPR, it aims to optimize for relevant distance between positive and negative samples instead of absolute outputs, making it well suited to recommender systems.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
#@save
class HingeLossbRec(gluon.loss.Loss):
    def __init__(self, weight=None, batch_axis=0, **kwargs):
        super(HingeLossbRec, self).__init__(weight=None, batch_axis=0,
                                            **kwargs)

    def forward(self, positive, negative, margin=1):
        distances = positive - negative
        loss = np.sum(np.maximum(- distances + margin, 0))
        return loss
</code></pre>
<p>These two losses are interchangeable for personalized ranking in recommendation.</p>
<h2 id="summary-120"><a class="header" href="#summary-120">Summary</a></h2>
<ul>
<li>There are three types of ranking losses available for the personalized ranking task in recommender systems, namely, pointwise, pairwise and listwise methods.</li>
<li>The two pairwise loses, Bayesian personalized ranking loss and hinge loss, can be used interchangeably.</li>
</ul>
<h2 id="exercises-138"><a class="header" href="#exercises-138">Exercises</a></h2>
<ul>
<li>Are there any variants of BPR and hinge loss available?</li>
<li>Can you find any recommendation models that use BPR or hinge loss?</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/402">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neural-collaborative-filtering-for-personalized-ranking"><a class="header" href="#neural-collaborative-filtering-for-personalized-ranking">Neural Collaborative Filtering for Personalized Ranking</a></h1>
<p>This section moves beyond explicit feedback, introducing the neural collaborative filtering (NCF) framework for recommendation with implicit feedback. Implicit feedback is pervasive in recommender systems. Actions such as Clicks, buys, and watches are common implicit feedback which are easy to collect and indicative of users' preferences. The model we will introduce, titled NeuMF :cite:<code>He.Liao.Zhang.ea.2017</code>, short for neural matrix factorization, aims to address the personalized ranking task with implicit feedback. This model leverages the flexibility and non-linearity of neural networks to replace dot products of matrix factorization, aiming at enhancing the model expressiveness. In specific, this model is structured with two subnetworks including generalized matrix factorization (GMF) and MLP and models the interactions from two pathways instead of simple dot products. The outputs of these two networks are concatenated for the final prediction scores calculation. Unlike the rating prediction task in AutoRec, this model generates a ranked recommendation list to each user based on the implicit feedback. We will use the personalized ranking loss introduced in the last section to train this model.</p>
<h2 id="the-neumf-model"><a class="header" href="#the-neumf-model">The NeuMF model</a></h2>
<p>As aforementioned, NeuMF fuses two subnetworks. The GMF is a generic neural network version of matrix factorization where the input is the elementwise product of user and item latent factors. It consists of two neural layers:</p>
<p>$$
\mathbf{x} = \mathbf{p}_u \odot \mathbf{q}<em>i \
\hat{y}</em>{ui} = \alpha(\mathbf{h}^\top \mathbf{x}),
$$</p>
<p>where $\odot$ denotes the Hadamard product of vectors. $\mathbf{P} \in \mathbb{R}^{m \times k}$  and $\mathbf{Q} \in \mathbb{R}^{n \times k}$ correspond to user and item latent matrix respectively. $\mathbf{p}_u \in \mathbb{R}^{ k}$ is the $u^\textrm{th}$ row of $P$ and $\mathbf{q}<em>i \in \mathbb{R}^{ k}$ is the $i^\textrm{th}$ row of $Q$.  $\alpha$ and $h$ denote the activation function and weight of the output layer. $\hat{y}</em>{ui}$ is the prediction score of the user $u$ might give to the item $i$.</p>
<p>Another component of this model is MLP. To enrich model flexibility, the MLP subnetwork does not share user and item embeddings with GMF. It uses the concatenation of user and item embeddings as input. With the complicated connections and nonlinear transformations, it is capable of estimating the intricate interactions between users and items. More precisely, the MLP subnetwork is defined as:</p>
<p>$$
\begin{aligned}
z^{(1)} &amp;= \phi_1(\mathbf{U}_u, \mathbf{V}_i) = \left[ \mathbf{U}_u, \mathbf{V}<em>i \right] \
\phi^{(2)}(z^{(1)})  &amp;= \alpha^1(\mathbf{W}^{(2)} z^{(1)} + b^{(2)}) \
&amp;... \
\phi^{(L)}(z^{(L-1)}) &amp;= \alpha^L(\mathbf{W}^{(L)} z^{(L-1)} + b^{(L)})) \
\hat{y}</em>{ui} &amp;= \alpha(\mathbf{h}^\top\phi^L(z^{(L-1)}))
\end{aligned}
$$</p>
<p>where $\mathbf{W}^<em>, \mathbf{b}^</em>$ and $\alpha^<em>$ denote the weight matrix, bias vector, and activation function. $\phi^</em>$ denotes the function of the corresponding layer. $\mathbf{z}^*$ denotes the output of corresponding layer.</p>
<p>To fuse the results of GMF and MLP, instead of simple addition, NeuMF concatenates the second last layers of two subnetworks to create a feature vector which can be passed to the further layers. Afterwards, the outputs are projected with matrix $\mathbf{h}$ and a sigmoid activation function. The prediction layer is formulated as:
$$
\hat{y}_{ui} = \sigma(\mathbf{h}^\top[\mathbf{x}, \phi^L(z^{(L-1)})]).
$$</p>
<p>The following figure illustrates the model architecture of NeuMF.</p>
<p><img src="chapter_recommender-systems/../img/rec-neumf.svg" alt="Illustration of the NeuMF model" /></p>
<pre><code class="language-{.python .input  n=1}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
import mxnet as mx
import random

npx.set_np()
</code></pre>
<h2 id="model-implementation-1"><a class="header" href="#model-implementation-1">Model Implementation</a></h2>
<p>The following code implements the NeuMF model. It consists of a generalized matrix factorization model and an MLP with different user and item embedding vectors. The structure of the MLP is controlled with the parameter <code>nums_hiddens</code>. ReLU is used as the default activation function.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
class NeuMF(nn.Block):
    def __init__(self, num_factors, num_users, num_items, nums_hiddens,
                 **kwargs):
        super(NeuMF, self).__init__(**kwargs)
        self.P = nn.Embedding(num_users, num_factors)
        self.Q = nn.Embedding(num_items, num_factors)
        self.U = nn.Embedding(num_users, num_factors)
        self.V = nn.Embedding(num_items, num_factors)
        self.mlp = nn.Sequential()
        for num_hiddens in nums_hiddens:
            self.mlp.add(nn.Dense(num_hiddens, activation='relu',
                                  use_bias=True))
        self.prediction_layer = nn.Dense(1, activation='sigmoid', use_bias=False)

    def forward(self, user_id, item_id):
        p_mf = self.P(user_id)
        q_mf = self.Q(item_id)
        gmf = p_mf * q_mf
        p_mlp = self.U(user_id)
        q_mlp = self.V(item_id)
        mlp = self.mlp(np.concatenate([p_mlp, q_mlp], axis=1))
        con_res = np.concatenate([gmf, mlp], axis=1)
        return self.prediction_layer(con_res)
</code></pre>
<h2 id="customized-dataset-with-negative-sampling"><a class="header" href="#customized-dataset-with-negative-sampling">Customized Dataset with Negative Sampling</a></h2>
<p>For pairwise ranking loss, an important step is negative sampling. For each user, the items that a user has not interacted with are candidate items (unobserved entries). The following function takes users identity and candidate items as input, and samples negative items randomly for each user from the candidate set of that user. During the training stage, the model ensures that the items that a user likes to be ranked higher than items he dislikes or has not interacted with.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
class PRDataset(gluon.data.Dataset):
    def __init__(self, users, items, candidates, num_items):
        self.users = users
        self.items = items
        self.cand = candidates
        self.all = set([i for i in range(num_items)])

    def __len__(self):
        return len(self.users)

    def __getitem__(self, idx):
        neg_items = list(self.all - set(self.cand[int(self.users[idx])]))
        indices = random.randint(0, len(neg_items) - 1)
        return self.users[idx], self.items[idx], neg_items[indices]
</code></pre>
<h2 id="evaluator"><a class="header" href="#evaluator">Evaluator</a></h2>
<p>In this section, we adopt the splitting by time strategy to construct the training and test sets. Two evaluation measures including hit rate at given cutting off $\ell$ ($\textrm{Hit}@\ell$) and area under the ROC curve (AUC) are used to assess the model effectiveness.  Hit rate at given position $\ell$ for each user indicates that whether the recommended item is included in the top $\ell$ ranked list. The formal definition is as follows:</p>
<p>$$
\textrm{Hit}@\ell = \frac{1}{m} \sum_{u \in \mathcal{U}} \textbf{1}(rank_{u, g_u} &lt;= \ell),
$$</p>
<p>where $\textbf{1}$ denotes an indicator function that is equal to one if the ground truth item is ranked in the top $\ell$ list, otherwise it is equal to zero. $rank_{u, g_u}$ denotes the ranking of the ground truth item $g_u$ of the user $u$ in the recommendation list (The ideal ranking is 1). $m$ is the number of users. $\mathcal{U}$ is the user set.</p>
<p>The definition of AUC is as follows:</p>
<p>$$
\textrm{AUC} = \frac{1}{m} \sum_{u \in \mathcal{U}} \frac{1}{|\mathcal{I} \backslash S_u|} \sum_{j \in I \backslash S_u} \textbf{1}(rank_{u, g_u} &lt; rank_{u, j}),
$$</p>
<p>where $\mathcal{I}$ is the item set. $S_u$ is the candidate items of user $u$. Note that many other evaluation protocols such as precision, recall and normalized discounted cumulative gain (NDCG) can also be used.</p>
<p>The following function calculates the hit counts and AUC for each user.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
#@save
def hit_and_auc(rankedlist, test_matrix, k):
    hits_k = [(idx, val) for idx, val in enumerate(rankedlist[:k])
              if val in set(test_matrix)]
    hits_all = [(idx, val) for idx, val in enumerate(rankedlist)
                if val in set(test_matrix)]
    max = len(rankedlist) - 1
    auc = 1.0 * (max - hits_all[0][0]) / max if len(hits_all) &gt; 0 else 0
    return len(hits_k), auc
</code></pre>
<p>Then, the overall Hit rate and AUC are calculated as follows.</p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
#@save
def evaluate_ranking(net, test_input, seq, candidates, num_users, num_items,
                     devices):
    ranked_list, ranked_items, hit_rate, auc = {}, {}, [], []
    all_items = set([i for i in range(num_users)])
    for u in range(num_users):
        neg_items = list(all_items - set(candidates[int(u)]))
        user_ids, item_ids, x, scores = [], [], [], []
        [item_ids.append(i) for i in neg_items]
        [user_ids.append(u) for _ in neg_items]
        x.extend([np.array(user_ids)])
        if seq is not None:
            x.append(seq[user_ids, :])
        x.extend([np.array(item_ids)])
        test_data_iter = gluon.data.DataLoader(
            gluon.data.ArrayDataset(*x), shuffle=False, last_batch="keep",
            batch_size=1024)
        for index, values in enumerate(test_data_iter):
            x = [gluon.utils.split_and_load(v, devices, even_split=False)
                 for v in values]
            scores.extend([list(net(*t).asnumpy()) for t in zip(*x)])
        scores = [item for sublist in scores for item in sublist]
        item_scores = list(zip(item_ids, scores))
        ranked_list[u] = sorted(item_scores, key=lambda t: t[1], reverse=True)
        ranked_items[u] = [r[0] for r in ranked_list[u]]
        temp = hit_and_auc(ranked_items[u], test_input[u], 50)
        hit_rate.append(temp[0])
        auc.append(temp[1])
    return np.mean(np.array(hit_rate)), np.mean(np.array(auc))
</code></pre>
<h2 id="training-and-evaluating-the-model-6"><a class="header" href="#training-and-evaluating-the-model-6">Training and Evaluating the Model</a></h2>
<p>The training function is defined below. We train the model in the pairwise manner.</p>
<pre><code class="language-{.python .input  n=6}">#@tab mxnet
#@save
def train_ranking(net, train_iter, test_iter, loss, trainer, test_seq_iter,
                  num_users, num_items, num_epochs, devices, evaluator,
                  candidates, eval_step=1):
    timer, hit_rate, auc = d2l.Timer(), 0, 0
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0, 1],
                            legend=['test hit rate', 'test AUC'])
    for epoch in range(num_epochs):
        metric, l = d2l.Accumulator(3), 0.
        for i, values in enumerate(train_iter):
            input_data = []
            for v in values:
                input_data.append(gluon.utils.split_and_load(v, devices))
            with autograd.record():
                p_pos = [net(*t) for t in zip(*input_data[:-1])]
                p_neg = [net(*t) for t in zip(*input_data[:-2],
                                              input_data[-1])]
                ls = [loss(p, n) for p, n in zip(p_pos, p_neg)]
            [l.backward(retain_graph=False) for l in ls]
            l += sum([l.asnumpy() for l in ls]).mean()/len(devices)
            trainer.step(values[0].shape[0])
            metric.add(l, values[0].shape[0], values[0].size)
            timer.stop()
        with autograd.predict_mode():
            if (epoch + 1) % eval_step == 0:
                hit_rate, auc = evaluator(net, test_iter, test_seq_iter,
                                          candidates, num_users, num_items,
                                          devices)
                animator.add(epoch + 1, (hit_rate, auc))
    print(f'train loss {metric[0] / metric[1]:.3f}, '
          f'test hit rate {float(hit_rate):.3f}, test AUC {float(auc):.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec '
          f'on {str(devices)}')
</code></pre>
<p>Now, we can load the MovieLens 100k dataset and train the model. Since there are only ratings in the MovieLens dataset, with some losses of accuracy, we binarize these ratings to zeros and ones. If a user rated an item, we consider the implicit feedback as one, otherwise as zero. The action of rating an item can be treated as a form of providing implicit feedback.  Here, we split the dataset in the <code>seq-aware</code> mode where users' latest interacted items are left out for test.</p>
<pre><code class="language-{.python .input  n=11}">#@tab mxnet
batch_size = 1024
df, num_users, num_items = d2l.read_data_ml100k()
train_data, test_data = d2l.split_data_ml100k(df, num_users, num_items,
                                              'seq-aware')
users_train, items_train, ratings_train, candidates = d2l.load_data_ml100k(
    train_data, num_users, num_items, feedback="implicit")
users_test, items_test, ratings_test, test_iter = d2l.load_data_ml100k(
    test_data, num_users, num_items, feedback="implicit")
train_iter = gluon.data.DataLoader(
    PRDataset(users_train, items_train, candidates, num_items ), batch_size,
    True, last_batch="rollover", num_workers=d2l.get_dataloader_workers())
</code></pre>
<p>We then create and initialize the model. We use a three-layer MLP with constant hidden size 10.</p>
<pre><code class="language-{.python .input  n=8}">#@tab mxnet
devices = d2l.try_all_gpus()
net = NeuMF(10, num_users, num_items, nums_hiddens=[10, 10, 10])
net.initialize(ctx=devices, force_reinit=True, init=mx.init.Normal(0.01))
</code></pre>
<p>The following code trains the model.</p>
<pre><code class="language-{.python .input  n=12}">#@tab mxnet
lr, num_epochs, wd, optimizer = 0.01, 10, 1e-5, 'adam'
loss = d2l.BPRLoss()
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {"learning_rate": lr, 'wd': wd})
train_ranking(net, train_iter, test_iter, loss, trainer, None, num_users,
              num_items, num_epochs, devices, evaluate_ranking, candidates)
</code></pre>
<h2 id="summary-121"><a class="header" href="#summary-121">Summary</a></h2>
<ul>
<li>Adding nonlinearity to matrix factorization model is beneficial for improving the model capability and effectiveness.</li>
<li>NeuMF is a combination of matrix factorization and an MLP. The MLP takes the concatenation of user and item embeddings as input.</li>
</ul>
<h2 id="exercises-139"><a class="header" href="#exercises-139">Exercises</a></h2>
<ul>
<li>Vary the size of latent factors. How the size of latent factors impact the model performance?</li>
<li>Vary the architectures (e.g., number of layers, number of neurons of each layer) of the MLP to check the its impact on the performance.</li>
<li>Try different optimizers, learning rate and weight decay rate.</li>
<li>Try to use hinge loss defined in the last section to optimize this model.</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/403">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-aware-recommender-systems"><a class="header" href="#sequence-aware-recommender-systems">Sequence-Aware Recommender Systems</a></h1>
<p>In previous sections, we abstract the recommendation task as a matrix completion problem without considering users' short-term behaviors. In this section, we will introduce a recommendation model that takes  the sequentially-ordered user interaction logs into account.  It is a sequence-aware recommender :cite:<code>Quadrana.Cremonesi.Jannach.2018</code> where the input is an ordered and often timestamped list of past user actions.  A number of recent literatures have demonstrated the usefulness of incorporating such information in modeling users' temporal behavioral patterns and discovering their interest drift.</p>
<p>The model we will introduce, Caser :cite:<code>Tang.Wang.2018</code>, short for convolutional sequence embedding recommendation model, adopts convolutional neural networks capture the dynamic pattern influences of users' recent activities. The main component of Caser consists of a horizontal convolutional network and a vertical convolutional network, aiming to uncover the union-level and point-level sequence patterns, respectively.  Point-level pattern indicates the impact of single item in the historical sequence on the target item, while union level pattern implies the influences of several previous actions on the subsequent target. For example, buying both milk and butter together leads to higher probability of buying flour than just buying one of them. Moreover, users' general interests, or long term preferences are also modeled in the last fully connected layers, resulting in a more comprehensive modeling of user interests. Details of the model are described as follows.</p>
<h2 id="model-architectures"><a class="header" href="#model-architectures">Model Architectures</a></h2>
<p>In sequence-aware recommendation system, each user is associated with a sequence of some items from the item set. Let $S^u = (S_1^u, ... S_{|S_u|}^u)$ denotes the ordered sequence. The goal of Caser is to recommend item by considering user general tastes as well as short-term intention. Suppose we take the previous $L$ items into consideration, an embedding matrix that represents the former interactions for time step $t$ can be constructed:</p>
<p>$$
\mathbf{E}^{(u, t)} = [ \mathbf{q}<em>{S</em>{t-L}^u} , ..., \mathbf{q}<em>{S</em>{t-2}^u}, \mathbf{q}<em>{S</em>{t-1}^u} ]^\top,
$$</p>
<p>where $\mathbf{Q} \in \mathbb{R}^{n \times k}$ represents item embeddings and $\mathbf{q}_i$ denotes the $i^\textrm{th}$ row. $\mathbf{E}^{(u, t)} \in \mathbb{R}^{L \times k}$ can be used to infer the transient interest of user $u$ at time-step $t$. We can view the input matrix $\mathbf{E}^{(u, t)}$ as an image which is the input of the subsequent two convolutional components.</p>
<p>The horizontal convolutional layer has $d$ horizontal filters $\mathbf{F}^j \in \mathbb{R}^{h \times k}, 1 \leq j \leq d, h = {1, ..., L}$, and the vertical convolutional layer has $d'$ vertical filters $\mathbf{G}^j \in \mathbb{R}^{ L \times 1}, 1 \leq j \leq d'$. After a series of convolutional and pool operations, we get the two outputs:</p>
<p>$$
\mathbf{o} = \textrm{HConv}(\mathbf{E}^{(u, t)}, \mathbf{F}) \
\mathbf{o}'= \textrm{VConv}(\mathbf{E}^{(u, t)}, \mathbf{G}) ,
$$</p>
<p>where $\mathbf{o} \in \mathbb{R}^d$ is the output of horizontal convolutional network and $\mathbf{o}' \in \mathbb{R}^{kd'}$ is the output of vertical convolutional network. For simplicity, we omit the details of convolution and pool operations. They are concatenated and fed into a fully connected neural network layer to get more high-level representations.</p>
<p>$$
\mathbf{z} = \phi(\mathbf{W}[\mathbf{o}, \mathbf{o}']^\top + \mathbf{b}),
$$</p>
<p>where $\mathbf{W} \in \mathbb{R}^{k \times (d + kd')}$ is the weight matrix and $\mathbf{b} \in \mathbb{R}^k$ is the bias. The learned vector $\mathbf{z} \in \mathbb{R}^k$ is the representation of user's short-term intent.</p>
<p>At last, the prediction function combines users' short-term and general taste together, which is defined as:</p>
<p>$$
\hat{y}_{uit} = \mathbf{v}_i \cdot [\mathbf{z}, \mathbf{p}_u]^\top + \mathbf{b}'_i,
$$</p>
<p>where $\mathbf{V} \in \mathbb{R}^{n \times 2k}$ is another item embedding matrix. $\mathbf{b}' \in \mathbb{R}^n$ is the item specific bias.  $\mathbf{P} \in \mathbb{R}^{m \times k}$ is the user embedding matrix for users' general tastes. $\mathbf{p}_u \in \mathbb{R}^{ k}$ is the $u^\textrm{th}$ row of $P$ and $\mathbf{v}_i \in \mathbb{R}^{2k}$ is the $i^\textrm{th}$ row of $\mathbf{V}$.</p>
<p>The model can be learned with BPR or Hinge loss. The architecture of Caser is shown below:</p>
<p><img src="chapter_recommender-systems/../img/rec-caser.svg" alt="Illustration of the Caser Model" /></p>
<p>We first import the required libraries.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import gluon, np, npx
from mxnet.gluon import nn
import mxnet as mx
import random

npx.set_np()
</code></pre>
<h2 id="model-implementation-2"><a class="header" href="#model-implementation-2">Model Implementation</a></h2>
<p>The following code implements the Caser model. It consists of a vertical convolutional layer, a horizontal convolutional layer, and a full-connected layer.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
class Caser(nn.Block):
    def __init__(self, num_factors, num_users, num_items, L=5, d=16,
                 d_prime=4, drop_ratio=0.05, **kwargs):
        super(Caser, self).__init__(**kwargs)
        self.P = nn.Embedding(num_users, num_factors)
        self.Q = nn.Embedding(num_items, num_factors)
        self.d_prime, self.d = d_prime, d
        # Vertical convolution layer
        self.conv_v = nn.Conv2D(d_prime, (L, 1), in_channels=1)
        # Horizontal convolution layer
        h = [i + 1 for i in range(L)]
        self.conv_h, self.max_pool = nn.Sequential(), nn.Sequential()
        for i in h:
            self.conv_h.add(nn.Conv2D(d, (i, num_factors), in_channels=1))
            self.max_pool.add(nn.MaxPool1D(L - i + 1))
        # Fully connected layer
        self.fc1_dim_v, self.fc1_dim_h = d_prime * num_factors, d * len(h)
        self.fc = nn.Dense(in_units=d_prime * num_factors + d * L,
                           activation='relu', units=num_factors)
        self.Q_prime = nn.Embedding(num_items, num_factors * 2)
        self.b = nn.Embedding(num_items, 1)
        self.dropout = nn.Dropout(drop_ratio)

    def forward(self, user_id, seq, item_id):
        item_embs = np.expand_dims(self.Q(seq), 1)
        user_emb = self.P(user_id)
        out, out_h, out_v, out_hs = None, None, None, []
        if self.d_prime:
            out_v = self.conv_v(item_embs)
            out_v = out_v.reshape(out_v.shape[0], self.fc1_dim_v)
        if self.d:
            for conv, maxp in zip(self.conv_h, self.max_pool):
                conv_out = np.squeeze(npx.relu(conv(item_embs)), axis=3)
                t = maxp(conv_out)
                pool_out = np.squeeze(t, axis=2)
                out_hs.append(pool_out)
            out_h = np.concatenate(out_hs, axis=1)
        out = np.concatenate([out_v, out_h], axis=1)
        z = self.fc(self.dropout(out))
        x = np.concatenate([z, user_emb], axis=1)
        q_prime_i = np.squeeze(self.Q_prime(item_id))
        b = np.squeeze(self.b(item_id))
        res = (x * q_prime_i).sum(1) + b
        return res
</code></pre>
<h2 id="sequential-dataset-with-negative-sampling"><a class="header" href="#sequential-dataset-with-negative-sampling">Sequential Dataset with Negative Sampling</a></h2>
<p>To process the sequential interaction data, we need to reimplement the <code>Dataset</code> class. The following code creates a new dataset class named <code>SeqDataset</code>. In each sample, it outputs the user identity, his previous $L$ interacted items as a sequence and the next item he interacts as the target. The following figure demonstrates the data loading process for one user. Suppose that this user liked 9 movies, we organize these nine movies in chronological order. The latest movie is left out as the test item. For the remaining eight movies, we can get three training samples, with each sample containing a sequence of five ($L=5$) movies and its subsequent item as the target item. Negative samples are also included in the customized dataset.</p>
<p><img src="chapter_recommender-systems/../img/rec-seq-data.svg" alt="Illustration of the data generation process" /></p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
class SeqDataset(gluon.data.Dataset):
    def __init__(self, user_ids, item_ids, L, num_users, num_items,
                 candidates):
        user_ids, item_ids = np.array(user_ids), np.array(item_ids)
        sort_idx = np.array(sorted(range(len(user_ids)),
                                   key=lambda k: user_ids[k]))
        u_ids, i_ids = user_ids[sort_idx], item_ids[sort_idx]
        temp, u_ids, self.cand = {}, u_ids.asnumpy(), candidates
        self.all_items = set([i for i in range(num_items)])
        [temp.setdefault(u_ids[i], []).append(i) for i, _ in enumerate(u_ids)]
        temp = sorted(temp.items(), key=lambda x: x[0])
        u_ids = np.array([i[0] for i in temp])
        idx = np.array([i[1][0] for i in temp])
        self.ns = ns = int(sum([c - L if c &gt;= L + 1 else 1 for c
                                in np.array([len(i[1]) for i in temp])]))
        self.seq_items = np.zeros((ns, L))
        self.seq_users = np.zeros(ns, dtype='int32')
        self.seq_tgt = np.zeros((ns, 1))
        self.test_seq = np.zeros((num_users, L))
        test_users, _uid = np.empty(num_users), None
        for i, (uid, i_seq) in enumerate(self._seq(u_ids, i_ids, idx, L + 1)):
            if uid != _uid:
                self.test_seq[uid][:] = i_seq[-L:]
                test_users[uid], _uid = uid, uid
            self.seq_tgt[i][:] = i_seq[-1:]
            self.seq_items[i][:], self.seq_users[i] = i_seq[:L], uid

    def _win(self, tensor, window_size, step_size=1):
        if len(tensor) - window_size &gt;= 0:
            for i in range(len(tensor), 0, - step_size):
                if i - window_size &gt;= 0:
                    yield tensor[i - window_size:i]
                else:
                    break
        else:
            yield tensor

    def _seq(self, u_ids, i_ids, idx, max_len):
        for i in range(len(idx)):
            stop_idx = None if i &gt;= len(idx) - 1 else int(idx[i + 1])
            for s in self._win(i_ids[int(idx[i]):stop_idx], max_len):
                yield (int(u_ids[i]), s)

    def __len__(self):
        return self.ns

    def __getitem__(self, idx):
        neg = list(self.all_items - set(self.cand[int(self.seq_users[idx])]))
        i = random.randint(0, len(neg) - 1)
        return (self.seq_users[idx], self.seq_items[idx], self.seq_tgt[idx],
                neg[i])
</code></pre>
<h2 id="load-the-movielens-100k-dataset"><a class="header" href="#load-the-movielens-100k-dataset">Load the MovieLens 100K dataset</a></h2>
<p>Afterwards, we read and split the MovieLens 100K dataset in sequence-aware mode and load the training data with sequential dataloader implemented above.</p>
<pre><code class="language-{.python .input  n=6}">#@tab mxnet
TARGET_NUM, L, batch_size = 1, 5, 4096
df, num_users, num_items = d2l.read_data_ml100k()
train_data, test_data = d2l.split_data_ml100k(df, num_users, num_items,
                                              'seq-aware')
users_train, items_train, ratings_train, candidates = d2l.load_data_ml100k(
    train_data, num_users, num_items, feedback="implicit")
users_test, items_test, ratings_test, test_iter = d2l.load_data_ml100k(
    test_data, num_users, num_items, feedback="implicit")
train_seq_data = SeqDataset(users_train, items_train, L, num_users,
                            num_items, candidates)
train_iter = gluon.data.DataLoader(train_seq_data, batch_size, True,
                                   last_batch="rollover",
                                   num_workers=d2l.get_dataloader_workers())
test_seq_iter = train_seq_data.test_seq
train_seq_data[0]
</code></pre>
<p>The training data structure is shown above. The first element is the user identity, the next list indicates the last five items this user liked, and the last element is the item this user liked after the five items.</p>
<h2 id="train-the-model"><a class="header" href="#train-the-model">Train the Model</a></h2>
<p>Now, let's train the model. We use the same setting as NeuMF, including learning rate, optimizer, and $k$, in the last section so that the results are comparable.</p>
<pre><code class="language-{.python .input  n=7}">#@tab mxnet
devices = d2l.try_all_gpus()
net = Caser(10, num_users, num_items, L)
net.initialize(ctx=devices, force_reinit=True, init=mx.init.Normal(0.01))
lr, num_epochs, wd, optimizer = 0.04, 8, 1e-5, 'adam'
loss = d2l.BPRLoss()
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {"learning_rate": lr, 'wd': wd})

# Running takes &gt; 1h (pending fix from MXNet)
# d2l.train_ranking(net, train_iter, test_iter, loss, trainer, test_seq_iter, num_users, num_items, num_epochs, devices, d2l.evaluate_ranking, candidates, eval_step=1)
</code></pre>
<h2 id="summary-122"><a class="header" href="#summary-122">Summary</a></h2>
<ul>
<li>Inferring a user's short-term and long-term interests can make prediction of the next item that he preferred more effectively.</li>
<li>Convolutional neural networks can be utilized to capture users' short-term interests from sequential interactions.</li>
</ul>
<h2 id="exercises-140"><a class="header" href="#exercises-140">Exercises</a></h2>
<ul>
<li>Conduct an ablation study by removing one of the horizontal and vertical convolutional networks, which component is the more important ?</li>
<li>Vary the hyperparameter $L$. Does longer historical interactions bring higher accuracy?</li>
<li>Apart from the sequence-aware recommendation task we introduced above, there is another type of sequence-aware recommendation task called session-based recommendation :cite:<code>Hidasi.Karatzoglou.Baltrunas.ea.2015</code>. Can you explain the differences between these two tasks?</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/404">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-rich-recommender-systems"><a class="header" href="#feature-rich-recommender-systems">Feature-Rich Recommender Systems</a></h1>
<p>Interaction data is the most basic indication of users' preferences and interests. It plays a critical role in former introduced models. Yet, interaction data is usually extremely sparse and can be noisy at times. To address this issue, we can integrate side information such as features of items, profiles of users, and even in which context that the interaction occurred into the recommendation model. Utilizing these features are helpful in making recommendations in that these features can be an effective predictor of users interests especially when interaction data is lacking. As such, it is essential for recommendation models also have the capability to deal with those features and give the model some content/context awareness. To demonstrate this type of recommendation models, we introduce another task on click-through rate (CTR) for online advertisement recommendations :cite:<code>McMahan.Holt.Sculley.ea.2013</code> and present an anonymous advertising dataset. Targeted advertisement services have attracted widespread attention and are often framed as recommendation engines. Recommending advertisements that match users' personal taste and interest is important for click-through rate improvement.</p>
<p>Digital marketers use online advertising to display advertisements to customers. Click-through rate is a metric that measures the number of clicks advertisers receive on their ads per number of impressions and it is expressed as a percentage calculated with the formula:</p>
<p>$$ \textrm{CTR} = \frac{#\textrm{Clicks}} {#\textrm{Impressions}} \times 100 % .$$</p>
<p>Click-through rate is an important signal that indicates the effectiveness of prediction algorithms. Click-through rate prediction is a task of predicting the likelihood that something on a website will be clicked. Models on CTR prediction can not only be employed in targeted advertising systems but also in general item (e.g., movies, news, products) recommender systems, email campaigns, and even search engines. It is also closely related to user satisfaction, conversion rate, and can be helpful in setting campaign goals as it can help advertisers to set realistic expectations.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from collections import defaultdict
from d2l import mxnet as d2l
from mxnet import gluon, np
import os
</code></pre>
<h2 id="an-online-advertising-dataset"><a class="header" href="#an-online-advertising-dataset">An Online Advertising Dataset</a></h2>
<p>With the considerable advancements of Internet and mobile technology, online advertising has become an important income resource and generates vast majority of revenue in the Internet industry. It is important to display relevant advertisements or advertisements that pique users' interests so that casual visitors can be converted into paying customers. The dataset we introduced is an online advertising dataset. It consists of 34 fields, with the first column representing the target variable that indicates if an ad was clicked (1) or not (0). All the other columns are categorical features. The columns might represent the advertisement id, site or application id, device id, time, user profiles and so on. The real semantics of the features are undisclosed due to anonymization and privacy concern.</p>
<p>The following code downloads the dataset from our server and saves it into the local data folder.</p>
<pre><code class="language-{.python .input  n=15}">#@tab mxnet
#@save
d2l.DATA_HUB['ctr'] = (d2l.DATA_URL + 'ctr.zip',
                       'e18327c48c8e8e5c23da714dd614e390d369843f')

data_dir = d2l.download_extract('ctr')
</code></pre>
<p>There are a training set and a test set, consisting of 15000 and 3000 samples/lines, respectively.</p>
<h2 id="dataset-wrapper"><a class="header" href="#dataset-wrapper">Dataset Wrapper</a></h2>
<p>For the convenience of data loading, we implement a <code>CTRDataset</code> which loads the advertising dataset from the CSV file and can be used by <code>DataLoader</code>.</p>
<pre><code class="language-{.python .input  n=13}">#@tab mxnet
#@save
class CTRDataset(gluon.data.Dataset):
    def __init__(self, data_path, feat_mapper=None, defaults=None,
                 min_threshold=4, num_feat=34):
        self.NUM_FEATS, self.count, self.data = num_feat, 0, {}
        feat_cnts = defaultdict(lambda: defaultdict(int))
        self.feat_mapper, self.defaults = feat_mapper, defaults
        self.field_dims = np.zeros(self.NUM_FEATS, dtype=np.int64)
        with open(data_path) as f:
            for line in f:
                instance = {}
                values = line.rstrip('\n').split('\t')
                if len(values) != self.NUM_FEATS + 1:
                    continue
                label = np.float32([0, 0])
                label[int(values[0])] = 1
                instance['y'] = [np.float32(values[0])]
                for i in range(1, self.NUM_FEATS + 1):
                    feat_cnts[i][values[i]] += 1
                    instance.setdefault('x', []).append(values[i])
                self.data[self.count] = instance
                self.count = self.count + 1
        if self.feat_mapper is None and self.defaults is None:
            feat_mapper = {i: {feat for feat, c in cnt.items() if c &gt;=
                               min_threshold} for i, cnt in feat_cnts.items()}
            self.feat_mapper = {i: {feat_v: idx for idx, feat_v in enumerate(feat_values)}
                                for i, feat_values in feat_mapper.items()}
            self.defaults = {i: len(feat_values) for i, feat_values in feat_mapper.items()}
        for i, fm in self.feat_mapper.items():
            self.field_dims[i - 1] = len(fm) + 1
        self.offsets = np.array((0, *np.cumsum(self.field_dims).asnumpy()
                                 [:-1]))
        
    def __len__(self):
        return self.count
    
    def __getitem__(self, idx):
        feat = np.array([self.feat_mapper[i + 1].get(v, self.defaults[i + 1])
                         for i, v in enumerate(self.data[idx]['x'])])
        return feat + self.offsets, self.data[idx]['y']
</code></pre>
<p>The following example loads the training data and print out the first record.</p>
<pre><code class="language-{.python .input  n=16}">#@tab mxnet
train_data = CTRDataset(os.path.join(data_dir, 'train.csv'))
train_data[0]
</code></pre>
<p>As can be seen, all the 34 fields are categorical features. Each value represents the one-hot index of the corresponding entry. The label $0$ means that it is not clicked. This <code>CTRDataset</code> can also be used to load other datasets such as the Criteo display advertising challenge <a href="https://labs.criteo.com/2014/02/kaggle-display-advertising-challenge-dataset/">dataset</a> and the Avazu click-through rate prediction <a href="https://www.kaggle.com/c/avazu-ctr-prediction">dataset</a>.</p>
<h2 id="summary-123"><a class="header" href="#summary-123">Summary</a></h2>
<ul>
<li>Click-through rate is an important metric that is used to measure the effectiveness of advertising systems and recommender systems.</li>
<li>Click-through rate prediction is usually converted to a binary classification problem. The target is to predict whether an ad/item will be clicked or not based on given features.</li>
</ul>
<h2 id="exercises-141"><a class="header" href="#exercises-141">Exercises</a></h2>
<ul>
<li>Can you load the Criteo and Avazu dataset with the provided <code>CTRDataset</code>. It is worth noting that the Criteo dataset consisting of real-valued features so you may have to revise the code a bit.</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/405">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorization-machines"><a class="header" href="#factorization-machines">Factorization Machines</a></h1>
<p>Factorization machines (FM), proposed by :citet:<code>Rendle.2010</code>, is a supervised algorithm that can be used for classification, regression, and ranking tasks. It quickly took notice and became a popular and impactful method for making predictions and recommendations. Particularly, it is a generalization of the linear regression model and the matrix factorization model. Moreover, it is reminiscent of support vector machines with a polynomial kernel. The strengths of factorization machines over the linear regression and matrix factorization are: (1) it can model $\chi$-way variable interactions, where $\chi$ is the number of polynomial order and is usually set to two. (2) A fast optimization algorithm associated with factorization machines can reduce the polynomial computation time to linear complexity, making it extremely efficient especially for high dimensional sparse inputs.  For these reasons, factorization machines are widely employed in modern advertisement and products recommendations. The technical details and implementations are described below.</p>
<h2 id="2-way-factorization-machines"><a class="header" href="#2-way-factorization-machines">2-Way Factorization Machines</a></h2>
<p>Formally, let $x \in \mathbb{R}^d$ denote the feature vectors of one sample, and $y$ denote the corresponding label which can be real-valued label or class label such as binary class "click/non-click". The model for a factorization machine of degree two is defined as:</p>
<p>$$
\hat{y}(x) = \mathbf{w}<em>0 + \sum</em>{i=1}^d \mathbf{w}<em>i x_i + \sum</em>{i=1}^d\sum_{j=i+1}^d \langle\mathbf{v}_i, \mathbf{v}_j\rangle x_i x_j
$$</p>
<p>where $\mathbf{w}_0 \in \mathbb{R}$ is the global bias; $\mathbf{w} \in \mathbb{R}^d$ denotes the weights of the i-th variable; $\mathbf{V} \in \mathbb{R}^{d\times k}$ represents the feature embeddings; $\mathbf{v}_i$ represents the $i^\textrm{th}$ row of $\mathbf{V}$; $k$ is the dimensionality of latent factors; $\langle\cdot, \cdot \rangle$ is the dot product of two vectors.  $\langle \mathbf{v}_i, \mathbf{v}_j \rangle$ model the interaction between the $i^\textrm{th}$ and $j^\textrm{th}$ feature. Some feature interactions can be easily understood so they can be designed by experts. However, most other feature interactions are hidden in data and difficult to identify. So modeling feature interactions automatically can greatly reduce the efforts in feature engineering. It is obvious that the first two terms correspond to the linear regression model and the last term is an extension of the matrix factorization model. If the feature $i$ represents an item and the feature $j$ represents a user, the third term is exactly the dot product between user and item embeddings. It is worth noting that FM can also generalize to higher orders (degree &gt; 2). Nevertheless, the numerical stability might weaken the generalization.</p>
<h2 id="an-efficient-optimization-criterion"><a class="header" href="#an-efficient-optimization-criterion">An Efficient Optimization Criterion</a></h2>
<p>Optimizing the factorization machines in a  straight forward method leads to a complexity of $\mathcal{O}(kd^2)$ as all pairwise interactions require to be computed. To solve this inefficiency problem, we can reorganize the third term of FM which could greatly reduce the computation cost, leading to a linear time complexity ($\mathcal{O}(kd)$).  The reformulation of the pairwise interaction term is as follows:</p>
<p>$$
\begin{aligned}
&amp;\sum_{i=1}^d \sum_{j=i+1}^d \langle\mathbf{v}<em>i, \mathbf{v}<em>j\rangle x_i x_j \
&amp;= \frac{1}{2} \sum</em>{i=1}^d \sum</em>{j=1}^d\langle\mathbf{v}<em>i, \mathbf{v}<em>j\rangle x_i x_j - \frac{1}{2}\sum</em>{i=1}^d \langle\mathbf{v}<em>i, \mathbf{v}<em>i\rangle x_i x_i \
&amp;= \frac{1}{2} \big (\sum</em>{i=1}^d \sum</em>{j=1}^d \sum</em>{l=1}^k\mathbf{v}<em>{i, l} \mathbf{v}</em>{j, l} x_i x_j - \sum_{i=1}^d \sum_{l=1}^k \mathbf{v}<em>{i, l} \mathbf{v}</em>{i, l} x_i x_i \big)\
&amp;=  \frac{1}{2} \sum_{l=1}^k \big ((\sum_{i=1}^d \mathbf{v}<em>{i, l} x_i) (\sum</em>{j=1}^d \mathbf{v}<em>{j, l}x_j) - \sum</em>{i=1}^d \mathbf{v}<em>{i, l}^2 x_i^2 \big ) \
&amp;= \frac{1}{2} \sum</em>{l=1}^k \big ((\sum_{i=1}^d \mathbf{v}<em>{i, l} x_i)^2 - \sum</em>{i=1}^d \mathbf{v}_{i, l}^2 x_i^2)
\end{aligned}
$$</p>
<p>With this reformulation, the model complexity are decreased greatly. Moreover, for sparse features, only non-zero elements needs to be computed so that the overall complexity is linear to the number of non-zero features.</p>
<p>To learn the FM model, we can use the MSE loss for regression task, the cross-entropy loss for classification tasks, and the BPR loss for ranking task. Standard optimizers such as stochastic gradient descent and Adam are viable for optimization.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import init, gluon, np, npx
from mxnet.gluon import nn
import os

npx.set_np()
</code></pre>
<h2 id="model-implementation-3"><a class="header" href="#model-implementation-3">Model Implementation</a></h2>
<p>The following code implement the factorization machines. It is clear to see that FM consists a linear regression block and an efficient feature interaction block. We apply a sigmoid function over the final score since we treat the CTR prediction as a classification task.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
class FM(nn.Block):
    def __init__(self, field_dims, num_factors):
        super(FM, self).__init__()
        num_inputs = int(sum(field_dims))
        self.embedding = nn.Embedding(num_inputs, num_factors)
        self.fc = nn.Embedding(num_inputs, 1)
        self.linear_layer = nn.Dense(1, use_bias=True)

    def forward(self, x):
        square_of_sum = np.sum(self.embedding(x), axis=1) ** 2
        sum_of_square = np.sum(self.embedding(x) ** 2, axis=1)
        x = self.linear_layer(self.fc(x).sum(1)) \
            + 0.5 * (square_of_sum - sum_of_square).sum(1, keepdims=True)
        x = npx.sigmoid(x)
        return x
</code></pre>
<h2 id="load-the-advertising-dataset"><a class="header" href="#load-the-advertising-dataset">Load the Advertising Dataset</a></h2>
<p>We use the CTR data wrapper from the last section to load the online advertising dataset.</p>
<pre><code class="language-{.python .input  n=3}">#@tab mxnet
batch_size = 2048
data_dir = d2l.download_extract('ctr')
train_data = d2l.CTRDataset(os.path.join(data_dir, 'train.csv'))
test_data = d2l.CTRDataset(os.path.join(data_dir, 'test.csv'),
                           feat_mapper=train_data.feat_mapper,
                           defaults=train_data.defaults)
train_iter = gluon.data.DataLoader(
    train_data, shuffle=True, last_batch='rollover', batch_size=batch_size,
    num_workers=d2l.get_dataloader_workers())
test_iter = gluon.data.DataLoader(
    test_data, shuffle=False, last_batch='rollover', batch_size=batch_size,
    num_workers=d2l.get_dataloader_workers())
</code></pre>
<h2 id="train-the-model-1"><a class="header" href="#train-the-model-1">Train the Model</a></h2>
<p>Afterwards, we train the model. The learning rate is set to 0.02 and the embedding size is set to 20 by default. The <code>Adam</code> optimizer and the <code>SigmoidBinaryCrossEntropyLoss</code> loss are used for model training.</p>
<pre><code class="language-{.python .input  n=5}">#@tab mxnet
devices = d2l.try_all_gpus()
net = FM(train_data.field_dims, num_factors=20)
net.initialize(init.Xavier(), ctx=devices)
lr, num_epochs, optimizer = 0.02, 30, 'adam'
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {'learning_rate': lr})
loss = gluon.loss.SigmoidBinaryCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<h2 id="summary-124"><a class="header" href="#summary-124">Summary</a></h2>
<ul>
<li>FM is a general framework that can be applied on a variety of tasks such as regression, classification, and ranking.</li>
<li>Feature interaction/crossing is important for prediction tasks and the 2-way interaction can be efficiently modeled with FM.</li>
</ul>
<h2 id="exercises-142"><a class="header" href="#exercises-142">Exercises</a></h2>
<ul>
<li>Can you test FM on other dataset such as Avazu, MovieLens, and Criteo datasets?</li>
<li>Vary the embedding size to check its impact on performance, can you observe a similar pattern as that of matrix factorization?</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/406">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deep-factorization-machines"><a class="header" href="#deep-factorization-machines">Deep Factorization Machines</a></h1>
<p>Learning effective feature combinations is critical to the success of click-through rate prediction task. Factorization machines model feature interactions in a linear paradigm (e.g., bilinear interactions). This is often insufficient for real-world data where inherent feature crossing structures are usually very complex and nonlinear. What's worse, second-order feature interactions are generally used in factorization machines in practice. Modeling higher degrees of feature combinations with factorization machines is possible theoretically but it is usually not adopted due to numerical instability and high computational complexity.</p>
<p>One effective solution is using deep neural networks. Deep neural networks are powerful in feature representation learning and have the potential to learn sophisticated feature interactions. As such, it is natural to integrate deep neural networks to factorization machines. Adding nonlinear transformation layers to factorization machines gives it the capability to model both low-order feature combinations and high-order feature combinations. Moreover, non-linear inherent structures from inputs can also be captured with deep neural networks. In this section, we will introduce a representative model named deep factorization machines (DeepFM) :cite:<code>Guo.Tang.Ye.ea.2017</code> which combine FM and deep neural networks.</p>
<h2 id="model-architectures-1"><a class="header" href="#model-architectures-1">Model Architectures</a></h2>
<p>DeepFM consists of an FM component and a deep component which are integrated in a parallel structure. The FM component is the same as the 2-way factorization machines which is used to model the low-order feature interactions. The deep component is an MLP that is used to capture high-order feature interactions and nonlinearities. These two components share the same inputs/embeddings and their outputs are summed up as the final prediction. It is worth pointing out that the spirit of DeepFM resembles that of the Wide &amp; Deep architecture which can capture both memorization and generalization. The advantages of DeepFM over the Wide &amp; Deep model is that it reduces the effort of hand-crafted feature engineering by identifying feature combinations automatically.</p>
<p>We omit the description of the FM component for brevity and denote the output as $\hat{y}^{(FM)}$. Readers are referred to the last section for more details. Let $\mathbf{e}_i \in \mathbb{R}^{k}$ denote the latent feature vector of the $i^\textrm{th}$ field.  The input of the deep component is the concatenation of the dense embeddings of all fields that are looked up with the sparse categorical feature input, denoted as:</p>
<p>$$
\mathbf{z}^{(0)}  = [\mathbf{e}_1, \mathbf{e}_2, ..., \mathbf{e}_f],
$$</p>
<p>where $f$ is the number of fields.  It is then fed into the following neural network:</p>
<p>$$
\mathbf{z}^{(l)}  = \alpha(\mathbf{W}^{(l)}\mathbf{z}^{(l-1)} + \mathbf{b}^{(l)}),
$$</p>
<p>where $\alpha$ is the activation function.  $\mathbf{W}<em>{l}$ and $\mathbf{b}</em>{l}$ are the weight and bias at the $l^\textrm{th}$ layer. Let $y_{DNN}$ denote the output of the prediction. The ultimate prediction of DeepFM is the summation of the outputs from both FM and DNN. So we have:</p>
<p>$$
\hat{y} = \sigma(\hat{y}^{(FM)} + \hat{y}^{(DNN)}),
$$</p>
<p>where $\sigma$ is the sigmoid function. The architecture of DeepFM is illustrated below.
<img src="chapter_recommender-systems/../img/rec-deepfm.svg" alt="Illustration of the DeepFM model" /></p>
<p>It is worth noting that DeepFM is not the only way to combine deep neural networks with FM. We can also add nonlinear layers over the feature interactions :cite:<code>He.Chua.2017</code>.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import init, gluon, np, npx
from mxnet.gluon import nn
import os

npx.set_np()
</code></pre>
<h2 id="implementation-of-deepfm"><a class="header" href="#implementation-of-deepfm">Implementation of DeepFM</a></h2>
<p>The implementation of DeepFM is similar to that of FM. We keep the FM part unchanged and use an MLP block with <code>relu</code> as the activation function. Dropout is also used to regularize the model. The number of neurons of the MLP can be adjusted with the <code>mlp_dims</code> hyperparameter.</p>
<pre><code class="language-{.python .input  n=2}">#@tab mxnet
class DeepFM(nn.Block):
    def __init__(self, field_dims, num_factors, mlp_dims, drop_rate=0.1):
        super(DeepFM, self).__init__()
        num_inputs = int(sum(field_dims))
        self.embedding = nn.Embedding(num_inputs, num_factors)
        self.fc = nn.Embedding(num_inputs, 1)
        self.linear_layer = nn.Dense(1, use_bias=True)
        input_dim = self.embed_output_dim = len(field_dims) * num_factors
        self.mlp = nn.Sequential()
        for dim in mlp_dims:
            self.mlp.add(nn.Dense(dim, 'relu', True, in_units=input_dim))
            self.mlp.add(nn.Dropout(rate=drop_rate))
            input_dim = dim
        self.mlp.add(nn.Dense(in_units=input_dim, units=1))

    def forward(self, x):
        embed_x = self.embedding(x)
        square_of_sum = np.sum(embed_x, axis=1) ** 2
        sum_of_square = np.sum(embed_x ** 2, axis=1)
        inputs = np.reshape(embed_x, (-1, self.embed_output_dim))
        x = self.linear_layer(self.fc(x).sum(1)) \
            + 0.5 * (square_of_sum - sum_of_square).sum(1, keepdims=True) \
            + self.mlp(inputs)
        x = npx.sigmoid(x)
        return x
</code></pre>
<h2 id="training-and-evaluating-the-model-7"><a class="header" href="#training-and-evaluating-the-model-7">Training and Evaluating the Model</a></h2>
<p>The data loading process is the same as that of FM. We set the MLP component of DeepFM to a three-layered dense network with the a pyramid structure (30-20-10). All other hyperparameters remain the same as FM.</p>
<pre><code class="language-{.python .input  n=4}">#@tab mxnet
batch_size = 2048
data_dir = d2l.download_extract('ctr')
train_data = d2l.CTRDataset(os.path.join(data_dir, 'train.csv'))
test_data = d2l.CTRDataset(os.path.join(data_dir, 'test.csv'),
                           feat_mapper=train_data.feat_mapper,
                           defaults=train_data.defaults)
field_dims = train_data.field_dims
train_iter = gluon.data.DataLoader(
    train_data, shuffle=True, last_batch='rollover', batch_size=batch_size,
    num_workers=d2l.get_dataloader_workers())
test_iter = gluon.data.DataLoader(
    test_data, shuffle=False, last_batch='rollover', batch_size=batch_size,
    num_workers=d2l.get_dataloader_workers())
devices = d2l.try_all_gpus()
net = DeepFM(field_dims, num_factors=10, mlp_dims=[30, 20, 10])
net.initialize(init.Xavier(), ctx=devices)
lr, num_epochs, optimizer = 0.01, 30, 'adam'
trainer = gluon.Trainer(net.collect_params(), optimizer,
                        {'learning_rate': lr})
loss = gluon.loss.SigmoidBinaryCrossEntropyLoss()
d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
</code></pre>
<p>Compared with FM, DeepFM converges faster and achieves better performance.</p>
<h2 id="summary-125"><a class="header" href="#summary-125">Summary</a></h2>
<ul>
<li>Integrating neural networks to FM enables it to model complex and high-order interactions.</li>
<li>DeepFM outperforms the original FM on the advertising dataset.</li>
</ul>
<h2 id="exercises-143"><a class="header" href="#exercises-143">Exercises</a></h2>
<ul>
<li>Vary the structure of the MLP to check its impact on model performance.</li>
<li>Change the dataset to Criteo and compare it with the original FM model.</li>
</ul>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/407">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-mathematics-for-deep-learning"><a class="header" href="#appendix-mathematics-for-deep-learning">Appendix: Mathematics for Deep Learning</a></h1>
<p>:label:<code>chap_appendix_math</code></p>
<p><strong>Brent Werness</strong> (<em>Amazon</em>), <strong>Rachel Hu</strong> (<em>Amazon</em>), and authors of this book</p>
<p>One of the wonderful parts of modern deep learning is the fact that much of it can be understood and used without a full understanding of the mathematics below it.  This is a sign that the field is maturing.  Just as most software developers no longer need to worry about the theory of computable functions, neither should deep learning practitioners need to worry about the theoretical foundations of maximum likelihood learning.</p>
<p>But, we are not quite there yet.</p>
<p>In practice, you will sometimes need to understand how architectural choices influence gradient flow, or the implicit assumptions you make by training with a certain loss function.  You might need to know what in the world entropy measures, and how it can help you understand exactly what bits-per-character means in your model.  These all require deeper mathematical understanding.</p>
<p>This appendix aims to provide you the mathematical background you need to understand the core theory of modern deep learning, but it is not exhaustive.  We will begin with examining linear algebra in greater depth.  We develop a geometric understanding of all the common linear algebraic objects and operations that will enable us to visualize the effects of various transformations on our data.  A key element is the development of the basics of eigen-decompositions.</p>
<p>We next develop the theory of differential calculus to the point that we can fully understand why the gradient is the direction of steepest descent, and why back-propagation takes the form it does.  Integral calculus is then discussed to the degree needed to support our next topic, probability theory.</p>
<p>Problems encountered in practice frequently are not certain, and thus we need a language to speak about uncertain things.  We review the theory of random variables and the most commonly encountered distributions so we may discuss models probabilistically.  This provides the foundation for the naive Bayes classifier, a probabilistic classification technique.</p>
<p>Closely related to probability theory is the study of statistics.  While statistics is far too large a field to do justice in a short section, we will introduce fundamental concepts that all machine learning practitioners should be aware of, in particular: evaluating and comparing estimators, conducting hypothesis tests, and constructing confidence intervals.</p>
<p>Last, we turn to the topic of information theory, which is the mathematical study of information storage and transmission.  This provides the core language by which we may discuss quantitatively how much information a model holds on a domain of discourse.</p>
<p>Taken together, these form the core of the mathematical concepts needed to begin down the path towards a deep understanding of deep learning.</p>
<pre><code class="language-toc">:maxdepth: 2

geometry-linear-algebraic-ops
eigendecomposition
single-variable-calculus
multivariable-calculus
integral-calculus
random-variables
maximum-likelihood
distributions
naive-bayes
statistics
information-theory
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-linear-algebraic-operations"><a class="header" href="#geometry-and-linear-algebraic-operations">Geometry and Linear Algebraic Operations</a></h1>
<p>:label:<code>sec_geometry-linear-algebraic-ops</code></p>
<p>In :numref:<code>sec_linear-algebra</code>, we encountered the basics of linear algebra
and saw how it could be used to express common operations for transforming our data.
Linear algebra is one of the key mathematical pillars
underlying much of the work that we do in deep learning
and in machine learning more broadly.
While :numref:<code>sec_linear-algebra</code> contained enough machinery
to communicate the mechanics of modern deep learning models,
there is a lot more to the subject.
In this section, we will go deeper,
highlighting some geometric interpretations of linear algebra operations,
and introducing a few fundamental concepts, including of eigenvalues and eigenvectors.</p>
<h2 id="geometry-of-vectors"><a class="header" href="#geometry-of-vectors">Geometry of Vectors</a></h2>
<p>First, we need to discuss the two common geometric interpretations of vectors,
as either points or directions in space.
Fundamentally, a vector is a list of numbers such as the Python list below.</p>
<pre><code class="language-{.python .input}">#@tab all
v = [1, 7, 0, 1]
</code></pre>
<p>Mathematicians most often write this as either a <em>column</em> or <em>row</em> vector, which is to say either as</p>
<p>$$
\mathbf{x} = \begin{bmatrix}1\7\0\1\end{bmatrix},
$$</p>
<p>or</p>
<p>$$
\mathbf{x}^\top = \begin{bmatrix}1 &amp; 7 &amp; 0 &amp; 1\end{bmatrix}.
$$</p>
<p>These often have different interpretations,
where data examples are column vectors
and weights used to form weighted sums are row vectors.
However, it can be beneficial to be flexible.
As we have described in :numref:<code>sec_linear-algebra</code>,
though a single vector's default orientation is a column vector,
for any matrix representing a tabular dataset,
treating each data example as a row vector
in the matrix
is more conventional.</p>
<p>Given a vector, the first interpretation
that we should give it is as a point in space.
In two or three dimensions, we can visualize these points
by using the components of the vectors to define
the location of the points in space compared
to a fixed reference called the <em>origin</em>.  This can be seen in :numref:<code>fig_grid</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/grid-points.svg" alt="An illustration of visualizing vectors as points in the plane.  The first component of the vector gives the $\mathit{x}$-coordinate, the second component gives the $\mathit{y}$-coordinate.  Higher dimensions are analogous, although much harder to visualize." />
:label:<code>fig_grid</code></p>
<p>This geometric point of view allows us to consider the problem on a more abstract level.
No longer faced with some insurmountable seeming problem
like classifying pictures as either cats or dogs,
we can start considering tasks abstractly
as collections of points in space and picturing the task
as discovering how to separate two distinct clusters of points.</p>
<p>In parallel, there is a second point of view
that people often take of vectors: as directions in space.
Not only can we think of the vector $\mathbf{v} = [3,2]^\top$
as the location $3$ units to the right and $2$ units up from the origin,
we can also think of it as the direction itself
to take $3$ steps to the right and $2$ steps up.
In this way, we consider all the vectors in figure :numref:<code>fig_arrow</code> the same.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/par-vec.svg" alt="Any vector can be visualized as an arrow in the plane.  In this case, every vector drawn is a representation of the vector $(3,2)^\top$." />
:label:<code>fig_arrow</code></p>
<p>One of the benefits of this shift is that
we can make visual sense of the act of vector addition.
In particular, we follow the directions given by one vector,
and then follow the directions given by the other, as is seen in :numref:<code>fig_add-vec</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/vec-add.svg" alt="We can visualize vector addition by first following one vector, and then another." />
:label:<code>fig_add-vec</code></p>
<p>Vector subtraction has a similar interpretation.
By considering the identity that $\mathbf{u} = \mathbf{v} + (\mathbf{u}-\mathbf{v})$,
we see that the vector $\mathbf{u}-\mathbf{v}$ is the direction
that takes us from the point $\mathbf{v}$ to the point $\mathbf{u}$.</p>
<h2 id="dot-products-and-angles"><a class="header" href="#dot-products-and-angles">Dot Products and Angles</a></h2>
<p>As we saw in :numref:<code>sec_linear-algebra</code>,
if we take two column vectors $\mathbf{u}$ and $\mathbf{v}$,
we can form their dot product by computing:</p>
<p>$$\mathbf{u}^\top\mathbf{v} = \sum_i u_i\cdot v_i.$$
:eqlabel:<code>eq_dot_def</code></p>
<p>Because :eqref:<code>eq_dot_def</code> is symmetric, we will mirror the notation
of classical multiplication and write</p>
<p>$$
\mathbf{u}\cdot\mathbf{v} = \mathbf{u}^\top\mathbf{v} = \mathbf{v}^\top\mathbf{u},
$$</p>
<p>to highlight the fact that exchanging the order of the vectors will yield the same answer.</p>
<p>The dot product :eqref:<code>eq_dot_def</code> also admits a geometric interpretation: it is closely related to the angle between two vectors.  Consider the angle shown in :numref:<code>fig_angle</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/vec-angle.svg" alt="Between any two vectors in the plane there is a well defined angle $\theta$.  We will see this angle is intimately tied to the dot product." />
:label:<code>fig_angle</code></p>
<p>To start, let's consider two specific vectors:</p>
<p>$$
\mathbf{v} = (r,0) ; \textrm{and} ; \mathbf{w} = (s\cos(\theta), s \sin(\theta)).
$$</p>
<p>The vector $\mathbf{v}$ is length $r$ and runs parallel to the $x$-axis,
and the vector $\mathbf{w}$ is of length $s$ and at angle $\theta$ with the $x$-axis.
If we compute the dot product of these two vectors, we see that</p>
<p>$$
\mathbf{v}\cdot\mathbf{w} = rs\cos(\theta) = |\mathbf{v}||\mathbf{w}|\cos(\theta).
$$</p>
<p>With some simple algebraic manipulation, we can rearrange terms to obtain</p>
<p>$$
\theta = \arccos\left(\frac{\mathbf{v}\cdot\mathbf{w}}{|\mathbf{v}||\mathbf{w}|}\right).
$$</p>
<p>In short, for these two specific vectors,
the dot product combined with the norms tell us the angle between the two vectors. This same fact is true in general. We will not derive the expression here, however,
if we consider writing $|\mathbf{v} - \mathbf{w}|^2$ in two ways:
one with the dot product, and the other geometrically using the law of cosines,
we can obtain the full relationship.
Indeed, for any two vectors $\mathbf{v}$ and $\mathbf{w}$,
the angle between the two vectors is</p>
<p>$$\theta = \arccos\left(\frac{\mathbf{v}\cdot\mathbf{w}}{|\mathbf{v}||\mathbf{w}|}\right).$$
:eqlabel:<code>eq_angle_forumla</code></p>
<p>This is a nice result since nothing in the computation references two-dimensions.
Indeed, we can use this in three or three million dimensions without issue.</p>
<p>As a simple example, let's see how to compute the angle between a pair of vectors:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from mxnet import gluon, np, npx
npx.set_np()

def angle(v, w):
    return np.arccos(v.dot(w) / (np.linalg.norm(v) * np.linalg.norm(w)))

angle(np.array([0, 1, 2]), np.array([2, 3, 4]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
import torch
from torchvision import transforms
import torchvision

def angle(v, w):
    return torch.acos(v.dot(w) / (torch.norm(v) * torch.norm(w)))

angle(torch.tensor([0, 1, 2], dtype=torch.float32), torch.tensor([2.0, 3, 4]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
import tensorflow as tf

def angle(v, w):
    return tf.acos(tf.tensordot(v, w, axes=1) / (tf.norm(v) * tf.norm(w)))

angle(tf.constant([0, 1, 2], dtype=tf.float32), tf.constant([2.0, 3, 4]))
</code></pre>
<p>We will not use it right now, but it is useful to know
that we will refer to vectors for which the angle is $\pi/2$
(or equivalently $90^{\circ}$) as being <em>orthogonal</em>.
By examining the equation above, we see that this happens when $\theta = \pi/2$,
which is the same thing as $\cos(\theta) = 0$.
The only way this can happen is if the dot product itself is zero,
and two vectors are orthogonal if and only if $\mathbf{v}\cdot\mathbf{w} = 0$.
This will prove to be a helpful formula when understanding objects geometrically.</p>
<p>It is reasonable to ask: why is computing the angle useful?
The answer comes in the kind of invariance we expect data to have.
Consider an image, and a duplicate image,
where every pixel value is the same but $10%$ the brightness.
The values of the individual pixels are in general far from the original values.
Thus, if one computed the distance between the original image and the darker one,
the distance can be large.
However, for most ML applications, the <em>content</em> is the same---it is still
an image of a cat as far as a cat/dog classifier is concerned.
However, if we consider the angle, it is not hard to see
that for any vector $\mathbf{v}$, the angle
between $\mathbf{v}$ and $0.1\cdot\mathbf{v}$ is zero.
This corresponds to the fact that scaling vectors
keeps the same direction and just changes the length.
The angle considers the darker image identical.</p>
<p>Examples like this are everywhere.
In text, we might want the topic being discussed
to not change if we write twice as long of document that says the same thing.
For some encoding (such as counting the number of occurrences of words in some vocabulary), this corresponds to a doubling of the vector encoding the document,
so again we can use the angle.</p>
<h3 id="cosine-similarity"><a class="header" href="#cosine-similarity">Cosine Similarity</a></h3>
<p>In ML contexts where the angle is employed
to measure the closeness of two vectors,
practitioners adopt the term <em>cosine similarity</em>
to refer to the portion
$$
\cos(\theta) = \frac{\mathbf{v}\cdot\mathbf{w}}{|\mathbf{v}||\mathbf{w}|}.
$$</p>
<p>The cosine takes a maximum value of $1$
when the two vectors point in the same direction,
a minimum value of $-1$ when they point in opposite directions,
and a value of $0$ when the two vectors are orthogonal.
Note that if the components of high-dimensional vectors
are sampled randomly with mean $0$,
their cosine will nearly always be close to $0$.</p>
<h2 id="hyperplanes"><a class="header" href="#hyperplanes">Hyperplanes</a></h2>
<p>In addition to working with vectors, another key object
that you must understand to go far in linear algebra
is the <em>hyperplane</em>, a generalization to higher dimensions
of a line (two dimensions) or of a plane (three dimensions).
In an $d$-dimensional vector space, a hyperplane has $d-1$ dimensions
and divides the space into two half-spaces.</p>
<p>Let's start with an example.
Suppose that we have a column vector $\mathbf{w}=[2,1]^\top$. We want to know, "what are the points $\mathbf{v}$ with $\mathbf{w}\cdot\mathbf{v} = 1$?"
By recalling the connection between dot products and angles above :eqref:<code>eq_angle_forumla</code>,
we can see that this is equivalent to
$$
|\mathbf{v}||\mathbf{w}|\cos(\theta) = 1 ; \iff ; |\mathbf{v}|\cos(\theta) = \frac{1}{|\mathbf{w}|} = \frac{1}{\sqrt{5}}.
$$</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/proj-vec.svg" alt="Recalling trigonometry, we see the formula $|\mathbf{v}|\cos(\theta)$ is the length of the projection of the vector $\mathbf{v}$ onto the direction of $\mathbf{w}$" />
:label:<code>fig_vector-project</code></p>
<p>If we consider the geometric meaning of this expression,
we see that this is equivalent to saying
that the length of the projection of $\mathbf{v}$
onto the direction of $\mathbf{w}$ is exactly $1/|\mathbf{w}|$, as is shown in :numref:<code>fig_vector-project</code>.
The set of all points where this is true is a line
at right angles to the vector $\mathbf{w}$.
If we wanted, we could find the equation for this line
and see that it is $2x + y = 1$ or equivalently $y = 1 - 2x$.</p>
<p>If we now look at what happens when we ask about the set of points with
$\mathbf{w}\cdot\mathbf{v} &gt; 1$ or $\mathbf{w}\cdot\mathbf{v} &lt; 1$,
we can see that these are cases where the projections
are longer or shorter than $1/|\mathbf{w}|$, respectively.
Thus, those two inequalities define either side of the line.
In this way, we have found a way to cut our space into two halves,
where all the points on one side have dot product below a threshold,
and the other side above as we see in :numref:<code>fig_space-division</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/space-division.svg" alt="If we now consider the inequality version of the expression, we see that our hyperplane (in this case: just a line) separates the space into two halves." />
:label:<code>fig_space-division</code></p>
<p>The story in higher dimension is much the same.
If we now take $\mathbf{w} = [1,2,3]^\top$
and ask about the points in three dimensions with $\mathbf{w}\cdot\mathbf{v} = 1$,
we obtain a plane at right angles to the given vector $\mathbf{w}$.
The two inequalities again define the two sides of the plane as is shown in :numref:<code>fig_higher-division</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/space-division-3d.svg" alt="Hyperplanes in any dimension separate the space into two halves." />
:label:<code>fig_higher-division</code></p>
<p>While our ability to visualize runs out at this point,
nothing stops us from doing this in tens, hundreds, or billions of dimensions.
This occurs often when thinking about machine learned models.
For instance, we can understand linear classification models
like those from :numref:<code>sec_softmax</code>,
as methods to find hyperplanes that separate the different target classes.
In this context, such hyperplanes are often referred to as <em>decision planes</em>.
The majority of deep learned classification models end
with a linear layer fed into a softmax,
so one can interpret the role of the deep neural network
to be to find a non-linear embedding such that the target classes
can be separated cleanly by hyperplanes.</p>
<p>To give a hand-built example, notice that we can produce a reasonable model
to classify tiny images of t-shirts and trousers from the Fashion-MNIST dataset
(seen in :numref:<code>sec_fashion_mnist</code>)
by just taking the vector between their means to define the decision plane
and eyeball a crude threshold.  First we will load the data and compute the averages.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Load in the dataset
train = gluon.data.vision.FashionMNIST(train=True)
test = gluon.data.vision.FashionMNIST(train=False)

X_train_0 = np.stack([x[0] for x in train if x[1] == 0]).astype(float)
X_train_1 = np.stack([x[0] for x in train if x[1] == 1]).astype(float)
X_test = np.stack(
    [x[0] for x in test if x[1] == 0 or x[1] == 1]).astype(float)
y_test = np.stack(
    [x[1] for x in test if x[1] == 0 or x[1] == 1]).astype(float)

# Compute averages
ave_0 = np.mean(X_train_0, axis=0)
ave_1 = np.mean(X_train_1, axis=0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Load in the dataset
trans = []
trans.append(transforms.ToTensor())
trans = transforms.Compose(trans)
train = torchvision.datasets.FashionMNIST(root="../data", transform=trans,
                                          train=True, download=True)
test = torchvision.datasets.FashionMNIST(root="../data", transform=trans,
                                         train=False, download=True)

X_train_0 = torch.stack(
    [x[0] * 256 for x in train if x[1] == 0]).type(torch.float32)
X_train_1 = torch.stack(
    [x[0] * 256 for x in train if x[1] == 1]).type(torch.float32)
X_test = torch.stack(
    [x[0] * 256 for x in test if x[1] == 0 or x[1] == 1]).type(torch.float32)
y_test = torch.stack([torch.tensor(x[1]) for x in test
                      if x[1] == 0 or x[1] == 1]).type(torch.float32)

# Compute averages
ave_0 = torch.mean(X_train_0, axis=0)
ave_1 = torch.mean(X_train_1, axis=0)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Load in the dataset
((train_images, train_labels), (
    test_images, test_labels)) = tf.keras.datasets.fashion_mnist.load_data()


X_train_0 = tf.cast(tf.stack(train_images[[i for i, label in enumerate(
    train_labels) if label == 0]] * 256), dtype=tf.float32)
X_train_1 = tf.cast(tf.stack(train_images[[i for i, label in enumerate(
    train_labels) if label == 1]] * 256), dtype=tf.float32)
X_test = tf.cast(tf.stack(test_images[[i for i, label in enumerate(
    test_labels) if label == 0]] * 256), dtype=tf.float32)
y_test = tf.cast(tf.stack(test_images[[i for i, label in enumerate(
    test_labels) if label == 1]] * 256), dtype=tf.float32)

# Compute averages
ave_0 = tf.reduce_mean(X_train_0, axis=0)
ave_1 = tf.reduce_mean(X_train_1, axis=0)
</code></pre>
<p>It can be informative to examine these averages in detail, so let's plot what they look like.  In this case, we see that the average indeed resembles a blurry image of a t-shirt.</p>
<pre><code class="language-{.python .input}">#@tab mxnet, pytorch
# Plot average t-shirt
d2l.set_figsize()
d2l.plt.imshow(ave_0.reshape(28, 28).tolist(), cmap='Greys')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot average t-shirt
d2l.set_figsize()
d2l.plt.imshow(tf.reshape(ave_0, (28, 28)), cmap='Greys')
d2l.plt.show()
</code></pre>
<p>In the second case, we again see that the average resembles a blurry image of trousers.</p>
<pre><code class="language-{.python .input}">#@tab mxnet, pytorch
# Plot average trousers
d2l.plt.imshow(ave_1.reshape(28, 28).tolist(), cmap='Greys')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot average trousers
d2l.plt.imshow(tf.reshape(ave_1, (28, 28)), cmap='Greys')
d2l.plt.show()
</code></pre>
<p>In a fully machine learned solution, we would learn the threshold from the dataset.  In this case, I simply eyeballed a threshold that looked good on the training data by hand.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Print test set accuracy with eyeballed threshold
w = (ave_1 - ave_0).T
predictions = X_test.reshape(2000, -1).dot(w.flatten()) &gt; -1500000

# Accuracy
np.mean(predictions.astype(y_test.dtype) == y_test, dtype=np.float64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Print test set accuracy with eyeballed threshold
w = (ave_1 - ave_0).T
# '@' is Matrix Multiplication operator in pytorch.
predictions = X_test.reshape(2000, -1) @ (w.flatten()) &gt; -1500000

# Accuracy
torch.mean((predictions.type(y_test.dtype) == y_test).float(), dtype=torch.float64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Print test set accuracy with eyeballed threshold
w = tf.transpose(ave_1 - ave_0)
predictions = tf.reduce_sum(X_test * tf.nest.flatten(w), axis=0) &gt; -1500000

# Accuracy
tf.reduce_mean(
    tf.cast(tf.cast(predictions, y_test.dtype) == y_test, tf.float32))
</code></pre>
<h2 id="geometry-of-linear-transformations"><a class="header" href="#geometry-of-linear-transformations">Geometry of Linear Transformations</a></h2>
<p>Through :numref:<code>sec_linear-algebra</code> and the above discussions,
we have a solid understanding of the geometry of vectors, lengths, and angles.
However, there is one important object we have omitted discussing,
and that is a geometric understanding of linear transformations represented by matrices.  Fully internalizing what matrices can do to transform data
between two potentially different high dimensional spaces takes significant practice,
and is beyond the scope of this appendix.
However, we can start building up intuition in two dimensions.</p>
<p>Suppose that we have some matrix:</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
a &amp; b \ c &amp; d
\end{bmatrix}.
$$</p>
<p>If we want to apply this to an arbitrary vector
$\mathbf{v} = [x, y]^\top$,
we multiply and see that</p>
<p>$$
\begin{aligned}
\mathbf{A}\mathbf{v} &amp; = \begin{bmatrix}a &amp; b \ c &amp; d\end{bmatrix}\begin{bmatrix}x \ y\end{bmatrix} \
&amp; = \begin{bmatrix}ax+by\ cx+dy\end{bmatrix} \
&amp; = x\begin{bmatrix}a \ c\end{bmatrix} + y\begin{bmatrix}b \d\end{bmatrix} \
&amp; = x\left{\mathbf{A}\begin{bmatrix}1\0\end{bmatrix}\right} + y\left{\mathbf{A}\begin{bmatrix}0\1\end{bmatrix}\right}.
\end{aligned}
$$</p>
<p>This may seem like an odd computation,
where something clear became somewhat impenetrable.
However, it tells us that we can write the way
that a matrix transforms <em>any</em> vector
in terms of how it transforms <em>two specific vectors</em>:
$[1,0]^\top$ and $[0,1]^\top$.
This is worth considering for a moment.
We have essentially reduced an infinite problem
(what happens to any pair of real numbers)
to a finite one (what happens to these specific vectors).
These vectors are an example a <em>basis</em>,
where we can write any vector in our space
as a weighted sum of these <em>basis vectors</em>.</p>
<p>Let's draw what happens when we use the specific matrix</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
1 &amp; 2 \
-1 &amp; 3
\end{bmatrix}.
$$</p>
<p>If we look at the specific vector $\mathbf{v} = [2, -1]^\top$,
we see this is $2\cdot[1,0]^\top + -1\cdot[0,1]^\top$,
and thus we know that the matrix $A$ will send this to
$2(\mathbf{A}[1,0]^\top) + -1(\mathbf{A}[0,1])^\top = 2[1, -1]^\top - [2,3]^\top = [0, -5]^\top$.
If we follow this logic through carefully,
say by considering the grid of all integer pairs of points,
we see that what happens is that the matrix multiplication
can skew, rotate, and scale the grid,
but the grid structure must remain as you see in :numref:<code>fig_grid-transform</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/grid-transform.svg" alt="The matrix $\mathbf{A}$ acting on the given basis vectors.  Notice how the entire grid is transported along with it." />
:label:<code>fig_grid-transform</code></p>
<p>This is the most important intuitive point
to internalize about linear transformations represented by matrices.
Matrices are incapable of distorting some parts of space differently than others.
All they can do is take the original coordinates on our space
and skew, rotate, and scale them.</p>
<p>Some distortions can be severe.  For instance the matrix</p>
<p>$$
\mathbf{B} = \begin{bmatrix}
2 &amp; -1 \ 4 &amp; -2
\end{bmatrix},
$$</p>
<p>compresses the entire two-dimensional plane down to a single line.
Identifying and working with such transformations are the topic of a later section,
but geometrically we can see that this is fundamentally different
from the types of transformations we saw above.
For instance, the result from matrix $\mathbf{A}$ can be "bent back" to the original grid.  The results from matrix $\mathbf{B}$ cannot
because we will never know where the vector $[1,2]^\top$ came from---was
it $[1,1]^\top$ or $[0, -1]^\top$?</p>
<p>While this picture was for a $2\times2$ matrix,
nothing prevents us from taking the lessons learned into higher dimensions.
If we take similar basis vectors like $[1,0, \ldots,0]$
and see where our matrix sends them,
we can start to get a feeling for how the matrix multiplication
distorts the entire space in whatever dimension space we are dealing with.</p>
<h2 id="linear-dependence"><a class="header" href="#linear-dependence">Linear Dependence</a></h2>
<p>Consider again the matrix</p>
<p>$$
\mathbf{B} = \begin{bmatrix}
2 &amp; -1 \ 4 &amp; -2
\end{bmatrix}.
$$</p>
<p>This compresses the entire plane down to live on the single line $y = 2x$.
The question now arises: is there some way we can detect this
just looking at the matrix itself?
The answer is that indeed we can.
Let's take $\mathbf{b}_1 = [2,4]^\top$ and $\mathbf{b}_2 = [-1, -2]^\top$
be the two columns of $\mathbf{B}$.
Remember that we can write everything transformed by the matrix $\mathbf{B}$
as a weighted sum of the columns of the matrix:
like $a_1\mathbf{b}_1 + a_2\mathbf{b}_2$.
We call this a <em>linear combination</em>.
The fact that $\mathbf{b}_1 = -2\cdot\mathbf{b}_2$
means that we can write any linear combination of those two columns
entirely in terms of say $\mathbf{b}_2$ since</p>
<p>$$
a_1\mathbf{b}_1 + a_2\mathbf{b}_2 = -2a_1\mathbf{b}_2 + a_2\mathbf{b}_2 = (a_2-2a_1)\mathbf{b}_2.
$$</p>
<p>This means that one of the columns is, in a sense, redundant
because it does not define a unique direction in space.
This should not surprise us too much
since we already saw that this matrix
collapses the entire plane down into a single line.
Moreover, we see that the linear dependence
$\mathbf{b}_1 = -2\cdot\mathbf{b}_2$ captures this.
To make this more symmetrical between the two vectors, we will write this as</p>
<p>$$
\mathbf{b}_1  + 2\cdot\mathbf{b}_2 = 0.
$$</p>
<p>In general, we will say that a collection of vectors
$\mathbf{v}_1, \ldots, \mathbf{v}_k$ are <em>linearly dependent</em>
if there exist coefficients $a_1, \ldots, a_k$ <em>not all equal to zero</em> so that</p>
<p>$$
\sum_{i=1}^k a_i\mathbf{v_i} = 0.
$$</p>
<p>In this case, we can solve for one of the vectors
in terms of some combination of the others,
and effectively render it redundant.
Thus, a linear dependence in the columns of a matrix
is a witness to the fact that our matrix
is compressing the space down to some lower dimension.
If there is no linear dependence we say the vectors are <em>linearly independent</em>.
If the columns of a matrix are linearly independent,
no compression occurs and the operation can be undone.</p>
<h2 id="rank"><a class="header" href="#rank">Rank</a></h2>
<p>If we have a general $n\times m$ matrix,
it is reasonable to ask what dimension space the matrix maps into.
A concept known as the <em>rank</em> will be our answer.
In the previous section, we noted that a linear dependence
bears witness to compression of space into a lower dimension
and so we will be able to use this to define the notion of rank.
In particular, the rank of a matrix $\mathbf{A}$
is the largest number of linearly independent columns
amongst all subsets of columns. For example, the matrix</p>
<p>$$
\mathbf{B} = \begin{bmatrix}
2 &amp; 4 \ -1 &amp; -2
\end{bmatrix},
$$</p>
<p>has $\textrm{rank}(B)=1$, since the two columns are linearly dependent,
but either column by itself is not linearly dependent.
For a more challenging example, we can consider</p>
<p>$$
\mathbf{C} = \begin{bmatrix}
1&amp; 3 &amp; 0 &amp; -1 &amp; 0 \
-1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 \
0 &amp; 3 &amp; 1 &amp; 0 &amp; -1 \
2 &amp; 3 &amp; -1 &amp; -2 &amp; 1
\end{bmatrix},
$$</p>
<p>and show that $\mathbf{C}$ has rank two since, for instance,
the first two columns are linearly independent,
however any of the four collections of three columns are dependent.</p>
<p>This procedure, as described, is very inefficient.
It requires looking at every subset of the columns of our given matrix,
and thus is potentially exponential in the number of columns.
Later we will see a more computationally efficient way
to compute the rank of a matrix, but for now,
this is sufficient to see that the concept
is well defined and understand the meaning.</p>
<h2 id="invertibility"><a class="header" href="#invertibility">Invertibility</a></h2>
<p>We have seen above that multiplication by a matrix with linearly dependent columns
cannot be undone, i.e., there is no inverse operation that can always recover the input.  However, multiplication by a full-rank matrix
(i.e., some $\mathbf{A}$ that is $n \times n$ matrix with rank $n$),
we should always be able to undo it.  Consider the matrix</p>
<p>$$
\mathbf{I} = \begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \
0 &amp; 1 &amp; \cdots &amp; 0 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}.
$$</p>
<p>which is the matrix with ones along the diagonal, and zeros elsewhere.
We call this the <em>identity</em> matrix.
It is the matrix which leaves our data unchanged when applied.
To find a matrix which undoes what our matrix $\mathbf{A}$ has done,
we want to find a matrix $\mathbf{A}^{-1}$ such that</p>
<p>$$
\mathbf{A}^{-1}\mathbf{A} = \mathbf{A}\mathbf{A}^{-1} =  \mathbf{I}.
$$</p>
<p>If we look at this as a system, we have $n \times n$ unknowns
(the entries of $\mathbf{A}^{-1}$) and $n \times n$ equations
(the equality that needs to hold between every entry of the product $\mathbf{A}^{-1}\mathbf{A}$ and every entry of $\mathbf{I}$)
so we should generically expect a solution to exist.
Indeed, in the next section we will see a quantity called the <em>determinant</em>,
which has the property that as long as the determinant is not zero, we can find a solution.  We call such a matrix $\mathbf{A}^{-1}$ the <em>inverse</em> matrix.
As an example, if $\mathbf{A}$ is the general $2 \times 2$ matrix</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
a &amp; b \
c &amp; d
\end{bmatrix},
$$</p>
<p>then we can see that the inverse is</p>
<p>$$
\frac{1}{ad-bc}  \begin{bmatrix}
d &amp; -b \
-c &amp; a
\end{bmatrix}.
$$</p>
<p>We can test to see this by seeing that multiplying
by the inverse given by the formula above works in practice.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
M = np.array([[1, 2], [1, 4]])
M_inv = np.array([[2, -1], [-0.5, 0.5]])
M_inv.dot(M)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
M = torch.tensor([[1, 2], [1, 4]], dtype=torch.float32)
M_inv = torch.tensor([[2, -1], [-0.5, 0.5]])
M_inv @ M
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
M = tf.constant([[1, 2], [1, 4]], dtype=tf.float32)
M_inv = tf.constant([[2, -1], [-0.5, 0.5]])
tf.matmul(M_inv, M)
</code></pre>
<h3 id="numerical-issues"><a class="header" href="#numerical-issues">Numerical Issues</a></h3>
<p>While the inverse of a matrix is useful in theory,
we must say that most of the time we do not wish
to <em>use</em> the matrix inverse to solve a problem in practice.
In general, there are far more numerically stable algorithms
for solving linear equations like</p>
<p>$$
\mathbf{A}\mathbf{x} = \mathbf{b},
$$</p>
<p>than computing the inverse and multiplying to get</p>
<p>$$
\mathbf{x} = \mathbf{A}^{-1}\mathbf{b}.
$$</p>
<p>Just as division by a small number can lead to numerical instability,
so can inversion of a matrix which is close to having low rank.</p>
<p>Moreover, it is common that the matrix $\mathbf{A}$ is <em>sparse</em>,
which is to say that it contains only a small number of non-zero values.
If we were to explore examples, we would see
that this does not mean the inverse is sparse.
Even if $\mathbf{A}$ was a $1$ million by $1$ million matrix
with only $5$ million non-zero entries
(and thus we need only store those $5$ million),
the inverse will typically have almost every entry non-negative,
requiring us to store all $1\textrm{M}^2$ entries---that is $1$ trillion entries!</p>
<p>While we do not have time to dive all the way into the thorny numerical issues
frequently encountered when working with linear algebra,
we want to provide you with some intuition about when to proceed with caution,
and generally avoiding inversion in practice is a good rule of thumb.</p>
<h2 id="determinant"><a class="header" href="#determinant">Determinant</a></h2>
<p>The geometric view of linear algebra gives an intuitive way
to interpret a fundamental quantity known as the <em>determinant</em>.
Consider the grid image from before, but now with a highlighted region (:numref:<code>fig_grid-filled</code>).</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/grid-transform-filled.svg" alt="The matrix $\mathbf{A}$ again distorting the grid.  This time, I want to draw particular attention to what happens to the highlighted square." />
:label:<code>fig_grid-filled</code></p>
<p>Look at the highlighted square.  This is a square with edges given
by $(0, 1)$ and $(1, 0)$ and thus it has area one.
After $\mathbf{A}$ transforms this square,
we see that it becomes a parallelogram.
There is no reason this parallelogram should have the same area
that we started with, and indeed in the specific case shown here of</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
1 &amp; 2 \
-1 &amp; 3
\end{bmatrix},
$$</p>
<p>it is an exercise in coordinate geometry to compute
the area of this parallelogram and obtain that the area is $5$.</p>
<p>In general, if we have a matrix</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
a &amp; b \
c &amp; d
\end{bmatrix},
$$</p>
<p>we can see with some computation that the area
of the resulting parallelogram is $ad-bc$.
This area is referred to as the <em>determinant</em>.</p>
<p>Let's check this quickly with some example code.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
import numpy as np
np.linalg.det(np.array([[1, -1], [2, 3]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.det(torch.tensor([[1, -1], [2, 3]], dtype=torch.float32))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.linalg.det(tf.constant([[1, -1], [2, 3]], dtype=tf.float32))
</code></pre>
<p>The eagle-eyed amongst us will notice
that this expression can be zero or even negative.
For the negative term, this is a matter of convention
taken generally in mathematics:
if the matrix flips the figure,
we say the area is negated.
Let's see now that when the determinant is zero, we learn more.</p>
<p>Let's consider</p>
<p>$$
\mathbf{B} = \begin{bmatrix}
2 &amp; 4 \ -1 &amp; -2
\end{bmatrix}.
$$</p>
<p>If we compute the determinant of this matrix,
we get $2\cdot(-2 ) - 4\cdot(-1) = 0$.
Given our understanding above, this makes sense.
$\mathbf{B}$ compresses the square from the original image
down to a line segment, which has zero area.
And indeed, being compressed into a lower dimensional space
is the only way to have zero area after the transformation.
Thus we see the following result is true:
a matrix $A$ is invertible if and only if
the determinant is not equal to zero.</p>
<p>As a final comment, imagine that we have any figure drawn on the plane.
Thinking like computer scientists, we can decompose
that figure into a collection of little squares
so that the area of the figure is in essence
just the number of squares in the decomposition.
If we now transform that figure by a matrix,
we send each of these squares to parallelograms,
each one of which has area given by the determinant.
We see that for any figure, the determinant gives the (signed) number
that a matrix scales the area of any figure.</p>
<p>Computing determinants for larger matrices can be laborious,
but the  intuition is the same.
The determinant remains the factor
that $n\times n$ matrices scale $n$-dimensional volumes.</p>
<h2 id="tensors-and-common-linear-algebra-operations"><a class="header" href="#tensors-and-common-linear-algebra-operations">Tensors and Common Linear Algebra Operations</a></h2>
<p>In :numref:<code>sec_linear-algebra</code> the concept of tensors was introduced.
In this section, we will dive more deeply into tensor contractions
(the tensor equivalent of matrix multiplication),
and see how it can provide a unified view
on a number of matrix and vector operations.</p>
<p>With matrices and vectors we knew how to multiply them to transform data.
We need to have a similar definition for tensors if they are to be useful to us.
Think about matrix multiplication:</p>
<p>$$
\mathbf{C} = \mathbf{A}\mathbf{B},
$$</p>
<p>or equivalently</p>
<p>$$ c_{i, j} = \sum_{k} a_{i, k}b_{k, j}.$$</p>
<p>This pattern is one we can repeat for tensors.
For tensors, there is no one case of what
to sum over that can be universally chosen,
so we need specify exactly which indices we want to sum over.
For instance we could consider</p>
<p>$$
y_{il} = \sum_{jk} x_{ijkl}a_{jk}.
$$</p>
<p>Such a transformation is called a <em>tensor contraction</em>.
It can represent a far more flexible family of transformations
that matrix multiplication alone.</p>
<p>As a often-used notational simplification,
we can notice that the sum is over exactly those indices
that occur more than once in the expression,
thus people often work with <em>Einstein notation</em>,
where the summation is implicitly taken over all repeated indices.
This gives the compact expression:</p>
<p>$$
y_{il} = x_{ijkl}a_{jk}.
$$</p>
<h3 id="common-examples-from-linear-algebra"><a class="header" href="#common-examples-from-linear-algebra">Common Examples from Linear Algebra</a></h3>
<p>Let's see how many of the linear algebraic definitions
we have seen before can be expressed in this compressed tensor notation:</p>
<ul>
<li>$\mathbf{v} \cdot \mathbf{w} = \sum_i v_iw_i$</li>
<li>$|\mathbf{v}|_2^{2} = \sum_i v_iv_i$</li>
<li>$(\mathbf{A}\mathbf{v})<em>i = \sum_j a</em>{ij}v_j$</li>
<li>$(\mathbf{A}\mathbf{B})<em>{ik} = \sum_j a</em>{ij}b_{jk}$</li>
<li>$\textrm{tr}(\mathbf{A}) = \sum_i a_{ii}$</li>
</ul>
<p>In this way, we can replace a myriad of specialized notations with short tensor expressions.</p>
<h3 id="expressing-in-code"><a class="header" href="#expressing-in-code">Expressing in Code</a></h3>
<p>Tensors may flexibly be operated on in code as well.
As seen in :numref:<code>sec_linear-algebra</code>,
we can create tensors as is shown below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Define tensors
B = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
A = np.array([[1, 2], [3, 4]])
v = np.array([1, 2])

# Print out the shapes
A.shape, B.shape, v.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Define tensors
B = torch.tensor([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
A = torch.tensor([[1, 2], [3, 4]])
v = torch.tensor([1, 2])

# Print out the shapes
A.shape, B.shape, v.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Define tensors
B = tf.constant([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
A = tf.constant([[1, 2], [3, 4]])
v = tf.constant([1, 2])

# Print out the shapes
A.shape, B.shape, v.shape
</code></pre>
<p>Einstein summation has been implemented directly.
The indices that occurs in the Einstein summation can be passed as a string,
followed by the tensors that are being acted upon.
For instance, to implement matrix multiplication,
we can consider the Einstein summation seen above
($\mathbf{A}\mathbf{v} = a_{ij}v_j$)
and strip out the indices themselves to get the implementation:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Reimplement matrix multiplication
np.einsum("ij, j -&gt; i", A, v), A.dot(v)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Reimplement matrix multiplication
torch.einsum("ij, j -&gt; i", A, v), A@v
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Reimplement matrix multiplication
tf.einsum("ij, j -&gt; i", A, v), tf.matmul(A, tf.reshape(v, (2, 1)))
</code></pre>
<p>This is a highly flexible notation.
For instance if we want to compute
what would be traditionally written as</p>
<p>$$
c_{kl} = \sum_{ij} \mathbf{b}<em>{ijk}\mathbf{a}</em>{il}v_j.
$$</p>
<p>it can be implemented via Einstein summation as:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.einsum("ijk, il, j -&gt; kl", B, A, v)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.einsum("ijk, il, j -&gt; kl", B, A, v)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.einsum("ijk, il, j -&gt; kl", B, A, v)
</code></pre>
<p>This notation is readable and efficient for humans,
however bulky if for whatever reason
we need to generate a tensor contraction programmatically.
For this reason, <code>einsum</code> provides an alternative notation
by providing integer indices for each tensor.
For example, the same tensor contraction can also be written as:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.einsum(B, [0, 1, 2], A, [0, 3], v, [1], [2, 3])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# PyTorch does not support this type of notation.
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# TensorFlow does not support this type of notation.
</code></pre>
<p>Either notation allows for concise and efficient representation of tensor contractions in code.</p>
<h2 id="summary-126"><a class="header" href="#summary-126">Summary</a></h2>
<ul>
<li>Vectors can be interpreted geometrically as either points or directions in space.</li>
<li>Dot products define the notion of angle to arbitrarily high-dimensional spaces.</li>
<li>Hyperplanes are high-dimensional generalizations of lines and planes.  They can be used to define decision planes that are often used as the last step in a classification task.</li>
<li>Matrix multiplication can be geometrically interpreted as uniform distortions of the underlying coordinates. They represent a very restricted, but mathematically clean, way to transform vectors.</li>
<li>Linear dependence is a way to tell when a collection of vectors are in a lower dimensional space than we would expect (say you have $3$ vectors living in a $2$-dimensional space). The rank of a matrix is the size of the largest subset of its columns that are linearly independent.</li>
<li>When a matrix's inverse is defined, matrix inversion allows us to find another matrix that undoes the action of the first. Matrix inversion is useful in theory, but requires care in practice owing to numerical instability.</li>
<li>Determinants allow us to measure how much a matrix expands or contracts a space. A nonzero determinant implies an invertible (non-singular) matrix and a zero-valued determinant means that the matrix is non-invertible (singular).</li>
<li>Tensor contractions and Einstein summation provide for a neat and clean notation for expressing many of the computations that are seen in machine learning.</li>
</ul>
<h2 id="exercises-144"><a class="header" href="#exercises-144">Exercises</a></h2>
<ol>
<li>What is the angle between
$$
\vec v_1 = \begin{bmatrix}
1 \ 0 \ -1 \ 2
\end{bmatrix}, \qquad \vec v_2 = \begin{bmatrix}
3 \ 1 \ 0 \ 1
\end{bmatrix}?
$$</li>
<li>True or false: $\begin{bmatrix}1 &amp; 2\0&amp;1\end{bmatrix}$ and $\begin{bmatrix}1 &amp; -2\0&amp;1\end{bmatrix}$ are inverses of one another?</li>
<li>Suppose that we draw a shape in the plane with area $100\textrm{m}^2$.  What is the area after transforming the figure by the matrix
$$
\begin{bmatrix}
2 &amp; 3\
1 &amp; 2
\end{bmatrix}.
$$</li>
<li>Which of the following sets of vectors are linearly independent?</li>
</ol>
<ul>
<li>$\left{\begin{pmatrix}1\0\-1\end{pmatrix}, \begin{pmatrix}2\1\-1\end{pmatrix}, \begin{pmatrix}3\1\1\end{pmatrix}\right}$</li>
<li>$\left{\begin{pmatrix}3\1\1\end{pmatrix}, \begin{pmatrix}1\1\1\end{pmatrix}, \begin{pmatrix}0\0\0\end{pmatrix}\right}$</li>
<li>$\left{\begin{pmatrix}1\1\0\end{pmatrix}, \begin{pmatrix}0\1\-1\end{pmatrix}, \begin{pmatrix}1\0\1\end{pmatrix}\right}$</li>
</ul>
<ol start="5">
<li>Suppose that you have a matrix written as $A = \begin{bmatrix}c\d\end{bmatrix}\cdot\begin{bmatrix}a &amp; b\end{bmatrix}$ for some choice of values $a, b, c$, and $d$.  True or false: the determinant of such a matrix is always $0$?</li>
<li>The vectors $e_1 = \begin{bmatrix}1\0\end{bmatrix}$ and $e_2 = \begin{bmatrix}0\1\end{bmatrix}$ are orthogonal.  What is the condition on a matrix $A$ so that $Ae_1$ and $Ae_2$ are orthogonal?</li>
<li>How can you write $\textrm{tr}(\mathbf{A}^4)$ in Einstein notation for an arbitrary matrix $A$?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/410">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1084">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1085">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eigendecompositions"><a class="header" href="#eigendecompositions">Eigendecompositions</a></h1>
<p>:label:<code>sec_eigendecompositions</code></p>
<p>Eigenvalues are often one of the most useful notions
we will encounter when studying linear algebra,
however, as a beginner, it is easy to overlook their importance.
Below, we introduce eigendecomposition and
try to convey some sense of just why it is so important.</p>
<p>Suppose that we have a matrix $A$ with the following entries:</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
2 &amp; 0 \
0 &amp; -1
\end{bmatrix}.
$$</p>
<p>If we apply $A$ to any vector $\mathbf{v} = [x, y]^\top$,
we obtain a vector $\mathbf{A}\mathbf{v} = [2x, -y]^\top$.
This has an intuitive interpretation:
stretch the vector to be twice as wide in the $x$-direction,
and then flip it in the $y$-direction.</p>
<p>However, there are <em>some</em> vectors for which something remains unchanged.
Namely $[1, 0]^\top$ gets sent to $[2, 0]^\top$
and $[0, 1]^\top$ gets sent to $[0, -1]^\top$.
These vectors are still in the same line,
and the only modification is that the matrix stretches them
by a factor of $2$ and $-1$ respectively.
We call such vectors <em>eigenvectors</em>
and the factor they are stretched by <em>eigenvalues</em>.</p>
<p>In general, if we can find a number $\lambda$
and a vector $\mathbf{v}$ such that</p>
<p>$$
\mathbf{A}\mathbf{v} = \lambda \mathbf{v}.
$$</p>
<p>We say that $\mathbf{v}$ is an eigenvector for $A$ and $\lambda$ is an eigenvalue.</p>
<h2 id="finding-eigenvalues"><a class="header" href="#finding-eigenvalues">Finding Eigenvalues</a></h2>
<p>Let's figure out how to find them. By subtracting off the $\lambda \mathbf{v}$ from both sides,
and then factoring out the vector,
we see the above is equivalent to:</p>
<p>$$(\mathbf{A} - \lambda \mathbf{I})\mathbf{v} = 0.$$
:eqlabel:<code>eq_eigvalue_der</code></p>
<p>For :eqref:<code>eq_eigvalue_der</code> to happen, we see that $(\mathbf{A} - \lambda \mathbf{I})$
must compress some direction down to zero,
hence it is not invertible, and thus the determinant is zero.
Thus, we can find the <em>eigenvalues</em>
by finding for what $\lambda$ is $\det(\mathbf{A}-\lambda \mathbf{I}) = 0$.
Once we find the eigenvalues, we can solve
$\mathbf{A}\mathbf{v} = \lambda \mathbf{v}$
to find the associated <em>eigenvector(s)</em>.</p>
<h3 id="an-example-2"><a class="header" href="#an-example-2">An Example</a></h3>
<p>Let's see this with a more challenging matrix</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
2 &amp; 1\
2 &amp; 3
\end{bmatrix}.
$$</p>
<p>If we consider $\det(\mathbf{A}-\lambda \mathbf{I}) = 0$,
we see this is equivalent to the polynomial equation
$0 = (2-\lambda)(3-\lambda)-2 = (4-\lambda)(1-\lambda)$.
Thus, two eigenvalues are $4$ and $1$.
To find the associated vectors, we then need to solve</p>
<p>$$
\begin{bmatrix}
2 &amp; 1\
2 &amp; 3
\end{bmatrix}\begin{bmatrix}x \ y\end{bmatrix} = \begin{bmatrix}x \ y\end{bmatrix}  ; \textrm{and} ;
\begin{bmatrix}
2 &amp; 1\
2 &amp; 3
\end{bmatrix}\begin{bmatrix}x \ y\end{bmatrix}  = \begin{bmatrix}4x \ 4y\end{bmatrix} .
$$</p>
<p>We can solve this with the vectors $[1, -1]^\top$ and $[1, 2]^\top$ respectively.</p>
<p>We can check this in code using the built-in <code>numpy.linalg.eig</code> routine.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
import numpy as np

np.linalg.eig(np.array([[2, 1], [2, 3]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
import torch

torch.linalg.eig(torch.tensor([[2, 1], [2, 3]], dtype=torch.float64))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
import tensorflow as tf

tf.linalg.eig(tf.constant([[2, 1], [2, 3]], dtype=tf.float64))
</code></pre>
<p>Note that <code>numpy</code> normalizes the eigenvectors to be of length one,
whereas we took ours to be of arbitrary length.
Additionally, the choice of sign is arbitrary.
However, the vectors computed are parallel
to the ones we found by hand with the same eigenvalues.</p>
<h2 id="decomposing-matrices"><a class="header" href="#decomposing-matrices">Decomposing Matrices</a></h2>
<p>Let's continue the previous example one step further.  Let</p>
<p>$$
\mathbf{W} = \begin{bmatrix}
1 &amp; 1 \
-1 &amp; 2
\end{bmatrix},
$$</p>
<p>be the matrix where the columns are the eigenvectors of the matrix $\mathbf{A}$. Let</p>
<p>$$
\boldsymbol{\Sigma} = \begin{bmatrix}
1 &amp; 0 \
0 &amp; 4
\end{bmatrix},
$$</p>
<p>be the matrix with the associated eigenvalues on the diagonal.
Then the definition of eigenvalues and eigenvectors tells us that</p>
<p>$$
\mathbf{A}\mathbf{W} =\mathbf{W} \boldsymbol{\Sigma} .
$$</p>
<p>The matrix $W$ is invertible, so we may multiply both sides by $W^{-1}$ on the right,
we see that we may write</p>
<p>$$\mathbf{A} = \mathbf{W} \boldsymbol{\Sigma} \mathbf{W}^{-1}.$$
:eqlabel:<code>eq_eig_decomp</code></p>
<p>In the next section we will see some nice consequences of this,
but for now we need only know that such a decomposition
will exist as long as we can find a full collection
of linearly independent eigenvectors (so that $W$ is invertible).</p>
<h2 id="operations-on-eigendecompositions"><a class="header" href="#operations-on-eigendecompositions">Operations on Eigendecompositions</a></h2>
<p>One nice thing about eigendecompositions :eqref:<code>eq_eig_decomp</code> is that
we can write many operations we usually encounter cleanly
in terms of the eigendecomposition. As a first example, consider:</p>
<p>$$
\mathbf{A}^n = \overbrace{\mathbf{A}\cdots \mathbf{A}}^{\textrm{$n$ times}} = \overbrace{(\mathbf{W}\boldsymbol{\Sigma} \mathbf{W}^{-1})\cdots(\mathbf{W}\boldsymbol{\Sigma} \mathbf{W}^{-1})}^{\textrm{$n$ times}} =  \mathbf{W}\overbrace{\boldsymbol{\Sigma}\cdots\boldsymbol{\Sigma}}^{\textrm{$n$ times}}\mathbf{W}^{-1} = \mathbf{W}\boldsymbol{\Sigma}^n \mathbf{W}^{-1}.
$$</p>
<p>This tells us that for any positive power of a matrix,
the eigendecomposition is obtained by just raising the eigenvalues to the same power.
The same can be shown for negative powers,
so if we want to invert a matrix we need only consider</p>
<p>$$
\mathbf{A}^{-1} = \mathbf{W}\boldsymbol{\Sigma}^{-1} \mathbf{W}^{-1},
$$</p>
<p>or in other words, just invert each eigenvalue.
This will work as long as each eigenvalue is non-zero,
so we see that invertible is the same as having no zero eigenvalues.</p>
<p>Indeed, additional work can show that if $\lambda_1, \ldots, \lambda_n$
are the eigenvalues of a matrix, then the determinant of that matrix is</p>
<p>$$
\det(\mathbf{A}) = \lambda_1 \cdots \lambda_n,
$$</p>
<p>or the product of all the eigenvalues.
This makes sense intuitively because whatever stretching $\mathbf{W}$ does,
$W^{-1}$ undoes it, so in the end the only stretching that happens is
by multiplication by the diagonal matrix $\boldsymbol{\Sigma}$,
which stretches volumes by the product of the diagonal elements.</p>
<p>Finally, recall that the rank was the maximum number
of linearly independent columns of your matrix.
By examining the eigendecomposition closely,
we can see that the rank is the same
as the number of non-zero eigenvalues of $\mathbf{A}$.</p>
<p>The examples could continue, but hopefully the point is clear:
eigendecomposition can simplify many linear-algebraic computations
and is a fundamental operation underlying many numerical algorithms
and much of the analysis that we do in linear algebra.</p>
<h2 id="eigendecompositions-of-symmetric-matrices"><a class="header" href="#eigendecompositions-of-symmetric-matrices">Eigendecompositions of Symmetric Matrices</a></h2>
<p>It is not always possible to find enough linearly independent eigenvectors
for the above process to work. For instance the matrix</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
1 &amp; 1 \
0 &amp; 1
\end{bmatrix},
$$</p>
<p>has only a single eigenvector, namely $(1, 0)^\top$.
To handle such matrices, we require more advanced techniques
than we can cover (such as the Jordan Normal Form, or Singular Value Decomposition).
We will often need to restrict our attention to those matrices
where we can guarantee the existence of a full set of eigenvectors.</p>
<p>The most commonly encountered family are the <em>symmetric matrices</em>,
which are those matrices where $\mathbf{A} = \mathbf{A}^\top$.
In this case, we may take $W$ to be an <em>orthogonal matrix</em>—a matrix whose columns are all length one vectors that are at right angles to one another, where
$\mathbf{W}^\top = \mathbf{W}^{-1}$—and all the eigenvalues will be real.
Thus, in this special case, we can write :eqref:<code>eq_eig_decomp</code> as</p>
<p>$$
\mathbf{A} = \mathbf{W}\boldsymbol{\Sigma}\mathbf{W}^\top .
$$</p>
<h2 id="gershgorin-circle-theorem"><a class="header" href="#gershgorin-circle-theorem">Gershgorin Circle Theorem</a></h2>
<p>Eigenvalues are often difficult to reason with intuitively.
If presented an arbitrary matrix, there is little that can be said
about what the eigenvalues are without computing them.
There is, however, one theorem that can make it easy to approximate well
if the largest values are on the diagonal.</p>
<p>Let $\mathbf{A} = (a_{ij})$ be any square matrix ($n\times n$).
We will define $r_i = \sum_{j \neq i} |a_{ij}|$.
Let $\mathcal{D}<em>i$ represent the disc in the complex plane
with center $a</em>{ii}$ radius $r_i$.
Then, every eigenvalue of $\mathbf{A}$ is contained in one of the $\mathcal{D}_i$.</p>
<p>This can be a bit to unpack, so let's look at an example.
Consider the matrix:</p>
<p>$$
\mathbf{A} = \begin{bmatrix}
1.0 &amp; 0.1 &amp; 0.1 &amp; 0.1 \
0.1 &amp; 3.0 &amp; 0.2 &amp; 0.3 \
0.1 &amp; 0.2 &amp; 5.0 &amp; 0.5 \
0.1 &amp; 0.3 &amp; 0.5 &amp; 9.0
\end{bmatrix}.
$$</p>
<p>We have $r_1 = 0.3$, $r_2 = 0.6$, $r_3 = 0.8$ and $r_4 = 0.9$.
The matrix is symmetric, so all eigenvalues are real.
This means that all of our eigenvalues will be in one of the ranges of</p>
<p>$$[a_{11}-r_1, a_{11}+r_1] = [0.7, 1.3], $$</p>
<p>$$[a_{22}-r_2, a_{22}+r_2] = [2.4, 3.6], $$</p>
<p>$$[a_{33}-r_3, a_{33}+r_3] = [4.2, 5.8], $$</p>
<p>$$[a_{44}-r_4, a_{44}+r_4] = [8.1, 9.9]. $$</p>
<p>Performing the numerical computation shows
that the eigenvalues are approximately $0.99$, $2.97$, $4.95$, $9.08$,
all comfortably inside the ranges provided.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
A = np.array([[1.0, 0.1, 0.1, 0.1],
              [0.1, 3.0, 0.2, 0.3],
              [0.1, 0.2, 5.0, 0.5],
              [0.1, 0.3, 0.5, 9.0]])

v, _ = np.linalg.eig(A)
v
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
A = torch.tensor([[1.0, 0.1, 0.1, 0.1],
              [0.1, 3.0, 0.2, 0.3],
              [0.1, 0.2, 5.0, 0.5],
              [0.1, 0.3, 0.5, 9.0]])

v, _ = torch.linalg.eig(A)
v
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
A = tf.constant([[1.0, 0.1, 0.1, 0.1],
                [0.1, 3.0, 0.2, 0.3],
                [0.1, 0.2, 5.0, 0.5],
                [0.1, 0.3, 0.5, 9.0]])

v, _ = tf.linalg.eigh(A)
v
</code></pre>
<p>In this way, eigenvalues can be approximated,
and the approximations will be fairly accurate
in the case that the diagonal is
significantly larger than all the other elements.</p>
<p>It is a small thing, but with a complex
and subtle topic like eigendecomposition,
it is good to get any intuitive grasp we can.</p>
<h2 id="a-useful-application-the-growth-of-iterated-maps"><a class="header" href="#a-useful-application-the-growth-of-iterated-maps">A Useful Application: The Growth of Iterated Maps</a></h2>
<p>Now that we understand what eigenvectors are in principle,
let's see how they can be used to provide a deep understanding
of a problem central to neural network behavior: proper weight initialization.</p>
<h3 id="eigenvectors-as-long-term-behavior"><a class="header" href="#eigenvectors-as-long-term-behavior">Eigenvectors as Long Term Behavior</a></h3>
<p>The full mathematical investigation of the initialization
of deep neural networks is beyond the scope of the text,
but we can see a toy version here to understand
how eigenvalues can help us see how these models work.
As we know, neural networks operate by interspersing layers
of linear transformations with non-linear operations.
For simplicity here, we will assume that there is no non-linearity,
and that the transformation is a single repeated matrix operation $A$,
so that the output of our model is</p>
<p>$$
\mathbf{v}<em>{out} = \mathbf{A}\cdot \mathbf{A}\cdots \mathbf{A} \mathbf{v}</em>{in} = \mathbf{A}^N \mathbf{v}_{in}.
$$</p>
<p>When these models are initialized, $A$ is taken to be
a random matrix with Gaussian entries, so let's make one of those.
To be concrete, we start with a mean zero, variance one Gaussian distributed $5 \times 5$ matrix.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.random.seed(8675309)

k = 5
A = np.random.randn(k, k)
A
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.manual_seed(42)

k = 5
A = torch.randn(k, k, dtype=torch.float64)
A
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
k = 5
A = tf.random.normal((k, k), dtype=tf.float64)
A
</code></pre>
<h3 id="behavior-on-random-data"><a class="header" href="#behavior-on-random-data">Behavior on Random Data</a></h3>
<p>For simplicity in our toy model,
we will assume that the data vector we feed in $\mathbf{v}_{in}$
is a random five dimensional Gaussian vector.
Let's think about what we want to have happen.
For context, lets think of a generic ML problem,
where we are trying to turn input data, like an image, into a prediction,
like the probability the image is a picture of a cat.
If repeated application of $\mathbf{A}$
stretches a random vector out to be very long,
then small changes in input will be amplified
into large changes in output---tiny modifications of the input image
would lead to vastly different predictions.
This does not seem right!</p>
<p>On the flip side, if $\mathbf{A}$ shrinks random vectors to be shorter,
then after running through many layers, the vector will essentially shrink to nothing,
and the output will not depend on the input. This is also clearly not right either!</p>
<p>We need to walk the narrow line between growth and decay
to make sure that our output changes depending on our input, but not much!</p>
<p>Let's see what happens when we repeatedly multiply our matrix $\mathbf{A}$
against a random input vector, and keep track of the norm.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Calculate the sequence of norms after repeatedly applying `A`
v_in = np.random.randn(k, 1)

norm_list = [np.linalg.norm(v_in)]
for i in range(1, 100):
    v_in = A.dot(v_in)
    norm_list.append(np.linalg.norm(v_in))

d2l.plot(np.arange(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Calculate the sequence of norms after repeatedly applying `A`
v_in = torch.randn(k, 1, dtype=torch.float64)

norm_list = [torch.norm(v_in).item()]
for i in range(1, 100):
    v_in = A @ v_in
    norm_list.append(torch.norm(v_in).item())

d2l.plot(torch.arange(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Calculate the sequence of norms after repeatedly applying `A`
v_in = tf.random.normal((k, 1), dtype=tf.float64)

norm_list = [tf.norm(v_in).numpy()]
for i in range(1, 100):
    v_in = tf.matmul(A, v_in)
    norm_list.append(tf.norm(v_in).numpy())

d2l.plot(tf.range(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<p>The norm is growing uncontrollably!
Indeed if we take the list of quotients, we will see a pattern.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute the scaling factor of the norms
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i - 1])

d2l.plot(np.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute the scaling factor of the norms
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i - 1])

d2l.plot(torch.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute the scaling factor of the norms
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i - 1])

d2l.plot(tf.range(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<p>If we look at the last portion of the above computation,
we see that the random vector is stretched by a factor of <code>1.974459321485[...]</code>,
where the portion at the end shifts a little,
but the stretching factor is stable.</p>
<h3 id="relating-back-to-eigenvectors"><a class="header" href="#relating-back-to-eigenvectors">Relating Back to Eigenvectors</a></h3>
<p>We have seen that eigenvectors and eigenvalues correspond
to the amount something is stretched,
but that was for specific vectors, and specific stretches.
Let's take a look at what they are for $\mathbf{A}$.
A bit of a caveat here: it turns out that to see them all,
we will need to go to complex numbers.
You can think of these as stretches and rotations.
By taking the norm of the complex number
(square root of the sums of squares of real and imaginary parts)
we can measure that stretching factor. Let's also sort them.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute the eigenvalues
eigs = np.linalg.eigvals(A).tolist()
norm_eigs = [np.absolute(x) for x in eigs]
norm_eigs.sort()
print(f'norms of eigenvalues: {norm_eigs}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute the eigenvalues
eigs = torch.linalg.eig(A).eigenvalues.tolist()
norm_eigs = [torch.abs(torch.tensor(x)) for x in eigs]
norm_eigs.sort()
print(f'norms of eigenvalues: {norm_eigs}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute the eigenvalues
eigs = tf.linalg.eigh(A)[0].numpy().tolist()
norm_eigs = [tf.abs(tf.constant(x, dtype=tf.float64)) for x in eigs]
norm_eigs.sort()
print(f'norms of eigenvalues: {norm_eigs}')
</code></pre>
<h3 id="an-observation"><a class="header" href="#an-observation">An Observation</a></h3>
<p>We see something a bit unexpected happening here:
that number we identified before for the
long term stretching of our matrix $\mathbf{A}$
applied to a random vector is <em>exactly</em>
(accurate to thirteen decimal places!)
the largest eigenvalue of $\mathbf{A}$.
This is clearly not a coincidence!</p>
<p>But, if we now think about what is happening geometrically,
this starts to make sense. Consider a random vector.
This random vector points a little in every direction,
so in particular, it points at least a little bit
in the same direction as the eigenvector of $\mathbf{A}$
associated with the largest eigenvalue.
This is so important that it is called
the <em>principle eigenvalue</em> and <em>principle eigenvector</em>.
After applying $\mathbf{A}$, our random vector
gets stretched in every possible direction,
as is associated with every possible eigenvector,
but it is stretched most of all in the direction
associated with this principle eigenvector.
What this means is that after apply in $A$,
our random vector is longer, and points in a direction
closer to being aligned with the principle eigenvector.
After applying the matrix many times,
the alignment with the principle eigenvector becomes closer and closer until,
for all practical purposes, our random vector has been transformed
into the principle eigenvector!
Indeed this algorithm is the basis
for what is known as the <em>power iteration</em>
for finding the largest eigenvalue and eigenvector of a matrix. For details see, for example, :cite:<code>Golub.Van-Loan.1996</code>.</p>
<h3 id="fixing-the-normalization"><a class="header" href="#fixing-the-normalization">Fixing the Normalization</a></h3>
<p>Now, from above discussions, we concluded
that we do not want a random vector to be stretched or squished at all,
we would like random vectors to stay about the same size throughout the entire process.
To do so, we now rescale our matrix by this principle eigenvalue
so that the largest eigenvalue is instead now just one.
Let's see what happens in this case.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Rescale the matrix `A`
A /= norm_eigs[-1]

# Do the same experiment again
v_in = np.random.randn(k, 1)

norm_list = [np.linalg.norm(v_in)]
for i in range(1, 100):
    v_in = A.dot(v_in)
    norm_list.append(np.linalg.norm(v_in))

d2l.plot(np.arange(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Rescale the matrix `A`
A /= norm_eigs[-1]

# Do the same experiment again
v_in = torch.randn(k, 1, dtype=torch.float64)

norm_list = [torch.norm(v_in).item()]
for i in range(1, 100):
    v_in = A @ v_in
    norm_list.append(torch.norm(v_in).item())

d2l.plot(torch.arange(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Rescale the matrix `A`
A /= norm_eigs[-1]

# Do the same experiment again
v_in = tf.random.normal((k, 1), dtype=tf.float64)

norm_list = [tf.norm(v_in).numpy()]
for i in range(1, 100):
    v_in = tf.matmul(A, v_in)
    norm_list.append(tf.norm(v_in).numpy())

d2l.plot(tf.range(0, 100), norm_list, 'Iteration', 'Value')
</code></pre>
<p>We can also plot the ratio between consecutive norms as before and see that indeed it stabilizes.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Also plot the ratio
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i-1])

d2l.plot(np.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Also plot the ratio
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i-1])

d2l.plot(torch.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Also plot the ratio
norm_ratio_list = []
for i in range(1, 100):
    norm_ratio_list.append(norm_list[i]/norm_list[i-1])

d2l.plot(tf.range(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
</code></pre>
<h2 id="discussion-10"><a class="header" href="#discussion-10">Discussion</a></h2>
<p>We now see exactly what we hoped for!
After normalizing the matrices by the principal eigenvalue,
we see that the random data does not explode as before,
but rather eventually equilibrates to a specific value.
It would be nice to be able to do these things from first principles,
and it turns out that if we look deeply at the mathematics of it,
we can see that the largest eigenvalue
of a large random matrix with independent mean zero,
variance one Gaussian entries is on average about $\sqrt{n}$,
or in our case $\sqrt{5} \approx 2.2$,
due to a fascinating fact known as the <em>circular law</em> :cite:<code>Ginibre.1965</code>.
The relationship between the eigenvalues (and a related object called singular values) of random matrices has been shown to have deep connections to proper initialization of neural networks as was discussed in :citet:<code>Pennington.Schoenholz.Ganguli.2017</code> and subsequent works.</p>
<h2 id="summary-127"><a class="header" href="#summary-127">Summary</a></h2>
<ul>
<li>Eigenvectors are vectors which are stretched by a matrix without changing direction.</li>
<li>Eigenvalues are the amount that the eigenvectors are stretched by the application of the matrix.</li>
<li>The eigendecomposition of a matrix can allow for many operations to be reduced to operations on the eigenvalues.</li>
<li>The Gershgorin Circle Theorem can provide approximate values for the eigenvalues of a matrix.</li>
<li>The behavior of iterated matrix powers depends primarily on the size of the largest eigenvalue.  This understanding has many applications in the theory of neural network initialization.</li>
</ul>
<h2 id="exercises-145"><a class="header" href="#exercises-145">Exercises</a></h2>
<ol>
<li>What are the eigenvalues and eigenvectors of
$$
\mathbf{A} = \begin{bmatrix}
2 &amp; 1 \
1 &amp; 2
\end{bmatrix}?
$$</li>
<li>What are the eigenvalues and eigenvectors of the following matrix, and what is strange about this example compared to the previous one?
$$
\mathbf{A} = \begin{bmatrix}
2 &amp; 1 \
0 &amp; 2
\end{bmatrix}.
$$</li>
<li>Without computing the eigenvalues, is it possible that the smallest eigenvalue of the following matrix is less that $0.5$? <em>Note</em>: this problem can be done in your head.
$$
\mathbf{A} = \begin{bmatrix}
3.0 &amp; 0.1 &amp; 0.3 &amp; 1.0 \
0.1 &amp; 1.0 &amp; 0.1 &amp; 0.2 \
0.3 &amp; 0.1 &amp; 5.0 &amp; 0.0 \
1.0 &amp; 0.2 &amp; 0.0 &amp; 1.8
\end{bmatrix}.
$$</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/411">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1086">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1087">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-variable-calculus"><a class="header" href="#single-variable-calculus">Single Variable Calculus</a></h1>
<p>:label:<code>sec_single_variable_calculus</code></p>
<p>In :numref:<code>sec_calculus</code>, we saw the basic elements of differential calculus.  This section takes a deeper dive into the fundamentals of calculus and how we can understand and apply it in the context of machine learning.</p>
<h2 id="differential-calculus"><a class="header" href="#differential-calculus">Differential Calculus</a></h2>
<p>Differential calculus is fundamentally the study of how functions behave under small changes.  To see why this is so core to deep learning, let's consider an example.</p>
<p>Suppose that we have a deep neural network where the weights are, for convenience, concatenated into a single vector $\mathbf{w} = (w_1, \ldots, w_n)$.  Given a training dataset, we consider the loss of our neural network on this dataset, which we will write as $\mathcal{L}(\mathbf{w})$.</p>
<p>This function is extraordinarily complex, encoding the performance of all possible models of the given architecture on this dataset, so it is nearly impossible to tell what set of weights $\mathbf{w}$ will minimize the loss. Thus, in practice, we often start by initializing our weights <em>randomly</em>, and then iteratively take small steps in the direction which makes the loss decrease as rapidly as possible.</p>
<p>The question then becomes something that on the surface is no easier: how do we find the direction which makes the weights decrease as quickly as possible?  To dig into this, let's first examine the case with only a single weight: $L(\mathbf{w}) = L(x)$ for a single real value $x$.</p>
<p>Let's take $x$ and try to understand what happens when we change it by a small amount to $x + \epsilon$. If you wish to be concrete, think a number like $\epsilon = 0.0000001$.  To help us visualize what happens, let's graph an example function, $f(x) = \sin(x^x)$, over the $[0, 3]$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from mxnet import np, npx
npx.set_np()

# Plot a function in a normal range
x_big = np.arange(0.01, 3.01, 0.01)
ys = np.sin(x_big**x_big)
d2l.plot(x_big, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
import torch
torch.pi = torch.acos(torch.zeros(1)).item() * 2  # Define pi in torch

# Plot a function in a normal range
x_big = torch.arange(0.01, 3.01, 0.01)
ys = torch.sin(x_big**x_big)
d2l.plot(x_big, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
import tensorflow as tf
tf.pi = tf.acos(tf.zeros(1)).numpy() * 2  # Define pi in TensorFlow

# Plot a function in a normal range
x_big = tf.range(0.01, 3.01, 0.01)
ys = tf.sin(x_big**x_big)
d2l.plot(x_big, ys, 'x', 'f(x)')
</code></pre>
<p>At this large scale, the function's behavior is not simple. However, if we reduce our range to something smaller like $[1.75,2.25]$, we see that the graph becomes much simpler.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot a the same function in a tiny range
x_med = np.arange(1.75, 2.25, 0.001)
ys = np.sin(x_med**x_med)
d2l.plot(x_med, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot a the same function in a tiny range
x_med = torch.arange(1.75, 2.25, 0.001)
ys = torch.sin(x_med**x_med)
d2l.plot(x_med, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot a the same function in a tiny range
x_med = tf.range(1.75, 2.25, 0.001)
ys = tf.sin(x_med**x_med)
d2l.plot(x_med, ys, 'x', 'f(x)')
</code></pre>
<p>Taking this to an extreme, if we zoom into a tiny segment, the behavior becomes far simpler: it is just a straight line.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot a the same function in a tiny range
x_small = np.arange(2.0, 2.01, 0.0001)
ys = np.sin(x_small**x_small)
d2l.plot(x_small, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot a the same function in a tiny range
x_small = torch.arange(2.0, 2.01, 0.0001)
ys = torch.sin(x_small**x_small)
d2l.plot(x_small, ys, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot a the same function in a tiny range
x_small = tf.range(2.0, 2.01, 0.0001)
ys = tf.sin(x_small**x_small)
d2l.plot(x_small, ys, 'x', 'f(x)')
</code></pre>
<p>This is the key observation of single variable calculus: the behavior of familiar functions can be modeled by a line in a small enough range.  This means that for most functions, it is reasonable to expect that as we shift the $x$ value of the function by a little bit, the output $f(x)$ will also be shifted by a little bit.  The only question we need to answer is, "How large is the change in the output compared to the change in the input?  Is it half as large?  Twice as large?"</p>
<p>Thus, we can consider the ratio of the change in the output of a function for a small change in the input of the function.  We can write this formally as</p>
<p>$$
\frac{L(x+\epsilon) - L(x)}{(x+\epsilon) - x} = \frac{L(x+\epsilon) - L(x)}{\epsilon}.
$$</p>
<p>This is already enough to start to play around with in code.  For instance, suppose that we know that $L(x) = x^{2} + 1701(x-4)^3$, then we can see how large this value is at the point $x = 4$ as follows.</p>
<pre><code class="language-{.python .input}">#@tab all
# Define our function
def L(x):
    return x**2 + 1701*(x-4)**3

# Print the difference divided by epsilon for several epsilon
for epsilon in [0.1, 0.001, 0.0001, 0.00001]:
    print(f'epsilon = {epsilon:.5f} -&gt; {(L(4+epsilon) - L(4)) / epsilon:.5f}')
</code></pre>
<p>Now, if we are observant, we will notice that the output of this number is suspiciously close to $8$.  Indeed, if we decrease $\epsilon$, we will see value becomes progressively closer to $8$.  Thus we may conclude, correctly, that the value we seek (the degree a change in the input changes the output) should be $8$ at the point $x=4$.  The way that a mathematician encodes this fact is</p>
<p>$$
\lim_{\epsilon \rightarrow 0}\frac{L(4+\epsilon) - L(4)}{\epsilon} = 8.
$$</p>
<p>As a bit of a historical digression: in the first few decades of neural network research, scientists used this algorithm (the <em>method of finite differences</em>) to evaluate how a loss function changed under small perturbation: just change the weights and see how the loss changed.  This is computationally inefficient, requiring two evaluations of the loss function to see how a single change of one variable influenced the loss.  If we tried to do this with even a paltry few thousand parameters, it would require several thousand evaluations of the network over the entire dataset!  It was not solved until 1986 that the <em>backpropagation algorithm</em> introduced in :citet:<code>Rumelhart.Hinton.Williams.ea.1988</code> provided a way to calculate how <em>any</em> change of the weights together would change the loss in the same computation time as a single prediction of the network over the dataset.</p>
<p>Back in our example, this value $8$ is different for different values of $x$, so it makes sense to define it as a function of $x$.  More formally, this value dependent rate of change is referred to as the <em>derivative</em> which is written as</p>
<p>$$\frac{df}{dx}(x) = \lim_{\epsilon \rightarrow 0}\frac{f(x+\epsilon) - f(x)}{\epsilon}.$$
:eqlabel:<code>eq_der_def</code></p>
<p>Different texts will use different notations for the derivative. For instance, all of the below notations indicate the same thing:</p>
<p>$$
\frac{df}{dx} = \frac{d}{dx}f = f' = \nabla_xf = D_xf = f_x.
$$</p>
<p>Most authors will pick a single notation and stick with it, however even that is not guaranteed.  It is best to be familiar with all of these.  We will use the notation $\frac{df}{dx}$ throughout this text, unless we want to take the derivative of a complex expression, in which case we will use $\frac{d}{dx}f$ to write expressions like
$$
\frac{d}{dx}\left[x^4+\cos\left(\frac{x^2+1}{2x-1}\right)\right].
$$</p>
<p>Oftentimes, it is intuitively useful to unravel the definition of derivative :eqref:<code>eq_der_def</code> again to see how a function changes when we make a small change of $x$:</p>
<p>$$\begin{aligned} \frac{df}{dx}(x) = \lim_{\epsilon \rightarrow 0}\frac{f(x+\epsilon) - f(x)}{\epsilon} &amp; \implies \frac{df}{dx}(x) \approx \frac{f(x+\epsilon) - f(x)}{\epsilon} \ &amp; \implies \epsilon \frac{df}{dx}(x) \approx f(x+\epsilon) - f(x) \ &amp; \implies f(x+\epsilon) \approx f(x) + \epsilon \frac{df}{dx}(x). \end{aligned}$$
:eqlabel:<code>eq_small_change</code></p>
<p>The last equation is worth explicitly calling out.  It tells us that if you take any function and change the input by a small amount, the output would change by that small amount scaled by the derivative.</p>
<p>In this way, we can understand the derivative as the scaling factor that tells us how large of change we get in the output from a change in the input.</p>
<h2 id="rules-of-calculus"><a class="header" href="#rules-of-calculus">Rules of Calculus</a></h2>
<p>:label:<code>sec_derivative_table</code></p>
<p>We now turn to the task of understanding how to compute the derivative of an explicit function.  A full formal treatment of calculus would derive everything from first principles.  We will not indulge in this temptation here, but rather provide an understanding of the common rules encountered.</p>
<h3 id="common-derivatives"><a class="header" href="#common-derivatives">Common Derivatives</a></h3>
<p>As was seen in :numref:<code>sec_calculus</code>, when computing derivatives one can oftentimes use a series of rules to reduce the computation to a few core functions.  We repeat them here for ease of reference.</p>
<ul>
<li><strong>Derivative of constants.</strong> $\frac{d}{dx}c = 0$.</li>
<li><strong>Derivative of linear functions.</strong> $\frac{d}{dx}(ax) = a$.</li>
<li><strong>Power rule.</strong> $\frac{d}{dx}x^n = nx^{n-1}$.</li>
<li><strong>Derivative of exponentials.</strong> $\frac{d}{dx}e^x = e^x$.</li>
<li><strong>Derivative of the logarithm.</strong> $\frac{d}{dx}\log(x) = \frac{1}{x}$.</li>
</ul>
<h3 id="derivative-rules"><a class="header" href="#derivative-rules">Derivative Rules</a></h3>
<p>If every derivative needed to be separately computed and stored in a table, differential calculus would be near impossible.  It is a gift of mathematics that we can generalize the above derivatives and compute more complex derivatives like finding the derivative of $f(x) = \log\left(1+(x-1)^{10}\right)$.  As was mentioned in :numref:<code>sec_calculus</code>, the key to doing so is to codify what happens when we take functions and combine them in various ways, most importantly: sums, products, and compositions.</p>
<ul>
<li><strong>Sum rule.</strong> $\frac{d}{dx}\left(g(x) + h(x)\right) = \frac{dg}{dx}(x) + \frac{dh}{dx}(x)$.</li>
<li><strong>Product rule.</strong> $\frac{d}{dx}\left(g(x)\cdot h(x)\right) = g(x)\frac{dh}{dx}(x) + \frac{dg}{dx}(x)h(x)$.</li>
<li><strong>Chain rule.</strong> $\frac{d}{dx}g(h(x)) = \frac{dg}{dh}(h(x))\cdot \frac{dh}{dx}(x)$.</li>
</ul>
<p>Let's see how we may use :eqref:<code>eq_small_change</code> to understand these rules.  For the sum rule, consider following chain of reasoning:</p>
<p>$$
\begin{aligned}
f(x+\epsilon) &amp; = g(x+\epsilon) + h(x+\epsilon) \
&amp; \approx g(x) + \epsilon \frac{dg}{dx}(x) + h(x) + \epsilon \frac{dh}{dx}(x) \
&amp; = g(x) + h(x) + \epsilon\left(\frac{dg}{dx}(x) + \frac{dh}{dx}(x)\right) \
&amp; = f(x) + \epsilon\left(\frac{dg}{dx}(x) + \frac{dh}{dx}(x)\right).
\end{aligned}
$$</p>
<p>By comparing this result with the fact that $f(x+\epsilon) \approx f(x) + \epsilon \frac{df}{dx}(x)$, we see that $\frac{df}{dx}(x) = \frac{dg}{dx}(x) + \frac{dh}{dx}(x)$ as desired.  The intuition here is: when we change the input $x$, $g$ and $h$ jointly contribute to the change of the output by $\frac{dg}{dx}(x)$ and $\frac{dh}{dx}(x)$.</p>
<p>The product is more subtle, and will require a new observation about how to work with these expressions.  We will begin as before using :eqref:<code>eq_small_change</code>:</p>
<p>$$
\begin{aligned}
f(x+\epsilon) &amp; = g(x+\epsilon)\cdot h(x+\epsilon) \
&amp; \approx \left(g(x) + \epsilon \frac{dg}{dx}(x)\right)\cdot\left(h(x) + \epsilon \frac{dh}{dx}(x)\right) \
&amp; = g(x)\cdot h(x) + \epsilon\left(g(x)\frac{dh}{dx}(x) + \frac{dg}{dx}(x)h(x)\right) + \epsilon^2\frac{dg}{dx}(x)\frac{dh}{dx}(x) \
&amp; = f(x) + \epsilon\left(g(x)\frac{dh}{dx}(x) + \frac{dg}{dx}(x)h(x)\right) + \epsilon^2\frac{dg}{dx}(x)\frac{dh}{dx}(x). \
\end{aligned}
$$</p>
<p>This resembles the computation done above, and indeed we see our answer ($\frac{df}{dx}(x) = g(x)\frac{dh}{dx}(x) + \frac{dg}{dx}(x)h(x)$) sitting next to $\epsilon$, but there is the issue of that term of size $\epsilon^{2}$.  We will refer to this as a <em>higher-order term</em>, since the power of $\epsilon^2$ is higher than the power of $\epsilon^1$.  We will see in a later section that we will sometimes want to keep track of these, however for now observe that if $\epsilon = 0.0000001$, then $\epsilon^{2}= 0.0000000000001$, which is vastly smaller.  As we send $\epsilon \rightarrow 0$, we may safely ignore the higher order terms.  As a general convention in this appendix, we will use "$\approx$" to denote that the two terms are equal up to higher order terms.  However, if we wish to be more formal we may examine the difference quotient</p>
<p>$$
\frac{f(x+\epsilon) - f(x)}{\epsilon} = g(x)\frac{dh}{dx}(x) + \frac{dg}{dx}(x)h(x) + \epsilon \frac{dg}{dx}(x)\frac{dh}{dx}(x),
$$</p>
<p>and see that as we send $\epsilon \rightarrow 0$, the right hand term goes to zero as well.</p>
<p>Finally, with the chain rule, we can again progress as before using :eqref:<code>eq_small_change</code> and see that</p>
<p>$$
\begin{aligned}
f(x+\epsilon) &amp; = g(h(x+\epsilon)) \
&amp; \approx g\left(h(x) + \epsilon \frac{dh}{dx}(x)\right) \
&amp; \approx g(h(x)) + \epsilon \frac{dh}{dx}(x) \frac{dg}{dh}(h(x))\
&amp; = f(x) + \epsilon \frac{dg}{dh}(h(x))\frac{dh}{dx}(x),
\end{aligned}
$$</p>
<p>where in the second line we view the function $g$ as having its input ($h(x)$) shifted by the tiny quantity $\epsilon \frac{dh}{dx}(x)$.</p>
<p>These rule provide us with a flexible set of tools to compute essentially any expression desired.  For instance,</p>
<p>$$
\begin{aligned}
\frac{d}{dx}\left[\log\left(1+(x-1)^{10}\right)\right] &amp; = \left(1+(x-1)^{10}\right)^{-1}\frac{d}{dx}\left[1+(x-1)^{10}\right]\
&amp; = \left(1+(x-1)^{10}\right)^{-1}\left(\frac{d}{dx}[1] + \frac{d}{dx}[(x-1)^{10}]\right) \
&amp; = \left(1+(x-1)^{10}\right)^{-1}\left(0 + 10(x-1)^9\frac{d}{dx}[x-1]\right) \
&amp; = 10\left(1+(x-1)^{10}\right)^{-1}(x-1)^9 \
&amp; = \frac{10(x-1)^9}{1+(x-1)^{10}}.
\end{aligned}
$$</p>
<p>Where each line has used the following rules:</p>
<ol>
<li>The chain rule and derivative of logarithm.</li>
<li>The sum rule.</li>
<li>The derivative of constants, chain rule, and power rule.</li>
<li>The sum rule, derivative of linear functions, derivative of constants.</li>
</ol>
<p>Two things should be clear after doing this example:</p>
<ol>
<li>Any function we can write down using sums, products, constants, powers, exponentials, and logarithms can have its derivative computed mechanically by following these rules.</li>
<li>Having a human follow these rules can be tedious and error prone!</li>
</ol>
<p>Thankfully, these two facts together hint towards a way forward: this is a perfect candidate for mechanization!  Indeed backpropagation, which we will revisit later in this section, is exactly that.</p>
<h3 id="linear-approximation"><a class="header" href="#linear-approximation">Linear Approximation</a></h3>
<p>When working with derivatives, it is often useful to geometrically interpret the approximation used above.  In particular, note that the equation</p>
<p>$$
f(x+\epsilon) \approx f(x) + \epsilon \frac{df}{dx}(x),
$$</p>
<p>approximates the value of $f$ by a line which passes through the point $(x, f(x))$ and has slope $\frac{df}{dx}(x)$.  In this way we say that the derivative gives a linear approximation to the function $f$, as illustrated below:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute sin
xs = np.arange(-np.pi, np.pi, 0.01)
plots = [np.sin(xs)]

# Compute some linear approximations. Use d(sin(x)) / dx = cos(x)
for x0 in [-1.5, 0, 2]:
    plots.append(np.sin(x0) + (xs - x0) * np.cos(x0))

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute sin
xs = torch.arange(-torch.pi, torch.pi, 0.01)
plots = [torch.sin(xs)]

# Compute some linear approximations. Use d(sin(x))/dx = cos(x)
for x0 in [-1.5, 0.0, 2.0]:
    plots.append(torch.sin(torch.tensor(x0)) + (xs - x0) *
                 torch.cos(torch.tensor(x0)))

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute sin
xs = tf.range(-tf.pi, tf.pi, 0.01)
plots = [tf.sin(xs)]

# Compute some linear approximations. Use d(sin(x))/dx = cos(x)
for x0 in [-1.5, 0.0, 2.0]:
    plots.append(tf.sin(tf.constant(x0)) + (xs - x0) *
                 tf.cos(tf.constant(x0)))

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<h3 id="higher-order-derivatives"><a class="header" href="#higher-order-derivatives">Higher Order Derivatives</a></h3>
<p>Let's now do something that may on the surface seem strange.  Take a function $f$ and compute the derivative $\frac{df}{dx}$.  This gives us the rate of change of $f$ at any point.</p>
<p>However, the derivative, $\frac{df}{dx}$, can be viewed as a function itself, so nothing stops us from computing the derivative of $\frac{df}{dx}$ to get $\frac{d^2f}{dx^2} = \frac{df}{dx}\left(\frac{df}{dx}\right)$.  We will call this the second derivative of $f$.  This function is the rate of change of the rate of change of $f$, or in other words, how the rate of change is changing. We may apply the derivative any number of times to obtain what is called the $n$-th derivative. To keep the notation clean, we will denote the $n$-th derivative as</p>
<p>$$
f^{(n)}(x) = \frac{d^{n}f}{dx^{n}} = \left(\frac{d}{dx}\right)^{n} f.
$$</p>
<p>Let's try to understand <em>why</em> this is a useful notion.  Below, we visualize $f^{(2)}(x)$, $f^{(1)}(x)$, and $f(x)$.</p>
<p>First, consider the case that the second derivative $f^{(2)}(x)$ is a positive constant.  This means that the slope of the first derivative is positive.  As a result, the first derivative $f^{(1)}(x)$ may start out negative, becomes zero at a point, and then becomes positive in the end. This tells us the slope of our original function $f$ and therefore, the function $f$ itself decreases, flattens out, then increases.  In other words, the function $f$ curves up, and has a single minimum as is shown in :numref:<code>fig_positive-second</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/posSecDer.svg" alt="If we assume the second derivative is a positive constant, then the fist derivative in increasing, which implies the function itself has a minimum." />
:label:<code>fig_positive-second</code></p>
<p>Second, if the second derivative is a negative constant, that means that the first derivative is decreasing.  This implies the first derivative may start out positive, becomes zero at a point, and then becomes negative. Hence, the function $f$ itself increases, flattens out, then decreases.  In other words, the function $f$ curves down, and has a single maximum as is shown in :numref:<code>fig_negative-second</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/negSecDer.svg" alt="If we assume the second derivative is a negative constant, then the fist derivative in decreasing, which implies the function itself has a maximum." />
:label:<code>fig_negative-second</code></p>
<p>Third, if the second derivative is a always zero, then the first derivative will never change---it is constant!  This means that $f$ increases (or decreases) at a fixed rate, and $f$ is itself a straight line  as is shown in :numref:<code>fig_zero-second</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/zeroSecDer.svg" alt="If we assume the second derivative is zero, then the fist derivative is constant, which implies the function itself is a straight line." />
:label:<code>fig_zero-second</code></p>
<p>To summarize, the second derivative can be interpreted as describing the way that the function $f$ curves.  A positive second derivative leads to a upwards curve, while a negative second derivative means that $f$ curves downwards, and a zero second derivative means that $f$ does not curve at all.</p>
<p>Let's take this one step further. Consider the function $g(x) = ax^{2}+ bx + c$.  We can then compute that</p>
<p>$$
\begin{aligned}
\frac{dg}{dx}(x) &amp; = 2ax + b \
\frac{d^2g}{dx^2}(x) &amp; = 2a.
\end{aligned}
$$</p>
<p>If we have some original function $f(x)$ in mind, we may compute the first two derivatives and find the values for $a, b$, and $c$ that make them match this computation.  Similarly to the previous section where we saw that the first derivative gave the best approximation with a straight line, this construction provides the best approximation by a quadratic.  Let's visualize this for $f(x) = \sin(x)$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute sin
xs = np.arange(-np.pi, np.pi, 0.01)
plots = [np.sin(xs)]

# Compute some quadratic approximations. Use d(sin(x)) / dx = cos(x)
for x0 in [-1.5, 0, 2]:
    plots.append(np.sin(x0) + (xs - x0) * np.cos(x0) -
                              (xs - x0)**2 * np.sin(x0) / 2)

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute sin
xs = torch.arange(-torch.pi, torch.pi, 0.01)
plots = [torch.sin(xs)]

# Compute some quadratic approximations. Use d(sin(x)) / dx = cos(x)
for x0 in [-1.5, 0.0, 2.0]:
    plots.append(torch.sin(torch.tensor(x0)) + (xs - x0) *
                 torch.cos(torch.tensor(x0)) - (xs - x0)**2 *
                 torch.sin(torch.tensor(x0)) / 2)

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute sin
xs = tf.range(-tf.pi, tf.pi, 0.01)
plots = [tf.sin(xs)]

# Compute some quadratic approximations. Use d(sin(x)) / dx = cos(x)
for x0 in [-1.5, 0.0, 2.0]:
    plots.append(tf.sin(tf.constant(x0)) + (xs - x0) *
                 tf.cos(tf.constant(x0)) - (xs - x0)**2 *
                 tf.sin(tf.constant(x0)) / 2)

d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
</code></pre>
<p>We will extend this idea to the idea of a <em>Taylor series</em> in the next section.</p>
<h3 id="taylor-series"><a class="header" href="#taylor-series">Taylor Series</a></h3>
<p>The <em>Taylor series</em> provides a method to approximate the function $f(x)$ if we are given values for the first $n$ derivatives at a point $x_0$, i.e., $\left{ f(x_0), f^{(1)}(x_0), f^{(2)}(x_0), \ldots, f^{(n)}(x_0) \right}$. The idea will be to find a degree $n$ polynomial that matches all the given derivatives at $x_0$.</p>
<p>We saw the case of $n=2$ in the previous section and a little algebra shows this is</p>
<p>$$
f(x) \approx \frac{1}{2}\frac{d^2f}{dx^2}(x_0)(x-x_0)^{2}+ \frac{df}{dx}(x_0)(x-x_0) + f(x_0).
$$</p>
<p>As we can see above, the denominator of $2$ is there to cancel out the $2$ we get when we take two derivatives of $x^2$, while the other terms are all zero.  Same logic applies for the first derivative and the value itself.</p>
<p>If we push the logic further to $n=3$, we will conclude that</p>
<p>$$
f(x) \approx \frac{\frac{d^3f}{dx^3}(x_0)}{6}(x-x_0)^3 + \frac{\frac{d^2f}{dx^2}(x_0)}{2}(x-x_0)^{2}+ \frac{df}{dx}(x_0)(x-x_0) + f(x_0).
$$</p>
<p>where the $6 = 3 \times 2 = 3!$ comes from the constant we get in front if we take three derivatives of $x^3$.</p>
<p>Furthermore, we can get a degree $n$ polynomial by</p>
<p>$$
P_n(x) = \sum_{i = 0}^{n} \frac{f^{(i)}(x_0)}{i!}(x-x_0)^{i}.
$$</p>
<p>where the notation</p>
<p>$$
f^{(n)}(x) = \frac{d^{n}f}{dx^{n}} = \left(\frac{d}{dx}\right)^{n} f.
$$</p>
<p>Indeed, $P_n(x)$ can be viewed as the best $n$-th degree polynomial approximation to our function $f(x)$.</p>
<p>While we are not going to dive all the way into the error of the above approximations, it is worth mentioning the infinite limit. In this case, for well behaved functions (known as real analytic functions) like $\cos(x)$ or $e^{x}$, we can write out the infinite number of terms and approximate the exactly same function</p>
<p>$$
f(x) = \sum_{n = 0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^{n}.
$$</p>
<p>Take $f(x) = e^{x}$ as am example. Since $e^{x}$ is its own derivative, we know that $f^{(n)}(x) = e^{x}$. Therefore, $e^{x}$ can be reconstructed by taking the Taylor series at $x_0 = 0$, i.e.,</p>
<p>$$
e^{x} = \sum_{n = 0}^\infty \frac{x^{n}}{n!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \cdots.
$$</p>
<p>Let's see how this works in code and observe how increasing the degree of the Taylor approximation brings us closer to the desired function $e^x$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Compute the exponential function
xs = np.arange(0, 3, 0.01)
ys = np.exp(xs)

# Compute a few Taylor series approximations
P1 = 1 + xs
P2 = 1 + xs + xs**2 / 2
P5 = 1 + xs + xs**2 / 2 + xs**3 / 6 + xs**4 / 24 + xs**5 / 120

d2l.plot(xs, [ys, P1, P2, P5], 'x', 'f(x)', legend=[
    "Exponential", "Degree 1 Taylor Series", "Degree 2 Taylor Series",
    "Degree 5 Taylor Series"])
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Compute the exponential function
xs = torch.arange(0, 3, 0.01)
ys = torch.exp(xs)

# Compute a few Taylor series approximations
P1 = 1 + xs
P2 = 1 + xs + xs**2 / 2
P5 = 1 + xs + xs**2 / 2 + xs**3 / 6 + xs**4 / 24 + xs**5 / 120

d2l.plot(xs, [ys, P1, P2, P5], 'x', 'f(x)', legend=[
    "Exponential", "Degree 1 Taylor Series", "Degree 2 Taylor Series",
    "Degree 5 Taylor Series"])
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Compute the exponential function
xs = tf.range(0, 3, 0.01)
ys = tf.exp(xs)

# Compute a few Taylor series approximations
P1 = 1 + xs
P2 = 1 + xs + xs**2 / 2
P5 = 1 + xs + xs**2 / 2 + xs**3 / 6 + xs**4 / 24 + xs**5 / 120

d2l.plot(xs, [ys, P1, P2, P5], 'x', 'f(x)', legend=[
    "Exponential", "Degree 1 Taylor Series", "Degree 2 Taylor Series",
    "Degree 5 Taylor Series"])
</code></pre>
<p>Taylor series have two primary applications:</p>
<ol>
<li>
<p><em>Theoretical applications</em>: Often when we try to understand a too complex function, using Taylor series enables us to turn it into a polynomial that we can work with directly.</p>
</li>
<li>
<p><em>Numerical applications</em>: Some functions like $e^{x}$ or $\cos(x)$ are  difficult for machines to compute.  They can store tables of values at a fixed precision (and this is often done), but it still leaves open questions like "What is the 1000-th digit of $\cos(1)$?"  Taylor series are often helpful to answer such questions.</p>
</li>
</ol>
<h2 id="summary-128"><a class="header" href="#summary-128">Summary</a></h2>
<ul>
<li>Derivatives can be used to express how functions change when we change the input by a small amount.</li>
<li>Elementary derivatives can be combined using derivative rules to create arbitrarily complex derivatives.</li>
<li>Derivatives can be iterated to get second or higher order derivatives.  Each increase in order provides more fine grained information on the behavior of the function.</li>
<li>Using information in the derivatives of a single data example, we can approximate well behaved functions by polynomials obtained from the Taylor series.</li>
</ul>
<h2 id="exercises-146"><a class="header" href="#exercises-146">Exercises</a></h2>
<ol>
<li>What is the derivative of $x^3-4x+1$?</li>
<li>What is the derivative of $\log(\frac{1}{x})$?</li>
<li>True or False: If $f'(x) = 0$ then $f$ has a maximum or minimum at $x$?</li>
<li>Where is the minimum of $f(x) = x\log(x)$ for $x\ge0$ (where we assume that $f$ takes the limiting value of $0$ at $f(0)$)?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/412">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1088">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1089">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multivariable-calculus"><a class="header" href="#multivariable-calculus">Multivariable Calculus</a></h1>
<p>:label:<code>sec_multivariable_calculus</code></p>
<p>Now that we have a fairly strong understanding of derivatives of a function of a single variable, let's return to our original question where we were considering a loss function of potentially billions of weights.</p>
<h2 id="higher-dimensional-differentiation"><a class="header" href="#higher-dimensional-differentiation">Higher-Dimensional Differentiation</a></h2>
<p>What :numref:<code>sec_single_variable_calculus</code> tells us is that if we change a single one of these billions of weights leaving every other one fixed, we know what will happen!  This is nothing more than a function of a single variable, so we can write</p>
<p>$$L(w_1+\epsilon_1, w_2, \ldots, w_N) \approx L(w_1, w_2, \ldots, w_N) + \epsilon_1 \frac{d}{dw_1} L(w_1, w_2, \ldots, w_N).$$
:eqlabel:<code>eq_part_der</code></p>
<p>We will call the derivative in one variable while fixing the other variables the <em>partial derivative</em>, and we will use the notation $\frac{\partial}{\partial w_1}$ for the derivative in :eqref:<code>eq_part_der</code>.</p>
<p>Now, let's take this and change $w_2$ a little bit to $w_2 + \epsilon_2$:</p>
<p>$$
\begin{aligned}
L(w_1+\epsilon_1, w_2+\epsilon_2, \ldots, w_N) &amp; \approx L(w_1, w_2+\epsilon_2, \ldots, w_N) + \epsilon_1 \frac{\partial}{\partial w_1} L(w_1, w_2+\epsilon_2, \ldots, w_N+\epsilon_N) \
&amp; \approx L(w_1, w_2, \ldots, w_N) \
&amp; \quad + \epsilon_2\frac{\partial}{\partial w_2} L(w_1, w_2, \ldots, w_N) \
&amp; \quad + \epsilon_1 \frac{\partial}{\partial w_1} L(w_1, w_2, \ldots, w_N) \
&amp; \quad + \epsilon_1\epsilon_2\frac{\partial}{\partial w_2}\frac{\partial}{\partial w_1} L(w_1, w_2, \ldots, w_N) \
&amp; \approx L(w_1, w_2, \ldots, w_N) \
&amp; \quad + \epsilon_2\frac{\partial}{\partial w_2} L(w_1, w_2, \ldots, w_N) \
&amp; \quad + \epsilon_1 \frac{\partial}{\partial w_1} L(w_1, w_2, \ldots, w_N).
\end{aligned}
$$</p>
<p>We have again used the idea that $\epsilon_1\epsilon_2$ is a higher order term that we can discard in the same way we could discard $\epsilon^{2}$ in the previous section, along with what we saw in :eqref:<code>eq_part_der</code>.  By continuing in this manner, we may write that</p>
<p>$$
L(w_1+\epsilon_1, w_2+\epsilon_2, \ldots, w_N+\epsilon_N) \approx L(w_1, w_2, \ldots, w_N) + \sum_i \epsilon_i \frac{\partial}{\partial w_i} L(w_1, w_2, \ldots, w_N).
$$</p>
<p>This may look like a mess, but we can make this more familiar by noting that the sum on the right looks exactly like a dot product, so if we let</p>
<p>$$
\boldsymbol{\epsilon} = [\epsilon_1, \ldots, \epsilon_N]^\top ; \textrm{and} ;
\nabla_{\mathbf{x}} L = \left[\frac{\partial L}{\partial x_1}, \ldots, \frac{\partial L}{\partial x_N}\right]^\top,
$$</p>
<p>then</p>
<p>$$L(\mathbf{w} + \boldsymbol{\epsilon}) \approx L(\mathbf{w}) + \boldsymbol{\epsilon}\cdot \nabla_{\mathbf{w}} L(\mathbf{w}).$$
:eqlabel:<code>eq_nabla_use</code></p>
<p>We will call the vector $\nabla_{\mathbf{w}} L$ the <em>gradient</em> of $L$.</p>
<p>Equation :eqref:<code>eq_nabla_use</code> is worth pondering for a moment.  It has exactly the format that we encountered in one dimension, just we have converted everything to vectors and dot products.  It allows us to tell approximately how the function $L$ will change given any perturbation to the input.  As we will see in the next section, this will provide us with an important tool in understanding geometrically how we can learn using information contained in the gradient.</p>
<p>But first, let's see this approximation at work with an example.  Suppose that we are working with the function</p>
<p>$$
f(x, y) = \log(e^x + e^y) \textrm{ with gradient } \nabla f (x, y) = \left[\frac{e^x}{e^x+e^y}, \frac{e^y}{e^x+e^y}\right].
$$</p>
<p>If we look at a point like $(0, \log(2))$, we see that</p>
<p>$$
f(x, y) = \log(3) \textrm{ with gradient } \nabla f (x, y) = \left[\frac{1}{3}, \frac{2}{3}\right].
$$</p>
<p>Thus, if we want to approximate $f$ at $(\epsilon_1, \log(2) + \epsilon_2)$,  we see that we should have the specific instance of :eqref:<code>eq_nabla_use</code>:</p>
<p>$$
f(\epsilon_1, \log(2) + \epsilon_2) \approx \log(3) + \frac{1}{3}\epsilon_1 + \frac{2}{3}\epsilon_2.
$$</p>
<p>We can test this in code to see how good the approximation is.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from mpl_toolkits import mplot3d
from mxnet import autograd, np, npx
npx.set_np()

def f(x, y):
    return np.log(np.exp(x) + np.exp(y))
def grad_f(x, y):
    return np.array([np.exp(x) / (np.exp(x) + np.exp(y)),
                     np.exp(y) / (np.exp(x) + np.exp(y))])

epsilon = np.array([0.01, -0.03])
grad_approx = f(0, np.log(2)) + epsilon.dot(grad_f(0, np.log(2)))
true_value = f(0 + epsilon[0], np.log(2) + epsilon[1])
f'approximation: {grad_approx}, true Value: {true_value}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
from mpl_toolkits import mplot3d
import torch
import numpy as np

def f(x, y):
    return torch.log(torch.exp(x) + torch.exp(y))
def grad_f(x, y):
    return torch.tensor([torch.exp(x) / (torch.exp(x) + torch.exp(y)),
                     torch.exp(y) / (torch.exp(x) + torch.exp(y))])

epsilon = torch.tensor([0.01, -0.03])
grad_approx = f(torch.tensor([0.]), torch.log(
    torch.tensor([2.]))) + epsilon.dot(
    grad_f(torch.tensor([0.]), torch.log(torch.tensor(2.))))
true_value = f(torch.tensor([0.]) + epsilon[0], torch.log(
    torch.tensor([2.])) + epsilon[1])
f'approximation: {grad_approx}, true Value: {true_value}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
from mpl_toolkits import mplot3d
import tensorflow as tf
import numpy as np

def f(x, y):
    return tf.math.log(tf.exp(x) + tf.exp(y))
def grad_f(x, y):
    return tf.constant([(tf.exp(x) / (tf.exp(x) + tf.exp(y))).numpy(),
                        (tf.exp(y) / (tf.exp(x) + tf.exp(y))).numpy()])

epsilon = tf.constant([0.01, -0.03])
grad_approx = f(tf.constant([0.]), tf.math.log(
    tf.constant([2.]))) + tf.tensordot(
    epsilon, grad_f(tf.constant([0.]), tf.math.log(tf.constant(2.))), axes=1)
true_value = f(tf.constant([0.]) + epsilon[0], tf.math.log(
    tf.constant([2.])) + epsilon[1])
f'approximation: {grad_approx}, true Value: {true_value}'
</code></pre>
<h2 id="geometry-of-gradients-and-gradient-descent"><a class="header" href="#geometry-of-gradients-and-gradient-descent">Geometry of Gradients and Gradient Descent</a></h2>
<p>Consider the expression from :eqref:<code>eq_nabla_use</code> again:</p>
<p>$$
L(\mathbf{w} + \boldsymbol{\epsilon}) \approx L(\mathbf{w}) + \boldsymbol{\epsilon}\cdot \nabla_{\mathbf{w}} L(\mathbf{w}).
$$</p>
<p>Let's suppose that I want to use this to help minimize our loss $L$.  Let's understand geometrically the algorithm of gradient descent first described in  :numref:<code>sec_autograd</code>. What we will do is the following:</p>
<ol>
<li>Start with a random choice for the initial parameters $\mathbf{w}$.</li>
<li>Find the direction $\mathbf{v}$ that makes $L$ decrease the most rapidly at $\mathbf{w}$.</li>
<li>Take a small step in that direction: $\mathbf{w} \rightarrow \mathbf{w} + \epsilon\mathbf{v}$.</li>
<li>Repeat.</li>
</ol>
<p>The only thing we do not know exactly how to do is to compute the vector $\mathbf{v}$ in the second step.  We will call such a direction the <em>direction of steepest descent</em>.  Using the geometric understanding of dot products from :numref:<code>sec_geometry-linear-algebraic-ops</code>, we see that we can rewrite :eqref:<code>eq_nabla_use</code> as</p>
<p>$$
L(\mathbf{w} + \mathbf{v}) \approx L(\mathbf{w}) + \mathbf{v}\cdot \nabla_{\mathbf{w}} L(\mathbf{w}) = L(\mathbf{w}) + |\nabla_{\mathbf{w}} L(\mathbf{w})|\cos(\theta).
$$</p>
<p>Note that we have taken our direction to have length one for convenience, and used $\theta$ for the angle between $\mathbf{v}$ and $\nabla_{\mathbf{w}} L(\mathbf{w})$.  If we want to find the direction that decreases $L$ as rapidly as possible, we want to make this expression as negative as possible.  The only way the direction we pick enters into this equation is through $\cos(\theta)$, and thus we wish to make this cosine as negative as possible.  Now, recalling the shape of cosine, we can make this as negative as possible by making $\cos(\theta) = -1$ or equivalently making the angle between the gradient and our chosen direction to be $\pi$ radians, or equivalently $180$ degrees.  The only way to achieve this is to head in the exact opposite direction:  pick $\mathbf{v}$ to point in the exact opposite direction to $\nabla_{\mathbf{w}} L(\mathbf{w})$!</p>
<p>This brings us to one of the most important mathematical concepts in machine learning: the direction of steepest decent points in the direction of $-\nabla_{\mathbf{w}}L(\mathbf{w})$.  Thus our informal algorithm can be rewritten as follows.</p>
<ol>
<li>Start with a random choice for the initial parameters $\mathbf{w}$.</li>
<li>Compute $\nabla_{\mathbf{w}} L(\mathbf{w})$.</li>
<li>Take a small step in the opposite of that direction: $\mathbf{w} \leftarrow \mathbf{w} - \epsilon\nabla_{\mathbf{w}} L(\mathbf{w})$.</li>
<li>Repeat.</li>
</ol>
<p>This basic algorithm has been modified and adapted many ways by many researchers, but the core concept remains the same in all of them.  Use the gradient to find the direction that decreases the loss as rapidly as possible, and update the parameters to take a step in that direction.</p>
<h2 id="a-note-on-mathematical-optimization"><a class="header" href="#a-note-on-mathematical-optimization">A Note on Mathematical Optimization</a></h2>
<p>Throughout this book, we focus squarely on numerical optimization techniques for the practical reason that all functions we encounter in the deep learning setting are too complex to minimize explicitly.</p>
<p>However, it is a useful exercise to consider what the geometric understanding we obtained above tells us about optimizing functions directly.</p>
<p>Suppose that we wish to find the value of $\mathbf{x}_0$ which minimizes some function $L(\mathbf{x})$.  Let's suppose that moreover someone gives us a value and tells us that it is the value that minimizes $L$.  Is there anything we can check to see if their answer is even plausible?</p>
<p>Again consider :eqref:<code>eq_nabla_use</code>:
$$
L(\mathbf{x}_0 + \boldsymbol{\epsilon}) \approx L(\mathbf{x}<em>0) + \boldsymbol{\epsilon}\cdot \nabla</em>{\mathbf{x}} L(\mathbf{x}_0).
$$</p>
<p>If the gradient is not zero, we know that we can take a step in the direction $-\epsilon \nabla_{\mathbf{x}} L(\mathbf{x}_0)$ to find a value of $L$ that is smaller.  Thus, if we truly are at a minimum, this cannot be the case!  We can conclude that if $\mathbf{x}<em>0$ is a minimum, then $\nabla</em>{\mathbf{x}} L(\mathbf{x}<em>0) = 0$.  We call points with $\nabla</em>{\mathbf{x}} L(\mathbf{x}_0) = 0$ <em>critical points</em>.</p>
<p>This is nice, because in some rare settings, we <em>can</em> explicitly find all the points where the gradient is zero, and find the one with the smallest value.</p>
<p>For a concrete example, consider the function
$$
f(x) = 3x^4 - 4x^3 -12x^2.
$$</p>
<p>This function has derivative
$$
\frac{df}{dx} = 12x^3 - 12x^2 -24x = 12x(x-2)(x+1).
$$</p>
<p>The only possible location of minima are at $x = -1, 0, 2$, where the function takes the values $-5,0, -32$ respectively, and thus we can conclude that we minimize our function when $x = 2$.  A quick plot confirms this.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-2, 3, 0.01)
f = (3 * x**4) - (4 * x**3) - (12 * x**2)

d2l.plot(x, f, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-2, 3, 0.01)
f = (3 * x**4) - (4 * x**3) - (12 * x**2)

d2l.plot(x, f, 'x', 'f(x)')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-2, 3, 0.01)
f = (3 * x**4) - (4 * x**3) - (12 * x**2)

d2l.plot(x, f, 'x', 'f(x)')
</code></pre>
<p>This highlights an important fact to know when working either theoretically or numerically: the only possible points where we can minimize (or maximize) a function will have gradient equal to zero, however, not every point with gradient zero is the true <em>global</em> minimum (or maximum).</p>
<h2 id="multivariate-chain-rule"><a class="header" href="#multivariate-chain-rule">Multivariate Chain Rule</a></h2>
<p>Let's suppose that we have a function of four variables ($w, x, y$, and $z$) which we can make by composing many terms:</p>
<p>$$\begin{aligned}f(u, v) &amp; = (u+v)^{2} \u(a, b) &amp; = (a+b)^{2}, \qquad v(a, b) = (a-b)^{2}, \a(w, x, y, z) &amp; = (w+x+y+z)^{2}, \qquad b(w, x, y, z) = (w+x-y-z)^2.\end{aligned}$$
:eqlabel:<code>eq_multi_func_def</code></p>
<p>Such chains of equations are common when working with neural networks, so trying to understand how to compute gradients of such functions is key.  We can start to see visual hints of this connection in :numref:<code>fig_chain-1</code> if we take a look at what variables directly relate to one another.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/chain-net1.svg" alt="The function relations above where nodes represent values and edges show functional dependence." />
:label:<code>fig_chain-1</code></p>
<p>Nothing stops us from just composing everything from :eqref:<code>eq_multi_func_def</code> and writing out that</p>
<p>$$
f(w, x, y, z) = \left(\left((w+x+y+z)^2+(w+x-y-z)^2\right)^2+\left((w+x+y+z)^2-(w+x-y-z)^2\right)^2\right)^2.
$$</p>
<p>We may then take the derivative by just using single variable derivatives, but if we did that we would quickly find ourself swamped with terms, many of which are repeats!  Indeed, one can see that, for instance:</p>
<p>$$
\begin{aligned}
\frac{\partial f}{\partial w} &amp; = 2 \left(2 \left(2 (w + x + y + z) - 2 (w + x - y - z)\right) \left((w + x + y + z)^{2}- (w + x - y - z)^{2}\right) + \right.\
&amp; \left. \quad 2 \left(2 (w + x - y - z) + 2 (w + x + y + z)\right) \left((w + x - y - z)^{2}+ (w + x + y + z)^{2}\right)\right) \times \
&amp; \quad \left(\left((w + x + y + z)^{2}- (w + x - y - z)^2\right)^{2}+ \left((w + x - y - z)^{2}+ (w + x + y + z)^{2}\right)^{2}\right).
\end{aligned}
$$</p>
<p>If we then also wanted to compute $\frac{\partial f}{\partial x}$, we would end up with a similar equation again with many repeated terms, and many <em>shared</em> repeated terms between the two derivatives.  This represents a massive quantity of wasted work, and if we needed to compute derivatives this way, the whole deep learning revolution would have stalled out before it began!</p>
<p>Let's break up the problem.  We will start by trying to understand how $f$ changes when we change $a$, essentially assuming that $w, x, y$, and $z$ all do not exist.  We will reason as we did back when we worked with the gradient for the first time.  Let's take $a$ and add a small amount $\epsilon$ to it.</p>
<p>$$
\begin{aligned}
&amp; f(u(a+\epsilon, b), v(a+\epsilon, b)) \
\approx &amp; f\left(u(a, b) + \epsilon\frac{\partial u}{\partial a}(a, b), v(a, b) + \epsilon\frac{\partial v}{\partial a}(a, b)\right) \
\approx &amp; f(u(a, b), v(a, b)) + \epsilon\left[\frac{\partial f}{\partial u}(u(a, b), v(a, b))\frac{\partial u}{\partial a}(a, b) + \frac{\partial f}{\partial v}(u(a, b), v(a, b))\frac{\partial v}{\partial a}(a, b)\right].
\end{aligned}
$$</p>
<p>The first line follows from the definition of partial derivative, and the second follows from the definition of gradient.  It is notationally burdensome to track exactly where we evaluate every derivative, as in the expression $\frac{\partial f}{\partial u}(u(a, b), v(a, b))$, so we often abbreviate this to the much more memorable</p>
<p>$$
\frac{\partial f}{\partial a} = \frac{\partial f}{\partial u}\frac{\partial u}{\partial a}+\frac{\partial f}{\partial v}\frac{\partial v}{\partial a}.
$$</p>
<p>It is useful to think about the meaning of the process. We are trying to understand how a function of the form $f(u(a, b), v(a, b))$ changes its value with a change in $a$.  There are two pathways this can occur: there is the pathway where $a \rightarrow u \rightarrow f$ and where $a \rightarrow v \rightarrow f$.  We can compute both of these contributions via the chain rule: $\frac{\partial w}{\partial u} \cdot \frac{\partial u}{\partial x}$ and $\frac{\partial w}{\partial v} \cdot \frac{\partial v}{\partial x}$ respectively, and added up.</p>
<p>Imagine we have a different network of functions where the functions on the right depend on those that are connected to on the left as is shown in :numref:<code>fig_chain-2</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/chain-net2.svg" alt="Another more subtle example of the chain rule." />
:label:<code>fig_chain-2</code></p>
<p>To compute something like $\frac{\partial f}{\partial y}$, we need to sum over all (in this case $3$) paths from $y$ to $f$ giving</p>
<p>$$
\frac{\partial f}{\partial y} = \frac{\partial f}{\partial a} \frac{\partial a}{\partial u} \frac{\partial u}{\partial y} + \frac{\partial f}{\partial u} \frac{\partial u}{\partial y} + \frac{\partial f}{\partial b} \frac{\partial b}{\partial v} \frac{\partial v}{\partial y}.
$$</p>
<p>Understanding the chain rule in this way will pay great dividends when trying to understand how gradients flow through networks, and why various architectural choices like those in LSTMs (:numref:<code>sec_lstm</code>) or residual layers (:numref:<code>sec_resnet</code>) can help shape the learning process by controlling gradient flow.</p>
<h2 id="the-backpropagation-algorithm"><a class="header" href="#the-backpropagation-algorithm">The Backpropagation Algorithm</a></h2>
<p>Let's return to the example of :eqref:<code>eq_multi_func_def</code> the previous section where</p>
<p>$$
\begin{aligned}
f(u, v) &amp; = (u+v)^{2} \
u(a, b) &amp; = (a+b)^{2}, \qquad v(a, b) = (a-b)^{2}, \
a(w, x, y, z) &amp; = (w+x+y+z)^{2}, \qquad b(w, x, y, z) = (w+x-y-z)^2.
\end{aligned}
$$</p>
<p>If we want to compute say $\frac{\partial f}{\partial w}$ we may apply the multi-variate chain rule to see:</p>
<p>$$
\begin{aligned}
\frac{\partial f}{\partial w} &amp; = \frac{\partial f}{\partial u}\frac{\partial u}{\partial w} + \frac{\partial f}{\partial v}\frac{\partial v}{\partial w}, \
\frac{\partial u}{\partial w} &amp; = \frac{\partial u}{\partial a}\frac{\partial a}{\partial w}+\frac{\partial u}{\partial b}\frac{\partial b}{\partial w}, \
\frac{\partial v}{\partial w} &amp; = \frac{\partial v}{\partial a}\frac{\partial a}{\partial w}+\frac{\partial v}{\partial b}\frac{\partial b}{\partial w}.
\end{aligned}
$$</p>
<p>Let's try using this decomposition to compute $\frac{\partial f}{\partial w}$.  Notice that all we need here are the various single step partials:</p>
<p>$$
\begin{aligned}
\frac{\partial f}{\partial u} = 2(u+v), &amp; \quad\frac{\partial f}{\partial v} = 2(u+v), \
\frac{\partial u}{\partial a} = 2(a+b), &amp; \quad\frac{\partial u}{\partial b} = 2(a+b), \
\frac{\partial v}{\partial a} = 2(a-b), &amp; \quad\frac{\partial v}{\partial b} = -2(a-b), \
\frac{\partial a}{\partial w} = 2(w+x+y+z), &amp; \quad\frac{\partial b}{\partial w} = 2(w+x-y-z).
\end{aligned}
$$</p>
<p>If we write this out into code this becomes a fairly manageable expression.</p>
<pre><code class="language-{.python .input}">#@tab all
# Compute the value of the function from inputs to outputs
w, x, y, z = -1, 0, -2, 1
a, b = (w + x + y + z)**2, (w + x - y - z)**2
u, v = (a + b)**2, (a - b)**2
f = (u + v)**2
print(f'    f at {w}, {x}, {y}, {z} is {f}')

# Compute the single step partials
df_du, df_dv = 2*(u + v), 2*(u + v)
du_da, du_db, dv_da, dv_db = 2*(a + b), 2*(a + b), 2*(a - b), -2*(a - b)
da_dw, db_dw = 2*(w + x + y + z), 2*(w + x - y - z)

# Compute the final result from inputs to outputs
du_dw, dv_dw = du_da*da_dw + du_db*db_dw, dv_da*da_dw + dv_db*db_dw
df_dw = df_du*du_dw + df_dv*dv_dw
print(f'df/dw at {w}, {x}, {y}, {z} is {df_dw}')
</code></pre>
<p>However, note that this still does not make it easy to compute something like $\frac{\partial f}{\partial x}$.  The reason for that is the <em>way</em> we chose to apply the chain rule.  If we look at what we did above, we always kept $\partial w$ in the denominator when we could.  In this way, we chose to apply the chain rule seeing how $w$ changed every other variable.  If that is what we wanted, this would be a good idea.  However, think back to our motivation from deep learning: we want to see how every parameter changes the <em>loss</em>.  In essence, we want to apply the chain rule keeping $\partial f$ in the numerator whenever we can!</p>
<p>To be more explicit, note that we can write</p>
<p>$$
\begin{aligned}
\frac{\partial f}{\partial w} &amp; = \frac{\partial f}{\partial a}\frac{\partial a}{\partial w} + \frac{\partial f}{\partial b}\frac{\partial b}{\partial w}, \
\frac{\partial f}{\partial a} &amp; = \frac{\partial f}{\partial u}\frac{\partial u}{\partial a}+\frac{\partial f}{\partial v}\frac{\partial v}{\partial a}, \
\frac{\partial f}{\partial b} &amp; = \frac{\partial f}{\partial u}\frac{\partial u}{\partial b}+\frac{\partial f}{\partial v}\frac{\partial v}{\partial b}.
\end{aligned}
$$</p>
<p>Note that this application of the chain rule has us explicitly compute $\frac{\partial f}{\partial u}, \frac{\partial f}{\partial v}, \frac{\partial f}{\partial a}, \frac{\partial f}{\partial b}, ; \textrm{and} ; \frac{\partial f}{\partial w}$.  Nothing stops us from also including the equations:</p>
<p>$$
\begin{aligned}
\frac{\partial f}{\partial x} &amp; = \frac{\partial f}{\partial a}\frac{\partial a}{\partial x} + \frac{\partial f}{\partial b}\frac{\partial b}{\partial x}, \
\frac{\partial f}{\partial y} &amp; = \frac{\partial f}{\partial a}\frac{\partial a}{\partial y}+\frac{\partial f}{\partial b}\frac{\partial b}{\partial y}, \
\frac{\partial f}{\partial z} &amp; = \frac{\partial f}{\partial a}\frac{\partial a}{\partial z}+\frac{\partial f}{\partial b}\frac{\partial b}{\partial z}.
\end{aligned}
$$</p>
<p>and then keeping track of how $f$ changes when we change <em>any</em> node in the entire network.  Let's implement it.</p>
<pre><code class="language-{.python .input}">#@tab all
# Compute the value of the function from inputs to outputs
w, x, y, z = -1, 0, -2, 1
a, b = (w + x + y + z)**2, (w + x - y - z)**2
u, v = (a + b)**2, (a - b)**2
f = (u + v)**2
print(f'f at {w}, {x}, {y}, {z} is {f}')

# Compute the derivative using the decomposition above
# First compute the single step partials
df_du, df_dv = 2*(u + v), 2*(u + v)
du_da, du_db, dv_da, dv_db = 2*(a + b), 2*(a + b), 2*(a - b), -2*(a - b)
da_dw, db_dw = 2*(w + x + y + z), 2*(w + x - y - z)
da_dx, db_dx = 2*(w + x + y + z), 2*(w + x - y - z)
da_dy, db_dy = 2*(w + x + y + z), -2*(w + x - y - z)
da_dz, db_dz = 2*(w + x + y + z), -2*(w + x - y - z)

# Now compute how f changes when we change any value from output to input
df_da, df_db = df_du*du_da + df_dv*dv_da, df_du*du_db + df_dv*dv_db
df_dw, df_dx = df_da*da_dw + df_db*db_dw, df_da*da_dx + df_db*db_dx
df_dy, df_dz = df_da*da_dy + df_db*db_dy, df_da*da_dz + df_db*db_dz

print(f'df/dw at {w}, {x}, {y}, {z} is {df_dw}')
print(f'df/dx at {w}, {x}, {y}, {z} is {df_dx}')
print(f'df/dy at {w}, {x}, {y}, {z} is {df_dy}')
print(f'df/dz at {w}, {x}, {y}, {z} is {df_dz}')
</code></pre>
<p>The fact that we compute derivatives from $f$ back towards the inputs rather than from the inputs forward to the outputs (as we did in the first code snippet above) is what gives this algorithm its name: <em>backpropagation</em>.  Note that there are two steps:</p>
<ol>
<li>Compute the value of the function, and the single step partials from front to back.  While not done above, this can be combined into a single <em>forward pass</em>.</li>
<li>Compute the gradient of $f$ from back to front.  We call this the <em>backwards pass</em>.</li>
</ol>
<p>This is precisely what every deep learning algorithm implements to allow the computation of the gradient of the loss with respect to every weight in the network at one pass.  It is an astonishing fact that we have such a decomposition.</p>
<p>To see how to encapsulated this, let's take a quick look at this example.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Initialize as ndarrays, then attach gradients
w, x, y, z = np.array(-1), np.array(0), np.array(-2), np.array(1)

w.attach_grad()
x.attach_grad()
y.attach_grad()
z.attach_grad()

# Do the computation like usual, tracking gradients
with autograd.record():
    a, b = (w + x + y + z)**2, (w + x - y - z)**2
    u, v = (a + b)**2, (a - b)**2
    f = (u + v)**2

# Execute backward pass
f.backward()

print(f'df/dw at {w}, {x}, {y}, {z} is {w.grad}')
print(f'df/dx at {w}, {x}, {y}, {z} is {x.grad}')
print(f'df/dy at {w}, {x}, {y}, {z} is {y.grad}')
print(f'df/dz at {w}, {x}, {y}, {z} is {z.grad}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Initialize as ndarrays, then attach gradients
w = torch.tensor([-1.], requires_grad=True)
x = torch.tensor([0.], requires_grad=True)
y = torch.tensor([-2.], requires_grad=True)
z = torch.tensor([1.], requires_grad=True)
# Do the computation like usual, tracking gradients
a, b = (w + x + y + z)**2, (w + x - y - z)**2
u, v = (a + b)**2, (a - b)**2
f = (u + v)**2

# Execute backward pass
f.backward()

print(f'df/dw at {w.data.item()}, {x.data.item()}, {y.data.item()}, '
      f'{z.data.item()} is {w.grad.data.item()}')
print(f'df/dx at {w.data.item()}, {x.data.item()}, {y.data.item()}, '
      f'{z.data.item()} is {x.grad.data.item()}')
print(f'df/dy at {w.data.item()}, {x.data.item()}, {y.data.item()}, '
      f'{z.data.item()} is {y.grad.data.item()}')
print(f'df/dz at {w.data.item()}, {x.data.item()}, {y.data.item()}, '
      f'{z.data.item()} is {z.grad.data.item()}')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Initialize as ndarrays, then attach gradients
w = tf.Variable(tf.constant([-1.]))
x = tf.Variable(tf.constant([0.]))
y = tf.Variable(tf.constant([-2.]))
z = tf.Variable(tf.constant([1.]))
# Do the computation like usual, tracking gradients
with tf.GradientTape(persistent=True) as t:
    a, b = (w + x + y + z)**2, (w + x - y - z)**2
    u, v = (a + b)**2, (a - b)**2
    f = (u + v)**2

# Execute backward pass
w_grad = t.gradient(f, w).numpy()
x_grad = t.gradient(f, x).numpy()
y_grad = t.gradient(f, y).numpy()
z_grad = t.gradient(f, z).numpy()

print(f'df/dw at {w.numpy()}, {x.numpy()}, {y.numpy()}, '
      f'{z.numpy()} is {w_grad}')
print(f'df/dx at {w.numpy()}, {x.numpy()}, {y.numpy()}, '
      f'{z.numpy()} is {x_grad}')
print(f'df/dy at {w.numpy()}, {x.numpy()}, {y.numpy()}, '
      f'{z.numpy()} is {y_grad}')
print(f'df/dz at {w.numpy()}, {x.numpy()}, {y.numpy()}, '
      f'{z.numpy()} is {z_grad}')
</code></pre>
<p>All of what we did above can be done automatically by calling <code>f.backwards()</code>.</p>
<h2 id="hessians"><a class="header" href="#hessians">Hessians</a></h2>
<p>As with single variable calculus, it is useful to consider higher-order derivatives in order to get a handle on how we can obtain a better approximation to a function than using the gradient alone.</p>
<p>There is one immediate problem one encounters when working with higher order derivatives of functions of several variables, and that is there are a large number of them.  If we have a function $f(x_1, \ldots, x_n)$ of $n$ variables, then we can take $n^{2}$ many second derivatives, namely for any choice of $i$ and $j$:</p>
<p>$$
\frac{d^2f}{dx_idx_j} = \frac{d}{dx_i}\left(\frac{d}{dx_j}f\right).
$$</p>
<p>This is traditionally assembled into a matrix called the <em>Hessian</em>:</p>
<p>$$\mathbf{H}_f = \begin{bmatrix} \frac{d^2f}{dx_1dx_1} &amp; \cdots &amp; \frac{d^2f}{dx_1dx_n} \ \vdots &amp; \ddots &amp; \vdots \ \frac{d^2f}{dx_ndx_1} &amp; \cdots &amp; \frac{d^2f}{dx_ndx_n} \ \end{bmatrix}.$$
:eqlabel:<code>eq_hess_def</code></p>
<p>Not every entry of this matrix is independent.  Indeed, we can show that as long as both <em>mixed partials</em> (partial derivatives with respect to more than one variable) exist and are continuous, we can say that for any $i$, and $j$,</p>
<p>$$
\frac{d^2f}{dx_idx_j} = \frac{d^2f}{dx_jdx_i}.
$$</p>
<p>This follows by considering first perturbing a function in the direction of $x_i$, and then perturbing it in $x_j$ and then comparing the result of that with what happens if we perturb first $x_j$ and then $x_i$, with the knowledge that both of these orders lead to the same final change in the output of $f$.</p>
<p>As with single variables, we can use these derivatives to get a far better idea of how the function behaves near a point.  In particular, we can use it to find the best fitting quadratic near a point $\mathbf{x}_0$, as we saw in a single variable.</p>
<p>Let's see an example.  Suppose that $f(x_1, x_2) = a + b_1x_1 + b_2x_2 + c_{11}x_1^{2} + c_{12}x_1x_2 + c_{22}x_2^{2}$.  This is the general form for a quadratic in two variables.  If we look at the value of the function, its gradient, and its Hessian :eqref:<code>eq_hess_def</code>, all at the point zero:</p>
<p>$$
\begin{aligned}
f(0,0) &amp; = a, \
\nabla f (0,0) &amp; = \begin{bmatrix}b_1 \ b_2\end{bmatrix}, \
\mathbf{H} f (0,0) &amp; = \begin{bmatrix}2 c_{11} &amp; c_{12} \ c_{12} &amp; 2c_{22}\end{bmatrix},
\end{aligned}
$$</p>
<p>we can get our original polynomial back by saying</p>
<p>$$
f(\mathbf{x}) = f(0) + \nabla f (0) \cdot \mathbf{x} + \frac{1}{2}\mathbf{x}^\top \mathbf{H} f (0) \mathbf{x}.
$$</p>
<p>In general, if we computed this expansion any point $\mathbf{x}_0$, we see that</p>
<p>$$
f(\mathbf{x}) = f(\mathbf{x}_0) + \nabla f (\mathbf{x}_0) \cdot (\mathbf{x}-\mathbf{x}_0) + \frac{1}{2}(\mathbf{x}-\mathbf{x}_0)^\top \mathbf{H} f (\mathbf{x}_0) (\mathbf{x}-\mathbf{x}_0).
$$</p>
<p>This works for any dimensional input, and provides the best approximating quadratic to any function at a point.  To give an example, let's plot the function</p>
<p>$$
f(x, y) = xe^{-x^2-y^2}.
$$</p>
<p>One can compute that the gradient and Hessian are
$$
\nabla f(x, y) = e^{-x^2-y^2}\begin{pmatrix}1-2x^2 \ -2xy\end{pmatrix} ; \textrm{and} ; \mathbf{H}f(x, y) = e^{-x^2-y^2}\begin{pmatrix} 4x^3 - 6x &amp; 4x^2y - 2y \ 4x^2y-2y &amp;4xy^2-2x\end{pmatrix}.
$$</p>
<p>And thus, with a little algebra, see that the approximating quadratic at $[-1,0]^\top$ is</p>
<p>$$
f(x, y) \approx e^{-1}\left(-1 - (x+1) +(x+1)^2+y^2\right).
$$</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Construct grid and compute function
x, y = np.meshgrid(np.linspace(-2, 2, 101),
                   np.linspace(-2, 2, 101), indexing='ij')
z = x*np.exp(- x**2 - y**2)

# Compute approximating quadratic with gradient and Hessian at (1, 0)
w = np.exp(-1)*(-1 - (x + 1) + (x + 1)**2 + y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.asnumpy(), y.asnumpy(), z.asnumpy(),
                  **{'rstride': 10, 'cstride': 10})
ax.plot_wireframe(x.asnumpy(), y.asnumpy(), w.asnumpy(),
                  **{'rstride': 10, 'cstride': 10}, color='purple')
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(-1, 1)
ax.dist = 12
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Construct grid and compute function
x, y = torch.meshgrid(torch.linspace(-2, 2, 101),
                   torch.linspace(-2, 2, 101))

z = x*torch.exp(- x**2 - y**2)

# Compute approximating quadratic with gradient and Hessian at (1, 0)
w = torch.exp(torch.tensor([-1.]))*(-1 - (x + 1) + 2 * (x + 1)**2 + 2 * y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.numpy(), y.numpy(), z.numpy(),
                  **{'rstride': 10, 'cstride': 10})
ax.plot_wireframe(x.numpy(), y.numpy(), w.numpy(),
                  **{'rstride': 10, 'cstride': 10}, color='purple')
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(-1, 1)
ax.dist = 12
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Construct grid and compute function
x, y = tf.meshgrid(tf.linspace(-2., 2., 101),
                   tf.linspace(-2., 2., 101))

z = x*tf.exp(- x**2 - y**2)

# Compute approximating quadratic with gradient and Hessian at (1, 0)
w = tf.exp(tf.constant([-1.]))*(-1 - (x + 1) + 2 * (x + 1)**2 + 2 * y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.numpy(), y.numpy(), z.numpy(),
                  **{'rstride': 10, 'cstride': 10})
ax.plot_wireframe(x.numpy(), y.numpy(), w.numpy(),
                  **{'rstride': 10, 'cstride': 10}, color='purple')
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(-1, 1)
ax.dist = 12
</code></pre>
<p>This forms the basis for Newton's Algorithm discussed in :numref:<code>sec_gd</code>, where we perform numerical optimization iteratively finding the best fitting quadratic, and then exactly minimizing that quadratic.</p>
<h2 id="a-little-matrix-calculus"><a class="header" href="#a-little-matrix-calculus">A Little Matrix Calculus</a></h2>
<p>Derivatives of functions involving matrices turn out to be particularly nice.  This section can become notationally heavy, so may be skipped in a first reading, but it is useful to know how derivatives of functions involving common matrix operations are often much cleaner than one might initially anticipate, particularly given how central matrix operations are to deep learning applications.</p>
<p>Let's begin with an example.  Suppose that we have some fixed column vector $\boldsymbol{\beta}$, and we want to take the product function $f(\mathbf{x}) = \boldsymbol{\beta}^\top\mathbf{x}$, and understand how the dot product changes when we change $\mathbf{x}$.</p>
<p>A bit of notation that will be useful when working with matrix derivatives in ML is called the <em>denominator layout matrix derivative</em> where we assemble our partial derivatives into the shape of whatever vector, matrix, or tensor is in the denominator of the differential.  In this case, we will write</p>
<p>$$
\frac{df}{d\mathbf{x}} = \begin{bmatrix}
\frac{df}{dx_1} \
\vdots \
\frac{df}{dx_n}
\end{bmatrix},
$$</p>
<p>where we matched the shape of the column vector $\mathbf{x}$.</p>
<p>If we write out our function into components this is</p>
<p>$$
f(\mathbf{x}) = \sum_{i = 1}^{n} \beta_ix_i = \beta_1x_1 + \cdots + \beta_nx_n.
$$</p>
<p>If we now take the partial derivative with respect to say $\beta_1$, note that everything is zero but the first term, which is just $x_1$ multiplied by $\beta_1$, so we obtain that</p>
<p>$$
\frac{df}{dx_1} = \beta_1,
$$</p>
<p>or more generally that</p>
<p>$$
\frac{df}{dx_i} = \beta_i.
$$</p>
<p>We can now reassemble this into a matrix to see</p>
<p>$$
\frac{df}{d\mathbf{x}} = \begin{bmatrix}
\frac{df}{dx_1} \
\vdots \
\frac{df}{dx_n}
\end{bmatrix} = \begin{bmatrix}
\beta_1 \
\vdots \
\beta_n
\end{bmatrix} = \boldsymbol{\beta}.
$$</p>
<p>This illustrates a few factors about matrix calculus that we will often counter throughout this section:</p>
<ul>
<li>First, The computations will get rather involved.</li>
<li>Second, The final results are much cleaner than the intermediate process, and will always look similar to the single variable case.  In this case, note that $\frac{d}{dx}(bx) = b$ and $\frac{d}{d\mathbf{x}} (\boldsymbol{\beta}^\top\mathbf{x}) = \boldsymbol{\beta}$ are both similar.</li>
<li>Third, transposes can often appear seemingly from nowhere.  The core reason for this is the convention that we match the shape of the denominator, thus when we multiply matrices, we will need to take transposes to match back to the shape of the original term.</li>
</ul>
<p>To keep building intuition, let's try a computation that is a little harder.  Suppose that we have a column vector $\mathbf{x}$, and a square matrix $A$ and we want to compute</p>
<p>$$\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A \mathbf{x}).$$
:eqlabel:<code>eq_mat_goal_1</code></p>
<p>To drive towards easier to manipulate notation, let's consider this problem using Einstein notation.  In this case we can write the function as</p>
<p>$$
\mathbf{x}^\top A \mathbf{x} = x_ia_{ij}x_j.
$$</p>
<p>To compute our derivative, we need to understand for every $k$, what is the value of</p>
<p>$$
\frac{d}{dx_k}(\mathbf{x}^\top A \mathbf{x}) = \frac{d}{dx_k}x_ia_{ij}x_j.
$$</p>
<p>By the product rule, this is</p>
<p>$$
\frac{d}{dx_k}x_ia_{ij}x_j = \frac{dx_i}{dx_k}a_{ij}x_j + x_ia_{ij}\frac{dx_j}{dx_k}.
$$</p>
<p>For a term like $\frac{dx_i}{dx_k}$, it is not hard to see that this is one when $i=k$ and zero otherwise.  This means that every term where $i$ and $k$ are different vanish from this sum, so the only terms that remain in that first sum are the ones where $i=k$.  The same reasoning holds for the second term where we need $j=k$.  This gives</p>
<p>$$
\frac{d}{dx_k}x_ia_{ij}x_j = a_{kj}x_j + x_ia_{ik}.
$$</p>
<p>Now, the names of the indices in Einstein notation are arbitrary---the fact that $i$ and $j$ are different is immaterial to this computation at this point, so we can re-index so that they both use $i$ to see that</p>
<p>$$
\frac{d}{dx_k}x_ia_{ij}x_j = a_{ki}x_i + x_ia_{ik} = (a_{ki} + a_{ik})x_i.
$$</p>
<p>Now, here is where we start to need some practice to go further.  Let's try and identify this outcome in terms of matrix operations.  $a_{ki} + a_{ik}$ is the $k, i$-th component of $\mathbf{A} + \mathbf{A}^\top$.  This gives</p>
<p>$$
\frac{d}{dx_k}x_ia_{ij}x_j = [\mathbf{A} + \mathbf{A}^\top]_{ki}x_i.
$$</p>
<p>Similarly, this term is now the product of the matrix $\mathbf{A} + \mathbf{A}^\top$ by the vector $\mathbf{x}$, so we see that</p>
<p>$$
\left[\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A \mathbf{x})\right]<em>k = \frac{d}{dx_k}x_ia</em>{ij}x_j = [(\mathbf{A} + \mathbf{A}^\top)\mathbf{x}]_k.
$$</p>
<p>Thus, we see that the $k$-th entry of the desired derivative from :eqref:<code>eq_mat_goal_1</code> is just the $k$-th entry of the vector on the right, and thus the two are the same.  Thus yields</p>
<p>$$
\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A \mathbf{x}) = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}.
$$</p>
<p>This required significantly more work than our last one, but the final result is small.  More than that, consider the following computation for traditional single variable derivatives:</p>
<p>$$
\frac{d}{dx}(xax) = \frac{dx}{dx}ax + xa\frac{dx}{dx} = (a+a)x.
$$</p>
<p>Equivalently $\frac{d}{dx}(ax^2) = 2ax = (a+a)x$.  Again, we get a result that looks rather like the single variable result but with a transpose tossed in.</p>
<p>At this point, the pattern should be looking rather suspicious, so let's try to figure out why.  When we take matrix derivatives like this, let's first assume that the expression we get will be another matrix expression: an expression we can write it in terms of products and sums of matrices and their transposes.  If such an expression exists, it will need to be true for all matrices.  In particular, it will need to be true of $1 \times 1$ matrices, in which case the matrix product is just the product of the numbers, the matrix sum is just the sum, and the transpose does nothing at all!  In other words, whatever expression we get <em>must</em> match the single variable expression.  This means that, with some practice, one can often guess matrix derivatives just by knowing what the associated single variable expression must look like!</p>
<p>Let's try this out.  Suppose that $\mathbf{X}$ is a $n \times m$ matrix, $\mathbf{U}$ is an $n \times r$ and $\mathbf{V}$ is an $r \times m$.  Let's try to compute</p>
<p>$$\frac{d}{d\mathbf{V}} |\mathbf{X} - \mathbf{U}\mathbf{V}|_2^{2} = ;?$$
:eqlabel:<code>eq_mat_goal_2</code></p>
<p>This computation is important in an area called matrix factorization.  For us, however, it is just a derivative to compute.  Let's try to imagine what this would be for $1\times1$ matrices.  In that case, we get the expression</p>
<p>$$
\frac{d}{dv} (x-uv)^{2}= -2(x-uv)u,
$$</p>
<p>where, the derivative is rather standard.  If we try to convert this back into a matrix expression we get</p>
<p>$$
\frac{d}{d\mathbf{V}} |\mathbf{X} - \mathbf{U}\mathbf{V}|_2^{2}= -2(\mathbf{X} - \mathbf{U}\mathbf{V})\mathbf{U}.
$$</p>
<p>However, if we look at this it does not quite work.  Recall that $\mathbf{X}$ is $n \times m$, as is $\mathbf{U}\mathbf{V}$, so the matrix $2(\mathbf{X} - \mathbf{U}\mathbf{V})$ is $n \times m$.  On the other hand $\mathbf{U}$ is $n \times r$, and we cannot multiply a $n \times m$ and a $n \times r$ matrix since the dimensions do not match!</p>
<p>We want to get $\frac{d}{d\mathbf{V}}$, which is the same shape as $\mathbf{V}$, which is $r \times m$.  So somehow we need to take a $n \times m$ matrix and a $n \times r$ matrix, multiply them together (perhaps with some transposes) to get a $r \times m$. We can do this by multiplying $U^\top$ by $(\mathbf{X} - \mathbf{U}\mathbf{V})$.  Thus, we can guess the solution to :eqref:<code>eq_mat_goal_2</code> is</p>
<p>$$
\frac{d}{d\mathbf{V}} |\mathbf{X} - \mathbf{U}\mathbf{V}|_2^{2}= -2\mathbf{U}^\top(\mathbf{X} - \mathbf{U}\mathbf{V}).
$$</p>
<p>To show that this works, we would be remiss to not provide a detailed computation.  If we already believe that this rule-of-thumb works, feel free to skip past this derivation.  To compute</p>
<p>$$
\frac{d}{d\mathbf{V}} |\mathbf{X} - \mathbf{U}\mathbf{V}|_2^2,
$$</p>
<p>we must find for every $a$, and $b$</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= \frac{d}{dv</em>{ab}} \sum_{i, j}\left(x_{ij} - \sum_k u_{ik}v_{kj}\right)^2.
$$</p>
<p>Recalling that all entries of $\mathbf{X}$ and $\mathbf{U}$ are constants as far as $\frac{d}{dv_{ab}}$ is concerned, we may push the derivative inside the sum, and apply the chain rule to the square to get</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= \sum</em>{i, j}2\left(x_{ij} - \sum_k u_{ik}v_{kj}\right)\left(-\sum_k u_{ik}\frac{dv_{kj}}{dv_{ab}} \right).
$$</p>
<p>As in the previous derivation, we may note that $\frac{dv_{kj}}{dv_{ab}}$ is only non-zero if the $k=a$ and $j=b$.  If either of those conditions do not hold, the term in the sum is zero, and we may freely discard it.  We see that</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= -2\sum</em>{i}\left(x_{ib} - \sum_k u_{ik}v_{kb}\right)u_{ia}.
$$</p>
<p>An important subtlety here is that the requirement that $k=a$ does not occur inside the inner sum since that $k$ is a dummy variable which we are summing over inside the inner term.  For a notationally cleaner example, consider why</p>
<p>$$
\frac{d}{dx_1} \left(\sum_i x_i \right)^{2}= 2\left(\sum_i x_i \right).
$$</p>
<p>From this point, we may start identifying components of the sum.  First,</p>
<p>$$
\sum_k u_{ik}v_{kb} = [\mathbf{U}\mathbf{V}]_{ib}.
$$</p>
<p>So the entire expression in the inside of the sum is</p>
<p>$$
x_{ib} - \sum_k u_{ik}v_{kb} = [\mathbf{X}-\mathbf{U}\mathbf{V}]_{ib}.
$$</p>
<p>This means we may now write our derivative as</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= -2\sum</em>{i}[\mathbf{X}-\mathbf{U}\mathbf{V}]<em>{ib}u</em>{ia}.
$$</p>
<p>We want this to look like the $a, b$ element of a matrix so we can use the technique as in the previous example to arrive at a matrix expression, which means that we need to exchange the order of the indices on $u_{ia}$.  If we notice that $u_{ia} = [\mathbf{U}^\top]_{ai}$, we can then write</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= -2\sum</em>{i} [\mathbf{U}^\top]<em>{ai}[\mathbf{X}-\mathbf{U}\mathbf{V}]</em>{ib}.
$$</p>
<p>This is a matrix product, and thus we can conclude that</p>
<p>$$
\frac{d}{dv_{ab}} |\mathbf{X} - \mathbf{U}\mathbf{V}|<em>2^{2}= -2[\mathbf{U}^\top(\mathbf{X}-\mathbf{U}\mathbf{V})]</em>{ab}.
$$</p>
<p>and thus we may write the solution to :eqref:<code>eq_mat_goal_2</code></p>
<p>$$
\frac{d}{d\mathbf{V}} |\mathbf{X} - \mathbf{U}\mathbf{V}|_2^{2}= -2\mathbf{U}^\top(\mathbf{X} - \mathbf{U}\mathbf{V}).
$$</p>
<p>This matches the solution we guessed above!</p>
<p>It is reasonable to ask at this point, "Why can I not just write down matrix versions of all the calculus rules I have learned?  It is clear this is still mechanical.  Why do we not just get it over with!"  And indeed there are such rules and :cite:<code>Petersen.Pedersen.ea.2008</code> provides an excellent summary.  However, due to the plethora of ways matrix operations can be combined compared to single values, there are many more matrix derivative rules than single variable ones.  It is often the case that it is best to work with the indices, or leave it up to automatic differentiation when appropriate.</p>
<h2 id="summary-129"><a class="header" href="#summary-129">Summary</a></h2>
<ul>
<li>In higher dimensions, we can define gradients which serve the same purpose as derivatives in one dimension.  These allow us to see how a multi-variable function changes when we make an arbitrary small change to the inputs.</li>
<li>The backpropagation algorithm can be seen to be a method of organizing the multi-variable chain rule to allow for the efficient computation of many partial derivatives.</li>
<li>Matrix calculus allows us to write the derivatives of matrix expressions in concise ways.</li>
</ul>
<h2 id="exercises-147"><a class="header" href="#exercises-147">Exercises</a></h2>
<ol>
<li>Given a column vector $\boldsymbol{\beta}$, compute the derivatives of both $f(\mathbf{x}) = \boldsymbol{\beta}^\top\mathbf{x}$ and $g(\mathbf{x}) = \mathbf{x}^\top\boldsymbol{\beta}$.  Why do you get the same answer?</li>
<li>Let $\mathbf{v}$ be an $n$ dimension vector. What is $\frac{\partial}{\partial\mathbf{v}}|\mathbf{v}|_2$?</li>
<li>Let $L(x, y) = \log(e^x + e^y)$.  Compute the gradient.  What is the sum of the components of the gradient?</li>
<li>Let $f(x, y) = x^2y + xy^2$. Show that the only critical point is $(0,0)$. By considering $f(x, x)$, determine if $(0,0)$ is a maximum, minimum, or neither.</li>
<li>Suppose that we are minimizing a function $f(\mathbf{x}) = g(\mathbf{x}) + h(\mathbf{x})$.  How can we geometrically interpret the condition of $\nabla f = 0$ in terms of $g$ and $h$?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/413">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1090">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1091">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integral-calculus"><a class="header" href="#integral-calculus">Integral Calculus</a></h1>
<p>:label:<code>sec_integral_calculus</code></p>
<p>Differentiation only makes up half of the content of a traditional calculus education.  The other pillar, integration, starts out seeming a rather disjoint question, "What is the area underneath this curve?"  While seemingly unrelated, integration is tightly intertwined with the differentiation via what is known as the <em>fundamental theorem of calculus</em>.</p>
<p>At the level of machine learning we discuss in this book, we will not need a deep understanding of integration. However, we will provide a brief introduction to lay the groundwork for any further applications we will encounter later on.</p>
<h2 id="geometric-interpretation"><a class="header" href="#geometric-interpretation">Geometric Interpretation</a></h2>
<p>Suppose that we have a function $f(x)$.  For simplicity, let's assume that $f(x)$ is non-negative (never takes a value less than zero).  What we want to try and understand is: what is the area contained between $f(x)$ and the $x$-axis?</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from mpl_toolkits import mplot3d
from mxnet import np, npx
npx.set_np()

x = np.arange(-2, 2, 0.01)
f = np.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.tolist(), f.tolist())
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
from mpl_toolkits import mplot3d
import torch

x = torch.arange(-2, 2, 0.01)
f = torch.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.tolist(), f.tolist())
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
from mpl_toolkits import mplot3d
import tensorflow as tf

x = tf.range(-2, 2, 0.01)
f = tf.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.numpy(), f.numpy())
d2l.plt.show()
</code></pre>
<p>In most cases, this area will be infinite or undefined (consider the area under $f(x) = x^{2}$), so people will often talk about the area between a pair of ends, say $a$ and $b$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-2, 2, 0.01)
f = np.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.tolist()[50:250], f.tolist()[50:250])
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-2, 2, 0.01)
f = torch.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.tolist()[50:250], f.tolist()[50:250])
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-2, 2, 0.01)
f = tf.exp(-x**2)

d2l.set_figsize()
d2l.plt.plot(x, f, color='black')
d2l.plt.fill_between(x.numpy()[50:250], f.numpy()[50:250])
d2l.plt.show()
</code></pre>
<p>We will denote this area by the integral symbol below:</p>
<p>$$
\textrm{Area}(\mathcal{A}) = \int_a^b f(x) ;dx.
$$</p>
<p>The inner variable is a dummy variable, much like the index of a sum in a $\sum$, and so this can be equivalently written with any inner value we like:</p>
<p>$$
\int_a^b f(x) ;dx = \int_a^b f(z) ;dz.
$$</p>
<p>There is a traditional way to try and understand how we might try to approximate such integrals: we can imagine taking the region in-between $a$ and $b$ and chopping it into $N$ vertical slices.  If $N$ is large, we can approximate the area of each slice by a rectangle, and then add up the areas to get the total area under the curve.  Let's take a look at an example doing this in code.  We will see how to get the true value in a later section.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
epsilon = 0.05
a = 0
b = 2

x = np.arange(a, b, epsilon)
f = x / (1 + x**2)

approx = np.sum(epsilon*f)
true = np.log(2) / 2

d2l.set_figsize()
d2l.plt.bar(x.asnumpy(), f.asnumpy(), width=epsilon, align='edge')
d2l.plt.plot(x, f, color='black')
d2l.plt.ylim([0, 1])
d2l.plt.show()

f'approximation: {approx}, truth: {true}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
epsilon = 0.05
a = 0
b = 2

x = torch.arange(a, b, epsilon)
f = x / (1 + x**2)

approx = torch.sum(epsilon*f)
true = torch.log(torch.tensor([5.])) / 2

d2l.set_figsize()
d2l.plt.bar(x, f, width=epsilon, align='edge')
d2l.plt.plot(x, f, color='black')
d2l.plt.ylim([0, 1])
d2l.plt.show()

f'approximation: {approx}, truth: {true}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
epsilon = 0.05
a = 0
b = 2

x = tf.range(a, b, epsilon)
f = x / (1 + x**2)

approx = tf.reduce_sum(epsilon*f)
true = tf.math.log(tf.constant([5.])) / 2

d2l.set_figsize()
d2l.plt.bar(x, f, width=epsilon, align='edge')
d2l.plt.plot(x, f, color='black')
d2l.plt.ylim([0, 1])
d2l.plt.show()

f'approximation: {approx}, truth: {true}'
</code></pre>
<p>The issue is that while it can be done numerically, we can do this approach analytically for only the simplest functions like</p>
<p>$$
\int_a^b x ;dx.
$$</p>
<p>Anything somewhat more complex like our example from the code above</p>
<p>$$
\int_a^b \frac{x}{1+x^{2}} ;dx.
$$</p>
<p>is beyond what we can solve with such a direct method.</p>
<p>We will instead take a different approach.  We will work intuitively with the notion of the area, and learn the main computational tool used to find integrals: the <em>fundamental theorem of calculus</em>.   This will be the basis for our study of integration.</p>
<h2 id="the-fundamental-theorem-of-calculus"><a class="header" href="#the-fundamental-theorem-of-calculus">The Fundamental Theorem of Calculus</a></h2>
<p>To dive deeper into the theory of integration, let's introduce a function</p>
<p>$$
F(x) = \int_0^x f(y) dy.
$$</p>
<p>This function measures the area between $0$ and $x$ depending on how we change $x$.  Notice that this is everything we need since</p>
<p>$$
\int_a^b f(x) ;dx = F(b) - F(a).
$$</p>
<p>This is a mathematical encoding of the fact that we can measure the area out to the far end-point and then subtract off the area to the near end point as indicated in :numref:<code>fig_area-subtract</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/sub-area.svg" alt="Visualizing why we may reduce the problem of computing the area under a curve between two points to computing the area to the left of a point." />
:label:<code>fig_area-subtract</code></p>
<p>Thus, we can figure out what the integral over any interval is by figuring out what $F(x)$ is.</p>
<p>To do so, let's consider an experiment.  As we often do in calculus, let's imagine what happens when we shift the value by a tiny bit.  From the comment above, we know that</p>
<p>$$
F(x+\epsilon) - F(x) = \int_x^{x+\epsilon} f(y) ; dy.
$$</p>
<p>This tells us that the function changes by the area under a tiny sliver of a function.</p>
<p>This is the point at which we make an approximation.  If we look at a tiny sliver of area like this, it looks like this area is close to the rectangular area with height the value of $f(x)$ and the base width $\epsilon$.  Indeed, one can show that as $\epsilon \rightarrow 0$ this approximation becomes better and better.  Thus we can conclude:</p>
<p>$$
F(x+\epsilon) - F(x) \approx \epsilon f(x).
$$</p>
<p>However, we can now notice: this is exactly the pattern we expect if we were computing the derivative of $F$!  Thus we see the following rather surprising fact:</p>
<p>$$
\frac{dF}{dx}(x) = f(x).
$$</p>
<p>This is the <em>fundamental theorem of calculus</em>.  We may write it in expanded form as
$$\frac{d}{dx}\int_0^x  f(y) ; dy = f(x).$$
:eqlabel:<code>eq_ftc</code></p>
<p>It takes the concept of finding areas (<em>a priori</em> rather hard), and reduces it to a statement derivatives (something much more completely understood).  One last comment that we must make is that this does not tell us exactly what $F(x)$ is.  Indeed $F(x) + C$ for any $C$ has the same derivative.  This is a fact-of-life in the theory of integration.  Thankfully, notice that when working with definite integrals, the constants drop out, and thus are irrelevant to the outcome.</p>
<p>$$
\int_a^b f(x) ; dx = (F(b) + C) - (F(a) + C) = F(b) - F(a).
$$</p>
<p>This may seem like abstract non-sense, but let's take a moment to appreciate that it has given us a whole new perspective on computing integrals.  Our goal is no-longer to do some sort of chop-and-sum process to try and recover the area, rather we need only find a function whose derivative is the function we have!  This is incredible since we can now list many rather difficult integrals by just reversing the table from :numref:<code>sec_derivative_table</code>.  For instance, we know that the derivative of $x^{n}$ is $nx^{n-1}$.  Thus, we can say using the fundamental theorem :eqref:<code>eq_ftc</code> that</p>
<p>$$
\int_0^{x} ny^{n-1} ; dy = x^n - 0^n = x^n.
$$</p>
<p>Similarly, we know that the derivative of $e^{x}$ is itself, so that means</p>
<p>$$
\int_0^{x} e^{x} ; dx = e^{x} - e^{0} = e^x - 1.
$$</p>
<p>In this way, we can develop the entire theory of integration leveraging ideas from differential calculus freely.  Every integration rule derives from this one fact.</p>
<h2 id="change-of-variables"><a class="header" href="#change-of-variables">Change of Variables</a></h2>
<p>:label:<code>subsec_integral_example</code></p>
<p>Just as with differentiation, there are a number of rules which make the computation of integrals more tractable.  In fact, every rule of differential calculus (like the product rule, sum rule, and chain rule) has a corresponding rule for integral calculus (integration by parts, linearity of integration, and the change of variables formula respectively).  In this section, we will dive into what is arguably the most important from the list: the change of variables formula.</p>
<p>First, suppose that we have a function which is itself an integral:</p>
<p>$$
F(x) = \int_0^x f(y) ; dy.
$$</p>
<p>Let's suppose that we want to know how this function looks when we compose it with another to obtain $F(u(x))$.  By the chain rule, we know</p>
<p>$$
\frac{d}{dx}F(u(x)) = \frac{dF}{du}(u(x))\cdot \frac{du}{dx}.
$$</p>
<p>We can turn this into a statement about integration by using the fundamental theorem :eqref:<code>eq_ftc</code> as above.  This gives</p>
<p>$$
F(u(x)) - F(u(0)) = \int_0^x \frac{dF}{du}(u(y))\cdot \frac{du}{dy} ;dy.
$$</p>
<p>Recalling that $F$ is itself an integral gives that the left hand side may be rewritten to be</p>
<p>$$
\int_{u(0)}^{u(x)} f(y) ; dy = \int_0^x \frac{dF}{du}(u(y))\cdot \frac{du}{dy} ;dy.
$$</p>
<p>Similarly, recalling that $F$ is an integral allows us to recognize that $\frac{dF}{dx} = f$ using the fundamental theorem :eqref:<code>eq_ftc</code>, and thus we may conclude</p>
<p>$$\int_{u(0)}^{u(x)} f(y) ; dy = \int_0^x f(u(y))\cdot \frac{du}{dy} ;dy.$$
:eqlabel:<code>eq_change_var</code></p>
<p>This is the <em>change of variables</em> formula.</p>
<p>For a more intuitive derivation, consider what happens when we take an integral of $f(u(x))$ between $x$ and $x+\epsilon$. For a small $\epsilon$, this integral is approximately $\epsilon f(u(x))$, the area of the associated rectangle.  Now, let's compare this with the integral of $f(y)$ from $u(x)$ to $u(x+\epsilon)$.  We know that $u(x+\epsilon) \approx u(x) + \epsilon \frac{du}{dx}(x)$, so the area of this rectangle is approximately $\epsilon \frac{du}{dx}(x)f(u(x))$.  Thus, to make the area of these two rectangles to agree, we need to multiply the first one by $\frac{du}{dx}(x)$ as is illustrated in :numref:<code>fig_rect-transform</code>.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/rect-trans.svg" alt="Visualizing the transformation of a single thin rectangle under the change of variables." />
:label:<code>fig_rect-transform</code></p>
<p>This tells us that</p>
<p>$$
\int_x^{x+\epsilon} f(u(y))\frac{du}{dy}(y);dy = \int_{u(x)}^{u(x+\epsilon)} f(y) ; dy.
$$</p>
<p>This is the change of variables formula expressed for a single small rectangle.</p>
<p>If $u(x)$ and $f(x)$ are properly chosen, this can allow for the computation of incredibly complex integrals.  For instance, if we even chose $f(y) = 1$ and $u(x) = e^{-x^{2}}$ (which means $\frac{du}{dx}(x) = -2xe^{-x^{2}}$), this can show for instance that</p>
<p>$$
e^{-1} - 1 = \int_{e^{-0}}^{e^{-1}} 1 ; dy = -2\int_0^{1} ye^{-y^2};dy,
$$</p>
<p>and thus by rearranging that</p>
<p>$$
\int_0^{1} ye^{-y^2}; dy = \frac{1-e^{-1}}{2}.
$$</p>
<h2 id="a-comment-on-sign-conventions"><a class="header" href="#a-comment-on-sign-conventions">A Comment on Sign Conventions</a></h2>
<p>Keen-eyed readers will observe something strange about the computations above.  Namely, computations like</p>
<p>$$
\int_{e^{-0}}^{e^{-1}} 1 ; dy = e^{-1} -1 &lt; 0,
$$</p>
<p>can produce negative numbers.  When thinking about areas, it can be strange to see a negative value, and so it is worth digging into what the convention is.</p>
<p>Mathematicians take the notion of signed areas.  This manifests itself in two ways.  First, if we consider a function $f(x)$ which is sometimes less than zero, then the area will also be negative.  So for instance</p>
<p>$$
\int_0^{1} (-1);dx = -1.
$$</p>
<p>Similarly, integrals which progress from right to left, rather than left to right are also taken to be negative areas</p>
<p>$$
\int_0^{-1} 1; dx = -1.
$$</p>
<p>The standard area (from left to right of a positive function) is always positive.  Anything obtained by flipping it (say flipping over the $x$-axis to get the integral of a negative number, or flipping over the $y$-axis to get an integral in the wrong order) will produce a negative area.  And indeed, flipping twice will give a pair of negative signs that cancel out to have positive area</p>
<p>$$
\int_0^{-1} (-1);dx =  1.
$$</p>
<p>If this discussion sounds familiar, it is!  In :numref:<code>sec_geometry-linear-algebraic-ops</code> we discussed how the determinant represented the signed area in much the same way.</p>
<h2 id="multiple-integrals"><a class="header" href="#multiple-integrals">Multiple Integrals</a></h2>
<p>In some cases, we will need to work in higher dimensions.  For instance, suppose that we have a function of two variables, like $f(x, y)$ and we want to know the volume under $f$ when $x$ ranges over $[a, b]$ and $y$ ranges over $[c, d]$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Construct grid and compute function
x, y = np.meshgrid(np.linspace(-2, 2, 101), np.linspace(-2, 2, 101),
                   indexing='ij')
z = np.exp(- x**2 - y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.asnumpy(), y.asnumpy(), z.asnumpy())
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.plt.xticks([-2, -1, 0, 1, 2])
d2l.plt.yticks([-2, -1, 0, 1, 2])
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(0, 1)
ax.dist = 12
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Construct grid and compute function
x, y = torch.meshgrid(torch.linspace(-2, 2, 101), torch.linspace(-2, 2, 101))
z = torch.exp(- x**2 - y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x, y, z)
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.plt.xticks([-2, -1, 0, 1, 2])
d2l.plt.yticks([-2, -1, 0, 1, 2])
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(0, 1)
ax.dist = 12
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Construct grid and compute function
x, y = tf.meshgrid(tf.linspace(-2., 2., 101), tf.linspace(-2., 2., 101))
z = tf.exp(- x**2 - y**2)

# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x, y, z)
d2l.plt.xlabel('x')
d2l.plt.ylabel('y')
d2l.plt.xticks([-2, -1, 0, 1, 2])
d2l.plt.yticks([-2, -1, 0, 1, 2])
d2l.set_figsize()
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.set_zlim(0, 1)
ax.dist = 12
</code></pre>
<p>We write this as</p>
<p>$$
\int_{[a, b]\times[c, d]} f(x, y);dx;dy.
$$</p>
<p>Suppose that we wish to compute this integral.  My claim is that we can do this by iteratively computing first the integral in $x$ and then shifting to the integral in $y$, that is to say</p>
<p>$$
\int_{[a, b]\times[c, d]} f(x, y);dx;dy = \int_c^{d} \left(\int_a^{b} f(x, y) ;dx\right) ; dy.
$$</p>
<p>Let's see why this is.</p>
<p>Consider the figure above where we have split the function into $\epsilon \times \epsilon$ squares which we will index with integer coordinates $i, j$.  In this case, our integral is approximately</p>
<p>$$
\sum_{i, j} \epsilon^{2} f(\epsilon i, \epsilon j).
$$</p>
<p>Once we discretize the problem, we may add up the values on these squares in whatever order we like, and not worry about changing the values.  This is illustrated in :numref:<code>fig_sum-order</code>.  In particular, we can say that</p>
<p>$$
\sum _ {j} \epsilon \left(\sum_{i} \epsilon f(\epsilon i, \epsilon j)\right).
$$</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/sum-order.svg" alt="Illustrating how to decompose a sum over many squares as a sum over first the columns (1), then adding the column sums together (2)." />
:label:<code>fig_sum-order</code></p>
<p>The sum on the inside is precisely the discretization of the integral</p>
<p>$$
G(\epsilon j) = \int _a^{b} f(x, \epsilon j) ; dx.
$$</p>
<p>Finally, notice that if we combine these two expressions we get</p>
<p>$$
\sum _ {j} \epsilon G(\epsilon j) \approx \int _ {c}^{d} G(y) ; dy = \int _ {[a, b]\times[c, d]} f(x, y);dx;dy.
$$</p>
<p>Thus putting it all together, we have that</p>
<p>$$
\int _ {[a, b]\times[c, d]} f(x, y);dx;dy = \int _ c^{d} \left(\int _ a^{b} f(x, y) ;dx\right) ; dy.
$$</p>
<p>Notice that, once discretized, all we did was rearrange the order in which we added a list of numbers.  This may make it seem like it is nothing, however this result (called <em>Fubini's Theorem</em>) is not always true!  For the type of mathematics encountered when doing machine learning (continuous functions), there is no concern, however it is possible to create examples where it fails (for example the function $f(x, y) = xy(x^2-y^2)/(x^2+y^2)^3$ over the rectangle $[0,2]\times[0,1]$).</p>
<p>Note that the choice to do the integral in $x$ first, and then the integral in $y$ was arbitrary.  We could have equally well chosen to do $y$ first and then $x$ to see</p>
<p>$$
\int _ {[a, b]\times[c, d]} f(x, y);dx;dy = \int _ a^{b} \left(\int _ c^{d} f(x, y) ;dy\right) ; dx.
$$</p>
<p>Often times, we will condense down to vector notation, and say that for $U = [a, b]\times [c, d]$ this is</p>
<p>$$
\int _ U f(\mathbf{x});d\mathbf{x}.
$$</p>
<h2 id="change-of-variables-in-multiple-integrals"><a class="header" href="#change-of-variables-in-multiple-integrals">Change of Variables in Multiple Integrals</a></h2>
<p>As with single variables in :eqref:<code>eq_change_var</code>, the ability to change variables inside a higher dimensional integral is a key tool.  Let's summarize the result without derivation.</p>
<p>We need a function that reparametrizes our domain of integration.  We can take this to be $\phi : \mathbb{R}^n \rightarrow \mathbb{R}^n$, that is any function which takes in $n$ real variables and returns another $n$.  To keep the expressions clean, we will assume that $\phi$ is <em>injective</em> which is to say it never folds over itself ($\phi(\mathbf{x}) = \phi(\mathbf{y}) \implies \mathbf{x} = \mathbf{y}$).</p>
<p>In this case, we can say that</p>
<p>$$
\int _ {\phi(U)} f(\mathbf{x});d\mathbf{x} = \int _ {U} f(\phi(\mathbf{x})) \left|\det(D\phi(\mathbf{x}))\right|;d\mathbf{x}.
$$</p>
<p>where $D\phi$ is the <em>Jacobian</em> of $\phi$, which is the matrix of partial derivatives of $\boldsymbol{\phi} = (\phi_1(x_1, \ldots, x_n), \ldots, \phi_n(x_1, \ldots, x_n))$,</p>
<p>$$
D\boldsymbol{\phi} = \begin{bmatrix}
\frac{\partial \phi _ 1}{\partial x _ 1} &amp; \cdots &amp; \frac{\partial \phi _ 1}{\partial x _ n} \
\vdots &amp; \ddots &amp; \vdots \
\frac{\partial \phi _ n}{\partial x _ 1} &amp; \cdots &amp; \frac{\partial \phi _ n}{\partial x _ n}
\end{bmatrix}.
$$</p>
<p>Looking closely, we see that this is similar to the single variable chain rule :eqref:<code>eq_change_var</code>, except we have replaced the term $\frac{du}{dx}(x)$ with $\left|\det(D\phi(\mathbf{x}))\right|$.  Let's see how we can to interpret this term.  Recall that the $\frac{du}{dx}(x)$ term existed to say how much we stretched our $x$-axis by applying $u$.  The same process in higher dimensions is to determine how much we stretch the area (or volume, or hyper-volume) of a little square (or little <em>hyper-cube</em>) by applying $\boldsymbol{\phi}$.  If $\boldsymbol{\phi}$ was the multiplication by a matrix, then we know how the determinant already gives the answer.</p>
<p>With some work, one can show that the <em>Jacobian</em> provides the best approximation to a multivariable function $\boldsymbol{\phi}$ at a point by a matrix in the same way we could approximate by lines or planes with derivatives and gradients. Thus the determinant of the Jacobian exactly mirrors the scaling factor we identified in one dimension.</p>
<p>It takes some work to fill in the details to this, so do not worry if they are not clear now.  Let's see at least one example we will make use of later on.  Consider the integral</p>
<p>$$
\int _ {-\infty}^{\infty} \int _ {-\infty}^{\infty} e^{-x^{2}-y^{2}} ;dx;dy.
$$</p>
<p>Playing with this integral directly will get us no-where, but if we change variables, we can make significant progress.  If we let $\boldsymbol{\phi}(r, \theta) = (r \cos(\theta),  r\sin(\theta))$ (which is to say that $x = r \cos(\theta)$, $y = r \sin(\theta)$), then we can apply the change of variable formula to see that this is the same thing as</p>
<p>$$
\int _ 0^\infty \int_0 ^ {2\pi} e^{-r^{2}} \left|\det(D\mathbf{\phi}(\mathbf{x}))\right|;d\theta;dr,
$$</p>
<p>where</p>
<p>$$
\left|\det(D\mathbf{\phi}(\mathbf{x}))\right| = \left|\det\begin{bmatrix}
\cos(\theta) &amp; -r\sin(\theta) \
\sin(\theta) &amp; r\cos(\theta)
\end{bmatrix}\right| = r(\cos^{2}(\theta) + \sin^{2}(\theta)) = r.
$$</p>
<p>Thus, the integral is</p>
<p>$$
\int _ 0^\infty \int _ 0 ^ {2\pi} re^{-r^{2}} ;d\theta;dr = 2\pi\int _ 0^\infty re^{-r^{2}} ;dr = \pi,
$$</p>
<p>where the final equality follows by the same computation that we used in section :numref:<code>subsec_integral_example</code>.</p>
<p>We will meet this integral again when we study continuous random variables in :numref:<code>sec_random_variables</code>.</p>
<h2 id="summary-130"><a class="header" href="#summary-130">Summary</a></h2>
<ul>
<li>The theory of integration allows us to answer questions about areas or volumes.</li>
<li>The fundamental theorem of calculus allows us to leverage knowledge about derivatives to compute areas via the observation that the derivative of the area up to some point is given by the value of the function being integrated.</li>
<li>Integrals in higher dimensions can be computed by iterating single variable integrals.</li>
</ul>
<h2 id="exercises-148"><a class="header" href="#exercises-148">Exercises</a></h2>
<ol>
<li>What is $\int_1^2 \frac{1}{x} ;dx$?</li>
<li>Use the change of variables formula to integrate $\int_0^{\sqrt{\pi}}x\sin(x^2);dx$.</li>
<li>What is $\int_{[0,1]^2} xy ;dx;dy$?</li>
<li>Use the change of variables formula to compute $\int_0^2\int_0^1xy(x^2-y^2)/(x^2+y^2)^3;dy;dx$ and $\int_0^1\int_0^2f(x, y) = xy(x^2-y^2)/(x^2+y^2)^3;dx;dy$ to see they are different.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/414">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1092">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1093">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="random-variables-1"><a class="header" href="#random-variables-1">Random Variables</a></h1>
<p>:label:<code>sec_random_variables</code></p>
<p>In :numref:<code>sec_prob</code> we saw the basics of how to work with discrete random variables, which in our case refer to those random variables which take either a finite set of possible values, or the integers.  In this section, we develop the theory of <em>continuous random variables</em>, which are random variables which  can take on any real value.</p>
<h2 id="continuous-random-variables"><a class="header" href="#continuous-random-variables">Continuous Random Variables</a></h2>
<p>Continuous random variables are a significantly more subtle topic than discrete random variables.  A fair analogy to make is that the technical jump is comparable to the jump between adding lists of numbers and integrating functions.  As such, we will need to take some time to develop the theory.</p>
<h3 id="from-discrete-to-continuous"><a class="header" href="#from-discrete-to-continuous">From Discrete to Continuous</a></h3>
<p>To understand the additional technical challenges encountered when working with continuous random variables, let's perform a thought experiment.  Suppose that we are throwing a dart at the dart board, and we want to know the probability that it hits exactly $2 \textrm{cm}$ from the center of the board.</p>
<p>To start with, we imagine measuring a single digit of accuracy, that is to say with bins for $0 \textrm{cm}$, $1 \textrm{cm}$, $2 \textrm{cm}$, and so on.  We throw say $100$ darts at the dart board, and if $20$ of them fall into the bin for $2\textrm{cm}$ we conclude that $20%$ of the darts we throw hit the board $2 \textrm{cm}$ away from the center.</p>
<p>However, when we look closer, this does not match our question!  We wanted exact equality, whereas these bins hold all that fell between say $1.5\textrm{cm}$ and $2.5\textrm{cm}$.</p>
<p>Undeterred, we continue further.  We measure even more precisely, say $1.9\textrm{cm}$, $2.0\textrm{cm}$, $2.1\textrm{cm}$, and now see that perhaps $3$ of the $100$ darts hit the board in the $2.0\textrm{cm}$ bucket.  Thus we conclude the probability is $3%$.</p>
<p>However, this does not solve anything!  We have just pushed the issue down one digit further.  Let's abstract a bit. Imagine we know the probability that the first $k$ digits match with $2.00000\ldots$ and we want to know the probability it matches for the first $k+1$ digits. It is fairly reasonable to assume that the ${k+1}^{\textrm{th}}$ digit is essentially a random choice from the set ${0, 1, 2, \ldots, 9}$.  At least, we cannot conceive of a physically meaningful process which would force the number of micrometers away form the center to prefer to end in a $7$ vs a $3$.</p>
<p>What this means is that in essence each additional digit of accuracy we require should decrease probability of matching by a factor of $10$.  Or put another way, we would expect that</p>
<p>$$
P(\textrm{distance is}; 2.00\ldots, ;\textrm{to}; k ;\textrm{digits} ) \approx p\cdot10^{-k}.
$$</p>
<p>The value $p$ essentially encodes what happens with the first few digits, and the $10^{-k}$ handles the rest.</p>
<p>Notice that if we know the position accurate to $k=4$ digits after the decimal, that means we know the value falls within the interval say $[1.99995,2.00005]$ which is an interval of length $2.00005-1.99995 = 10^{-4}$.  Thus, if we call the length of this interval $\epsilon$, we can say</p>
<p>$$
P(\textrm{distance is in an}; \epsilon\textrm{-sized interval around}; 2 ) \approx \epsilon \cdot p.
$$</p>
<p>Let's take this one final step further.  We have been thinking about the point $2$ the entire time, but never thinking about other points.  Nothing is different there fundamentally, but it is the case that the value $p$ will likely be different.  We would at least hope that a dart thrower was more likely to hit a point near the center, like $2\textrm{cm}$ rather than $20\textrm{cm}$.  Thus, the value $p$ is not fixed, but rather should depend on the point $x$.  This tells us that we should expect</p>
<p>$$P(\textrm{distance is in an}; \epsilon \textrm{-sized interval around}; x ) \approx \epsilon \cdot p(x).$$
:eqlabel:<code>eq_pdf_deriv</code></p>
<p>Indeed, :eqref:<code>eq_pdf_deriv</code> precisely defines the <em>probability density function</em>.  It is a function $p(x)$ which encodes the relative probability of hitting near one point vs. another.  Let's visualize what such a function might look like.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from mxnet import np, npx
npx.set_np()

# Plot the probability density function for some random variable
x = np.arange(-5, 5, 0.01)
p = 0.2*np.exp(-(x - 3)**2 / 2)/np.sqrt(2 * np.pi) + \
    0.8*np.exp(-(x + 1)**2 / 2)/np.sqrt(2 * np.pi)

d2l.plot(x, p, 'x', 'Density')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
import torch
torch.pi = torch.acos(torch.zeros(1)).item() * 2  # Define pi in torch

# Plot the probability density function for some random variable
x = torch.arange(-5, 5, 0.01)
p = 0.2*torch.exp(-(x - 3)**2 / 2)/torch.sqrt(2 * torch.tensor(torch.pi)) + \
    0.8*torch.exp(-(x + 1)**2 / 2)/torch.sqrt(2 * torch.tensor(torch.pi))

d2l.plot(x, p, 'x', 'Density')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
import tensorflow as tf
tf.pi = tf.acos(tf.zeros(1)).numpy() * 2  # Define pi in TensorFlow

# Plot the probability density function for some random variable
x = tf.range(-5, 5, 0.01)
p = 0.2*tf.exp(-(x - 3)**2 / 2)/tf.sqrt(2 * tf.constant(tf.pi)) + \
    0.8*tf.exp(-(x + 1)**2 / 2)/tf.sqrt(2 * tf.constant(tf.pi))

d2l.plot(x, p, 'x', 'Density')
</code></pre>
<p>The locations where the function value is large indicates regions where we are more likely to find the random value.  The low portions are areas where we are unlikely to find the random value.</p>
<h3 id="probability-density-functions"><a class="header" href="#probability-density-functions">Probability Density Functions</a></h3>
<p>Let's now investigate this further.  We have already seen what a probability density function is intuitively for a random variable $X$, namely the density function is a function $p(x)$ so that</p>
<p>$$P(X ; \textrm{is in an}; \epsilon \textrm{-sized interval around}; x ) \approx \epsilon \cdot p(x).$$
:eqlabel:<code>eq_pdf_def</code></p>
<p>But what does this imply for the properties of $p(x)$?</p>
<p>First, probabilities are never negative, thus we should expect that $p(x) \ge 0$ as well.</p>
<p>Second, let's imagine that we slice up the $\mathbb{R}$ into an infinite number of slices which are $\epsilon$ wide, say with slices $(\epsilon\cdot i, \epsilon \cdot (i+1)]$.  For each of these, we know from :eqref:<code>eq_pdf_def</code> the probability is approximately</p>
<p>$$
P(X ; \textrm{is in an}; \epsilon\textrm{-sized interval around}; x ) \approx \epsilon \cdot p(\epsilon \cdot i),
$$</p>
<p>so summed over all of them it should be</p>
<p>$$
P(X\in\mathbb{R}) \approx \sum_i \epsilon \cdot p(\epsilon\cdot i).
$$</p>
<p>This is nothing more than the approximation of an integral discussed in :numref:<code>sec_integral_calculus</code>, thus we can say that</p>
<p>$$
P(X\in\mathbb{R}) = \int_{-\infty}^{\infty} p(x) ; dx.
$$</p>
<p>We know that $P(X\in\mathbb{R}) = 1$, since the random variable must take on <em>some</em> number, we can conclude that for any density</p>
<p>$$
\int_{-\infty}^{\infty} p(x) ; dx = 1.
$$</p>
<p>Indeed, digging into this further shows that for any $a$, and $b$, we see that</p>
<p>$$
P(X\in(a, b]) = \int _ {a}^{b} p(x) ; dx.
$$</p>
<p>We may approximate this in code by using the same discrete approximation methods as before.  In this case we can approximate the probability of falling in the blue region.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Approximate probability using numerical integration
epsilon = 0.01
x = np.arange(-5, 5, 0.01)
p = 0.2*np.exp(-(x - 3)**2 / 2) / np.sqrt(2 * np.pi) + \
    0.8*np.exp(-(x + 1)**2 / 2) / np.sqrt(2 * np.pi)

d2l.set_figsize()
d2l.plt.plot(x, p, color='black')
d2l.plt.fill_between(x.tolist()[300:800], p.tolist()[300:800])
d2l.plt.show()

f'approximate Probability: {np.sum(epsilon*p[300:800])}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Approximate probability using numerical integration
epsilon = 0.01
x = torch.arange(-5, 5, 0.01)
p = 0.2*torch.exp(-(x - 3)**2 / 2) / torch.sqrt(2 * torch.tensor(torch.pi)) +\
    0.8*torch.exp(-(x + 1)**2 / 2) / torch.sqrt(2 * torch.tensor(torch.pi))

d2l.set_figsize()
d2l.plt.plot(x, p, color='black')
d2l.plt.fill_between(x.tolist()[300:800], p.tolist()[300:800])
d2l.plt.show()

f'approximate Probability: {torch.sum(epsilon*p[300:800])}'
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Approximate probability using numerical integration
epsilon = 0.01
x = tf.range(-5, 5, 0.01)
p = 0.2*tf.exp(-(x - 3)**2 / 2) / tf.sqrt(2 * tf.constant(tf.pi)) +\
    0.8*tf.exp(-(x + 1)**2 / 2) / tf.sqrt(2 * tf.constant(tf.pi))

d2l.set_figsize()
d2l.plt.plot(x, p, color='black')
d2l.plt.fill_between(x.numpy().tolist()[300:800], p.numpy().tolist()[300:800])
d2l.plt.show()

f'approximate Probability: {tf.reduce_sum(epsilon*p[300:800])}'
</code></pre>
<p>It turns out that these two properties describe exactly the space of possible probability density functions (or <em>p.d.f.</em>'s for the commonly encountered abbreviation).  They are non-negative functions $p(x) \ge 0$ such that</p>
<p>$$\int_{-\infty}^{\infty} p(x) ; dx = 1.$$
:eqlabel:<code>eq_pdf_int_one</code></p>
<p>We interpret this function by using integration to obtain the probability our random variable is in a specific interval:</p>
<p>$$P(X\in(a, b]) = \int _ {a}^{b} p(x) ; dx.$$
:eqlabel:<code>eq_pdf_int_int</code></p>
<p>In :numref:<code>sec_distributions</code> we will see a number of common distributions, but let's continue working in the abstract.</p>
<h3 id="cumulative-distribution-functions"><a class="header" href="#cumulative-distribution-functions">Cumulative Distribution Functions</a></h3>
<p>In the previous section, we saw the notion of the p.d.f.  In practice, this is a commonly encountered method to discuss continuous random variables, but it has one significant pitfall: that the values of the p.d.f. are not themselves probabilities, but rather a function that we must integrate to yield probabilities.  There is nothing wrong with a density being larger than $10$, as long as it is not larger than $10$ for more than an interval of length $1/10$.  This can be counter-intuitive, so people often also think in terms of the <em>cumulative distribution function</em>, or c.d.f., which <em>is</em> a probability.</p>
<p>In particular, by using :eqref:<code>eq_pdf_int_int</code>, we define the c.d.f. for a random variable $X$ with density $p(x)$ by</p>
<p>$$
F(x) = \int _ {-\infty}^{x} p(x) ; dx = P(X \le x).
$$</p>
<p>Let's observe a few properties.</p>
<ul>
<li>$F(x) \rightarrow 0$ as $x\rightarrow -\infty$.</li>
<li>$F(x) \rightarrow 1$ as $x\rightarrow \infty$.</li>
<li>$F(x)$ is non-decreasing ($y &gt; x \implies F(y) \ge F(x)$).</li>
<li>$F(x)$ is continuous (has no jumps) if $X$ is a continuous random variable.</li>
</ul>
<p>With the fourth bullet point, note that this would not be true if $X$ were discrete, say taking the values $0$ and $1$ both with probability $1/2$.  In that case</p>
<p>$$
F(x) = \begin{cases}
0 &amp; x &lt; 0, \
\frac{1}{2} &amp; x &lt; 1, \
1 &amp; x \ge 1.
\end{cases}
$$</p>
<p>In this example, we see one of the benefits of working with the c.d.f., the ability to deal with continuous or discrete random variables in the same framework, or indeed mixtures of the two (flip a coin: if heads return the roll of a die, if tails return the distance of a dart throw from the center of a dart board).</p>
<h3 id="means"><a class="header" href="#means">Means</a></h3>
<p>Suppose that we are dealing with a random variables $X$.  The distribution itself can be hard to interpret.  It is often useful to be able to summarize the behavior of a random variable concisely.  Numbers that help us capture the behavior of a random variable are called <em>summary statistics</em>.  The most commonly encountered ones are the <em>mean</em>, the <em>variance</em>, and the <em>standard deviation</em>.</p>
<p>The <em>mean</em> encodes the average value of a random variable.  If we have a discrete random variable $X$, which takes the values $x_i$ with probabilities $p_i$, then the mean is given by the weighted average: sum the values times the probability that the random variable takes on that value:</p>
<p>$$\mu_X = E[X] = \sum_i x_i p_i.$$
:eqlabel:<code>eq_exp_def</code></p>
<p>The way we should interpret the mean (albeit with caution) is that it tells us essentially where the random variable tends to be located.</p>
<p>As a minimalistic example that we will examine throughout this section, let's take $X$ to be the random variable which takes the value $a-2$ with probability $p$, $a+2$ with probability $p$ and $a$ with probability $1-2p$.  We can compute using :eqref:<code>eq_exp_def</code> that, for any possible choice of $a$ and $p$, the mean is</p>
<p>$$
\mu_X = E[X] = \sum_i x_i p_i = (a-2)p + a(1-2p) + (a+2)p = a.
$$</p>
<p>Thus we see that the mean is $a$.  This matches the intuition since $a$ is the location around which we centered our random variable.</p>
<p>Because they are helpful, let's summarize a few properties.</p>
<ul>
<li>For any random variable $X$ and numbers $a$ and $b$, we have that $\mu_{aX+b} = a\mu_X + b$.</li>
<li>If we have two random variables $X$ and $Y$, we have $\mu_{X+Y} = \mu_X+\mu_Y$.</li>
</ul>
<p>Means are useful for understanding the average behavior of a random variable, however the mean is not sufficient to even have a full intuitive understanding.  Making a profit of $$10 \pm $1$ per sale is very different from making $$10 \pm $15$ per sale despite having the same average value.  The second one has a much larger degree of fluctuation, and thus represents a much larger risk.  Thus, to understand the behavior of a random variable, we will need at minimum one more measure: some measure of how widely a random variable fluctuates.</p>
<h3 id="variances"><a class="header" href="#variances">Variances</a></h3>
<p>This leads us to consider the <em>variance</em> of a random variable.  This is a quantitative measure of how far a random variable deviates from the mean.  Consider the expression $X - \mu_X$.  This is the deviation of the random variable from its mean.  This value can be positive or negative, so we need to do something to make it positive so that we are measuring the magnitude of the deviation.</p>
<p>A reasonable thing to try is to look at $\left|X-\mu_X\right|$, and indeed this leads to a useful quantity called the <em>mean absolute deviation</em>, however due to connections with other areas of mathematics and statistics, people often use a different solution.</p>
<p>In particular, they look at $(X-\mu_X)^2.$  If we look at the typical size of this quantity by taking the mean, we arrive at the variance</p>
<p>$$\sigma_X^2 = \textrm{Var}(X) = E\left[(X-\mu_X)^2\right] = E[X^2] - \mu_X^2.$$
:eqlabel:<code>eq_var_def</code></p>
<p>The last equality in :eqref:<code>eq_var_def</code> holds by expanding out the definition in the middle, and applying the properties of expectation.</p>
<p>Let's look at our example where $X$ is the random variable which takes the value $a-2$ with probability $p$, $a+2$ with probability $p$ and $a$ with probability $1-2p$.  In this case $\mu_X = a$, so all we need to compute is $E\left[X^2\right]$.  This can readily be done:</p>
<p>$$
E\left[X^2\right] = (a-2)^2p + a^2(1-2p) + (a+2)^2p = a^2 + 8p.
$$</p>
<p>Thus, we see that by :eqref:<code>eq_var_def</code> our variance is</p>
<p>$$
\sigma_X^2 = \textrm{Var}(X) = E[X^2] - \mu_X^2 = a^2 + 8p - a^2 = 8p.
$$</p>
<p>This result again makes sense.  The largest $p$ can be is $1/2$ which corresponds to picking $a-2$ or $a+2$ with a coin flip.  The variance of this being $4$ corresponds to the fact that both $a-2$ and $a+2$ are $2$ units away from the mean, and $2^2 = 4$.  On the other end of the spectrum, if $p=0$, this random variable always takes the value $0$ and so it has no variance at all.</p>
<p>We will list a few properties of variance below:</p>
<ul>
<li>For any random variable $X$, $\textrm{Var}(X) \ge 0$, with $\textrm{Var}(X) = 0$ if and only if $X$ is a constant.</li>
<li>For any random variable $X$ and numbers $a$ and $b$, we have that $\textrm{Var}(aX+b) = a^2\textrm{Var}(X)$.</li>
<li>If we have two <em>independent</em> random variables $X$ and $Y$, we have $\textrm{Var}(X+Y) = \textrm{Var}(X) + \textrm{Var}(Y)$.</li>
</ul>
<p>When interpreting these values, there can be a bit of a hiccup.  In particular, let's try imagining what happens if we keep track of units through this computation.  Suppose that we are working with the star rating assigned to a product on the web page.  Then $a$, $a-2$, and $a+2$ are all measured in units of stars.  Similarly, the mean $\mu_X$ is then also measured in stars (being a weighted average).  However, if we get to the variance, we immediately encounter an issue, which is we want to look at $(X-\mu_X)^2$, which is in units of <em>squared stars</em>.  This means that the variance itself is not comparable to the original measurements.  To make it interpretable, we will need to return to our original units.</p>
<h3 id="standard-deviations"><a class="header" href="#standard-deviations">Standard Deviations</a></h3>
<p>This summary statistics can always be deduced from the variance by taking the square root!  Thus we define the <em>standard deviation</em> to be</p>
<p>$$
\sigma_X = \sqrt{\textrm{Var}(X)}.
$$</p>
<p>In our example, this means we now have the standard deviation is $\sigma_X = 2\sqrt{2p}$.  If we are dealing with units of stars for our review example, $\sigma_X$ is again in units of stars.</p>
<p>The properties we had for the variance can be restated for the standard deviation.</p>
<ul>
<li>For any random variable $X$, $\sigma_{X} \ge 0$.</li>
<li>For any random variable $X$ and numbers $a$ and $b$, we have that $\sigma_{aX+b} = |a|\sigma_{X}$</li>
<li>If we have two <em>independent</em> random variables $X$ and $Y$, we have $\sigma_{X+Y} = \sqrt{\sigma_{X}^2 + \sigma_{Y}^2}$.</li>
</ul>
<p>It is natural at this moment to ask, "If the standard deviation is in the units of our original random variable, does it represent something we can draw with regards to that random variable?"  The answer is a resounding yes!  Indeed much like the mean told us the typical location of our random variable, the standard deviation gives the typical range of variation of that random variable.  We can make this rigorous with what is known as Chebyshev's inequality:</p>
<p>$$P\left(X \not\in [\mu_X - \alpha\sigma_X, \mu_X + \alpha\sigma_X]\right) \le \frac{1}{\alpha^2}.$$
:eqlabel:<code>eq_chebyshev</code></p>
<p>Or to state it verbally in the case of $\alpha=10$, $99%$ of the samples from any random variable fall within $10$ standard deviations of the mean.  This gives an immediate interpretation to our standard summary statistics.</p>
<p>To see how this statement is rather subtle, let's take a look at our running example again where  $X$ is the random variable which takes the value $a-2$ with probability $p$, $a+2$ with probability $p$ and $a$ with probability $1-2p$.  We saw that the mean was $a$ and the standard deviation was $2\sqrt{2p}$.  This means, if we take Chebyshev's inequality :eqref:<code>eq_chebyshev</code> with $\alpha = 2$, we see that the expression is</p>
<p>$$
P\left(X \not\in [a - 4\sqrt{2p}, a + 4\sqrt{2p}]\right) \le \frac{1}{4}.
$$</p>
<p>This means that $75%$ of the time, this random variable will fall within this interval for any value of $p$.  Now, notice that as $p \rightarrow 0$, this interval also converges to the single point $a$.  But we know that our random variable takes the values $a-2, a$, and $a+2$ only so eventually we can be certain $a-2$ and $a+2$ will fall outside the interval!  The question is, at what $p$ does that happen.  So we want to solve: for what $p$ does $a+4\sqrt{2p} = a+2$, which is solved when $p=1/8$, which is <em>exactly</em> the first $p$ where it could possibly happen without violating our claim that no more than $1/4$ of samples from the distribution would fall outside the interval ($1/8$ to the left, and $1/8$ to the right).</p>
<p>Let's visualize this.  We will show the probability of getting the three values as three vertical bars with height proportional to the probability.  The interval will be drawn as a horizontal line in the middle.  The first plot shows what happens for $p &gt; 1/8$ where the interval safely contains all points.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Define a helper to plot these figures
def plot_chebyshev(a, p):
    d2l.set_figsize()
    d2l.plt.stem([a-2, a, a+2], [p, 1-2*p, p], use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')

    d2l.plt.hlines(0.5, a - 4 * np.sqrt(2 * p),
                   a + 4 * np.sqrt(2 * p), 'black', lw=4)
    d2l.plt.vlines(a - 4 * np.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.vlines(a + 4 * np.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.title(f'p = {p:.3f}')

    d2l.plt.show()

# Plot interval when p &gt; 1/8
plot_chebyshev(0.0, 0.2)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Define a helper to plot these figures
def plot_chebyshev(a, p):
    d2l.set_figsize()
    d2l.plt.stem([a-2, a, a+2], [p, 1-2*p, p], use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')

    d2l.plt.hlines(0.5, a - 4 * torch.sqrt(2 * p),
                   a + 4 * torch.sqrt(2 * p), 'black', lw=4)
    d2l.plt.vlines(a - 4 * torch.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.vlines(a + 4 * torch.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.title(f'p = {p:.3f}')

    d2l.plt.show()

# Plot interval when p &gt; 1/8
plot_chebyshev(0.0, torch.tensor(0.2))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Define a helper to plot these figures
def plot_chebyshev(a, p):
    d2l.set_figsize()
    d2l.plt.stem([a-2, a, a+2], [p, 1-2*p, p], use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')

    d2l.plt.hlines(0.5, a - 4 * tf.sqrt(2 * p),
                   a + 4 * tf.sqrt(2 * p), 'black', lw=4)
    d2l.plt.vlines(a - 4 * tf.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.vlines(a + 4 * tf.sqrt(2 * p), 0.53, 0.47, 'black', lw=1)
    d2l.plt.title(f'p = {p:.3f}')

    d2l.plt.show()

# Plot interval when p &gt; 1/8
plot_chebyshev(0.0, tf.constant(0.2))
</code></pre>
<p>The second shows that at $p = 1/8$, the interval exactly touches the two points.  This shows that the inequality is <em>sharp</em>, since no smaller interval could be taken while keeping the inequality true.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot interval when p = 1/8
plot_chebyshev(0.0, 0.125)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot interval when p = 1/8
plot_chebyshev(0.0, torch.tensor(0.125))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot interval when p = 1/8
plot_chebyshev(0.0, tf.constant(0.125))
</code></pre>
<p>The third shows that for $p &lt; 1/8$ the interval only contains the center.  This does not invalidate the inequality since we only needed to ensure that no more than $1/4$ of the probability falls outside the interval, which means that once $p &lt; 1/8$, the two points at $a-2$ and $a+2$ can be discarded.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot interval when p &lt; 1/8
plot_chebyshev(0.0, 0.05)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot interval when p &lt; 1/8
plot_chebyshev(0.0, torch.tensor(0.05))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot interval when p &lt; 1/8
plot_chebyshev(0.0, tf.constant(0.05))
</code></pre>
<h3 id="means-and-variances-in-the-continuum"><a class="header" href="#means-and-variances-in-the-continuum">Means and Variances in the Continuum</a></h3>
<p>This has all been in terms of discrete random variables, but the case of continuous random variables is similar.  To intuitively understand how this works, imagine that we split the real number line into intervals of length $\epsilon$ given by $(\epsilon i, \epsilon (i+1)]$.  Once we do this, our continuous random variable has been made discrete and we can use :eqref:<code>eq_exp_def</code> say that</p>
<p>$$
\begin{aligned}
\mu_X &amp; \approx \sum_{i} (\epsilon i)P(X \in (\epsilon i, \epsilon (i+1)]) \
&amp; \approx \sum_{i} (\epsilon i)p_X(\epsilon i)\epsilon, \
\end{aligned}
$$</p>
<p>where $p_X$ is the density of $X$.  This is an approximation to the integral of $xp_X(x)$, so we can conclude that</p>
<p>$$
\mu_X = \int_{-\infty}^\infty xp_X(x) ; dx.
$$</p>
<p>Similarly, using :eqref:<code>eq_var_def</code> the variance can be written as</p>
<p>$$
\sigma^2_X = E[X^2] - \mu_X^2 = \int_{-\infty}^\infty x^2p_X(x) ; dx - \left(\int_{-\infty}^\infty xp_X(x) ; dx\right)^2.
$$</p>
<p>Everything stated above about the mean, the variance, and the standard deviation still applies in this case.  For instance, if we consider the random variable with density</p>
<p>$$
p(x) = \begin{cases}
1 &amp; x \in [0,1], \
0 &amp; \textrm{otherwise}.
\end{cases}
$$</p>
<p>we can compute</p>
<p>$$
\mu_X = \int_{-\infty}^\infty xp(x) ; dx = \int_0^1 x ; dx = \frac{1}{2}.
$$</p>
<p>and</p>
<p>$$
\sigma_X^2 = \int_{-\infty}^\infty x^2p(x) ; dx - \left(\frac{1}{2}\right)^2 = \frac{1}{3} - \frac{1}{4} = \frac{1}{12}.
$$</p>
<p>As a warning, let's examine one more example, known as the <em>Cauchy distribution</em>.  This is the distribution with p.d.f. given by</p>
<p>$$
p(x) = \frac{1}{1+x^2}.
$$</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot the Cauchy distribution p.d.f.
x = np.arange(-5, 5, 0.01)
p = 1 / (1 + x**2)

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot the Cauchy distribution p.d.f.
x = torch.arange(-5, 5, 0.01)
p = 1 / (1 + x**2)

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot the Cauchy distribution p.d.f.
x = tf.range(-5, 5, 0.01)
p = 1 / (1 + x**2)

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<p>This function looks innocent, and indeed consulting a table of integrals will show it has area one under it, and thus it defines a continuous random variable.</p>
<p>To see what goes astray, let's try to compute the variance of this.  This would involve using :eqref:<code>eq_var_def</code> computing</p>
<p>$$
\int_{-\infty}^\infty \frac{x^2}{1+x^2}; dx.
$$</p>
<p>The function on the inside looks like this:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot the integrand needed to compute the variance
x = np.arange(-20, 20, 0.01)
p = x**2 / (1 + x**2)

d2l.plot(x, p, 'x', 'integrand')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot the integrand needed to compute the variance
x = torch.arange(-20, 20, 0.01)
p = x**2 / (1 + x**2)

d2l.plot(x, p, 'x', 'integrand')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot the integrand needed to compute the variance
x = tf.range(-20, 20, 0.01)
p = x**2 / (1 + x**2)

d2l.plot(x, p, 'x', 'integrand')
</code></pre>
<p>This function clearly has infinite area under it since it is essentially the constant one with a small dip near zero, and indeed we could show that</p>
<p>$$
\int_{-\infty}^\infty \frac{x^2}{1+x^2}; dx = \infty.
$$</p>
<p>This means it does not have a well-defined finite variance.</p>
<p>However, looking deeper shows an even more disturbing result.  Let's try to compute the mean using :eqref:<code>eq_exp_def</code>.  Using the change of variables formula, we see</p>
<p>$$
\mu_X = \int_{-\infty}^{\infty} \frac{x}{1+x^2} ; dx = \frac{1}{2}\int_1^\infty \frac{1}{u} ; du.
$$</p>
<p>The integral inside is the definition of the logarithm, so this is in essence $\log(\infty) = \infty$, so there is no well-defined average value either!</p>
<p>Machine learning scientists define their models so that we most often do not need to deal with these issues, and will in the vast majority of cases deal with random variables with well-defined means and variances.  However, every so often random variables with <em>heavy tails</em> (that is those random variables where the probabilities of getting large values are large enough to make things like the mean or variance undefined) are helpful in modeling physical systems, thus it is worth knowing that they exist.</p>
<h3 id="joint-density-functions"><a class="header" href="#joint-density-functions">Joint Density Functions</a></h3>
<p>The above work all assumes we are working with a single real valued random variable.  But what if we are dealing with two or more potentially highly correlated random variables?  This circumstance is the norm in machine learning: imagine random variables like $R_{i, j}$ which encode the red value of the pixel at the $(i, j)$ coordinate in an image, or $P_t$ which is a random variable given by a stock price at time $t$.  Nearby pixels tend to have similar color, and nearby times tend to have similar prices.  We cannot treat them as separate random variables, and expect to create a successful model (we will see in :numref:<code>sec_naive_bayes</code> a model that under-performs due to such an assumption).  We need to develop the mathematical language to handle these correlated continuous random variables.</p>
<p>Thankfully, with the multiple integrals in :numref:<code>sec_integral_calculus</code> we can develop such a language.  Suppose that we have, for simplicity, two random variables $X, Y$ which can be correlated.  Then, similar to the case of a single variable, we can ask the question:</p>
<p>$$
P(X ;\textrm{is in an}; \epsilon \textrm{-sized interval around}; x ; \textrm{and} ;Y ;\textrm{is in an}; \epsilon \textrm{-sized interval around}; y ).
$$</p>
<p>Similar reasoning to the single variable case shows that this should be approximately</p>
<p>$$
P(X ;\textrm{is in an}; \epsilon \textrm{-sized interval around}; x ; \textrm{and} ;Y ;\textrm{is in an}; \epsilon \textrm{-sized interval around}; y ) \approx \epsilon^{2}p(x, y),
$$</p>
<p>for some function $p(x, y)$.  This is referred to as the joint density of $X$ and $Y$.  Similar properties are true for this as we saw in the single variable case. Namely:</p>
<ul>
<li>$p(x, y) \ge 0$;</li>
<li>$\int _ {\mathbb{R}^2} p(x, y) ;dx ;dy = 1$;</li>
<li>$P((X, Y) \in \mathcal{D}) = \int _ {\mathcal{D}} p(x, y) ;dx ;dy$.</li>
</ul>
<p>In this way, we can deal with multiple, potentially correlated random variables.  If we wish to work with more than two random variables, we can extend the multivariate density to as many coordinates as desired by considering $p(\mathbf{x}) = p(x_1, \ldots, x_n)$.  The same properties of being non-negative, and having total integral of one still hold.</p>
<h3 id="marginal-distributions"><a class="header" href="#marginal-distributions">Marginal Distributions</a></h3>
<p>When dealing with multiple variables, we oftentimes want to be able to ignore the relationships and ask, "how is this one variable distributed?"  Such a distribution is called a <em>marginal distribution</em>.</p>
<p>To be concrete, let's suppose that we have two random variables $X, Y$ with joint density given by $p _ {X, Y}(x, y)$.  We will be using the subscript to indicate what random variables the density is for.  The question of finding the marginal distribution is taking this function, and using it to find $p _ X(x)$.</p>
<p>As with most things, it is best to return to the intuitive picture to figure out what should be true.  Recall that the density is the function $p _ X$ so that</p>
<p>$$
P(X \in [x, x+\epsilon]) \approx \epsilon \cdot p _ X(x).
$$</p>
<p>There is no mention of $Y$, but if all we are given is $p _{X, Y}$, we need to include $Y$ somehow. We can first observe that this is the same as</p>
<p>$$
P(X \in [x, x+\epsilon] \textrm{, and } Y \in \mathbb{R}) \approx \epsilon \cdot p _ X(x).
$$</p>
<p>Our density does not directly tell us about what happens in this case, we need to split into small intervals in $y$ as well, so we can write this as</p>
<p>$$
\begin{aligned}
\epsilon \cdot p _ X(x) &amp; \approx \sum _ {i} P(X \in [x, x+\epsilon] \textrm{, and } Y \in [\epsilon \cdot i, \epsilon \cdot (i+1)]) \
&amp; \approx \sum _ {i} \epsilon^{2} p _ {X, Y}(x, \epsilon\cdot i).
\end{aligned}
$$</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/marginal.svg" alt="By summing along the columns of our array of probabilities, we are able to obtain the marginal distribution for just the random variable represented along the $\mathit{x}$-axis." />
:label:<code>fig_marginal</code></p>
<p>This tells us to add up the value of the density along a series of squares in a line as is shown in :numref:<code>fig_marginal</code>.  Indeed, after canceling one factor of epsilon from both sides, and recognizing the sum on the right is the integral over $y$, we can conclude that</p>
<p>$$
\begin{aligned}
p _ X(x) &amp;  \approx \sum _ {i} \epsilon p _ {X, Y}(x, \epsilon\cdot i) \
&amp; \approx \int_{-\infty}^\infty p_{X, Y}(x, y) ; dy.
\end{aligned}
$$</p>
<p>Thus we see</p>
<p>$$
p _ X(x) = \int_{-\infty}^\infty p_{X, Y}(x, y) ; dy.
$$</p>
<p>This tells us that to get a marginal distribution, we integrate over the variables we do not care about.  This process is often referred to as <em>integrating out</em> or <em>marginalized out</em> the unneeded variables.</p>
<h3 id="covariance"><a class="header" href="#covariance">Covariance</a></h3>
<p>When dealing with multiple random variables, there is one additional summary statistic which is helpful to know: the <em>covariance</em>.  This measures the degree that two random variable fluctuate together.</p>
<p>Suppose that we have two random variables $X$ and $Y$, to begin with, let's suppose they are discrete, taking on values $(x_i, y_j)$ with probability $p_{ij}$.  In this case, the covariance is defined as</p>
<p>$$\sigma_{XY} = \textrm{Cov}(X, Y) = \sum_{i, j} (x_i - \mu_X) (y_j-\mu_Y) p_{ij}. = E[XY] - E[X]E[Y].$$
:eqlabel:<code>eq_cov_def</code></p>
<p>To think about this intuitively: consider the following pair of random variables.  Suppose that $X$ takes the values $1$ and $3$, and $Y$ takes the values $-1$ and $3$.  Suppose that we have the following probabilities</p>
<p>$$
\begin{aligned}
P(X = 1 ; \textrm{and} ; Y = -1) &amp; = \frac{p}{2}, \
P(X = 1 ; \textrm{and} ; Y = 3) &amp; = \frac{1-p}{2}, \
P(X = 3 ; \textrm{and} ; Y = -1) &amp; = \frac{1-p}{2}, \
P(X = 3 ; \textrm{and} ; Y = 3) &amp; = \frac{p}{2},
\end{aligned}
$$</p>
<p>where $p$ is a parameter in $[0,1]$ we get to pick.  Notice that if $p=1$ then they are both always their minimum or maximum values simultaneously, and if $p=0$ they are guaranteed to take their flipped values simultaneously (one is large when the other is small and vice versa).  If $p=1/2$, then the four possibilities are all equally likely, and neither should be related.  Let's compute the covariance.  First, note $\mu_X = 2$ and $\mu_Y = 1$, so we may compute using :eqref:<code>eq_cov_def</code>:</p>
<p>$$
\begin{aligned}
\textrm{Cov}(X, Y) &amp; = \sum_{i, j} (x_i - \mu_X) (y_j-\mu_Y) p_{ij} \
&amp; = (1-2)(-1-1)\frac{p}{2} + (1-2)(3-1)\frac{1-p}{2} + (3-2)(-1-1)\frac{1-p}{2} + (3-2)(3-1)\frac{p}{2} \
&amp; = 4p-2.
\end{aligned}
$$</p>
<p>When $p=1$ (the case where they are both maximally positive or negative at the same time) has a covariance of $2$. When $p=0$ (the case where they are flipped) the covariance is $-2$.  Finally, when $p=1/2$ (the case where they are unrelated), the covariance is $0$.  Thus we see that the covariance measures how these two random variables are related.</p>
<p>A quick note on the covariance is that it only measures these linear relationships.  More complex relationships like $X = Y^2$ where $Y$ is randomly chosen from ${-2, -1, 0, 1, 2}$ with equal probability can be missed.  Indeed a quick computation shows that these random variables have covariance zero, despite one being a deterministic function of the other.</p>
<p>For continuous random variables, much the same story holds.  At this point, we are pretty comfortable with doing the transition between discrete and continuous, so we will provide the continuous analogue of :eqref:<code>eq_cov_def</code> without any derivation.</p>
<p>$$
\sigma_{XY} = \int_{\mathbb{R}^2} (x-\mu_X)(y-\mu_Y)p(x, y) ;dx ;dy.
$$</p>
<p>For visualization, let's take a look at a collection of random variables with tunable covariance.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot a few random variables adjustable covariance
covs = [-0.9, 0.0, 1.2]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = np.random.normal(0, 1, 500)
    Y = covs[i]*X + np.random.normal(0, 1, (500))

    d2l.plt.subplot(1, 4, i+1)
    d2l.plt.scatter(X.asnumpy(), Y.asnumpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cov = {covs[i]}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot a few random variables adjustable covariance
covs = [-0.9, 0.0, 1.2]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = torch.randn(500)
    Y = covs[i]*X + torch.randn(500)

    d2l.plt.subplot(1, 4, i+1)
    d2l.plt.scatter(X.numpy(), Y.numpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cov = {covs[i]}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot a few random variables adjustable covariance
covs = [-0.9, 0.0, 1.2]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = tf.random.normal((500, ))
    Y = covs[i]*X + tf.random.normal((500, ))

    d2l.plt.subplot(1, 4, i+1)
    d2l.plt.scatter(X.numpy(), Y.numpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cov = {covs[i]}')
d2l.plt.show()
</code></pre>
<p>Let's see some properties of covariances:</p>
<ul>
<li>For any random variable $X$, $\textrm{Cov}(X, X) = \textrm{Var}(X)$.</li>
<li>For any random variables $X, Y$ and numbers $a$ and $b$, $\textrm{Cov}(aX+b, Y) = \textrm{Cov}(X, aY+b) = a\textrm{Cov}(X, Y)$.</li>
<li>If $X$ and $Y$ are independent then $\textrm{Cov}(X, Y) = 0$.</li>
</ul>
<p>In addition, we can use the covariance to expand a relationship we saw before.  Recall that is $X$ and $Y$ are two independent random variables then</p>
<p>$$
\textrm{Var}(X+Y) = \textrm{Var}(X) + \textrm{Var}(Y).
$$</p>
<p>With knowledge of covariances, we can expand this relationship.  Indeed, some algebra can show that in general,</p>
<p>$$
\textrm{Var}(X+Y) = \textrm{Var}(X) + \textrm{Var}(Y) + 2\textrm{Cov}(X, Y).
$$</p>
<p>This allows us to generalize the variance summation rule for correlated random variables.</p>
<h3 id="correlation"><a class="header" href="#correlation">Correlation</a></h3>
<p>As we did in the case of means and variances, let's now consider units.  If $X$ is measured in one unit (say inches), and $Y$ is measured in another (say dollars), the covariance is measured in the product of these two units $\textrm{inches} \times \textrm{dollars}$.  These units can be hard to interpret.  What we will often want in this case is a unit-less measurement of relatedness.  Indeed, often we do not care about exact quantitative correlation, but rather ask if the correlation is in the same direction, and how strong the relationship is.</p>
<p>To see what makes sense, let's perform a thought experiment.  Suppose that we convert our random variables in inches and dollars to be in inches and cents.  In this case the random variable $Y$ is multiplied by $100$.  If we work through the definition, this means that $\textrm{Cov}(X, Y)$ will be multiplied by $100$.  Thus we see that in this case a change of units change the covariance by a factor of $100$.  Thus, to find our unit-invariant measure of correlation, we will need to divide by something else that also gets scaled by $100$.  Indeed we have a clear candidate, the standard deviation!  Indeed if we define the <em>correlation coefficient</em> to be</p>
<p>$$\rho(X, Y) = \frac{\textrm{Cov}(X, Y)}{\sigma_{X}\sigma_{Y}},$$
:eqlabel:<code>eq_cor_def</code></p>
<p>we see that this is a unit-less value.  A little mathematics can show that this number is between $-1$ and $1$ with $1$ meaning maximally positively correlated, whereas $-1$ means maximally negatively correlated.</p>
<p>Returning to our explicit discrete example above, we can see that $\sigma_X = 1$ and $\sigma_Y = 2$, so we can compute the correlation between the two random variables using :eqref:<code>eq_cor_def</code> to see that</p>
<p>$$
\rho(X, Y) = \frac{4p-2}{1\cdot 2} = 2p-1.
$$</p>
<p>This now ranges between $-1$ and $1$ with the expected behavior of $1$ meaning most correlated, and $-1$ meaning minimally correlated.</p>
<p>As another example, consider $X$ as any random variable, and $Y=aX+b$ as any linear deterministic function of $X$.  Then, one can compute that</p>
<p>$$\sigma_{Y} = \sigma_{aX+b} = |a|\sigma_{X},$$</p>
<p>$$\textrm{Cov}(X, Y) = \textrm{Cov}(X, aX+b) = a\textrm{Cov}(X, X) = a\textrm{Var}(X),$$</p>
<p>and thus by :eqref:<code>eq_cor_def</code> that</p>
<p>$$
\rho(X, Y) = \frac{a\textrm{Var}(X)}{|a|\sigma_{X}^2} = \frac{a}{|a|} = \textrm{sign}(a).
$$</p>
<p>Thus we see that the correlation is $+1$ for any $a &gt; 0$, and $-1$ for any $a &lt; 0$ illustrating that correlation measures the degree and directionality the two random variables are related, not the scale that the variation takes.</p>
<p>Let's again plot a collection of random variables with tunable correlation.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Plot a few random variables adjustable correlations
cors = [-0.9, 0.0, 1.0]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = np.random.normal(0, 1, 500)
    Y = cors[i] * X + np.sqrt(1 - cors[i]**2) * np.random.normal(0, 1, 500)

    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.scatter(X.asnumpy(), Y.asnumpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cor = {cors[i]}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Plot a few random variables adjustable correlations
cors = [-0.9, 0.0, 1.0]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = torch.randn(500)
    Y = cors[i] * X + torch.sqrt(torch.tensor(1) -
                                 cors[i]**2) * torch.randn(500)

    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.scatter(X.numpy(), Y.numpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cor = {cors[i]}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Plot a few random variables adjustable correlations
cors = [-0.9, 0.0, 1.0]
d2l.plt.figure(figsize=(12, 3))
for i in range(3):
    X = tf.random.normal((500, ))
    Y = cors[i] * X + tf.sqrt(tf.constant(1.) -
                                 cors[i]**2) * tf.random.normal((500, ))

    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.scatter(X.numpy(), Y.numpy())
    d2l.plt.xlabel('X')
    d2l.plt.ylabel('Y')
    d2l.plt.title(f'cor = {cors[i]}')
d2l.plt.show()
</code></pre>
<p>Let's list a few properties of the correlation below.</p>
<ul>
<li>For any random variable $X$, $\rho(X, X) = 1$.</li>
<li>For any random variables $X, Y$ and numbers $a$ and $b$, $\rho(aX+b, Y) = \rho(X, aY+b) = \rho(X, Y)$.</li>
<li>If $X$ and $Y$ are independent with non-zero variance then $\rho(X, Y) = 0$.</li>
</ul>
<p>As a final note, you may feel like some of these formulae are familiar.  Indeed, if we expand everything out assuming that $\mu_X = \mu_Y = 0$, we see that this is</p>
<p>$$
\rho(X, Y) = \frac{\sum_{i, j} x_iy_ip_{ij}}{\sqrt{\sum_{i, j}x_i^2 p_{ij}}\sqrt{\sum_{i, j}y_j^2 p_{ij}}}.
$$</p>
<p>This looks like a sum of a product of terms divided by the square root of sums of terms.  This is exactly the formula for the cosine of the angle between two vectors $\mathbf{v}, \mathbf{w}$ with the different coordinates weighted by $p_{ij}$:</p>
<p>$$
\cos(\theta) = \frac{\mathbf{v}\cdot \mathbf{w}}{|\mathbf{v}||\mathbf{w}|} = \frac{\sum_{i} v_iw_i}{\sqrt{\sum_{i}v_i^2}\sqrt{\sum_{i}w_i^2}}.
$$</p>
<p>Indeed if we think of norms as being related to standard deviations, and correlations as being cosines of angles, much of the intuition we have from geometry can be applied to thinking about random variables.</p>
<h2 id="summary-131"><a class="header" href="#summary-131">Summary</a></h2>
<ul>
<li>Continuous random variables are random variables that can take on a continuum of values.  They have some technical difficulties that make them more challenging to work with compared to discrete random variables.</li>
<li>The probability density function allows us to work with continuous random variables by giving a function where the area under the curve on some interval gives the probability of finding a sample point in that interval.</li>
<li>The cumulative distribution function is the probability of observing the random variable to be less than a given threshold.  It can provide a useful alternate viewpoint which unifies discrete and continuous variables.</li>
<li>The mean is the average value of a random variable.</li>
<li>The variance is the expected square of the difference between the random variable and its mean.</li>
<li>The standard deviation is the square root of the variance.  It can be thought of as measuring the range of values the random variable may take.</li>
<li>Chebyshev's inequality allows us to make this intuition rigorous by giving an explicit interval that contains the random variable most of the time.</li>
<li>Joint densities allow us to work with correlated random variables.  We may marginalize joint densities by integrating over unwanted random variables to get the distribution of the desired random variable.</li>
<li>The covariance and correlation coefficient provide a way to measure any linear relationship between two correlated random variables.</li>
</ul>
<h2 id="exercises-149"><a class="header" href="#exercises-149">Exercises</a></h2>
<ol>
<li>Suppose that we have the random variable with density given by $p(x) = \frac{1}{x^2}$ for $x \ge 1$ and $p(x) = 0$ otherwise.  What is $P(X &gt; 2)$?</li>
<li>The Laplace distribution is a random variable whose density is given by $p(x = \frac{1}{2}e^{-|x|}$.  What is the mean and the standard deviation of this function?  As a hint, $\int_0^\infty xe^{-x} ; dx = 1$ and $\int_0^\infty x^2e^{-x} ; dx = 2$.</li>
<li>I walk up to you on the street and say "I have a random variable with mean $1$, standard deviation $2$, and I observed $25%$ of my samples taking a value larger than $9$."  Do you believe me?  Why or why not?</li>
<li>Suppose that you have two random variables $X, Y$, with joint density given by $p_{XY}(x, y) = 4xy$ for $x, y \in [0,1]$ and $p_{XY}(x, y) = 0$ otherwise.  What is the covariance of $X$ and $Y$?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/415">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1094">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1095">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-likelihood"><a class="header" href="#maximum-likelihood">Maximum Likelihood</a></h1>
<p>:label:<code>sec_maximum_likelihood</code></p>
<p>One of the most commonly encountered way of thinking in machine learning is the maximum likelihood point of view.  This is the concept that when working with a probabilistic model with unknown parameters, the parameters which make the data have the highest probability are the most likely ones.</p>
<h2 id="the-maximum-likelihood-principle"><a class="header" href="#the-maximum-likelihood-principle">The Maximum Likelihood Principle</a></h2>
<p>This has a Bayesian interpretation which can be helpful to think about.  Suppose that we have a model with parameters $\boldsymbol{\theta}$ and a collection of data examples $X$.  For concreteness, we can imagine that $\boldsymbol{\theta}$ is a single value representing the probability that a coin comes up heads when flipped, and $X$ is a sequence of independent coin flips.  We will look at this example in depth later.</p>
<p>If we want to find the most likely value for the parameters of our model, that means we want to find</p>
<p>$$\mathop{\mathrm{argmax}} P(\boldsymbol{\theta}\mid X).$$
:eqlabel:<code>eq_max_like</code></p>
<p>By Bayes' rule, this is the same thing as</p>
<p>$$
\mathop{\mathrm{argmax}} \frac{P(X \mid \boldsymbol{\theta})P(\boldsymbol{\theta})}{P(X)}.
$$</p>
<p>The expression $P(X)$, a parameter agnostic probability of generating the data, does not depend on $\boldsymbol{\theta}$ at all, and so can be dropped without changing the best choice of $\boldsymbol{\theta}$.  Similarly, we may now posit that we have no prior assumption on which set of parameters are better than any others, so we may declare that $P(\boldsymbol{\theta})$ does not depend on theta either!  This, for instance, makes sense in our coin flipping example where the probability it comes up heads could be any value in $[0,1]$ without any prior belief it is fair or not (often referred to as an <em>uninformative prior</em>).  Thus we see that our application of Bayes' rule shows that our best choice of $\boldsymbol{\theta}$ is the maximum likelihood estimate for $\boldsymbol{\theta}$:</p>
<p>$$
\hat{\boldsymbol{\theta}} = \mathop{\mathrm{argmax}} _ {\boldsymbol{\theta}} P(X \mid \boldsymbol{\theta}).
$$</p>
<p>As a matter of common terminology, the probability of the data given the parameters ($P(X \mid \boldsymbol{\theta})$) is referred to as the <em>likelihood</em>.</p>
<h3 id="a-concrete-example"><a class="header" href="#a-concrete-example">A Concrete Example</a></h3>
<p>Let's see how this works in a concrete example.  Suppose that we have a single parameter $\theta$ representing the probability that a coin flip is heads.  Then the probability of getting a tails is $1-\theta$, and so if our observed data $X$ is a sequence with $n_H$ heads and $n_T$ tails, we can use the fact that independent probabilities multiply to see that</p>
<p>$$
P(X \mid \theta) = \theta^{n_H}(1-\theta)^{n_T}.
$$</p>
<p>If we flip $13$ coins and get the sequence "HHHTHTTHHHHHT", which has $n_H = 9$ and $n_T = 4$, we see that this is</p>
<p>$$
P(X \mid \theta) = \theta^9(1-\theta)^4.
$$</p>
<p>One nice thing about this example will be that we know the answer going in.  Indeed, if we said verbally, "I flipped 13 coins, and 9 came up heads, what is our best guess for the probability that the coin comes us heads?, " everyone would correctly guess $9/13$.  What this maximum likelihood method will give us is a way to get that number from first principals in a way that will generalize to vastly more complex situations.</p>
<p>For our example, the plot of $P(X \mid \theta)$ is as follows:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from mxnet import autograd, np, npx
npx.set_np()

theta = np.arange(0, 1, 0.001)
p = theta**9 * (1 - theta)**4.

d2l.plot(theta, p, 'theta', 'likelihood')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import torch

theta = torch.arange(0, 1, 0.001)
p = theta**9 * (1 - theta)**4.

d2l.plot(theta, p, 'theta', 'likelihood')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import tensorflow as tf

theta = tf.range(0, 1, 0.001)
p = theta**9 * (1 - theta)**4.

d2l.plot(theta, p, 'theta', 'likelihood')
</code></pre>
<p>This has its maximum value somewhere near our expected $9/13 \approx 0.7\ldots$.  To see if it is exactly there, we can turn to calculus.  Notice that at the maximum, the gradient of the function is flat.  Thus, we could find the maximum likelihood estimate :eqref:<code>eq_max_like</code> by finding the values of $\theta$ where the derivative is zero, and finding the one that gives the highest probability.  We compute:</p>
<p>$$
\begin{aligned}
0 &amp; = \frac{d}{d\theta} P(X \mid \theta) \
&amp; = \frac{d}{d\theta} \theta^9(1-\theta)^4 \
&amp; = 9\theta^8(1-\theta)^4 - 4\theta^9(1-\theta)^3 \
&amp; = \theta^8(1-\theta)^3(9-13\theta).
\end{aligned}
$$</p>
<p>This has three solutions: $0$, $1$ and $9/13$.  The first two are clearly minima, not maxima as they assign probability $0$ to our sequence.  The final value does <em>not</em> assign zero probability to our sequence, and thus must be the maximum likelihood estimate $\hat \theta = 9/13$.</p>
<h2 id="numerical-optimization-and-the-negative-log-likelihood"><a class="header" href="#numerical-optimization-and-the-negative-log-likelihood">Numerical Optimization and the Negative Log-Likelihood</a></h2>
<p>The previous example is nice, but what if we have billions of parameters and data examples?</p>
<p>First, notice that if we make the assumption that all the data examples are independent, we can no longer practically consider the likelihood itself as it is a product of many probabilities.  Indeed, each probability is in $[0,1]$, say typically of value about $1/2$, and the product of $(1/2)^{1000000000}$ is far below machine precision.  We cannot work with that directly.</p>
<p>However, recall that the logarithm turns products to sums, in which case</p>
<p>$$
\log((1/2)^{1000000000}) = 1000000000\cdot\log(1/2) \approx -301029995.6\ldots
$$</p>
<p>This number fits perfectly within even a single precision $32$-bit float.  Thus, we should consider the <em>log-likelihood</em>, which is</p>
<p>$$
\log(P(X \mid \boldsymbol{\theta})).
$$</p>
<p>Since the function $x \mapsto \log(x)$ is increasing, maximizing the likelihood is the same thing as maximizing the log-likelihood.  Indeed in :numref:<code>sec_naive_bayes</code> we will see this reasoning applied when working with the specific example of the naive Bayes classifier.</p>
<p>We often work with loss functions, where we wish to minimize the loss.  We may turn maximum likelihood into the minimization of a loss by taking $-\log(P(X \mid \boldsymbol{\theta}))$, which is the <em>negative log-likelihood</em>.</p>
<p>To illustrate this, consider the coin flipping problem from before, and pretend that we do not know the closed form solution.  We may compute that</p>
<p>$$
-\log(P(X \mid \boldsymbol{\theta})) = -\log(\theta^{n_H}(1-\theta)^{n_T}) = -(n_H\log(\theta) + n_T\log(1-\theta)).
$$</p>
<p>This can be written into code, and freely optimized even for billions of coin flips.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Set up our data
n_H = 8675309
n_T = 256245

# Initialize our paramteres
theta = np.array(0.5)
theta.attach_grad()

# Perform gradient descent
lr = 1e-9
for iter in range(100):
    with autograd.record():
        loss = -(n_H * np.log(theta) + n_T * np.log(1 - theta))
    loss.backward()
    theta -= lr * theta.grad

# Check output
theta, n_H / (n_H + n_T)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Set up our data
n_H = 8675309
n_T = 256245

# Initialize our paramteres
theta = torch.tensor(0.5, requires_grad=True)

# Perform gradient descent
lr = 1e-9
for iter in range(100):
    loss = -(n_H * torch.log(theta) + n_T * torch.log(1 - theta))
    loss.backward()
    with torch.no_grad():
        theta -= lr * theta.grad
    theta.grad.zero_()

# Check output
theta, n_H / (n_H + n_T)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Set up our data
n_H = 8675309
n_T = 256245

# Initialize our paramteres
theta = tf.Variable(tf.constant(0.5))

# Perform gradient descent
lr = 1e-9
for iter in range(100):
    with tf.GradientTape() as t:
        loss = -(n_H * tf.math.log(theta) + n_T * tf.math.log(1 - theta))
    theta.assign_sub(lr * t.gradient(loss, theta))

# Check output
theta, n_H / (n_H + n_T)
</code></pre>
<p>Numerical convenience is not the only reason why people like to use negative log-likelihoods. There are several other reasons why it is preferable.</p>
<p>The second reason we consider the log-likelihood is the simplified application of calculus rules. As discussed above, due to independence assumptions, most probabilities we encounter in machine learning are products of individual probabilities.</p>
<p>$$
P(X\mid\boldsymbol{\theta}) = p(x_1\mid\boldsymbol{\theta})\cdot p(x_2\mid\boldsymbol{\theta})\cdots p(x_n\mid\boldsymbol{\theta}).
$$</p>
<p>This means that if we directly apply the product rule to compute a derivative we get</p>
<p>$$
\begin{aligned}
\frac{\partial}{\partial \boldsymbol{\theta}} P(X\mid\boldsymbol{\theta}) &amp; = \left(\frac{\partial}{\partial \boldsymbol{\theta}}P(x_1\mid\boldsymbol{\theta})\right)\cdot P(x_2\mid\boldsymbol{\theta})\cdots P(x_n\mid\boldsymbol{\theta}) \
&amp; \quad + P(x_1\mid\boldsymbol{\theta})\cdot \left(\frac{\partial}{\partial \boldsymbol{\theta}}P(x_2\mid\boldsymbol{\theta})\right)\cdots P(x_n\mid\boldsymbol{\theta}) \
&amp; \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \vdots \
&amp; \quad + P(x_1\mid\boldsymbol{\theta})\cdot P(x_2\mid\boldsymbol{\theta}) \cdots \left(\frac{\partial}{\partial \boldsymbol{\theta}}P(x_n\mid\boldsymbol{\theta})\right).
\end{aligned}
$$</p>
<p>This requires $n(n-1)$ multiplications, along with $(n-1)$ additions, so it is proportional to quadratic time in the inputs!  Sufficient cleverness in grouping terms will reduce this to linear time, but it requires some thought.  For the negative log-likelihood we have instead</p>
<p>$$
-\log\left(P(X\mid\boldsymbol{\theta})\right) = -\log(P(x_1\mid\boldsymbol{\theta})) - \log(P(x_2\mid\boldsymbol{\theta})) \cdots - \log(P(x_n\mid\boldsymbol{\theta})),
$$</p>
<p>which then gives</p>
<p>$$</p>
<ul>
<li>\frac{\partial}{\partial \boldsymbol{\theta}} \log\left(P(X\mid\boldsymbol{\theta})\right) = \frac{1}{P(x_1\mid\boldsymbol{\theta})}\left(\frac{\partial}{\partial \boldsymbol{\theta}}P(x_1\mid\boldsymbol{\theta})\right) + \cdots + \frac{1}{P(x_n\mid\boldsymbol{\theta})}\left(\frac{\partial}{\partial \boldsymbol{\theta}}P(x_n\mid\boldsymbol{\theta})\right).
$$</li>
</ul>
<p>This requires only $n$ divides and $n-1$ sums, and thus is linear time in the inputs.</p>
<p>The third and final reason to consider the negative log-likelihood is the relationship to information theory, which we will discuss in detail in :numref:<code>sec_information_theory</code>.  This is a rigorous mathematical theory which gives a way to measure the degree of information or randomness in a random variable.  The key object of study in that field is the entropy which is</p>
<p>$$
H(p) = -\sum_{i} p_i \log_2(p_i),
$$</p>
<p>which measures the randomness of a source. Notice that this is nothing more than the average $-\log$ probability, and thus if we take our negative log-likelihood and divide by the number of data examples, we get a relative of entropy known as cross-entropy.  This theoretical interpretation alone would be sufficiently compelling to motivate reporting the average negative log-likelihood over the dataset as a way of measuring model performance.</p>
<h2 id="maximum-likelihood-for-continuous-variables"><a class="header" href="#maximum-likelihood-for-continuous-variables">Maximum Likelihood for Continuous Variables</a></h2>
<p>Everything that we have done so far assumes we are working with discrete random variables, but what if we want to work with continuous ones?</p>
<p>The short summary is that nothing at all changes, except we replace all the instances of the probability with the probability density.  Recalling that we write densities with lower case $p$, this means that for example we now say</p>
<p>$$
-\log\left(p(X\mid\boldsymbol{\theta})\right) = -\log(p(x_1\mid\boldsymbol{\theta})) - \log(p(x_2\mid\boldsymbol{\theta})) \cdots - \log(p(x_n\mid\boldsymbol{\theta})) = -\sum_i \log(p(x_i \mid \theta)).
$$</p>
<p>The question becomes, "Why is this OK?"  After all, the reason we introduced densities was because probabilities of getting specific outcomes themselves was zero, and thus is not the probability of generating our data for any set of parameters zero?</p>
<p>Indeed, this is the case, and understanding why we can shift to densities is an exercise in tracing what happens to the epsilons.</p>
<p>Let's first re-define our goal.  Suppose that for continuous random variables we no longer want to compute the probability of getting exactly the right value, but instead matching to within some range $\epsilon$.  For simplicity, we assume our data is repeated observations $x_1, \ldots, x_N$ of identically distributed random variables $X_1, \ldots, X_N$.  As we have seen previously, this can be written as</p>
<p>$$
\begin{aligned}
&amp;P(X_1 \in [x_1, x_1+\epsilon], X_2 \in [x_2, x_2+\epsilon], \ldots, X_N \in [x_N, x_N+\epsilon]\mid\boldsymbol{\theta}) \
\approx &amp;\epsilon^Np(x_1\mid\boldsymbol{\theta})\cdot p(x_2\mid\boldsymbol{\theta}) \cdots p(x_n\mid\boldsymbol{\theta}).
\end{aligned}
$$</p>
<p>Thus, if we take negative logarithms of this we obtain</p>
<p>$$
\begin{aligned}
&amp;-\log(P(X_1 \in [x_1, x_1+\epsilon], X_2 \in [x_2, x_2+\epsilon], \ldots, X_N \in [x_N, x_N+\epsilon]\mid\boldsymbol{\theta})) \
\approx &amp; -N\log(\epsilon) - \sum_{i} \log(p(x_i\mid\boldsymbol{\theta})).
\end{aligned}
$$</p>
<p>If we examine this expression, the only place that the $\epsilon$ occurs is in the additive constant $-N\log(\epsilon)$.  This does not depend on the parameters $\boldsymbol{\theta}$ at all, so the optimal choice of $\boldsymbol{\theta}$ does not depend on our choice of $\epsilon$!  If we demand four digits or four-hundred, the best choice of $\boldsymbol{\theta}$ remains the same, thus we may freely drop the epsilon to see that what we want to optimize is</p>
<p>$$</p>
<ul>
<li>\sum_{i} \log(p(x_i\mid\boldsymbol{\theta})).
$$</li>
</ul>
<p>Thus, we see that the maximum likelihood point of view can operate with continuous random variables as easily as with discrete ones by replacing the probabilities with probability densities.</p>
<h2 id="summary-132"><a class="header" href="#summary-132">Summary</a></h2>
<ul>
<li>The maximum likelihood principle tells us that the best fit model for a given dataset is the one that generates the data with the highest probability.</li>
<li>Often people work with the negative log-likelihood instead for a variety of reasons: numerical stability, conversion of products to sums (and the resulting simplification of gradient computations), and theoretical ties to information theory.</li>
<li>While simplest to motivate in the discrete setting, it may be freely generalized to the continuous setting as well by maximizing the probability density assigned to the datapoints.</li>
</ul>
<h2 id="exercises-150"><a class="header" href="#exercises-150">Exercises</a></h2>
<ol>
<li>Suppose that you know that a non-negative random variable has density $\alpha e^{-\alpha x}$ for some value $\alpha&gt;0$.  You obtain a single observation from the random variable which is the number $3$.  What is the maximum likelihood estimate for $\alpha$?</li>
<li>Suppose that you have a dataset of samples ${x_i}_{i=1}^N$ drawn from a Gaussian with unknown mean, but variance $1$.  What is the maximum likelihood estimate for the mean?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/416">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1096">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1097">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributions"><a class="header" href="#distributions">Distributions</a></h1>
<p>:label:<code>sec_distributions</code></p>
<p>Now that we have learned how to work with probability in both the discrete and the continuous setting, let's get to know some of the common distributions encountered.  Depending on the area of machine learning, we may need to be familiar with vastly more of these, or for some areas of deep learning potentially none at all.  This is, however, a good basic list to be familiar with.  Let's first import some common libraries.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
from IPython import display
from math import erf, factorial
import numpy as np
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
from IPython import display
from math import erf, factorial
import torch

torch.pi = torch.acos(torch.zeros(1)) * 2  # Define pi in torch
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
from IPython import display
from math import erf, factorial
import tensorflow as tf
import tensorflow_probability as tfp

tf.pi = tf.acos(tf.zeros(1)) * 2  # Define pi in TensorFlow
</code></pre>
<h2 id="bernoulli"><a class="header" href="#bernoulli">Bernoulli</a></h2>
<p>This is the simplest random variable usually encountered.  This random variable encodes a coin flip which comes up $1$ with probability $p$ and $0$ with probability $1-p$.  If we have a random variable $X$ with this distribution, we will write</p>
<p>$$
X \sim \textrm{Bernoulli}(p).
$$</p>
<p>The cumulative distribution function is</p>
<p>$$F(x) = \begin{cases} 0 &amp; x &lt; 0, \ 1-p &amp; 0 \le x &lt; 1, \ 1 &amp; x &gt;= 1 . \end{cases}$$
:eqlabel:<code>eq_bernoulli_cdf</code></p>
<p>The probability mass function is plotted below.</p>
<pre><code class="language-{.python .input}">#@tab all
p = 0.3

d2l.set_figsize()
d2l.plt.stem([0, 1], [1 - p, p], use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<p>Now, let's plot the cumulative distribution function :eqref:<code>eq_bernoulli_cdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-1, 2, 0.01)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; 1 else 1 - p

d2l.plot(x, np.array([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-1, 2, 0.01)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; 1 else 1 - p

d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-1, 2, 0.01)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; 1 else 1 - p

d2l.plot(x, tf.constant([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<p>If $X \sim \textrm{Bernoulli}(p)$, then:</p>
<ul>
<li>$\mu_X = p$,</li>
<li>$\sigma_X^2 = p(1-p)$.</li>
</ul>
<p>We can sample an array of arbitrary shape from a Bernoulli random variable as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
1*(np.random.rand(10, 10) &lt; p)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
1*(torch.rand(10, 10) &lt; p)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.cast(tf.random.uniform((10, 10)) &lt; p, dtype=tf.float32)
</code></pre>
<h2 id="discrete-uniform"><a class="header" href="#discrete-uniform">Discrete Uniform</a></h2>
<p>The next commonly encountered random variable is a discrete uniform.  For our discussion here, we will assume that it is supported on the integers ${1, 2, \ldots, n}$, however any other set of values can be freely chosen.  The meaning of the word <em>uniform</em> in this context is that every possible value is equally likely.  The probability for each value $i \in {1, 2, 3, \ldots, n}$ is $p_i = \frac{1}{n}$.  We will denote a random variable $X$ with this distribution as</p>
<p>$$
X \sim U(n).
$$</p>
<p>The cumulative distribution function is</p>
<p>$$F(x) = \begin{cases} 0 &amp; x &lt; 1, \ \frac{k}{n} &amp; k \le x &lt; k+1 \textrm{ with } 1 \le k &lt; n, \ 1 &amp; x &gt;= n . \end{cases}$$
:eqlabel:<code>eq_discrete_uniform_cdf</code></p>
<p>Let's first plot the probability mass function.</p>
<pre><code class="language-{.python .input}">#@tab all
n = 5

d2l.plt.stem([i+1 for i in range(n)], n*[1 / n], use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<p>Now, let's plot the cumulative distribution function :eqref:<code>eq_discrete_uniform_cdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-1, 6, 0.01)

def F(x):
    return 0 if x &lt; 1 else 1 if x &gt; n else np.floor(x) / n

d2l.plot(x, np.array([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-1, 6, 0.01)

def F(x):
    return 0 if x &lt; 1 else 1 if x &gt; n else torch.floor(x) / n

d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-1, 6, 0.01)

def F(x):
    return 0 if x &lt; 1 else 1 if x &gt; n else tf.floor(x) / n

d2l.plot(x, [F(y) for y in x], 'x', 'c.d.f.')
</code></pre>
<p>If $X \sim U(n)$, then:</p>
<ul>
<li>$\mu_X = \frac{1+n}{2}$,</li>
<li>$\sigma_X^2 = \frac{n^2-1}{12}$.</li>
</ul>
<p>We can sample an array of arbitrary shape from a discrete uniform random variable as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.random.randint(1, n, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.randint(1, n, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.random.uniform((10, 10), 1, n, dtype=tf.int32)
</code></pre>
<h2 id="continuous-uniform"><a class="header" href="#continuous-uniform">Continuous Uniform</a></h2>
<p>Next, let's discuss the continuous uniform distribution. The idea behind this random variable is that if we increase the $n$ in the discrete uniform distribution, and then scale it to fit within the interval $[a, b]$, we will approach a continuous random variable that just picks an arbitrary value in $[a, b]$ all with equal probability.  We will denote this distribution as</p>
<p>$$
X \sim U(a, b).
$$</p>
<p>The probability density function is</p>
<p>$$p(x) = \begin{cases} \frac{1}{b-a} &amp; x \in [a, b], \ 0 &amp; x \not\in [a, b].\end{cases}$$
:eqlabel:<code>eq_cont_uniform_pdf</code></p>
<p>The cumulative distribution function is</p>
<p>$$F(x) = \begin{cases} 0 &amp; x &lt; a, \ \frac{x-a}{b-a} &amp; x \in [a, b], \ 1 &amp; x &gt;= b . \end{cases}$$
:eqlabel:<code>eq_cont_uniform_cdf</code></p>
<p>Let's first plot the probability density function :eqref:<code>eq_cont_uniform_pdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
a, b = 1, 3

x = np.arange(0, 4, 0.01)
p = (x &gt; a)*(x &lt; b)/(b - a)

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
a, b = 1, 3

x = torch.arange(0, 4, 0.01)
p = (x &gt; a).type(torch.float32)*(x &lt; b).type(torch.float32)/(b-a)
d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
a, b = 1, 3

x = tf.range(0, 4, 0.01)
p = tf.cast(x &gt; a, tf.float32) * tf.cast(x &lt; b, tf.float32) / (b - a)
d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<p>Now, let's plot the cumulative distribution function :eqref:<code>eq_cont_uniform_cdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def F(x):
    return 0 if x &lt; a else 1 if x &gt; b else (x - a) / (b - a)

d2l.plot(x, np.array([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def F(x):
    return 0 if x &lt; a else 1 if x &gt; b else (x - a) / (b - a)

d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def F(x):
    return 0 if x &lt; a else 1 if x &gt; b else (x - a) / (b - a)

d2l.plot(x, [F(y) for y in x], 'x', 'c.d.f.')
</code></pre>
<p>If $X \sim U(a, b)$, then:</p>
<ul>
<li>$\mu_X = \frac{a+b}{2}$,</li>
<li>$\sigma_X^2 = \frac{(b-a)^2}{12}$.</li>
</ul>
<p>We can sample an array of arbitrary shape from a uniform random variable as follows.  Note that it by default samples from a $U(0,1)$, so if we want a different range we need to scale it.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
(b - a) * np.random.rand(10, 10) + a
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
(b - a) * torch.rand(10, 10) + a
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
(b - a) * tf.random.uniform((10, 10)) + a
</code></pre>
<h2 id="binomial"><a class="header" href="#binomial">Binomial</a></h2>
<p>Let's make things a little more complex and examine the <em>binomial</em> random variable.  This random variable originates from performing a sequence of $n$ independent experiments, each of which has probability $p$ of succeeding, and asking how many successes we expect to see.</p>
<p>Let's express this mathematically.  Each experiment is an independent random variable $X_i$ where we will use $1$ to encode success, and $0$ to encode failure.  Since each is an independent coin flip which is successful with probability $p$, we can say that $X_i \sim \textrm{Bernoulli}(p)$.  Then, the binomial random variable is</p>
<p>$$
X = \sum_{i=1}^n X_i.
$$</p>
<p>In this case, we will write</p>
<p>$$
X \sim \textrm{Binomial}(n, p).
$$</p>
<p>To get the cumulative distribution function, we need to notice that getting exactly $k$ successes can occur in $\binom{n}{k} = \frac{n!}{k!(n-k)!}$ ways each of which has a probability of $p^k(1-p)^{n-k}$ of occurring.  Thus the cumulative distribution function is</p>
<p>$$F(x) = \begin{cases} 0 &amp; x &lt; 0, \ \sum_{m \le k} \binom{n}{m} p^m(1-p)^{n-m}  &amp; k \le x &lt; k+1 \textrm{ with } 0 \le k &lt; n, \ 1 &amp; x &gt;= n . \end{cases}$$
:eqlabel:<code>eq_binomial_cdf</code></p>
<p>Let's first plot the probability mass function.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
n, p = 10, 0.2

# Compute binomial coefficient
def binom(n, k):
    comb = 1
    for i in range(min(k, n - k)):
        comb = comb * (n - i) // (i + 1)
    return comb

pmf = np.array([p**i * (1-p)**(n - i) * binom(n, i) for i in range(n + 1)])

d2l.plt.stem([i for i in range(n + 1)], pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
n, p = 10, 0.2

# Compute binomial coefficient
def binom(n, k):
    comb = 1
    for i in range(min(k, n - k)):
        comb = comb * (n - i) // (i + 1)
    return comb

pmf = d2l.tensor([p**i * (1-p)**(n - i) * binom(n, i) for i in range(n + 1)])

d2l.plt.stem([i for i in range(n + 1)], pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
n, p = 10, 0.2

# Compute binomial coefficient
def binom(n, k):
    comb = 1
    for i in range(min(k, n - k)):
        comb = comb * (n - i) // (i + 1)
    return comb

pmf = tf.constant([p**i * (1-p)**(n - i) * binom(n, i) for i in range(n + 1)])

d2l.plt.stem([i for i in range(n + 1)], pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<p>Now, let's plot the cumulative distribution function :eqref:<code>eq_binomial_cdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-1, 11, 0.01)
cmf = np.cumsum(pmf)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, np.array([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-1, 11, 0.01)
cmf = torch.cumsum(pmf, dim=0)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, torch.tensor([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-1, 11, 0.01)
cmf = tf.cumsum(pmf)

def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, [F(y) for y in x.numpy().tolist()], 'x', 'c.d.f.')
</code></pre>
<p>If $X \sim \textrm{Binomial}(n, p)$, then:</p>
<ul>
<li>$\mu_X = np$,</li>
<li>$\sigma_X^2 = np(1-p)$.</li>
</ul>
<p>This follows from the linearity of expected value over the sum of $n$ Bernoulli random variables, and the fact that the variance of the sum of independent random variables is the sum of the variances. This can be sampled as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.random.binomial(n, p, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
m = torch.distributions.binomial.Binomial(n, p)
m.sample(sample_shape=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
m = tfp.distributions.Binomial(n, p)
m.sample(sample_shape=(10, 10))
</code></pre>
<h2 id="poisson"><a class="header" href="#poisson">Poisson</a></h2>
<p>Let's now perform a thought experiment.  We are standing at a bus stop and we want to know how many buses will arrive in the next minute.  Let's start by considering $X^{(1)} \sim \textrm{Bernoulli}(p)$ which is simply the probability that a bus arrives in the one minute window.  For bus stops far from an urban center, this might be a pretty good approximation.  We may never see more than one bus in a minute.</p>
<p>However, if we are in a busy area, it is possible or even likely that two buses will arrive.  We can model this by splitting our random variable into two parts for the first 30 seconds, or the second 30 seconds.  In this case we can write</p>
<p>$$
X^{(2)} \sim X^{(2)}_1 + X^{(2)}_2,
$$</p>
<p>where $X^{(2)}$ is the total sum, and $X^{(2)}_i \sim \textrm{Bernoulli}(p/2)$.  The total distribution is then $X^{(2)} \sim \textrm{Binomial}(2, p/2)$.</p>
<p>Why stop here?  Let's continue to split that minute into $n$ parts.  By the same reasoning as above, we see that</p>
<p>$$X^{(n)} \sim \textrm{Binomial}(n, p/n).$$
:eqlabel:<code>eq_eq_poisson_approx</code></p>
<p>Consider these random variables.  By the previous section, we know that :eqref:<code>eq_eq_poisson_approx</code> has mean $\mu_{X^{(n)}} = n(p/n) = p$, and variance $\sigma_{X^{(n)}}^2 = n(p/n)(1-(p/n)) = p(1-p/n)$.  If we take $n \rightarrow \infty$, we can see that these numbers stabilize to $\mu_{X^{(\infty)}} = p$, and variance $\sigma_{X^{(\infty)}}^2 = p$.  This indicates that there <em>could be</em> some random variable we can define in this infinite subdivision limit.</p>
<p>This should not come as too much of a surprise, since in the real world we can just count the number of bus arrivals, however it is nice to see that our mathematical model is well defined.  This discussion can be made formal as the <em>law of rare events</em>.</p>
<p>Following through this reasoning carefully, we can arrive at the following model.  We will say that $X \sim \textrm{Poisson}(\lambda)$ if it is a random variable which takes the values ${0,1,2, \ldots}$ with probability</p>
<p>$$p_k = \frac{\lambda^ke^{-\lambda}}{k!}.$$
:eqlabel:<code>eq_poisson_mass</code></p>
<p>The value $\lambda &gt; 0$ is known as the <em>rate</em> (or the <em>shape</em> parameter), and denotes the average number of arrivals we expect in one unit of time.</p>
<p>We may sum this probability mass function to get the cumulative distribution function.</p>
<p>$$F(x) = \begin{cases} 0 &amp; x &lt; 0, \ e^{-\lambda}\sum_{m = 0}^k \frac{\lambda^m}{m!} &amp; k \le x &lt; k+1 \textrm{ with } 0 \le k. \end{cases}$$
:eqlabel:<code>eq_poisson_cdf</code></p>
<p>Let's first plot the probability mass function :eqref:<code>eq_poisson_mass</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
lam = 5.0

xs = [i for i in range(20)]
pmf = np.array([np.exp(-lam) * lam**k / factorial(k) for k in xs])

d2l.plt.stem(xs, pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
lam = 5.0

xs = [i for i in range(20)]
pmf = torch.tensor([torch.exp(torch.tensor(-lam)) * lam**k
                    / factorial(k) for k in xs])

d2l.plt.stem(xs, pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
lam = 5.0

xs = [i for i in range(20)]
pmf = tf.constant([tf.exp(tf.constant(-lam)).numpy() * lam**k
                    / factorial(k) for k in xs])

d2l.plt.stem(xs, pmf, use_line_collection=True)
d2l.plt.xlabel('x')
d2l.plt.ylabel('p.m.f.')
d2l.plt.show()
</code></pre>
<p>Now, let's plot the cumulative distribution function :eqref:<code>eq_poisson_cdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
x = np.arange(-1, 21, 0.01)
cmf = np.cumsum(pmf)
def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, np.array([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
x = torch.arange(-1, 21, 0.01)
cmf = torch.cumsum(pmf, dim=0)
def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, torch.tensor([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
x = tf.range(-1, 21, 0.01)
cmf = tf.cumsum(pmf)
def F(x):
    return 0 if x &lt; 0 else 1 if x &gt; n else cmf[int(x)]

d2l.plot(x, [F(y) for y in x.numpy().tolist()], 'x', 'c.d.f.')
</code></pre>
<p>As we saw above, the means and variances are particularly concise.  If $X \sim \textrm{Poisson}(\lambda)$, then:</p>
<ul>
<li>$\mu_X = \lambda$,</li>
<li>$\sigma_X^2 = \lambda$.</li>
</ul>
<p>This can be sampled as follows.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.random.poisson(lam, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
m = torch.distributions.poisson.Poisson(lam)
m.sample((10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
m = tfp.distributions.Poisson(lam)
m.sample((10, 10))
</code></pre>
<h2 id="gaussian"><a class="header" href="#gaussian">Gaussian</a></h2>
<p>Now Let's try a different, but related experiment.  Let's say we again are performing $n$ independent $\textrm{Bernoulli}(p)$ measurements $X_i$.  The distribution of the sum of these is $X^{(n)} \sim \textrm{Binomial}(n, p)$.  Rather than taking a limit as $n$ increases and $p$ decreases, Let's fix $p$, and then send $n \rightarrow \infty$.  In this case $\mu_{X^{(n)}} = np \rightarrow \infty$ and $\sigma_{X^{(n)}}^2 = np(1-p) \rightarrow \infty$, so there is no reason to think this limit should be well defined.</p>
<p>However, not all hope is lost!  Let's just make the mean and variance be well behaved by defining</p>
<p>$$
Y^{(n)} = \frac{X^{(n)} - \mu_{X^{(n)}}}{\sigma_{X^{(n)}}}.
$$</p>
<p>This can be seen to have mean zero and variance one, and so it is plausible to believe that it will converge to some limiting distribution.  If we plot what these distributions look like, we will become even more convinced that it will work.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
p = 0.2
ns = [1, 10, 100, 1000]
d2l.plt.figure(figsize=(10, 3))
for i in range(4):
    n = ns[i]
    pmf = np.array([p**i * (1-p)**(n-i) * binom(n, i) for i in range(n + 1)])
    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.stem([(i - n*p)/np.sqrt(n*p*(1 - p)) for i in range(n + 1)], pmf,
                 use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')
    d2l.plt.title("n = {}".format(n))
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
p = 0.2
ns = [1, 10, 100, 1000]
d2l.plt.figure(figsize=(10, 3))
for i in range(4):
    n = ns[i]
    pmf = torch.tensor([p**i * (1-p)**(n-i) * binom(n, i)
                        for i in range(n + 1)])
    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.stem([(i - n*p)/torch.sqrt(torch.tensor(n*p*(1 - p)))
                  for i in range(n + 1)], pmf,
                 use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')
    d2l.plt.title("n = {}".format(n))
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
p = 0.2
ns = [1, 10, 100, 1000]
d2l.plt.figure(figsize=(10, 3))
for i in range(4):
    n = ns[i]
    pmf = tf.constant([p**i * (1-p)**(n-i) * binom(n, i)
                        for i in range(n + 1)])
    d2l.plt.subplot(1, 4, i + 1)
    d2l.plt.stem([(i - n*p)/tf.sqrt(tf.constant(n*p*(1 - p)))
                  for i in range(n + 1)], pmf,
                 use_line_collection=True)
    d2l.plt.xlim([-4, 4])
    d2l.plt.xlabel('x')
    d2l.plt.ylabel('p.m.f.')
    d2l.plt.title("n = {}".format(n))
d2l.plt.show()
</code></pre>
<p>One thing to note: compared to the Poisson case, we are now dividing by the standard deviation which means that we are squeezing the possible outcomes into smaller and smaller areas.  This is an indication that our limit will no longer be discrete, but rather continuous.</p>
<p>A derivation of what occurs is beyond the scope of this document, but the <em>central limit theorem</em> states that as $n \rightarrow \infty$, this will yield the Gaussian Distribution (or sometimes normal distribution).  More explicitly, for any $a, b$:</p>
<p>$$
\lim_{n \rightarrow \infty} P(Y^{(n)} \in [a, b]) = P(\mathcal{N}(0,1) \in [a, b]),
$$</p>
<p>where we say a random variable is normally distributed with given mean $\mu$ and variance $\sigma^2$, written $X \sim \mathcal{N}(\mu, \sigma^2)$ if $X$ has density</p>
<p>$$p_X(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}.$$
:eqlabel:<code>eq_gaussian_pdf</code></p>
<p>Let's first plot the probability density function :eqref:<code>eq_gaussian_pdf</code>.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
mu, sigma = 0, 1

x = np.arange(-3, 3, 0.01)
p = 1 / np.sqrt(2 * np.pi * sigma**2) * np.exp(-(x - mu)**2 / (2 * sigma**2))

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
mu, sigma = 0, 1

x = torch.arange(-3, 3, 0.01)
p = 1 / torch.sqrt(2 * torch.pi * sigma**2) * torch.exp(
    -(x - mu)**2 / (2 * sigma**2))

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
mu, sigma = 0, 1

x = tf.range(-3, 3, 0.01)
p = 1 / tf.sqrt(2 * tf.pi * sigma**2) * tf.exp(
    -(x - mu)**2 / (2 * sigma**2))

d2l.plot(x, p, 'x', 'p.d.f.')
</code></pre>
<p>Now, let's plot the cumulative distribution function.  It is beyond the scope of this appendix, but the Gaussian c.d.f. does not have a closed-form formula in terms of more elementary functions.  We will use <code>erf</code> which provides a way to compute this integral numerically.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def phi(x):
    return (1.0 + erf((x - mu) / (sigma * np.sqrt(2)))) / 2.0

d2l.plot(x, np.array([phi(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def phi(x):
    return (1.0 + erf((x - mu) / (sigma * torch.sqrt(d2l.tensor(2.))))) / 2.0

d2l.plot(x, torch.tensor([phi(y) for y in x.tolist()]), 'x', 'c.d.f.')
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def phi(x):
    return (1.0 + erf((x - mu) / (sigma * tf.sqrt(tf.constant(2.))))) / 2.0

d2l.plot(x, [phi(y) for y in x.numpy().tolist()], 'x', 'c.d.f.')
</code></pre>
<p>Keen-eyed readers will recognize some of these terms.  Indeed, we encountered this integral in :numref:<code>sec_integral_calculus</code>.  Indeed we need exactly that computation to see that this $p_X(x)$ has total area one and is thus a valid density.</p>
<p>Our choice of working with coin flips made computations shorter, but nothing about that choice was fundamental.  Indeed, if we take any collection of independent identically distributed random variables $X_i$, and form</p>
<p>$$
X^{(N)} = \sum_{i=1}^N X_i.
$$</p>
<p>Then</p>
<p>$$
\frac{X^{(N)} - \mu_{X^{(N)}}}{\sigma_{X^{(N)}}}
$$</p>
<p>will be approximately Gaussian.  There are additional requirements needed to make it work, most commonly $E[X^4] &lt; \infty$, but the philosophy is clear.</p>
<p>The central limit theorem is the reason why the Gaussian is fundamental to probability, statistics, and machine learning.  Whenever we can say that something we measured is a sum of many small independent contributions, we can assume that the thing being measured will be close to Gaussian.</p>
<p>There are many more fascinating properties of Gaussians, and we would like to discuss one more here.  The Gaussian is what is known as a <em>maximum entropy distribution</em>.  We will get into entropy more deeply in :numref:<code>sec_information_theory</code>, however all we need to know at this point is that it is a measure of randomness.  In a rigorous mathematical sense, we can think of the Gaussian as the <em>most</em> random choice of random variable with fixed mean and variance.  Thus, if we know that our random variable has some mean and variance, the Gaussian is in a sense the most conservative choice of distribution we can make.</p>
<p>To close the section, let's recall that if $X \sim \mathcal{N}(\mu, \sigma^2)$, then:</p>
<ul>
<li>$\mu_X = \mu$,</li>
<li>$\sigma_X^2 = \sigma^2$.</li>
</ul>
<p>We can sample from the Gaussian (or standard normal) distribution as shown below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
np.random.normal(mu, sigma, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.normal(mu, sigma, size=(10, 10))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.random.normal((10, 10), mu, sigma)
</code></pre>
<h2 id="exponential-family"><a class="header" href="#exponential-family">Exponential Family</a></h2>
<p>:label:<code>subsec_exponential_family</code></p>
<p>One shared property for all the distributions listed above is that they all
belong to which is known as the <em>exponential family</em>. The exponential family
is a set of distributions whose density can be expressed in the following
form:</p>
<p>$$p(\mathbf{x} \mid \boldsymbol{\eta}) = h(\mathbf{x}) \cdot \exp \left( \boldsymbol{\eta}^{\top} \cdot T(\mathbf{x}) - A(\boldsymbol{\eta}) \right)$$
:eqlabel:<code>eq_exp_pdf</code></p>
<p>As this definition can be a little subtle, let's examine it closely.</p>
<p>First, $h(\mathbf{x})$ is known as the <em>underlying measure</em> or the
<em>base measure</em>.  This can be viewed as an original choice of measure we are
modifying with our exponential weight.</p>
<p>Second, we have the vector $\boldsymbol{\eta} = (\eta_1, \eta_2, ..., \eta_l) \in
\mathbb{R}^l$ called the <em>natural parameters</em> or <em>canonical parameters</em>.  These
define how the base measure will be modified.  The natural parameters enter
into the new measure by taking the dot product of these parameters against
some function $T(\cdot)$ of $\mathbf{x}= (x_1, x_2, ..., x_n) \in
\mathbb{R}^n$ and exponentiated. The vector $T(\mathbf{x})= (T_1(\mathbf{x}),
T_2(\mathbf{x}), ..., T_l(\mathbf{x}))$
is called the <em>sufficient statistics</em> for $\boldsymbol{\eta}$. This name is used since the
information represented by $T(\mathbf{x})$ is sufficient to calculate the
probability density and no other information from the sample $\mathbf{x}$'s
are required.</p>
<p>Third, we have $A(\boldsymbol{\eta})$, which is referred to as the <em>cumulant
function</em>, which ensures that the above distribution :eqref:<code>eq_exp_pdf</code>
integrates to one, i.e.,</p>
<p>$$A(\boldsymbol{\eta})  = \log \left[\int h(\mathbf{x}) \cdot \exp
\left(\boldsymbol{\eta}^{\top} \cdot T(\mathbf{x}) \right) d\mathbf{x} \right].$$</p>
<p>To be concrete, let's consider the Gaussian. Assuming that $\mathbf{x}$ is
an univariate variable, we saw that it had a density of</p>
<p>$$
\begin{aligned}
p(x \mid \mu, \sigma) &amp;= \frac{1}{\sqrt{2 \pi \sigma^2}} \cdot \exp
\left{ \frac{-(x-\mu)^2}{2 \sigma^2} \right} \
&amp;= \frac{1}{\sqrt{2 \pi}} \cdot \exp \left{ \frac{\mu}{\sigma^2}x
-\frac{1}{2 \sigma^2} x^2 - \left( \frac{1}{2 \sigma^2} \mu^2
+\log(\sigma) \right) \right}.
\end{aligned}
$$</p>
<p>This matches the definition of the exponential family with:</p>
<ul>
<li><em>underlying measure</em>: $h(x) = \frac{1}{\sqrt{2 \pi}}$,</li>
<li><em>natural parameters</em>: $\boldsymbol{\eta} = \begin{bmatrix} \eta_1 \ \eta_2
\end{bmatrix} = \begin{bmatrix} \frac{\mu}{\sigma^2} \
\frac{1}{2 \sigma^2} \end{bmatrix}$,</li>
<li><em>sufficient statistics</em>: $T(x) = \begin{bmatrix}x\-x^2\end{bmatrix}$, and</li>
<li><em>cumulant function</em>: $A({\boldsymbol\eta}) = \frac{1}{2 \sigma^2} \mu^2 + \log(\sigma)
= \frac{\eta_1^2}{4 \eta_2} - \frac{1}{2}\log(2 \eta_2)$.</li>
</ul>
<p>It is worth noting that the exact choice of each of above terms is somewhat
arbitrary.  Indeed, the important feature is that the distribution can be
expressed in this form, not the exact form itself.</p>
<p>As we allude to in :numref:<code>subsec_softmax_and_derivatives</code>, a widely used
technique is to assume that the  final output $\mathbf{y}$ follows an
exponential family distribution. The exponential family is a common and
powerful family of distributions encountered frequently in machine learning.</p>
<h2 id="summary-133"><a class="header" href="#summary-133">Summary</a></h2>
<ul>
<li>Bernoulli random variables can be used to model events with a yes/no outcome.</li>
<li>Discrete uniform distributions model selects from a finite set of possibilities.</li>
<li>Continuous uniform distributions select from an interval.</li>
<li>Binomial distributions model a series of Bernoulli random variables, and count the number of successes.</li>
<li>Poisson random variables model the arrival of rare events.</li>
<li>Gaussian random variables model the result of adding a large number of independent random variables together.</li>
<li>All the above distributions belong to exponential family.</li>
</ul>
<h2 id="exercises-151"><a class="header" href="#exercises-151">Exercises</a></h2>
<ol>
<li>What is the standard deviation of a random variable that is the difference $X-Y$ of two independent binomial random variables $X, Y \sim \textrm{Binomial}(16, 1/2)$.</li>
<li>If we take a Poisson random variable $X \sim \textrm{Poisson}(\lambda)$ and consider $(X - \lambda)/\sqrt{\lambda}$ as $\lambda \rightarrow \infty$, we can show that this becomes approximately Gaussian.  Why does this make sense?</li>
<li>What is the probability mass function for a sum of two discrete uniform random variables on $n$ elements?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/417">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1098">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1099">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naive-bayes"><a class="header" href="#naive-bayes">Naive Bayes</a></h1>
<p>:label:<code>sec_naive_bayes</code></p>
<p>Throughout the previous sections, we learned about the theory of probability and random variables.  To put this theory to work, let's introduce the <em>naive Bayes</em> classifier.  This uses nothing but probabilistic fundamentals to allow us to perform classification of digits.</p>
<p>Learning is all about making assumptions. If we want to classify a new data example that we have never seen before we have to make some assumptions about which data examples are similar to each other. The naive Bayes classifier, a popular and remarkably clear algorithm, assumes all features are independent from each other to simplify the computation. In this section, we will apply this model to recognize characters in images.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
%matplotlib inline
from d2l import mxnet as d2l
import math
from mxnet import gluon, np, npx
npx.set_np()
d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
%matplotlib inline
from d2l import torch as d2l
import math
import torch
import torchvision
d2l.use_svg_display()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
%matplotlib inline
from d2l import tensorflow as d2l
import math
import tensorflow as tf
d2l.use_svg_display()
</code></pre>
<h2 id="optical-character-recognition"><a class="header" href="#optical-character-recognition">Optical Character Recognition</a></h2>
<p>MNIST :cite:<code>LeCun.Bottou.Bengio.ea.1998</code> is one of widely used datasets. It contains 60,000 images for training and 10,000 images for validation. Each image contains a handwritten digit from 0 to 9. The task is classifying each image into the corresponding digit.</p>
<p>Gluon provides a <code>MNIST</code> class in the <code>data.vision</code> module to
automatically retrieve the dataset from the Internet.
Subsequently, Gluon will use the already-downloaded local copy.
We specify whether we are requesting the training set or the test set
by setting the value of the parameter <code>train</code> to <code>True</code> or <code>False</code>, respectively.
Each image is a grayscale image with both width and height of $28$ with shape ($28$,$28$,$1$). We use a customized transformation to remove the last channel dimension. In addition, the dataset represents each pixel by an unsigned $8$-bit integer.  We quantize them into binary features to simplify the problem.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def transform(data, label):
    return np.floor(data.astype('float32') / 128).squeeze(axis=-1), label

mnist_train = gluon.data.vision.MNIST(train=True, transform=transform)
mnist_test = gluon.data.vision.MNIST(train=False, transform=transform)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
data_transform = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor(),
    lambda x: torch.floor(x * 255 / 128).squeeze(dim=0)
])

mnist_train = torchvision.datasets.MNIST(
    root='./temp', train=True, transform=data_transform, download=True)
mnist_test = torchvision.datasets.MNIST(
    root='./temp', train=False, transform=data_transform, download=True)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
((train_images, train_labels), (
    test_images, test_labels)) = tf.keras.datasets.mnist.load_data()

# Original pixel values of MNIST range from 0-255 (as the digits are stored as
# uint8). For this section, pixel values that are greater than 128 (in the
# original image) are converted to 1 and values that are less than 128 are
# converted to 0. See section 18.9.2 and 18.9.3 for why
train_images = tf.floor(tf.constant(train_images / 128, dtype = tf.float32))
test_images = tf.floor(tf.constant(test_images / 128, dtype = tf.float32))

train_labels = tf.constant(train_labels, dtype = tf.int32)
test_labels = tf.constant(test_labels, dtype = tf.int32)
</code></pre>
<p>We can access a particular example, which contains the image and the corresponding label.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
image, label = mnist_train[2]
image.shape, label
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
image, label = mnist_train[2]
image.shape, label
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
image, label = train_images[2], train_labels[2]
image.shape, label.numpy()
</code></pre>
<p>Our example, stored here in the variable <code>image</code>, corresponds to an image with a height and width of $28$ pixels.</p>
<pre><code class="language-{.python .input}">#@tab all
image.shape, image.dtype
</code></pre>
<p>Our code stores the label of each image as a scalar. Its type is a $32$-bit integer.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
label, type(label), label.dtype
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
label, type(label)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
label.numpy(), label.dtype
</code></pre>
<p>We can also access multiple examples at the same time.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
images, labels = mnist_train[10:38]
images.shape, labels.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
images = torch.stack([mnist_train[i][0] for i in range(10, 38)], dim=0)
labels = torch.tensor([mnist_train[i][1] for i in range(10, 38)])
images.shape, labels.shape
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
images = tf.stack([train_images[i] for i in range(10, 38)], axis=0)
labels = tf.constant([train_labels[i].numpy() for i in range(10, 38)])
images.shape, labels.shape
</code></pre>
<p>Let's visualize these examples.</p>
<pre><code class="language-{.python .input}">#@tab all
d2l.show_images(images, 2, 9);
</code></pre>
<h2 id="the-probabilistic-model-for-classification"><a class="header" href="#the-probabilistic-model-for-classification">The Probabilistic Model for Classification</a></h2>
<p>In a classification task, we map an example into a category. Here an example is a grayscale $28\times 28$ image, and a category is a digit. (Refer to :numref:<code>sec_softmax</code> for a more detailed explanation.)
One natural way to express the classification task is via the probabilistic question: what is the most likely label given the features (i.e., image pixels)? Denote by $\mathbf x\in\mathbb R^d$ the features of the example and $y\in\mathbb R$ the label. Here features are image pixels, where we can reshape a $2$-dimensional image to a vector so that $d=28^2=784$, and labels are digits.
The probability of the label given the features is $p(y  \mid  \mathbf{x})$. If we are able to compute these probabilities, which are $p(y  \mid  \mathbf{x})$ for $y=0, \ldots,9$ in our example, then the classifier will output the prediction $\hat{y}$ given by the expression:</p>
<p>$$\hat{y} = \mathrm{argmax} &gt; p(y  \mid  \mathbf{x}).$$</p>
<p>Unfortunately, this requires that we estimate $p(y  \mid  \mathbf{x})$ for every value of $\mathbf{x} = x_1, ..., x_d$. Imagine that each feature could take one of $2$ values. For example, the feature $x_1 = 1$ might signify that the word apple appears in a given document and $x_1 = 0$ would signify that it does not. If we had $30$ such binary features, that would mean that we need to be prepared to classify any of $2^{30}$ (over 1 billion!) possible values of the input vector $\mathbf{x}$.</p>
<p>Moreover, where is the learning? If we need to see every single possible example in order to predict the corresponding label then we are not really learning a pattern but just memorizing the dataset.</p>
<h2 id="the-naive-bayes-classifier"><a class="header" href="#the-naive-bayes-classifier">The Naive Bayes Classifier</a></h2>
<p>Fortunately, by making some assumptions about conditional independence, we can introduce some inductive bias and build a model capable of generalizing from a comparatively modest selection of training examples. To begin, let's use Bayes theorem, to express the classifier as</p>
<p>$$\hat{y} = \mathrm{argmax}_y &gt; p(y  \mid  \mathbf{x}) = \mathrm{argmax}_y &gt; \frac{p( \mathbf{x}  \mid  y) p(y)}{p(\mathbf{x})}.$$</p>
<p>Note that the denominator is the normalizing term $p(\mathbf{x})$ which does not depend on the value of the label $y$. As a result, we only need to worry about comparing the numerator across different values of $y$. Even if calculating the denominator turned out to be intractable, we could get away with ignoring it, so long as we could evaluate the numerator. Fortunately, even if we wanted to recover the normalizing constant, we could.  We can always recover the normalization term since $\sum_y p(y  \mid  \mathbf{x}) = 1$.</p>
<p>Now, let's focus on $p( \mathbf{x}  \mid  y)$. Using the chain rule of probability, we can express the term $p( \mathbf{x}  \mid  y)$ as</p>
<p>$$p(x_1  \mid y) \cdot p(x_2  \mid  x_1, y) \cdot ... \cdot p( x_d  \mid  x_1, ..., x_{d-1}, y).$$</p>
<p>By itself, this expression does not get us any further. We still must estimate roughly $2^d$ parameters. However, if we assume that <em>the features are conditionally independent of each other, given the label</em>, then suddenly we are in much better shape, as this term simplifies to $\prod_i p(x_i  \mid  y)$, giving us the predictor</p>
<p>$$\hat{y} = \mathrm{argmax}<em>y &gt; \prod</em>{i=1}^d p(x_i  \mid  y) p(y).$$</p>
<p>If we can estimate $p(x_i=1  \mid  y)$ for every $i$ and $y$, and save its value in $P_{xy}[i, y]$, here $P_{xy}$ is a $d\times n$ matrix with $n$ being the number of classes and $y\in{1, \ldots, n}$, then we can also use this to estimate $p(x_i = 0 \mid y)$, i.e.,</p>
<p>$$
p(x_i = t_i \mid y) =
\begin{cases}
P_{xy}[i, y] &amp; \textrm{for } t_i=1 ;\
1 - P_{xy}[i, y] &amp; \textrm{for } t_i = 0 .
\end{cases}
$$</p>
<p>In addition, we estimate $p(y)$ for every $y$ and save it in $P_y[y]$, with $P_y$ a $n$-length vector. Then, for any new example $\mathbf t = (t_1, t_2, \ldots, t_d)$, we could compute</p>
<p>$$\begin{aligned}\hat{y} &amp;= \mathrm{argmax}_ y \ p(y)\prod_{i=1}^d   p(x_t = t_i \mid y) \ &amp;= \mathrm{argmax}<em>y \ P_y[y]\prod</em>{i=1}^d \ P_{xy}[i, y]^{t_i}, \left(1 - P_{xy}[i, y]\right)^{1-t_i}\end{aligned}$$
:eqlabel:<code>eq_naive_bayes_estimation</code></p>
<p>for any $y$. So our assumption of conditional independence has taken the complexity of our model from an exponential dependence on the number of features $\mathcal{O}(2^dn)$ to a linear dependence, which is $\mathcal{O}(dn)$.</p>
<h2 id="training-33"><a class="header" href="#training-33">Training</a></h2>
<p>The problem now is that we do not know $P_{xy}$ and $P_y$. So we need to estimate their values given some training data first. This is <em>training</em> the model. Estimating $P_y$ is not too hard. Since we are only dealing with $10$ classes, we may count the number of occurrences $n_y$ for each of the digits and divide it by the total amount of data $n$. For instance, if digit 8 occurs $n_8 = 5,800$ times and we have a total of $n = 60,000$ images, the probability estimate is $p(y=8) = 0.0967$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
X, Y = mnist_train[:]  # All training examples

n_y = np.zeros((10))
for y in range(10):
    n_y[y] = (Y == y).sum()
P_y = n_y / n_y.sum()
P_y
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X = torch.stack([mnist_train[i][0] for i in range(len(mnist_train))], dim=0)
Y = torch.tensor([mnist_train[i][1] for i in range(len(mnist_train))])

n_y = torch.zeros(10)
for y in range(10):
    n_y[y] = (Y == y).sum()
P_y = n_y / n_y.sum()
P_y
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
X = train_images
Y = train_labels

n_y = tf.Variable(tf.zeros(10))
for y in range(10):
    n_y[y].assign(tf.reduce_sum(tf.cast(Y == y, tf.float32)))
P_y = n_y / tf.reduce_sum(n_y)
P_y
</code></pre>
<p>Now on to slightly more difficult things $P_{xy}$. Since we picked black and white images, $p(x_i  \mid  y)$ denotes the probability that pixel $i$ is switched on for class $y$. Just like before we can go and count the number of times $n_{iy}$ such that an event occurs and divide it by the total number of occurrences of $y$, i.e., $n_y$. But there is something slightly troubling: certain pixels may never be black (e.g., for well cropped images the corner pixels might always be white). A convenient way for statisticians to deal with this problem is to add pseudo counts to all occurrences. Hence, rather than $n_{iy}$ we use $n_{iy}+1$ and instead of $n_y$ we use $n_{y}+2$ (since there are two possible values pixel $i$ can take - it can either be black or white). This is also called <em>Laplace Smoothing</em>.  It may seem ad-hoc, however it can be motivated from a Bayesian point-of-view by a Beta-binomial model.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
n_x = np.zeros((10, 28, 28))
for y in range(10):
    n_x[y] = np.array(X.asnumpy()[Y.asnumpy() == y].sum(axis=0))
P_xy = (n_x + 1) / (n_y + 2).reshape(10, 1, 1)

d2l.show_images(P_xy, 2, 5);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
n_x = torch.zeros((10, 28, 28))
for y in range(10):
    n_x[y] = torch.tensor(X.numpy()[Y.numpy() == y].sum(axis=0))
P_xy = (n_x + 1) / (n_y + 2).reshape(10, 1, 1)

d2l.show_images(P_xy, 2, 5);
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
n_x = tf.Variable(tf.zeros((10, 28, 28)))
for y in range(10):
    n_x[y].assign(tf.cast(tf.reduce_sum(
        X.numpy()[Y.numpy() == y], axis=0), tf.float32))
P_xy = (n_x + 1) / tf.reshape((n_y + 2), (10, 1, 1))

d2l.show_images(P_xy, 2, 5);
</code></pre>
<p>By visualizing these $10\times 28\times 28$ probabilities (for each pixel for each class) we could get some mean looking digits.</p>
<p>Now we can use :eqref:<code>eq_naive_bayes_estimation</code> to predict a new image. Given $\mathbf x$, the following functions computes $p(\mathbf x \mid y)p(y)$ for every $y$.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def bayes_pred(x):
    x = np.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = P_xy * x + (1 - P_xy)*(1 - x)
    p_xy = p_xy.reshape(10, -1).prod(axis=1)  # p(x|y)
    return np.array(p_xy) * P_y

image, label = mnist_test[0]
bayes_pred(image)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def bayes_pred(x):
    x = x.unsqueeze(0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = P_xy * x + (1 - P_xy)*(1 - x)
    p_xy = p_xy.reshape(10, -1).prod(dim=1)  # p(x|y)
    return p_xy * P_y

image, label = mnist_test[0]
bayes_pred(image)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def bayes_pred(x):
    x = tf.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = P_xy * x + (1 - P_xy)*(1 - x)
    p_xy = tf.math.reduce_prod(tf.reshape(p_xy, (10, -1)), axis=1)  # p(x|y)
    return p_xy * P_y

image, label = train_images[0], train_labels[0]
bayes_pred(image)
</code></pre>
<p>This went horribly wrong! To find out why, let's look at the per pixel probabilities. They are typically numbers between $0.001$ and $1$. We are multiplying $784$ of them. At this point it is worth mentioning that we are calculating these numbers on a computer, hence with a fixed range for the exponent. What happens is that we experience <em>numerical underflow</em>, i.e., multiplying all the small numbers leads to something even smaller until it is rounded down to zero.  We discussed this as a theoretical issue in :numref:<code>sec_maximum_likelihood</code>, but we see the phenomena clearly here in practice.</p>
<p>As discussed in that section, we fix this by use the fact that $\log a b = \log a + \log b$, i.e., we switch to summing logarithms.
Even if both $a$ and $b$ are small numbers, the logarithm values should be in a proper range.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
a = 0.1
print('underflow:', a**784)
print('logarithm is normal:', 784*math.log(a))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
a = 0.1
print('underflow:', a**784)
print('logarithm is normal:', 784*math.log(a))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
a = 0.1
print('underflow:', a**784)
print('logarithm is normal:', 784*tf.math.log(a).numpy())
</code></pre>
<p>Since the logarithm is an increasing function, we can rewrite :eqref:<code>eq_naive_bayes_estimation</code> as</p>
<p>$$ \hat{y} = \mathrm{argmax}<em>y \ \log P_y[y] + \sum</em>{i=1}^d \Big[t_i\log P_{xy}[x_i, y] + (1-t_i) \log (1 - P_{xy}[x_i, y]) \Big].$$</p>
<p>We can implement the following stable version:</p>
<pre><code class="language-{.python .input}">#@tab mxnet
log_P_xy = np.log(P_xy)
log_P_xy_neg = np.log(1 - P_xy)
log_P_y = np.log(P_y)

def bayes_pred_stable(x):
    x = np.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = log_P_xy * x + log_P_xy_neg * (1 - x)
    p_xy = p_xy.reshape(10, -1).sum(axis=1)  # p(x|y)
    return p_xy + log_P_y

py = bayes_pred_stable(image)
py
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
log_P_xy = torch.log(P_xy)
log_P_xy_neg = torch.log(1 - P_xy)
log_P_y = torch.log(P_y)

def bayes_pred_stable(x):
    x = x.unsqueeze(0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = log_P_xy * x + log_P_xy_neg * (1 - x)
    p_xy = p_xy.reshape(10, -1).sum(axis=1)  # p(x|y)
    return p_xy + log_P_y

py = bayes_pred_stable(image)
py
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
log_P_xy = tf.math.log(P_xy)
log_P_xy_neg = tf.math.log(1 - P_xy)
log_P_y = tf.math.log(P_y)

def bayes_pred_stable(x):
    x = tf.expand_dims(x, axis=0)  # (28, 28) -&gt; (1, 28, 28)
    p_xy = log_P_xy * x + log_P_xy_neg * (1 - x)
    p_xy = tf.math.reduce_sum(tf.reshape(p_xy, (10, -1)), axis=1)  # p(x|y)
    return p_xy + log_P_y

py = bayes_pred_stable(image)
py
</code></pre>
<p>We may now check if the prediction is correct.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Convert label which is a scalar tensor of int32 dtype to a Python scalar
# integer for comparison
py.argmax(axis=0) == int(label)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
py.argmax(dim=0) == label
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tf.argmax(py, axis=0, output_type = tf.int32) == label
</code></pre>
<p>If we now predict a few validation examples, we can see the Bayes
classifier works pretty well.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def predict(X):
    return [bayes_pred_stable(x).argmax(axis=0).astype(np.int32) for x in X]

X, y = mnist_test[:18]
preds = predict(X)
d2l.show_images(X, 2, 9, titles=[str(d) for d in preds]);
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def predict(X):
    return [bayes_pred_stable(x).argmax(dim=0).type(torch.int32).item()
            for x in X]

X = torch.stack([mnist_test[i][0] for i in range(18)], dim=0)
y = torch.tensor([mnist_test[i][1] for i in range(18)])
preds = predict(X)
d2l.show_images(X, 2, 9, titles=[str(d) for d in preds]);
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def predict(X):
    return [tf.argmax(
        bayes_pred_stable(x), axis=0, output_type = tf.int32).numpy()
            for x in X]

X = tf.stack([train_images[i] for i in range(10, 38)], axis=0)
y = tf.constant([train_labels[i].numpy() for i in range(10, 38)])
preds = predict(X)
d2l.show_images(X, 2, 9, titles=[str(d) for d in preds]);
</code></pre>
<p>Finally, let's compute the overall accuracy of the classifier.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
X, y = mnist_test[:]
preds = np.array(predict(X), dtype=np.int32)
float((preds == y).sum()) / len(y)  # Validation accuracy
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
X = torch.stack([mnist_test[i][0] for i in range(len(mnist_test))], dim=0)
y = torch.tensor([mnist_test[i][1] for i in range(len(mnist_test))])
preds = torch.tensor(predict(X), dtype=torch.int32)
float((preds == y).sum()) / len(y)  # Validation accuracy
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
X = test_images
y = test_labels
preds = tf.constant(predict(X), dtype=tf.int32)
# Validation accuracy
tf.reduce_sum(tf.cast(preds == y, tf.float32)).numpy() / len(y)
</code></pre>
<p>Modern deep networks achieve error rates of less than $0.01$. The relatively poor performance is due to the incorrect statistical assumptions that we made in our model: we assumed that each and every pixel are <em>independently</em> generated, depending only on the label. This is clearly not how humans write digits, and this wrong assumption led to the downfall of our overly naive (Bayes) classifier.</p>
<h2 id="summary-134"><a class="header" href="#summary-134">Summary</a></h2>
<ul>
<li>Using Bayes' rule, a classifier can be made by assuming all observed features are independent.</li>
<li>This classifier can be trained on a dataset by counting the number of occurrences of combinations of labels and pixel values.</li>
<li>This classifier was the gold standard for decades for tasks such as spam detection.</li>
</ul>
<h2 id="exercises-152"><a class="header" href="#exercises-152">Exercises</a></h2>
<ol>
<li>Consider the dataset $[[0,0], [0,1], [1,0], [1,1]]$ with labels given by the XOR of the two elements $[0,1,1,0]$.  What are the probabilities for a Naive Bayes classifier built on this dataset.  Does it successfully classify our points?  If not, what assumptions are violated?</li>
<li>Suppose that we did not use Laplace smoothing when estimating probabilities and a data example arrived at testing time which contained a value never observed in training.  What would the model output?</li>
<li>The naive Bayes classifier is a specific example of a Bayesian network, where the dependence of random variables are encoded with a graph structure.  While the full theory is beyond the scope of this section (see :citet:<code>Koller.Friedman.2009</code> for full details), explain why allowing explicit dependence between the two input variables in the XOR model allows for the creation of a successful classifier.</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/418">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1100">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1101">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statistics"><a class="header" href="#statistics">Statistics</a></h1>
<p>:label:<code>sec_statistics</code></p>
<p>Undoubtedly, to be a top deep learning practitioner, the ability to train the state-of-the-art and high accurate models is crucial.  However, it is often unclear when improvements are significant, or only the result of random fluctuations in the training process.  To be able to discuss uncertainty in estimated values, we must learn some statistics.</p>
<p>The earliest reference of <em>statistics</em> can be traced back to an Arab scholar Al-Kindi in the $9^{\textrm{th}}$-century, who gave a detailed description of how to use statistics and frequency analysis to decipher encrypted messages. After 800 years, the modern statistics arose from Germany in 1700s, when the researchers focused on the demographic and economic data collection and analysis. Today, statistics is the science subject that concerns the collection, processing, analysis, interpretation and visualization of data. What is more, the core theory of statistics has been widely used in the research within academia, industry, and government.</p>
<p>More specifically, statistics can be divided to <em>descriptive statistics</em> and <em>statistical inference</em>. The former focus on summarizing and illustrating the features of a collection of observed data, which is referred to as a <em>sample</em>. The sample is drawn from a <em>population</em>, denotes the total set of similar individuals, items, or events of our experiment interests. Contrary to descriptive statistics, <em>statistical inference</em> further deduces the characteristics of a population from the given <em>samples</em>, based on the assumptions that the sample distribution can replicate the population distribution at some degree.</p>
<p>You may wonder: “What is the essential difference between machine learning and statistics?” Fundamentally speaking, statistics focuses on the inference problem. This type of problems includes modeling the relationship between the variables, such as causal inference, and testing the statistically significance of model parameters, such as A/B testing. In contrast, machine learning emphasizes on making accurate predictions, without explicitly programming and understanding each parameter's functionality.</p>
<p>In this section, we will introduce three types of statistics inference methods: evaluating and comparing estimators, conducting hypothesis tests, and constructing confidence intervals. These methods can help us infer the characteristics of a given population, i.e., the true parameter $\theta$. For brevity, we assume that the true parameter $\theta$ of a given population is a scalar value. It is straightforward to extend to the case where $\theta$ is a vector or a tensor, thus we omit it in our discussion.</p>
<h2 id="evaluating-and-comparing-estimators"><a class="header" href="#evaluating-and-comparing-estimators">Evaluating and Comparing Estimators</a></h2>
<p>In statistics, an <em>estimator</em> is a function of given samples used to estimate the true parameter $\theta$. We will write $\hat{\theta}_n = \hat{f}(x_1, \ldots, x_n)$ for the estimate of $\theta$ after observing the samples {$x_1, x_2, \ldots, x_n$}.</p>
<p>We have seen simple examples of estimators before in section :numref:<code>sec_maximum_likelihood</code>.  If you have a number of samples from a Bernoulli random variable, then the maximum likelihood estimate for the probability the random variable is one can be obtained by counting the number of ones observed and dividing by the total number of samples.  Similarly, an exercise asked you to show that the maximum likelihood estimate of the mean of a Gaussian given a number of samples is given by the average value of all the samples.  These estimators will almost never give the true value of the parameter, but ideally for a large number of samples the estimate will be close.</p>
<p>As an example, we show below the true density of a Gaussian random variable with mean zero and variance one, along with a collection samples from that Gaussian.  We constructed the $y$ coordinate so every point is visible and the relationship to the original density is clearer.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from d2l import mxnet as d2l
from mxnet import np, npx
import random
npx.set_np()

# Sample datapoints and create y coordinate
epsilon = 0.1
random.seed(8675309)
xs = np.random.normal(loc=0, scale=1, size=(300,))

ys = [np.sum(np.exp(-(xs[:i] - xs[i])**2 / (2 * epsilon**2))
             / np.sqrt(2*np.pi*epsilon**2)) / len(xs) for i in range(len(xs))]

# Compute true density
xd = np.arange(np.min(xs), np.max(xs), 0.01)
yd = np.exp(-xd**2/2) / np.sqrt(2 * np.pi)

# Plot the results
d2l.plot(xd, yd, 'x', 'density')
d2l.plt.scatter(xs, ys)
d2l.plt.axvline(x=0)
d2l.plt.axvline(x=np.mean(xs), linestyle='--', color='purple')
d2l.plt.title(f'sample mean: {float(np.mean(xs)):.2f}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
from d2l import torch as d2l
import torch

torch.pi = torch.acos(torch.zeros(1)) * 2  #define pi in torch

# Sample datapoints and create y coordinate
epsilon = 0.1
torch.manual_seed(8675309)
xs = torch.randn(size=(300,))

ys = torch.tensor(
    [torch.sum(torch.exp(-(xs[:i] - xs[i])**2 / (2 * epsilon**2))\
               / torch.sqrt(2*torch.pi*epsilon**2)) / len(xs)\
     for i in range(len(xs))])

# Compute true density
xd = torch.arange(torch.min(xs), torch.max(xs), 0.01)
yd = torch.exp(-xd**2/2) / torch.sqrt(2 * torch.pi)

# Plot the results
d2l.plot(xd, yd, 'x', 'density')
d2l.plt.scatter(xs, ys)
d2l.plt.axvline(x=0)
d2l.plt.axvline(x=torch.mean(xs), linestyle='--', color='purple')
d2l.plt.title(f'sample mean: {float(torch.mean(xs).item()):.2f}')
d2l.plt.show()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
from d2l import tensorflow as d2l
import tensorflow as tf

tf.pi = tf.acos(tf.zeros(1)) * 2  # define pi in TensorFlow

# Sample datapoints and create y coordinate
epsilon = 0.1
xs = tf.random.normal((300,))

ys = tf.constant(
    [(tf.reduce_sum(tf.exp(-(xs[:i] - xs[i])**2 / (2 * epsilon**2)) \
               / tf.sqrt(2*tf.pi*epsilon**2)) / tf.cast(
        tf.size(xs), dtype=tf.float32)).numpy() \
     for i in range(tf.size(xs))])

# Compute true density
xd = tf.range(tf.reduce_min(xs), tf.reduce_max(xs), 0.01)
yd = tf.exp(-xd**2/2) / tf.sqrt(2 * tf.pi)

# Plot the results
d2l.plot(xd, yd, 'x', 'density')
d2l.plt.scatter(xs, ys)
d2l.plt.axvline(x=0)
d2l.plt.axvline(x=tf.reduce_mean(xs), linestyle='--', color='purple')
d2l.plt.title(f'sample mean: {float(tf.reduce_mean(xs).numpy()):.2f}')
d2l.plt.show()
</code></pre>
<p>There can be many ways to compute an estimator of a parameter $\hat{\theta}_n$.  In this section, we introduce three common methods to evaluate and compare estimators: the mean squared error, the standard deviation, and statistical bias.</p>
<h3 id="mean-squared-error"><a class="header" href="#mean-squared-error">Mean Squared Error</a></h3>
<p>Perhaps the simplest metric used to evaluate estimators is the <em>mean squared error (MSE)</em> (or $l_2$ loss) estimator which can be defined as</p>
<p>$$\textrm{MSE} (\hat{\theta}_n, \theta) = E[(\hat{\theta}_n - \theta)^2].$$
:eqlabel:<code>eq_mse_est</code></p>
<p>This allows us to quantify the average squared deviation from the true value.  MSE is always non-negative. If you have read :numref:<code>sec_linear_regression</code>, you will recognize it as the most commonly used regression loss function. As a measure to evaluate an estimator, the closer its value is to zero, the closer the estimator is to the true parameter $\theta$.</p>
<h3 id="statistical-bias"><a class="header" href="#statistical-bias">Statistical Bias</a></h3>
<p>The MSE provides a natural metric, but we can easily imagine multiple different phenomena that might make it large.  Two fundamentally important are fluctuation in the estimator due to randomness in the dataset, and systematic error in the estimator due to the estimation procedure.</p>
<p>First, let's measure the systematic error. For an estimator $\hat{\theta}_n$, the mathematical illustration of <em>statistical bias</em> can be defined as</p>
<p>$$\textrm{bias}(\hat{\theta}_n) = E(\hat{\theta}_n - \theta) = E(\hat{\theta}_n) - \theta.$$
:eqlabel:<code>eq_bias</code></p>
<p>Note that when $\textrm{bias}(\hat{\theta}_n) = 0$, the expectation of the estimator $\hat{\theta}_n$ is equal to the true value of parameter.  In this case, we say $\hat{\theta}_n$ is an unbiased estimator.  In general, an unbiased estimator is better than a biased estimator since its expectation is the same as the true parameter.</p>
<p>It is worth being aware, however, that biased estimators are frequently used in practice.  There are cases where unbiased estimators do not exist without further assumptions, or are intractable to compute.  This may seem like a significant flaw in an estimator, however the majority of estimators encountered in practice are at least asymptotically unbiased in the sense that the bias tends to zero as the number of available samples tends to infinity: $\lim_{n \rightarrow \infty} \textrm{bias}(\hat{\theta}_n) = 0$.</p>
<h3 id="variance-and-standard-deviation"><a class="header" href="#variance-and-standard-deviation">Variance and Standard Deviation</a></h3>
<p>Second, let's measure the randomness in the estimator.  Recall from :numref:<code>sec_random_variables</code>, the <em>standard deviation</em> (or <em>standard error</em>) is defined as the squared root of the variance.  We may measure the degree of fluctuation of an estimator by measuring the standard deviation or variance of that estimator.</p>
<p>$$\sigma_{\hat{\theta}_n} = \sqrt{\textrm{Var} (\hat{\theta}_n )} = \sqrt{E[(\hat{\theta}_n - E(\hat{\theta}_n))^2]}.$$
:eqlabel:<code>eq_var_est</code></p>
<p>It is important to compare :eqref:<code>eq_var_est</code> to :eqref:<code>eq_mse_est</code>.  In this equation we do not compare to the true population value $\theta$, but instead to $E(\hat{\theta}_n)$, the expected sample mean.  Thus we are not measuring how far the estimator tends to be from the true value, but instead we are measuring the fluctuation of the estimator itself.</p>
<h3 id="the-bias-variance-trade-off"><a class="header" href="#the-bias-variance-trade-off">The Bias-Variance Trade-off</a></h3>
<p>It is intuitively clear that these two main components contribute to the mean squared error.  What is somewhat shocking is that we can show that this is actually a <em>decomposition</em> of the mean squared error into these two contributions plus a third one. That is to say that we can write the mean squared error as the sum of the square of the bias, the variance and the irreducible error.</p>
<p>$$
\begin{aligned}
\textrm{MSE} (\hat{\theta}_n, \theta) &amp;= E[(\hat{\theta}_n - \theta)^2] \
&amp;= E[(\hat{\theta}_n)^2] + E[\theta^2] - 2E[\hat{\theta}_n\theta] \
&amp;= \textrm{Var} [\hat{\theta}_n] + E[\hat{\theta}_n]^2 + \textrm{Var} [\theta] + E[\theta]^2 - 2E[\hat{\theta}_n]E[\theta] \
&amp;= (E[\hat{\theta}_n] - E[\theta])^2 + \textrm{Var} [\hat{\theta}_n] + \textrm{Var} [\theta] \
&amp;= (E[\hat{\theta}_n - \theta])^2 + \textrm{Var} [\hat{\theta}_n] + \textrm{Var} [\theta] \
&amp;= (\textrm{bias} [\hat{\theta}_n])^2 + \textrm{Var} (\hat{\theta}_n) + \textrm{Var} [\theta].\
\end{aligned}
$$</p>
<p>We refer the above formula as <em>bias-variance trade-off</em>. The mean squared error can be divided into three sources of error: the error from high bias, the error from high variance and the irreducible error. The bias error is commonly seen in a simple model (such as a linear regression model), which cannot extract high dimensional relations between the features and the outputs. If a model suffers from high bias error, we often say it is <em>underfitting</em> or lack of <em>flexibility</em> as introduced in (:numref:<code>sec_generalization_basics</code>). The high variance usually results from a too complex model, which overfits the training data. As a result, an <em>overfitting</em> model is sensitive to small fluctuations in the data. If a model suffers from high variance, we often say it is <em>overfitting</em> and lack of <em>generalization</em> as introduced in (:numref:<code>sec_generalization_basics</code>). The irreducible error is the result from noise in the $\theta$ itself.</p>
<h3 id="evaluating-estimators-in-code"><a class="header" href="#evaluating-estimators-in-code">Evaluating Estimators in Code</a></h3>
<p>Since the standard deviation of an estimator has been implementing by simply calling <code>a.std()</code> for a tensor <code>a</code>, we will skip it but implement the statistical bias and the mean squared error.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Statistical bias
def stat_bias(true_theta, est_theta):
    return(np.mean(est_theta) - true_theta)

# Mean squared error
def mse(data, true_theta):
    return(np.mean(np.square(data - true_theta)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Statistical bias
def stat_bias(true_theta, est_theta):
    return(torch.mean(est_theta) - true_theta)

# Mean squared error
def mse(data, true_theta):
    return(torch.mean(torch.square(data - true_theta)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Statistical bias
def stat_bias(true_theta, est_theta):
    return(tf.reduce_mean(est_theta) - true_theta)

# Mean squared error
def mse(data, true_theta):
    return(tf.reduce_mean(tf.square(data - true_theta)))
</code></pre>
<p>To illustrate the equation of the bias-variance trade-off, let's simulate of normal distribution $\mathcal{N}(\theta, \sigma^2)$ with $10,000$ samples. Here, we use a $\theta = 1$ and $\sigma = 4$. As the estimator is a function of the given samples, here we use the mean of the samples as an estimator for true $\theta$ in this normal distribution $\mathcal{N}(\theta, \sigma^2)$ .</p>
<pre><code class="language-{.python .input}">#@tab mxnet
theta_true = 1
sigma = 4
sample_len = 10000
samples = np.random.normal(theta_true, sigma, sample_len)
theta_est = np.mean(samples)
theta_est
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
theta_true = 1
sigma = 4
sample_len = 10000
samples = torch.normal(theta_true, sigma, size=(sample_len, 1))
theta_est = torch.mean(samples)
theta_est
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
theta_true = 1
sigma = 4
sample_len = 10000
samples = tf.random.normal((sample_len, 1), theta_true, sigma)
theta_est = tf.reduce_mean(samples)
theta_est
</code></pre>
<p>Let's validate the trade-off equation by calculating the summation of the squared bias and the variance of our estimator. First, calculate the MSE of our estimator.</p>
<pre><code class="language-{.python .input}">#@tab all
mse(samples, theta_true)
</code></pre>
<p>Next, we calculate $\textrm{Var} (\hat{\theta}_n) + [\textrm{bias} (\hat{\theta}_n)]^2$ as below. As you can see, the two values agree to numerical precision.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
bias = stat_bias(theta_true, theta_est)
np.square(samples.std()) + np.square(bias)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
bias = stat_bias(theta_true, theta_est)
torch.square(samples.std(unbiased=False)) + torch.square(bias)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
bias = stat_bias(theta_true, theta_est)
tf.square(tf.math.reduce_std(samples)) + tf.square(bias)
</code></pre>
<h2 id="conducting-hypothesis-tests"><a class="header" href="#conducting-hypothesis-tests">Conducting Hypothesis Tests</a></h2>
<p>The most commonly encountered topic in statistical inference is hypothesis testing. While hypothesis testing was popularized in the early $20^{th}$ century, the first use can be traced back to John Arbuthnot in the 1700s. John tracked 80-year birth records in London and concluded that more men were born than women each year. Following that, the modern significance testing is the intelligence heritage by Karl Pearson who invented $p$-value and Pearson's chi-squared test, William Gosset who is the father of Student's t-distribution, and Ronald Fisher who initialed the null hypothesis and the significance test.</p>
<p>A <em>hypothesis test</em> is a way of evaluating some evidence against the default statement about a population. We refer the default statement as the <em>null hypothesis</em> $H_0$, which we try to reject using the observed data. Here, we use $H_0$ as a starting point for the statistical significance testing. The <em>alternative hypothesis</em> $H_A$ (or $H_1$) is a statement that is contrary to the null hypothesis. A null hypothesis is often stated in a declarative form which posits a relationship between variables. It should reflect the brief as explicit as possible, and be testable by statistics theory.</p>
<p>Imagine you are a chemist. After spending thousands of hours in the lab, you develop a new medicine which can dramatically improve one's ability to understand math. To show its magic power, you need to test it. Naturally, you may need some volunteers to take the medicine and see whether it can help them learn mathematics better. How do you get started?</p>
<p>First, you will need carefully random selected two groups of volunteers, so that there is no difference between their mathematical understanding ability measured by some metrics. The two groups are commonly referred to as the test group and the control group. The <em>test group</em> (or <em>treatment group</em>) is a group of individuals who will experience the medicine, while the <em>control group</em> represents the group of users who are set aside as a benchmark, i.e., identical environment setups except taking this medicine. In this way, the influence of all the variables are minimized, except the impact of the independent variable in the treatment.</p>
<p>Second, after a period of taking the medicine, you will need to measure the two groups' mathematical understanding by the same metrics, such as letting the volunteers do the same tests after learning a new mathematical formula. Then, you can collect their performance and compare the results.  In this case, our null hypothesis will be that there is no difference between the two groups, and our alternate will be that there is.</p>
<p>This is still not fully formal.  There are many details you have to think of carefully. For example, what is the suitable metrics to test their mathematical understanding ability? How many volunteers for your test so you can be confident to claim the effectiveness of your medicine? How long should you run the test? How do you decide if there is a difference between the two groups?  Do you care about the average performance only, or also the range of variation of the scores? And so on.</p>
<p>In this way, hypothesis testing provides a framework for experimental design and reasoning about certainty in observed results.  If we can now show that the null hypothesis is very unlikely to be true, we may reject it with confidence.</p>
<p>To complete the story of how to work with hypothesis testing, we need to now introduce some additional terminology and make some of our concepts above formal.</p>
<h3 id="statistical-significance"><a class="header" href="#statistical-significance">Statistical Significance</a></h3>
<p>The <em>statistical significance</em> measures the probability of erroneously rejecting the null hypothesis, $H_0$, when it should not be rejected, i.e.,</p>
<p>$$ \textrm{statistical significance }= 1 - \alpha = 1 - P(\textrm{reject } H_0 \mid H_0 \textrm{ is true} ).$$</p>
<p>It is also referred to as the <em>type I error</em> or <em>false positive</em>. The $\alpha$, is called as the <em>significance level</em> and its commonly used value is $5%$, i.e., $1-\alpha = 95%$. The significance level can be explained as the level of risk that we are willing to take, when we reject a true null hypothesis.</p>
<p>:numref:<code>fig_statistical_significance</code> shows the observations' values and probability of a given normal distribution in a two-sample hypothesis test. If the observation data example is located outsides the $95%$ threshold, it will be a very unlikely observation under the null hypothesis assumption. Hence, there might be something wrong with the null hypothesis and we will reject it.</p>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/statistical-significance.svg" alt="Statistical significance." />
:label:<code>fig_statistical_significance</code></p>
<h3 id="statistical-power"><a class="header" href="#statistical-power">Statistical Power</a></h3>
<p>The <em>statistical power</em> (or <em>sensitivity</em>) measures the probability of reject the null hypothesis, $H_0$, when it should be rejected, i.e.,</p>
<p>$$ \textrm{statistical power }= 1 - \beta = 1 - P(\textrm{ fail to reject } H_0  \mid H_0 \textrm{ is false} ).$$</p>
<p>Recall that a <em>type I error</em> is error caused by rejecting the null hypothesis when it is true, whereas a <em>type II error</em> is resulted from failing to reject the null hypothesis when it is false. A type II error is usually denoted as $\beta$, and hence the corresponding statistical power is $1-\beta$.</p>
<p>Intuitively, statistical power can be interpreted as how likely our test will detect a real discrepancy of some minimum magnitude at a desired statistical significance level. $80%$ is a commonly used statistical power threshold. The higher the statistical power, the more likely we are to detect true differences.</p>
<p>One of the most common uses of statistical power is in determining the number of samples needed.  The probability you reject the null hypothesis when it is false depends on the degree to which it is false (known as the <em>effect size</em>) and the number of samples you have.  As you might expect, small effect sizes will require a very large number of samples to be detectable with high probability.  While beyond the scope of this brief appendix to derive in detail, as an example, want to be able to reject a null hypothesis that our sample came from a mean zero variance one Gaussian, and we believe that our sample's mean is actually close to one, we can do so with acceptable error rates with a sample size of only $8$.  However, if we think our sample population true mean is close to $0.01$, then we'd need a sample size of nearly $80000$ to detect the difference.</p>
<p>We can imagine the power as a water filter. In this analogy, a high power hypothesis test is like a high quality water filtration system that will reduce harmful substances in the water as much as possible. On the other hand, a smaller discrepancy is like a low quality water filter, where some relative small substances may easily escape from the gaps. Similarly, if the statistical power is not of enough high power, then the test may not catch the smaller discrepancy.</p>
<h3 id="test-statistic"><a class="header" href="#test-statistic">Test Statistic</a></h3>
<p>A <em>test statistic</em> $T(x)$ is a scalar which summarizes some characteristic of the sample data.  The goal of defining such a statistic is that it should allow us to distinguish between different distributions and conduct our hypothesis test.  Thinking back to our chemist example, if we wish to show that one population performs better than the other, it could be reasonable to take the mean as the test statistic.  Different choices of test statistic can lead to statistical test with drastically different statistical power.</p>
<p>Often, $T(X)$ (the distribution of the test statistic under our null hypothesis) will follow, at least approximately, a common probability distribution such as a normal distribution when considered under the null hypothesis. If we can derive explicitly such a distribution, and then measure our test statistic on our dataset, we can safely reject the null hypothesis if our statistic is far outside the range that we would expect.  Making this quantitative leads us to the notion of $p$-values.</p>
<h3 id="p-value"><a class="header" href="#p-value">$p$-value</a></h3>
<p>The $p$-value (or the <em>probability value</em>) is the probability that $T(X)$ is at least as extreme as the observed test statistic $T(x)$ assuming that the null hypothesis is <em>true</em>, i.e.,</p>
<p>$$ p\textrm{-value} = P_{H_0}(T(X) \geq T(x)).$$</p>
<p>If the $p$-value is smaller than or equal to a predefined and fixed statistical significance level $\alpha$, we may reject the null hypothesis. Otherwise, we will conclude that we are lack of evidence to reject the null hypothesis. For a given population distribution, the <em>region of rejection</em> will be the interval contained of all the points which has a $p$-value smaller than the statistical significance level $\alpha$.</p>
<h3 id="one-side-test-and-two-sided-test"><a class="header" href="#one-side-test-and-two-sided-test">One-side Test and Two-sided Test</a></h3>
<p>Normally there are two kinds of significance test: the one-sided test and the two-sided test. The <em>one-sided test</em> (or <em>one-tailed test</em>) is applicable when the null hypothesis and the alternative hypothesis only have one direction. For example, the null hypothesis may state that the true parameter $\theta$ is less than or equal to a value $c$. The alternative hypothesis would be that $\theta$ is greater than $c$. That is, the region of rejection is on only one side of the sampling distribution.  Contrary to the one-sided test, the <em>two-sided test</em> (or <em>two-tailed test</em>) is applicable when the region of rejection is on both sides of the sampling distribution. An example in this case may have a null hypothesis state that the true parameter $\theta$ is equal to a value $c$. The alternative hypothesis would be that $\theta$ is not equal to $c$.</p>
<h3 id="general-steps-of-hypothesis-testing"><a class="header" href="#general-steps-of-hypothesis-testing">General Steps of Hypothesis Testing</a></h3>
<p>After getting familiar with the above concepts, let's go through the general steps of hypothesis testing.</p>
<ol>
<li>State the question and establish a null hypotheses $H_0$.</li>
<li>Set the statistical significance level $\alpha$ and a statistical power ($1 - \beta$).</li>
<li>Obtain samples through experiments.  The number of samples needed will depend on the statistical power, and the expected effect size.</li>
<li>Calculate the test statistic and the $p$-value.</li>
<li>Make the decision to keep or reject the null hypothesis based on the $p$-value and the statistical significance level $\alpha$.</li>
</ol>
<p>To conduct a hypothesis test, we start by defining a null hypothesis and a level of risk that we are willing to take. Then we calculate the test statistic of the sample, taking an extreme value of the test statistic as evidence against the null hypothesis. If the test statistic falls within the reject region, we may reject the null hypothesis in favor of the alternative.</p>
<p>Hypothesis testing is applicable in a variety of scenarios such as the clinical trails and A/B testing.</p>
<h2 id="constructing-confidence-intervals"><a class="header" href="#constructing-confidence-intervals">Constructing Confidence Intervals</a></h2>
<p>When estimating the value of a parameter $\theta$, point estimators like $\hat \theta$ are of limited utility since they contain no notion of uncertainty. Rather, it would be far better if we could produce an interval that would contain the true parameter $\theta$ with high probability.  If you were interested in such ideas a century ago, then you would have been excited to read "Outline of a Theory of Statistical Estimation Based on the Classical Theory of Probability" by Jerzy Neyman :cite:<code>Neyman.1937</code>, who first introduced the concept of confidence interval in 1937.</p>
<p>To be useful, a confidence interval should be as small as possible for a given degree of certainty. Let's see how to derive it.</p>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<p>Mathematically, a <em>confidence interval</em> for the true parameter $\theta$ is an interval $C_n$ that computed from the sample data such that</p>
<p>$$P_{\theta} (C_n \ni \theta) \geq 1 - \alpha, \forall \theta.$$
:eqlabel:<code>eq_confidence</code></p>
<p>Here $\alpha \in (0, 1)$, and $1 - \alpha$ is called the <em>confidence level</em> or <em>coverage</em> of the interval. This is the same $\alpha$ as the significance level as we discussed about above.</p>
<p>Note that :eqref:<code>eq_confidence</code> is about variable $C_n$, not about the fixed $\theta$. To emphasize this, we write $P_{\theta} (C_n \ni \theta)$ rather than $P_{\theta} (\theta \in C_n)$.</p>
<h3 id="interpretation"><a class="header" href="#interpretation">Interpretation</a></h3>
<p>It is very tempting to interpret a $95%$ confidence interval as an interval where you can be $95%$ sure the true parameter lies, however this is sadly not true.  The true parameter is fixed, and it is the interval that is random.  Thus a better interpretation would be to say that if you generated a large number of confidence intervals by this procedure, $95%$ of the generated intervals would contain the true parameter.</p>
<p>This may seem pedantic, but it can have real implications for the interpretation of the results.  In particular, we may satisfy :eqref:<code>eq_confidence</code> by constructing intervals that we are <em>almost certain</em> do not contain the true value, as long as we only do so rarely enough.  We close this section by providing three tempting but false statements.  An in-depth discussion of these points can be found in :citet:<code>Morey.Hoekstra.Rouder.ea.2016</code>.</p>
<ul>
<li><strong>Fallacy 1</strong>. Narrow confidence intervals mean we can estimate the parameter precisely.</li>
<li><strong>Fallacy 2</strong>. The values inside the confidence interval are more likely to be the true value than those outside the interval.</li>
<li><strong>Fallacy 3</strong>. The probability that a particular observed $95%$ confidence interval contains the true value is $95%$.</li>
</ul>
<p>Sufficed to say, confidence intervals are subtle objects.  However, if you keep the interpretation clear, they can be powerful tools.</p>
<h3 id="a-gaussian-example"><a class="header" href="#a-gaussian-example">A Gaussian Example</a></h3>
<p>Let's discuss the most classical example, the confidence interval for the mean of a Gaussian of unknown mean and variance.  Suppose we collect $n$ samples ${x_i}_{i=1}^n$ from our Gaussian $\mathcal{N}(\mu, \sigma^2)$.  We can compute estimators for the mean and variance by taking</p>
<p>$$\hat\mu_n = \frac{1}{n}\sum_{i=1}^n x_i ;\textrm{and}; \hat\sigma^2_n = \frac{1}{n-1}\sum_{i=1}^n (x_i - \hat\mu)^2.$$</p>
<p>If we now consider the random variable</p>
<p>$$
T = \frac{\hat\mu_n - \mu}{\hat\sigma_n/\sqrt{n}},
$$</p>
<p>we obtain a random variable following a well-known distribution called the <em>Student's t-distribution on</em> $n-1$ <em>degrees of freedom</em>.</p>
<p>This distribution is very well studied, and it is known, for instance, that as $n\rightarrow \infty$, it is approximately a standard Gaussian, and thus by looking up values of the Gaussian c.d.f. in a table, we may conclude that the value of $T$ is in the interval $[-1.96, 1.96]$ at least $95%$ of the time.  For finite values of $n$, the interval needs to be somewhat larger, but are well known and precomputed in tables.</p>
<p>Thus, we may conclude that for large $n$,</p>
<p>$$
P\left(\frac{\hat\mu_n - \mu}{\hat\sigma_n/\sqrt{n}} \in [-1.96, 1.96]\right) \ge 0.95.
$$</p>
<p>Rearranging this by multiplying both sides by $\hat\sigma_n/\sqrt{n}$ and then adding $\hat\mu_n$, we obtain</p>
<p>$$
P\left(\mu \in \left[\hat\mu_n - 1.96\frac{\hat\sigma_n}{\sqrt{n}}, \hat\mu_n + 1.96\frac{\hat\sigma_n}{\sqrt{n}}\right]\right) \ge 0.95.
$$</p>
<p>Thus we know that we have found our $95%$ confidence interval:
$$\left[\hat\mu_n - 1.96\frac{\hat\sigma_n}{\sqrt{n}}, \hat\mu_n + 1.96\frac{\hat\sigma_n}{\sqrt{n}}\right].$$
:eqlabel:<code>eq_gauss_confidence</code></p>
<p>It is safe to say that :eqref:<code>eq_gauss_confidence</code> is one of the most used formula in statistics.  Let's close our discussion of statistics by implementing it.  For simplicity, we assume we are in the asymptotic regime.  Small values of $N$ should include the correct value of <code>t_star</code> obtained either programmatically or from a $t$-table.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
# Number of samples
N = 1000

# Sample dataset
samples = np.random.normal(loc=0, scale=1, size=(N,))

# Lookup Students's t-distribution c.d.f.
t_star = 1.96

# Construct interval
mu_hat = np.mean(samples)
sigma_hat = samples.std(ddof=1)
(mu_hat - t_star*sigma_hat/np.sqrt(N), mu_hat + t_star*sigma_hat/np.sqrt(N))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# PyTorch uses Bessel's correction by default, which means the use of ddof=1
# instead of default ddof=0 in numpy. We can use unbiased=False to imitate
# ddof=0.

# Number of samples
N = 1000

# Sample dataset
samples = torch.normal(0, 1, size=(N,))

# Lookup Students's t-distribution c.d.f.
t_star = 1.96

# Construct interval
mu_hat = torch.mean(samples)
sigma_hat = samples.std(unbiased=True)
(mu_hat - t_star*sigma_hat/torch.sqrt(torch.tensor(N, dtype=torch.float32)),\
 mu_hat + t_star*sigma_hat/torch.sqrt(torch.tensor(N, dtype=torch.float32)))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
# Number of samples
N = 1000

# Sample dataset
samples = tf.random.normal((N,), 0, 1)

# Lookup Students's t-distribution c.d.f.
t_star = 1.96

# Construct interval
mu_hat = tf.reduce_mean(samples)
sigma_hat = tf.math.reduce_std(samples)
(mu_hat - t_star*sigma_hat/tf.sqrt(tf.constant(N, dtype=tf.float32)), \
 mu_hat + t_star*sigma_hat/tf.sqrt(tf.constant(N, dtype=tf.float32)))
</code></pre>
<h2 id="summary-135"><a class="header" href="#summary-135">Summary</a></h2>
<ul>
<li>Statistics focuses on inference problems, whereas deep learning emphasizes on making accurate predictions without explicitly programming and understanding.</li>
<li>There are three common statistics inference methods: evaluating and comparing estimators, conducting hypothesis tests, and constructing confidence intervals.</li>
<li>There are three most common estimators: statistical bias, standard deviation, and mean square error.</li>
<li>A confidence interval is an estimated range of a true population parameter that we can construct by given the samples.</li>
<li>Hypothesis testing is a way of evaluating some evidence against the default statement about a population.</li>
</ul>
<h2 id="exercises-153"><a class="header" href="#exercises-153">Exercises</a></h2>
<ol>
<li>Let $X_1, X_2, \ldots, X_n \overset{\textrm{iid}}{\sim} \textrm{Unif}(0, \theta)$, where "iid" stands for <em>independent and identically distributed</em>. Consider the following estimators of $\theta$:
$$\hat{\theta} = \max {X_1, X_2, \ldots, X_n };$$
$$\tilde{\theta} = 2 \bar{X_n} = \frac{2}{n} \sum_{i=1}^n X_i.$$
<ul>
<li>Find the statistical bias, standard deviation, and mean square error of $\hat{\theta}.$</li>
<li>Find the statistical bias, standard deviation, and mean square error of $\tilde{\theta}.$</li>
<li>Which estimator is better?</li>
</ul>
</li>
<li>For our chemist example in introduction, can you derive the 5 steps to conduct a two-sided hypothesis testing? Given the statistical significance level $\alpha = 0.05$ and the statistical power $1 - \beta = 0.8$.</li>
<li>Run the confidence interval code with $N=2$ and $\alpha = 0.5$ for $100$ independently generated dataset, and plot the resulting intervals (in this case <code>t_star = 1.0</code>).  You will see several very short intervals which are very far from containing the true mean $0$.  Does this contradict the interpretation of the confidence interval?  Do you feel comfortable using short intervals to indicate high precision estimates?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/419">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1102">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1103">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="information-theory"><a class="header" href="#information-theory">Information Theory</a></h1>
<p>:label:<code>sec_information_theory</code></p>
<p>The universe is overflowing with information. Information provides a common language across disciplinary rifts: from Shakespeare's Sonnet to researchers' paper on Cornell ArXiv, from Van Gogh's printing Starry Night to Beethoven's music Symphony No. 5, from the first programming language Plankalkül to the state-of-the-art machine learning algorithms. Everything must follow the rules of information theory, no matter the format. With information theory, we can measure and compare how much information is present in different signals. In this section, we will investigate the fundamental concepts of information theory and applications of information theory in machine learning.</p>
<p>Before we get started, let's outline the relationship between machine learning and information theory. Machine learning aims to extract interesting signals from data and make critical predictions.  On the other hand, information theory studies encoding, decoding, transmitting, and manipulating information. As a result, information theory provides fundamental language for discussing the information processing in machine learned systems. For example, many machine learning applications use the cross-entropy loss as described in :numref:<code>sec_softmax</code>.  This loss can be directly derived from information theoretic considerations.</p>
<h2 id="information"><a class="header" href="#information">Information</a></h2>
<p>Let's start with the "soul" of information theory: information. <em>Information</em> can be encoded in anything with a particular sequence of one or more encoding formats. Suppose that we task ourselves with trying to define a notion of information.  What could be our starting point?</p>
<p>Consider the following thought experiment.  We have a friend with a deck of cards.  They will shuffle the deck, flip over some cards, and tell us statements about the cards.  We will try to assess the information content of each statement.</p>
<p>First, they flip over a card and tell us, "I see a card."  This provides us with no information at all.  We were already certain that this was the case so we hope the information should be zero.</p>
<p>Next, they flip over a card and say, "I see a heart."  This provides us some information, but in reality there are only $4$ different suits that were possible, each equally likely, so we are not surprised by this outcome.  We hope that whatever the measure of information, this event should have low information content.</p>
<p>Next, they flip over a card and say, "This is the $3$ of spades."  This is more information.  Indeed there were $52$ equally likely possible outcomes, and our friend told us which one it was.  This should be a medium amount of information.</p>
<p>Let's take this to the logical extreme.  Suppose that finally they flip over every card from the deck and read off the entire sequence of the shuffled deck.  There are $52!$ different orders to the deck, again all equally likely, so we need a lot of information to know which one it is.</p>
<p>Any notion of information we develop must conform to this intuition.  Indeed, in the next sections we will learn how to compute that these events have $0\textrm{ bits}$, $2\textrm{ bits}$, $~5.7\textrm{ bits}$, and $~225.6\textrm{ bits}$ of information respectively.</p>
<p>If we read through these thought experiments, we see a natural idea.  As a starting point, rather than caring about the knowledge, we may build off the idea that information represents the degree of surprise or the abstract possibility of the event. For example, if we want to describe an unusual event, we need a lot information. For a common event, we may not need much information.</p>
<p>In 1948, Claude E. Shannon published <em>A Mathematical Theory of Communication</em> :cite:<code>Shannon.1948</code> establishing the theory of information.  In his article, Shannon introduced the concept of information entropy for the first time. We will begin our journey here.</p>
<h3 id="self-information"><a class="header" href="#self-information">Self-information</a></h3>
<p>Since information embodies the abstract possibility of an event, how do we map the possibility to the number of bits? Shannon introduced the terminology <em>bit</em> as the unit of information, which was originally created by John Tukey. So what is a "bit" and why do we use it to measure information? Historically, an antique transmitter can only send or receive two types of code: $0$ and $1$.  Indeed, binary encoding is still in common use on all modern digital computers. In this way, any information is encoded by a series of $0$ and $1$. And hence, a series of binary digits of length $n$ contains $n$ bits of information.</p>
<p>Now, suppose that for any series of codes, each $0$ or $1$ occurs with a probability of $\frac{1}{2}$. Hence, an event $X$ with a series of codes of length $n$, occurs with a probability of $\frac{1}{2^n}$. At the same time, as we mentioned before, this series contains $n$ bits of information. So, can we generalize to a mathematical function which can transfer the probability $p$ to the number of bits? Shannon gave the answer by defining <em>self-information</em></p>
<p>$$I(X) = - \log_2 (p),$$</p>
<p>as the <em>bits</em> of information we have received for this event $X$. Note that we will always use base-2 logarithms in this section. For the sake of simplicity, the rest of this section will omit the subscript 2 in the logarithm notation, i.e., $\log(.)$ always refers to $\log_2(.)$. For example, the code "0010" has a self-information</p>
<p>$$I(\textrm{"0010"}) = - \log (p(\textrm{"0010"})) = - \log \left( \frac{1}{2^4} \right) = 4 \textrm{ bits}.$$</p>
<p>We can calculate self information as shown below. Before that, let's first import all the necessary packages in this section.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
from mxnet import np
from mxnet.metric import NegativeLogLikelihood
from mxnet.ndarray import nansum
import random

def self_information(p):
    return -np.log2(p)

self_information(1 / 64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
import torch
from torch.nn import NLLLoss

def nansum(x):
    # Define nansum, as pytorch does not offer it inbuilt.
    return x[~torch.isnan(x)].sum()

def self_information(p):
    return -torch.log2(torch.tensor(p)).item()

self_information(1 / 64)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
import tensorflow as tf

def log2(x):
    return tf.math.log(x) / tf.math.log(2.)

def nansum(x):
    return tf.reduce_sum(tf.where(tf.math.is_nan(
        x), tf.zeros_like(x), x), axis=-1)

def self_information(p):
    return -log2(tf.constant(p)).numpy()

self_information(1 / 64)
</code></pre>
<h2 id="entropy-1"><a class="header" href="#entropy-1">Entropy</a></h2>
<p>As self-information only measures the information of a single discrete event, we need a more generalized measure for any random variable of either discrete or continuous distribution.</p>
<h3 id="motivating-entropy"><a class="header" href="#motivating-entropy">Motivating Entropy</a></h3>
<p>Let's try to get specific about what we want.  This will be an informal statement of what are known as the <em>axioms of Shannon entropy</em>.  It will turn out that the following collection of common-sense statements force us to a unique definition of information.  A formal version of these axioms, along with several others may be found in :citet:<code>Csiszar.2008</code>.</p>
<ol>
<li>The information we gain by observing a random variable does not depend on what we call the elements, or the presence of additional elements which have probability zero.</li>
<li>The information we gain by observing two random variables is no more than the sum of the information we gain by observing them separately.  If they are independent, then it is exactly the sum.</li>
<li>The information gained when observing (nearly) certain events is (nearly) zero.</li>
</ol>
<p>While proving this fact is beyond the scope of our text, it is important to know that this uniquely determines the form that entropy must take.  The only ambiguity that these allow is in the choice of fundamental units, which is most often normalized by making the choice we saw before that the information provided by a single fair coin flip is one bit.</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<p>For any random variable $X$ that follows a probability distribution $P$ with a probability density function (p.d.f.) or a probability mass function (p.m.f.) $p(x)$, we measure the expected amount of information through <em>entropy</em> (or <em>Shannon entropy</em>)</p>
<p>$$H(X) = - E_{x \sim P} [\log p(x)].$$
:eqlabel:<code>eq_ent_def</code></p>
<p>To be specific, if $X$ is discrete, $$H(X) = - \sum_i p_i \log p_i \textrm{, where } p_i = P(X_i).$$</p>
<p>Otherwise, if $X$ is continuous, we also refer entropy as <em>differential entropy</em></p>
<p>$$H(X) = - \int_x p(x) \log p(x) ; dx.$$</p>
<p>We can define entropy as below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def entropy(p):
    entropy = - p * np.log2(p)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(entropy.as_nd_ndarray())
    return out

entropy(np.array([0.1, 0.5, 0.1, 0.3]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def entropy(p):
    entropy = - p * torch.log2(p)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(entropy)
    return out

entropy(torch.tensor([0.1, 0.5, 0.1, 0.3]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def entropy(p):
    return nansum(- p * log2(p))

entropy(tf.constant([0.1, 0.5, 0.1, 0.3]))
</code></pre>
<h3 id="interpretations"><a class="header" href="#interpretations">Interpretations</a></h3>
<p>You may be curious: in the entropy definition :eqref:<code>eq_ent_def</code>, why do we use an expectation of a negative logarithm? Here are some intuitions.</p>
<p>First, why do we use a <em>logarithm</em> function $\log$? Suppose that $p(x) = f_1(x) f_2(x) \ldots, f_n(x)$, where each component function $f_i(x)$ is independent from each other. This means that each $f_i(x)$ contributes independently to the total information obtained from $p(x)$. As discussed above, we want the entropy formula to be additive over independent random variables. Luckily, $\log$ can naturally turn a product of probability distributions to a summation of the individual terms.</p>
<p>Next, why do we use a <em>negative</em> $\log$? Intuitively, more frequent events should contain less information than less common events, since we often gain more information from an unusual case than from an ordinary one. However, $\log$ is monotonically increasing with the probabilities, and indeed negative for all values in $[0, 1]$.  We need to construct a monotonically decreasing relationship between the probability of events and their entropy, which will ideally be always positive (for nothing we observe should force us to forget what we have known). Hence, we add a negative sign in front of $\log$ function.</p>
<p>Last, where does the <em>expectation</em> function come from? Consider a random variable $X$. We can interpret the self-information ($-\log(p)$) as the amount of <em>surprise</em> we have at seeing a particular outcome.  Indeed, as the probability approaches zero, the surprise becomes infinite.  Similarly, we can interpret the entropy as the average amount of surprise from observing $X$. For example, imagine that a slot machine system emits statistical independently symbols ${s_1, \ldots, s_k}$ with probabilities ${p_1, \ldots, p_k}$ respectively. Then the entropy of this system equals to the average self-information from observing each output, i.e.,</p>
<p>$$H(S) = \sum_i {p_i \cdot I(s_i)} = - \sum_i {p_i \cdot \log p_i}.$$</p>
<h3 id="properties-of-entropy"><a class="header" href="#properties-of-entropy">Properties of Entropy</a></h3>
<p>By the above examples and interpretations, we can derive the following properties of entropy :eqref:<code>eq_ent_def</code>. Here, we refer to $X$ as an event and $P$ as the probability distribution of $X$.</p>
<ul>
<li>
<p>$H(X) \geq 0$ for all discrete $X$ (entropy can be negative for continuous $X$).</p>
</li>
<li>
<p>If $X \sim P$ with a p.d.f. or a p.m.f. $p(x)$, and we try to estimate $P$ by a new probability distribution $Q$ with a p.d.f. or a p.m.f. $q(x)$, then $$H(X) = - E_{x \sim P} [\log p(x)] \leq  - E_{x \sim P} [\log q(x)], \textrm{ with equality if and only if } P = Q.$$  Alternatively, $H(X)$ gives a lower bound of the average number of bits needed to encode symbols drawn from $P$.</p>
</li>
<li>
<p>If $X \sim P$, then $x$ conveys the maximum amount of information if it spreads evenly among all possible outcomes. Specifically, if the probability distribution $P$ is discrete with $k$-class ${p_1, \ldots, p_k }$, then $$H(X) \leq \log(k), \textrm{ with equality if and only if } p_i = \frac{1}{k}, \forall i.$$ If $P$ is a continuous random variable, then the story becomes much more complicated.  However, if we additionally impose that $P$ is supported on a finite interval (with all values between $0$ and $1$), then $P$ has the highest entropy if it is the uniform distribution on that interval.</p>
</li>
</ul>
<h2 id="mutual-information"><a class="header" href="#mutual-information">Mutual Information</a></h2>
<p>Previously we defined entropy of a single random variable $X$, how about the entropy of a pair random variables $(X, Y)$?  We can think of these techniques as trying to answer the following type of question, "What information is contained in $X$ and $Y$ together compared to each separately?  Is there redundant information, or is it all unique?"</p>
<p>For the following discussion, we always use $(X, Y)$ as a pair of random variables that follows a joint probability distribution $P$ with a p.d.f. or a p.m.f. $p_{X, Y}(x, y)$, while $X$ and $Y$ follow probability distribution $p_X(x)$ and $p_Y(y)$, respectively.</p>
<h3 id="joint-entropy"><a class="header" href="#joint-entropy">Joint Entropy</a></h3>
<p>Similar to entropy of a single random variable :eqref:<code>eq_ent_def</code>, we define the <em>joint entropy</em> $H(X, Y)$ of a pair random variables $(X, Y)$ as</p>
<p>$$H(X, Y) = -E_{(x, y) \sim P} [\log p_{X, Y}(x, y)]. $$
:eqlabel:<code>eq_joint_ent_def</code></p>
<p>Precisely, on the one hand, if $(X, Y)$ is a pair of discrete random variables, then</p>
<p>$$H(X, Y) = - \sum_{x} \sum_{y} p_{X, Y}(x, y) \log p_{X, Y}(x, y).$$</p>
<p>On the other hand, if $(X, Y)$ is a pair of continuous random variables, then we define the <em>differential joint entropy</em> as</p>
<p>$$H(X, Y) = - \int_{x, y} p_{X, Y}(x, y) \ \log p_{X, Y}(x, y) ;dx ;dy.$$</p>
<p>We can think of :eqref:<code>eq_joint_ent_def</code> as telling us the total randomness in the pair of random variables.  As a pair of extremes, if $X = Y$ are two identical random variables, then the information in the pair is exactly the information in one and we have $H(X, Y) = H(X) = H(Y)$.  On the other extreme, if $X$ and $Y$ are independent then $H(X, Y) = H(X) + H(Y)$.  Indeed we will always have that the information contained in a pair of random variables is no smaller than the entropy of either random variable and no more than the sum of both.</p>
<p>$$
H(X), H(Y) \le H(X, Y) \le H(X) + H(Y).
$$</p>
<p>Let's implement joint entropy from scratch.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def joint_entropy(p_xy):
    joint_ent = -p_xy * np.log2(p_xy)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(joint_ent.as_nd_ndarray())
    return out

joint_entropy(np.array([[0.1, 0.5], [0.1, 0.3]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def joint_entropy(p_xy):
    joint_ent = -p_xy * torch.log2(p_xy)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(joint_ent)
    return out

joint_entropy(torch.tensor([[0.1, 0.5], [0.1, 0.3]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def joint_entropy(p_xy):
    joint_ent = -p_xy * log2(p_xy)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(joint_ent)
    return out

joint_entropy(tf.constant([[0.1, 0.5], [0.1, 0.3]]))
</code></pre>
<p>Notice that this is the same <em>code</em> as before, but now we interpret it differently as working on the joint distribution of the two random variables.</p>
<h3 id="conditional-entropy"><a class="header" href="#conditional-entropy">Conditional Entropy</a></h3>
<p>The joint entropy defined above the amount of information contained in a pair of random variables.  This is useful, but oftentimes it is not what we care about.  Consider the setting of machine learning.  Let's take $X$ to be the random variable (or vector of random variables) that describes the pixel values of an image, and $Y$ to be the random variable which is the class label.  $X$ should contain substantial information---a natural image is a complex thing.  However, the information contained in $Y$ once the image has been show should be low.  Indeed, the image of a digit should already contain the information about what digit it is unless the digit is illegible.  Thus, to continue to extend our vocabulary of information theory, we need to be able to reason about the information content in a random variable conditional on another.</p>
<p>In the probability theory, we saw the definition of the <em>conditional probability</em> to measure the relationship between variables. We now want to analogously define the <em>conditional entropy</em> $H(Y \mid X)$.  We can write this as</p>
<p>$$ H(Y \mid X) = - E_{(x, y) \sim P} [\log p(y \mid x)],$$
:eqlabel:<code>eq_cond_ent_def</code></p>
<p>where $p(y \mid x) = \frac{p_{X, Y}(x, y)}{p_X(x)}$ is the conditional probability. Specifically, if $(X, Y)$ is a pair of discrete random variables, then</p>
<p>$$H(Y \mid X) = - \sum_{x} \sum_{y} p(x, y) \log p(y \mid x).$$</p>
<p>If $(X, Y)$ is a pair of continuous random variables, then the <em>differential conditional entropy</em> is similarly defined as</p>
<p>$$H(Y \mid X) = - \int_x \int_y p(x, y) \ \log p(y \mid x) ;dx ;dy.$$</p>
<p>It is now natural to ask, how does the <em>conditional entropy</em> $H(Y \mid X)$ relate to the entropy $H(X)$ and the joint entropy $H(X, Y)$?  Using the definitions above, we can express this cleanly:</p>
<p>$$H(Y \mid X) = H(X, Y) - H(X).$$</p>
<p>This has an intuitive interpretation: the information in $Y$ given $X$ ($H(Y \mid X)$) is the same as the information in both $X$ and $Y$ together ($H(X, Y)$) minus the information already contained in $X$.  This gives us the information in $Y$ which is not also represented in $X$.</p>
<p>Now, let's implement conditional entropy :eqref:<code>eq_cond_ent_def</code> from scratch.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def conditional_entropy(p_xy, p_x):
    p_y_given_x = p_xy/p_x
    cond_ent = -p_xy * np.log2(p_y_given_x)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(cond_ent.as_nd_ndarray())
    return out

conditional_entropy(np.array([[0.1, 0.5], [0.2, 0.3]]), np.array([0.2, 0.8]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def conditional_entropy(p_xy, p_x):
    p_y_given_x = p_xy/p_x
    cond_ent = -p_xy * torch.log2(p_y_given_x)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(cond_ent)
    return out

conditional_entropy(torch.tensor([[0.1, 0.5], [0.2, 0.3]]),
                    torch.tensor([0.2, 0.8]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def conditional_entropy(p_xy, p_x):
    p_y_given_x = p_xy/p_x
    cond_ent = -p_xy * log2(p_y_given_x)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(cond_ent)
    return out

conditional_entropy(tf.constant([[0.1, 0.5], [0.2, 0.3]]),
                    tf.constant([0.2, 0.8]))
</code></pre>
<h3 id="mutual-information-1"><a class="header" href="#mutual-information-1">Mutual Information</a></h3>
<p>Given the previous setting of random variables $(X, Y)$, you may wonder: "Now that we know how much information is contained in $Y$ but not in $X$, can we similarly ask how much information is shared between $X$ and $Y$?" The answer will be the <em>mutual information</em> of $(X, Y)$, which we will write as $I(X, Y)$.</p>
<p>Rather than diving straight into the formal definition, let's practice our intuition by first trying to derive an expression for the mutual information entirely based on terms we have constructed before.  We wish to find the information shared between two random variables.  One way we could try to do this is to start with all the information contained in both $X$ and $Y$ together, and then we take off the parts that are not shared.  The information contained in both $X$ and $Y$ together is written as $H(X, Y)$.  We want to subtract from this the information contained in $X$ but not in $Y$, and the information contained in $Y$ but not in $X$.  As we saw in the previous section, this is given by $H(X \mid Y)$ and $H(Y \mid X)$ respectively.  Thus, we have that the mutual information should be</p>
<p>$$
I(X, Y) = H(X, Y) - H(Y \mid X) - H(X \mid Y).
$$</p>
<p>Indeed, this is a valid definition for the mutual information.  If we expand out the definitions of these terms and combine them, a little algebra shows that this is the same as</p>
<p>$$I(X, Y) = E_{x} E_{y} \left{ p_{X, Y}(x, y) \log\frac{p_{X, Y}(x, y)}{p_X(x) p_Y(y)} \right}. $$
:eqlabel:<code>eq_mut_ent_def</code></p>
<p>We can summarize all of these relationships in image :numref:<code>fig_mutual_information</code>.  It is an excellent test of intuition to see why the following statements are all also equivalent to $I(X, Y)$.</p>
<ul>
<li>$H(X) - H(X \mid Y)$</li>
<li>$H(Y) - H(Y \mid X)$</li>
<li>$H(X) + H(Y) - H(X, Y)$</li>
</ul>
<p><img src="chapter_appendix-mathematics-for-deep-learning/../img/mutual-information.svg" alt="Mutual information&#39;s relationship with joint entropy and conditional entropy." />
:label:<code>fig_mutual_information</code></p>
<p>In many ways we can think of the mutual information :eqref:<code>eq_mut_ent_def</code> as principled extension of correlation coefficient we saw in :numref:<code>sec_random_variables</code>.  This allows us to ask not only for linear relationships between variables, but for the maximum information shared between the two random variables of any kind.</p>
<p>Now, let's implement mutual information from scratch.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def mutual_information(p_xy, p_x, p_y):
    p = p_xy / (p_x * p_y)
    mutual = p_xy * np.log2(p)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(mutual.as_nd_ndarray())
    return out

mutual_information(np.array([[0.1, 0.5], [0.1, 0.3]]),
                   np.array([0.2, 0.8]), np.array([[0.75, 0.25]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def mutual_information(p_xy, p_x, p_y):
    p = p_xy / (p_x * p_y)
    mutual = p_xy * torch.log2(p)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(mutual)
    return out

mutual_information(torch.tensor([[0.1, 0.5], [0.1, 0.3]]),
                   torch.tensor([0.2, 0.8]), torch.tensor([[0.75, 0.25]]))
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def mutual_information(p_xy, p_x, p_y):
    p = p_xy / (p_x * p_y)
    mutual = p_xy * log2(p)
    # Operator `nansum` will sum up the non-nan number
    out = nansum(mutual)
    return out

mutual_information(tf.constant([[0.1, 0.5], [0.1, 0.3]]),
                   tf.constant([0.2, 0.8]), tf.constant([[0.75, 0.25]]))
</code></pre>
<h3 id="properties-of-mutual-information"><a class="header" href="#properties-of-mutual-information">Properties of Mutual Information</a></h3>
<p>Rather than memorizing the definition of mutual information :eqref:<code>eq_mut_ent_def</code>, you only need to keep in mind its notable properties:</p>
<ul>
<li>Mutual information is symmetric, i.e., $I(X, Y) = I(Y, X)$.</li>
<li>Mutual information is non-negative, i.e., $I(X, Y) \geq 0$.</li>
<li>$I(X, Y) = 0$ if and only if $X$ and $Y$ are independent. For example, if $X$ and $Y$ are independent, then knowing $Y$ does not give any information about $X$ and vice versa, so their mutual information is zero.</li>
<li>Alternatively, if $X$ is an invertible function of $Y$, then $Y$ and $X$ share all information and $$I(X, Y) = H(Y) = H(X).$$</li>
</ul>
<h3 id="pointwise-mutual-information"><a class="header" href="#pointwise-mutual-information">Pointwise Mutual Information</a></h3>
<p>When we worked with entropy at the beginning of this chapter, we were able to provide an interpretation of $-\log(p_X(x))$ as how <em>surprised</em> we were with the particular outcome.  We may give a similar interpretation to the logarithmic term in the mutual information, which is often referred to as the <em>pointwise mutual information</em>:</p>
<p>$$\textrm{pmi}(x, y) = \log\frac{p_{X, Y}(x, y)}{p_X(x) p_Y(y)}.$$
:eqlabel:<code>eq_pmi_def</code></p>
<p>We can think of :eqref:<code>eq_pmi_def</code> as measuring how much more or less likely the specific combination of outcomes $x$ and $y$ are compared to what we would expect for independent random outcomes.  If it is large and positive, then these two specific outcomes occur much more frequently than they would compared to random chance (<em>note</em>: the denominator is $p_X(x) p_Y(y)$ which is the probability of the two outcomes were independent), whereas if it is large and negative it represents the two outcomes happening far less than we would expect by random chance.</p>
<p>This allows us to interpret the mutual information :eqref:<code>eq_mut_ent_def</code> as the average amount that we were surprised to see two outcomes occurring together compared to what we would expect if they were independent.</p>
<h3 id="applications-of-mutual-information"><a class="header" href="#applications-of-mutual-information">Applications of Mutual Information</a></h3>
<p>Mutual information may be a little abstract in it pure definition, so how does it related to machine learning? In natural language processing, one of the most difficult problems is the <em>ambiguity resolution</em>, or the issue of the meaning of a word being unclear from context. For example, recently a headline in the news reported that "Amazon is on fire". You may wonder whether the company Amazon has a building on fire, or the Amazon rain forest is on fire.</p>
<p>In this case, mutual information can help us resolve this ambiguity. We first find the group of words that each has a relatively large mutual information with the company Amazon, such as e-commerce, technology, and online. Second, we find another group of words that each has a relatively large mutual information with the Amazon rain forest, such as rain, forest, and tropical. When we need to disambiguate "Amazon", we can compare which group has more occurrence in the context of the word Amazon.  In this case the article would go on to describe the forest, and make the context clear.</p>
<h2 id="kullbackleibler-divergence"><a class="header" href="#kullbackleibler-divergence">Kullback–Leibler Divergence</a></h2>
<p>As what we have discussed in :numref:<code>sec_linear-algebra</code>, we can use norms to measure distance between two points in space of any dimensionality.  We would like to be able to do a similar task with probability distributions.  There are many ways to go about this, but information theory provides one of the nicest.  We now explore the <em>Kullback–Leibler (KL) divergence</em>, which provides a way to measure if two distributions are close together or not.</p>
<h3 id="definition-3"><a class="header" href="#definition-3">Definition</a></h3>
<p>Given a random variable $X$ that follows the probability distribution $P$ with a p.d.f. or a p.m.f. $p(x)$, and we estimate $P$ by another probability distribution $Q$ with a p.d.f. or a p.m.f. $q(x)$. Then the <em>Kullback–Leibler (KL) divergence</em> (or <em>relative entropy</em>) between $P$ and $Q$ is</p>
<p>$$D_{\textrm{KL}}(P|Q) = E_{x \sim P} \left[ \log \frac{p(x)}{q(x)} \right].$$
:eqlabel:<code>eq_kl_def</code></p>
<p>As with the pointwise mutual information :eqref:<code>eq_pmi_def</code>, we can again provide an interpretation of the logarithmic term:  $-\log \frac{q(x)}{p(x)} = -\log(q(x)) - (-\log(p(x)))$ will be large and positive if we see $x$ far more often under $P$ than we would expect for $Q$, and large and negative if we see the outcome far less than expected.  In this way, we can interpret it as our <em>relative</em> surprise at observing the outcome compared to how surprised we would be observing it from our reference distribution.</p>
<p>Let's implement the KL divergence from Scratch.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def kl_divergence(p, q):
    kl = p * np.log2(p / q)
    out = nansum(kl.as_nd_ndarray())
    return out.abs().asscalar()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def kl_divergence(p, q):
    kl = p * torch.log2(p / q)
    out = nansum(kl)
    return out.abs().item()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def kl_divergence(p, q):
    kl = p * log2(p / q)
    out = nansum(kl)
    return tf.abs(out).numpy()
</code></pre>
<h3 id="kl-divergence-properties"><a class="header" href="#kl-divergence-properties">KL Divergence Properties</a></h3>
<p>Let's take a look at some properties of the KL divergence :eqref:<code>eq_kl_def</code>.</p>
<ul>
<li>
<p>KL divergence is non-symmetric, i.e., there are $P,Q$ such that $$D_{\textrm{KL}}(P|Q) \neq D_{\textrm{KL}}(Q|P).$$</p>
</li>
<li>
<p>KL divergence is non-negative, i.e., $$D_{\textrm{KL}}(P|Q) \geq 0.$$ Note that the equality holds only when $P = Q$.</p>
</li>
<li>
<p>If there exists an $x$ such that $p(x) &gt; 0$ and $q(x) = 0$, then $D_{\textrm{KL}}(P|Q) = \infty$.</p>
</li>
<li>
<p>There is a close relationship between KL divergence and mutual information. Besides the relationship shown in :numref:<code>fig_mutual_information</code>, $I(X, Y)$ is also numerically equivalent with the following terms:</p>
<ol>
<li>$D_{\textrm{KL}}(P(X, Y)  \ | \ P(X)P(Y))$;</li>
<li>$E_Y { D_{\textrm{KL}}(P(X \mid Y) \ | \ P(X)) }$;</li>
<li>$E_X { D_{\textrm{KL}}(P(Y \mid X) \ | \ P(Y)) }$.</li>
</ol>
<p>For the first term, we interpret mutual information as the KL divergence between $P(X, Y)$ and the product of $P(X)$ and $P(Y)$, and thus is a measure of how different the joint distribution is from the distribution if they were independent. For the second term, mutual information tells us the average reduction in uncertainty about $Y$ that results from learning the value of the $X$'s distribution. Similarly to the third term.</p>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's go through a toy example to see the non-symmetry explicitly.</p>
<p>First, let's generate and sort three tensors of length $10,000$: an objective tensor $p$ which follows a normal distribution $N(0, 1)$, and two candidate tensors $q_1$ and $q_2$ which follow normal distributions $N(-1, 1)$ and $N(1, 1)$ respectively.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
random.seed(1)

nd_len = 10000
p = np.random.normal(loc=0, scale=1, size=(nd_len, ))
q1 = np.random.normal(loc=-1, scale=1, size=(nd_len, ))
q2 = np.random.normal(loc=1, scale=1, size=(nd_len, ))

p = np.array(sorted(p.asnumpy()))
q1 = np.array(sorted(q1.asnumpy()))
q2 = np.array(sorted(q2.asnumpy()))
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
torch.manual_seed(1)

tensor_len = 10000
p = torch.normal(0, 1, (tensor_len, ))
q1 = torch.normal(-1, 1, (tensor_len, ))
q2 = torch.normal(1, 1, (tensor_len, ))

p = torch.sort(p)[0]
q1 = torch.sort(q1)[0]
q2 = torch.sort(q2)[0]
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
tensor_len = 10000
p = tf.random.normal((tensor_len, ), 0, 1)
q1 = tf.random.normal((tensor_len, ), -1, 1)
q2 = tf.random.normal((tensor_len, ), 1, 1)

p = tf.sort(p)
q1 = tf.sort(q1)
q2 = tf.sort(q2)
</code></pre>
<p>Since $q_1$ and $q_2$ are symmetric with respect to the y-axis (i.e., $x=0$), we expect a similar value of KL divergence between $D_{\textrm{KL}}(p|q_1)$ and $D_{\textrm{KL}}(p|q_2)$. As you can see below, there is only a less than 3% off between $D_{\textrm{KL}}(p|q_1)$ and $D_{\textrm{KL}}(p|q_2)$.</p>
<pre><code class="language-{.python .input}">#@tab all
kl_pq1 = kl_divergence(p, q1)
kl_pq2 = kl_divergence(p, q2)
similar_percentage = abs(kl_pq1 - kl_pq2) / ((kl_pq1 + kl_pq2) / 2) * 100

kl_pq1, kl_pq2, similar_percentage
</code></pre>
<p>In contrast, you may find that $D_{\textrm{KL}}(q_2 |p)$ and $D_{\textrm{KL}}(p | q_2)$ are off a lot, with around 40% off as shown below.</p>
<pre><code class="language-{.python .input}">#@tab all
kl_q2p = kl_divergence(q2, p)
differ_percentage = abs(kl_q2p - kl_pq2) / ((kl_q2p + kl_pq2) / 2) * 100

kl_q2p, differ_percentage
</code></pre>
<h2 id="cross-entropy"><a class="header" href="#cross-entropy">Cross-Entropy</a></h2>
<p>If you are curious about applications of information theory in deep learning, here is a quick example. We define the true distribution $P$ with probability distribution $p(x)$, and the estimated distribution $Q$ with probability distribution $q(x)$, and we will use them in the rest of this section.</p>
<p>Say we need to solve a binary classification problem based on given $n$ data examples {$x_1, \ldots, x_n$}. Assume that we encode $1$ and $0$ as the positive and negative class label $y_i$ respectively, and our neural network is parametrized by $\theta$. If we aim to find a best $\theta$ so that $\hat{y}<em>i= p</em>{\theta}(y_i \mid x_i)$, it is natural to apply the maximum log-likelihood approach as was seen in :numref:<code>sec_maximum_likelihood</code>. To be specific, for true labels $y_i$ and predictions $\hat{y}<em>i= p</em>{\theta}(y_i \mid x_i)$, the probability to be classified as positive is $\pi_i= p_{\theta}(y_i = 1 \mid x_i)$. Hence, the log-likelihood function would be</p>
<p>$$
\begin{aligned}
l(\theta) &amp;= \log L(\theta) \
&amp;= \log \prod_{i=1}^n \pi_i^{y_i} (1 - \pi_i)^{1 - y_i} \
&amp;= \sum_{i=1}^n y_i \log(\pi_i) + (1 - y_i) \log (1 - \pi_i). \
\end{aligned}
$$</p>
<p>Maximizing the log-likelihood function $l(\theta)$ is identical to minimizing $- l(\theta)$, and hence we can find the best $\theta$ from here. To generalize the above loss to any distributions, we also called $-l(\theta)$ the <em>cross-entropy loss</em> $\textrm{CE}(y, \hat{y})$, where $y$ follows the true distribution $P$ and $\hat{y}$ follows the estimated distribution $Q$.</p>
<p>This was all derived by working from the maximum likelihood point of view.  However, if we look closely we can see that terms like $\log(\pi_i)$ have entered into our computation which is a solid indication that we can understand the expression from an information theoretic point of view.</p>
<h3 id="formal-definition"><a class="header" href="#formal-definition">Formal Definition</a></h3>
<p>Like KL divergence, for a random variable $X$, we can also measure the divergence between the estimating distribution $Q$ and the true distribution $P$ via <em>cross-entropy</em>,</p>
<p>$$\textrm{CE}(P, Q) = - E_{x \sim P} [\log(q(x))].$$
:eqlabel:<code>eq_ce_def</code></p>
<p>By using properties of entropy discussed above, we can also interpret it as the summation of the entropy $H(P)$ and the KL divergence between $P$ and $Q$, i.e.,</p>
<p>$$\textrm{CE} (P, Q) = H(P) + D_{\textrm{KL}}(P|Q).$$</p>
<p>We can implement the cross-entropy loss as below.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
def cross_entropy(y_hat, y):
    ce = -np.log(y_hat[range(len(y_hat)), y])
    return ce.mean()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
def cross_entropy(y_hat, y):
    ce = -torch.log(y_hat[range(len(y_hat)), y])
    return ce.mean()
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def cross_entropy(y_hat, y):
    # `tf.gather_nd` is used to select specific indices of a tensor.
    ce = -tf.math.log(tf.gather_nd(y_hat, indices = [[i, j] for i, j in zip(
        range(len(y_hat)), y)]))
    return tf.reduce_mean(ce).numpy()
</code></pre>
<p>Now define two tensors for the labels and predictions, and calculate the cross-entropy loss of them.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
labels = np.array([0, 2])
preds = np.array([[0.3, 0.6, 0.1], [0.2, 0.3, 0.5]])

cross_entropy(preds, labels)
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
labels = torch.tensor([0, 2])
preds = torch.tensor([[0.3, 0.6, 0.1], [0.2, 0.3, 0.5]])

cross_entropy(preds, labels)
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
labels = tf.constant([0, 2])
preds = tf.constant([[0.3, 0.6, 0.1], [0.2, 0.3, 0.5]])

cross_entropy(preds, labels)
</code></pre>
<h3 id="properties-1"><a class="header" href="#properties-1">Properties</a></h3>
<p>As alluded in the beginning of this section, cross-entropy :eqref:<code>eq_ce_def</code> can be used to define a loss function in the optimization problem. It turns out that the following are equivalent:</p>
<ol>
<li>Maximizing predictive probability of $Q$ for distribution $P$, (i.e., $E_{x
\sim P} [\log (q(x))]$);</li>
<li>Minimizing cross-entropy $\textrm{CE} (P, Q)$;</li>
<li>Minimizing the KL divergence $D_{\textrm{KL}}(P|Q)$.</li>
</ol>
<p>The definition of cross-entropy indirectly proves the equivalent relationship between objective 2 and objective 3, as long as the entropy of true data $H(P)$ is constant.</p>
<h3 id="cross-entropy-as-an-objective-function-of-multi-class-classification"><a class="header" href="#cross-entropy-as-an-objective-function-of-multi-class-classification">Cross-Entropy as An Objective Function of Multi-class Classification</a></h3>
<p>If we dive deep into the classification objective function with cross-entropy loss $\textrm{CE}$, we will find minimizing $\textrm{CE}$ is equivalent to maximizing the log-likelihood function $L$.</p>
<p>To begin with, suppose that we are given a dataset with $n$ examples, and it can be classified into $k$-classes. For each data example $i$, we represent any $k$-class label $\mathbf{y}<em>i = (y</em>{i1}, \ldots, y_{ik})$ by <em>one-hot encoding</em>. To be specific, if the  example $i$ belongs to class $j$, then we set the $j$-th entry to $1$, and all other components to $0$, i.e.,</p>
<p>$$ y_{ij} = \begin{cases}1 &amp; j \in J; \ 0 &amp;\textrm{otherwise.}\end{cases}$$</p>
<p>For instance, if a multi-class classification problem contains three classes $A$, $B$, and $C$, then the labels $\mathbf{y}_i$ can be encoded in {$A: (1, 0, 0); B: (0, 1, 0); C: (0, 0, 1)$}.</p>
<p>Assume that our neural network is parametrized by $\theta$. For true label vectors $\mathbf{y}<em>i$ and predictions $$\hat{\mathbf{y}}<em>i= p</em>{\theta}(\mathbf{y}<em>i \mid \mathbf{x}<em>i) = \sum</em>{j=1}^k y</em>{ij} p</em>{\theta} (y_{ij}  \mid  \mathbf{x}_i).$$</p>
<p>Hence, the <em>cross-entropy loss</em> would be</p>
<p>$$
\textrm{CE}(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{i=1}^n \mathbf{y}<em>i \log \hat{\mathbf{y}}<em>i
= - \sum</em>{i=1}^n \sum</em>{j=1}^k y_{ij} \log{p_{\theta} (y_{ij}  \mid  \mathbf{x}_i)}.\
$$</p>
<p>On the other side, we can also approach the problem through maximum likelihood estimation. To begin with, let's quickly introduce a $k$-class multinoulli distribution. It is an extension of the Bernoulli distribution from binary class to multi-class. If a random variable $\mathbf{z} = (z_{1}, \ldots, z_{k})$ follows a $k$-class <em>multinoulli distribution</em> with probabilities $\mathbf{p} =$ ($p_{1}, \ldots, p_{k}$), i.e., $$p(\mathbf{z}) = p(z_1, \ldots, z_k) = \textrm{Multi} (p_1, \ldots, p_k), \textrm{ where } \sum_{i=1}^k p_i = 1,$$ then the joint probability mass function(p.m.f.) of $\mathbf{z}$ is
$$\mathbf{p}^\mathbf{z} = \prod_{j=1}^k p_{j}^{z_{j}}.$$</p>
<p>It can be seen that the label of each data example, $\mathbf{y}<em>i$, is following a $k$-class multinoulli distribution with probabilities $\boldsymbol{\pi} =$ ($\pi</em>{1}, \ldots, \pi_{k}$). Therefore, the joint p.m.f. of each data example $\mathbf{y}<em>i$ is  $\mathbf{\pi}^{\mathbf{y}<em>i} = \prod</em>{j=1}^k \pi</em>{j}^{y_{ij}}.$
Hence, the log-likelihood function would be</p>
<p>$$
\begin{aligned}
l(\theta)
= \log L(\theta)
= \log \prod_{i=1}^n \boldsymbol{\pi}^{\mathbf{y}<em>i}
= \log \prod</em>{i=1}^n \prod_{j=1}^k \pi_{j}^{y_{ij}}
= \sum_{i=1}^n \sum_{j=1}^k y_{ij} \log{\pi_{j}}.\
\end{aligned}
$$</p>
<p>Since in maximum likelihood estimation, we maximizing the objective function $l(\theta)$ by having $\pi_{j} = p_{\theta} (y_{ij}  \mid  \mathbf{x}_i)$. Therefore, for any multi-class classification, maximizing the above log-likelihood function $l(\theta)$ is equivalent to minimizing the CE loss $\textrm{CE}(y, \hat{y})$.</p>
<p>To test the above proof, let's apply the built-in measure <code>NegativeLogLikelihood</code>. Using the same <code>labels</code> and <code>preds</code> as in the earlier example, we will get the same numerical loss as the previous example up to the 5 decimal place.</p>
<pre><code class="language-{.python .input}">#@tab mxnet
nll_loss = NegativeLogLikelihood()
nll_loss.update(labels.as_nd_ndarray(), preds.as_nd_ndarray())
nll_loss.get()
</code></pre>
<pre><code class="language-{.python .input}">#@tab pytorch
# Implementation of cross-entropy loss in PyTorch combines `nn.LogSoftmax()`
# and `nn.NLLLoss()`
nll_loss = NLLLoss()
loss = nll_loss(torch.log(preds), labels)
loss
</code></pre>
<pre><code class="language-{.python .input}">#@tab tensorflow
def nll_loss(y_hat, y):
    # Convert labels to one-hot vectors.
    y = tf.keras.utils.to_categorical(y, num_classes= y_hat.shape[1])
    # We will not calculate negative log-likelihood from the definition.
    # Rather, we will follow a circular argument. Because NLL is same as
    # `cross_entropy`, if we calculate cross_entropy that would give us NLL
    cross_entropy = tf.keras.losses.CategoricalCrossentropy(
        from_logits = True, reduction = tf.keras.losses.Reduction.NONE)
    return tf.reduce_mean(cross_entropy(y, y_hat)).numpy()

loss = nll_loss(tf.math.log(preds), labels)
loss
</code></pre>
<h2 id="summary-136"><a class="header" href="#summary-136">Summary</a></h2>
<ul>
<li>Information theory is a field of study about encoding, decoding, transmitting, and manipulating information.</li>
<li>Entropy is the unit to measure how much information is presented in different signals.</li>
<li>KL divergence can also measure the divergence between two distributions.</li>
<li>Cross-entropy can be viewed as an objective function of multi-class classification. Minimizing cross-entropy loss is equivalent to maximizing the log-likelihood function.</li>
</ul>
<h2 id="exercises-154"><a class="header" href="#exercises-154">Exercises</a></h2>
<ol>
<li>Verify that the card examples from the first section indeed have the claimed entropy.</li>
<li>Show that the KL divergence $D(p|q)$ is nonnegative for all distributions $p$ and $q$. Hint: use Jensen's inequality, i.e., use the fact that $-\log x$ is a convex function.</li>
<li>Let's compute the entropy from a few data sources:
<ul>
<li>Assume that you are watching the output generated by a monkey at a typewriter. The monkey presses any of the $44$ keys of the typewriter at random (you can assume that it has not discovered any special keys or the shift key yet). How many bits of randomness per character do you observe?</li>
<li>Being unhappy with the monkey, you replaced it by a drunk typesetter. It is able to generate words, albeit not coherently. Instead, it picks a random word out of a vocabulary of $2,000$ words. Let's assume that the average length of a word is $4.5$ letters in English. How many bits of randomness per character do you observe now?</li>
<li>Still being unhappy with the result, you replace the typesetter by a high quality language model. The language model can currently obtain a perplexity as low as $15$ points per word. The character <em>perplexity</em> of a language model is defined as the inverse of the geometric mean of a set of probabilities, each probability is corresponding to a character in the word. To be specific, if the length of a given word is $l$, then  $\textrm{PPL}(\textrm{word}) = \left[\prod_i p(\textrm{character}_i)\right]^{ -\frac{1}{l}} = \exp \left[ - \frac{1}{l} \sum_i{\log p(\textrm{character}_i)} \right].$  Assume that the test word has 4.5 letters, how many bits of randomness per character do you observe now?</li>
</ul>
</li>
<li>Explain intuitively why $I(X, Y) = H(X) - H(X \mid Y)$.  Then, show this is true by expressing both sides as an expectation with respect to the joint distribution.</li>
<li>What is the KL Divergence between the two Gaussian distributions $\mathcal{N}(\mu_1, \sigma_1^2)$ and $\mathcal{N}(\mu_2, \sigma_2^2)$?</li>
</ol>
<p>:begin_tab:<code>mxnet</code>
<a href="https://discuss.d2l.ai/t/420">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
<a href="https://discuss.d2l.ai/t/1104">Discussions</a>
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
<a href="https://discuss.d2l.ai/t/1105">Discussions</a>
:end_tab:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-tools-for-deep-learning"><a class="header" href="#appendix-tools-for-deep-learning">Appendix: Tools for Deep Learning</a></h1>
<p>:label:<code>chap_appendix_tools</code></p>
<p>To get the most out of <em>Dive into Deep Learning</em>,
we will talk you through different tools
in this appendix,
such as
for running and contributing to this
interactive open-source book.</p>
<pre><code class="language-toc">:maxdepth: 2

jupyter
sagemaker
aws
colab
selecting-servers-gpus
contributing
utils
d2l
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-jupyter-notebooks"><a class="header" href="#using-jupyter-notebooks">Using Jupyter Notebooks</a></h1>
<p>:label:<code>sec_jupyter</code></p>
<p>This section describes how to edit and run the code
in each section of this book
using the Jupyter Notebook. Make sure you have
installed Jupyter and downloaded the
code as described in
:ref:<code>chap_installation</code>.
If you want to know more about Jupyter see the excellent tutorial in
their <a href="https://jupyter.readthedocs.io/en/latest/">documentation</a>.</p>
<h2 id="editing-and-running-the-code-locally"><a class="header" href="#editing-and-running-the-code-locally">Editing and Running the Code Locally</a></h2>
<p>Suppose that the local path of the book's code is <code>xx/yy/d2l-en/</code>. Use the shell to change the directory to this path (<code>cd xx/yy/d2l-en</code>) and run the command <code>jupyter notebook</code>. If your browser does not do this automatically, open http://localhost:8888 and you will see the interface of Jupyter and all the folders containing the code of the book, as shown in :numref:<code>fig_jupyter00</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter00.png" alt="The folders containing the code of this book." />
:width:<code>600px</code>
:label:<code>fig_jupyter00</code></p>
<p>You can access the notebook files by clicking on the folder displayed on the webpage.
They usually have the suffix ".ipynb".
For the sake of brevity, we create a temporary "test.ipynb" file.
The content displayed after you click it is
shown in :numref:<code>fig_jupyter01</code>.
This notebook includes a markdown cell and a code cell. The content in the markdown cell includes "This Is a Title" and "This is text.".
The code cell contains two lines of Python code.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter01.png" alt="Markdown and code cells in the &quot;text.ipynb&quot; file." />
:width:<code>600px</code>
:label:<code>fig_jupyter01</code></p>
<p>Double click on the markdown cell to enter edit mode.
Add a new text string "Hello world." at the end of the cell, as shown in :numref:<code>fig_jupyter02</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter02.png" alt="Edit the markdown cell." />
:width:<code>600px</code>
:label:<code>fig_jupyter02</code></p>
<p>As demonstrated in :numref:<code>fig_jupyter03</code>,
click "Cell" $\rightarrow$ "Run Cells" in the menu bar to run the edited cell.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter03.png" alt="Run the cell." />
:width:<code>600px</code>
:label:<code>fig_jupyter03</code></p>
<p>After running, the markdown cell is shown in :numref:<code>fig_jupyter04</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter04.png" alt="The markdown cell after running." />
:width:<code>600px</code>
:label:<code>fig_jupyter04</code></p>
<p>Next, click on the code cell. Multiply the elements by 2 after the last line of code, as shown in :numref:<code>fig_jupyter05</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter05.png" alt="Edit the code cell." />
:width:<code>600px</code>
:label:<code>fig_jupyter05</code></p>
<p>You can also run the cell with a shortcut ("Ctrl + Enter" by default) and obtain the output result from :numref:<code>fig_jupyter06</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter06.png" alt="Run the code cell to obtain the output." />
:width:<code>600px</code>
:label:<code>fig_jupyter06</code></p>
<p>When a notebook contains more cells, we can click "Kernel" $\rightarrow$ "Restart &amp; Run All" in the menu bar to run all the cells in the entire notebook. By clicking "Help" $\rightarrow$ "Edit Keyboard Shortcuts" in the menu bar, you can edit the shortcuts according to your preferences.</p>
<h2 id="advanced-options"><a class="header" href="#advanced-options">Advanced Options</a></h2>
<p>Beyond local editing two things are quite important: editing the notebooks in the markdown format and running Jupyter remotely.
The latter matters when we want to run the code on a faster server.
The former matters since Jupyter's native ipynb format stores a lot of auxiliary data that is
irrelevant to the content,
mostly related to how and where the code is run.
This is confusing for Git, making
reviewing contributions very difficult.
Fortunately there is an alternative---native editing in the markdown format.</p>
<h3 id="markdown-files-in-jupyter"><a class="header" href="#markdown-files-in-jupyter">Markdown Files in Jupyter</a></h3>
<p>If you wish to contribute to the content of this book, you need to modify the
source file (md file, not ipynb file) on GitHub.
Using the notedown plugin we
can modify notebooks in the md format directly in Jupyter.</p>
<p>First, install the notedown plugin, run the Jupyter Notebook, and load the plugin:</p>
<pre><code>pip install d2l-notedown  # You may need to uninstall the original notedown.
jupyter notebook --NotebookApp.contents_manager_class='notedown.NotedownContentsManager'
</code></pre>
<p>You may also turn on the notedown plugin by default whenever you run the Jupyter Notebook.
First, generate a Jupyter Notebook configuration file (if it has already been generated, you can skip this step).</p>
<pre><code>jupyter notebook --generate-config
</code></pre>
<p>Then, add the following line to the end of the Jupyter Notebook configuration file (for Linux or macOS, usually in the path <code>~/.jupyter/jupyter_notebook_config.py</code>):</p>
<pre><code>c.NotebookApp.contents_manager_class = 'notedown.NotedownContentsManager'
</code></pre>
<p>After that, you only need to run the <code>jupyter notebook</code> command to turn on the notedown plugin by default.</p>
<h3 id="running-jupyter-notebooks-on-a-remote-server"><a class="header" href="#running-jupyter-notebooks-on-a-remote-server">Running Jupyter Notebooks on a Remote Server</a></h3>
<p>Sometimes, you may want to run Jupyter notebooks on a remote server and access it through a browser on your local computer. If Linux or macOS is installed on your local machine (Windows can also support this function through third-party software such as PuTTY), you can use port forwarding:</p>
<pre><code>ssh myserver -L 8888:localhost:8888
</code></pre>
<p>The above string <code>myserver</code> is the address of the remote server.
Then we can use http://localhost:8888 to access the remote server <code>myserver</code> that runs Jupyter notebooks. We will detail on how to run Jupyter notebooks on AWS instances
later in this appendix.</p>
<h3 id="timing"><a class="header" href="#timing">Timing</a></h3>
<p>We can use the <code>ExecuteTime</code> plugin to time the execution of each code cell in Jupyter notebooks.
Use the following commands to install the plugin:</p>
<pre><code>pip install jupyter_contrib_nbextensions
jupyter contrib nbextension install --user
jupyter nbextension enable execute_time/ExecuteTime
</code></pre>
<h2 id="summary-137"><a class="header" href="#summary-137">Summary</a></h2>
<ul>
<li>Using the Jupyter Notebook tool, we can edit, run, and contribute to each section of the book.</li>
<li>We can run Jupyter notebooks on remote servers using port forwarding.</li>
</ul>
<h2 id="exercises-155"><a class="header" href="#exercises-155">Exercises</a></h2>
<ol>
<li>Edit and run the code in this book with the Jupyter Notebook on your local machine.</li>
<li>Edit and run the code in this book with the Jupyter Notebook <em>remotely</em> via port forwarding.</li>
<li>Compare the running time of the operations $\mathbf{A}^\top \mathbf{B}$ and $\mathbf{A} \mathbf{B}$ for two square matrices in $\mathbb{R}^{1024 \times 1024}$. Which one is faster?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/421">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-amazon-sagemaker"><a class="header" href="#using-amazon-sagemaker">Using Amazon SageMaker</a></h1>
<p>:label:<code>sec_sagemaker</code></p>
<p>Deep learning applications
may demand so much computational resource
that easily goes beyond
what your local machine can offer.
Cloud computing services
allow you to
run GPU-intensive code of this book
more easily
using more powerful computers.
This section will introduce
how to use Amazon SageMaker
to run the code of this book.</p>
<h2 id="signing-up"><a class="header" href="#signing-up">Signing Up</a></h2>
<p>First, we need to sign up an account at https://aws.amazon.com/.
For additional security,
using two-factor authentication
is encouraged.
It is also a good idea to
set up detailed billing and spending alerts to
avoid any surprise,
e.g.,
when forgetting to stop running instances.
After logging into your AWS account,
go to your <a href="http://console.aws.amazon.com/">console</a> and search for "Amazon SageMaker" (see :numref:<code>fig_sagemaker</code>),
then click it to open the SageMaker panel.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker.png" alt="Search for and open the SageMaker panel." />
:width:<code>300px</code>
:label:<code>fig_sagemaker</code></p>
<h2 id="creating-a-sagemaker-instance"><a class="header" href="#creating-a-sagemaker-instance">Creating a SageMaker Instance</a></h2>
<p>Next, let's create a notebook instance as described in :numref:<code>fig_sagemaker-create</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-create.png" alt="Create a SageMaker instance." />
:width:<code>400px</code>
:label:<code>fig_sagemaker-create</code></p>
<p>SageMaker provides multiple <a href="https://aws.amazon.com/sagemaker/pricing/instance-types/">instance types</a> with varying computational power and prices.
When creating a notebook instance,
we can specify its name and type.
In :numref:<code>fig_sagemaker-create-2</code>, we choose <code>ml.p3.2xlarge</code>: with one Tesla V100 GPU and an 8-core CPU, this instance is powerful enough for most of the book.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-create-2.png" alt="Choose the instance type." />
:width:<code>400px</code>
:label:<code>fig_sagemaker-create-2</code></p>
<p>:begin_tab:<code>mxnet</code>
The entire book in the ipynb format for running with SageMaker is available at https://github.com/d2l-ai/d2l-en-sagemaker. We can specify this GitHub repository URL (:numref:<code>fig_sagemaker-create-3</code>) to allow SageMaker to clone it when creating the instance.
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
The entire book in the ipynb format for running with SageMaker is available at https://github.com/d2l-ai/d2l-pytorch-sagemaker. We can specify this GitHub repository URL (:numref:<code>fig_sagemaker-create-3</code>) to allow SageMaker to clone it when creating the instance.
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
The entire book in the ipynb format for running with SageMaker is available at https://github.com/d2l-ai/d2l-tensorflow-sagemaker. We can specify this GitHub repository URL (:numref:<code>fig_sagemaker-create-3</code>) to allow SageMaker to clone it when creating the instance.
:end_tab:</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-create-3.png" alt="Specify the GitHub repository." />
:width:<code>400px</code>
:label:<code>fig_sagemaker-create-3</code></p>
<h2 id="running-and-stopping-an-instance"><a class="header" href="#running-and-stopping-an-instance">Running and Stopping an Instance</a></h2>
<p>Creating an instance
may take a few minutes.
When it is ready,
click on the "Open Jupyter" link next to it (:numref:<code>fig_sagemaker-open</code>) so you can
edit and run all the Jupyter notebooks
of this book on this instance
(similar to steps in :numref:<code>sec_jupyter</code>).</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-open.png" alt="Open Jupyter on the created SageMaker instance." />
:width:<code>400px</code>
:label:<code>fig_sagemaker-open</code></p>
<p>After finishing your work,
do not forget to stop the instance to avoid
being charged further (:numref:<code>fig_sagemaker-stop</code>).</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-stop.png" alt="Stop a SageMaker instance." />
:width:<code>300px</code>
:label:<code>fig_sagemaker-stop</code></p>
<h2 id="updating-notebooks"><a class="header" href="#updating-notebooks">Updating Notebooks</a></h2>
<p>:begin_tab:<code>mxnet</code>
Notebooks of this open-source book will be regularly updated in the <a href="https://github.com/d2l-ai/d2l-en-sagemaker">d2l-ai/d2l-en-sagemaker</a> repository
on GitHub.
To update to the latest version,
you may open a terminal on the SageMaker instance (:numref:<code>fig_sagemaker-terminal</code>).
:end_tab:</p>
<p>:begin_tab:<code>pytorch</code>
Notebooks of this open-source book will be regularly updated in the <a href="https://github.com/d2l-ai/d2l-pytorch-sagemaker">d2l-ai/d2l-pytorch-sagemaker</a> repository
on GitHub.
To update to the latest version,
you may open a terminal on the SageMaker instance (:numref:<code>fig_sagemaker-terminal</code>).
:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code>
Notebooks of this open-source book will be regularly updated in the <a href="https://github.com/d2l-ai/d2l-tensorflow-sagemaker">d2l-ai/d2l-tensorflow-sagemaker</a> repository
on GitHub.
To update to the latest version,
you may open a terminal on the SageMaker instance (:numref:<code>fig_sagemaker-terminal</code>).
:end_tab:</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/sagemaker-terminal.png" alt="Open a terminal on the SageMaker instance." />
:width:<code>300px</code>
:label:<code>fig_sagemaker-terminal</code></p>
<p>You may wish to commit your local changes before pulling updates from the remote repository.
Otherwise, simply discard all your local changes
with the following commands in the terminal:</p>
<p>:begin_tab:<code>mxnet</code></p>
<pre><code class="language-bash">cd SageMaker/d2l-en-sagemaker/
git reset --hard
git pull
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>pytorch</code></p>
<pre><code class="language-bash">cd SageMaker/d2l-pytorch-sagemaker/
git reset --hard
git pull
</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code></p>
<pre><code class="language-bash">cd SageMaker/d2l-tensorflow-sagemaker/
git reset --hard
git pull
</code></pre>
<p>:end_tab:</p>
<h2 id="summary-138"><a class="header" href="#summary-138">Summary</a></h2>
<ul>
<li>We can create a notebook instance using Amazon SageMaker to run GPU-intensive code of this book.</li>
<li>We can update notebooks via the terminal on the Amazon SageMaker instance.</li>
</ul>
<h2 id="exercises-156"><a class="header" href="#exercises-156">Exercises</a></h2>
<ol>
<li>Edit and run any section that requires a GPU using Amazon SageMaker.</li>
<li>Open a terminal to access the local directory that hosts all the notebooks of this book.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/422">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-aws-ec2-instances"><a class="header" href="#using-aws-ec2-instances">Using AWS EC2 Instances</a></h1>
<p>:label:<code>sec_aws</code></p>
<p>In this section, we will show you how to install all libraries on a raw Linux machine. Recall that in :numref:<code>sec_sagemaker</code> we discussed how to use Amazon SageMaker, while building an instance by yourself costs less on AWS. The walkthrough includes three steps:</p>
<ol>
<li>Request for a GPU Linux instance from AWS EC2.</li>
<li>Install CUDA (or use an Amazon Machine Image with preinstalled CUDA).</li>
<li>Install the deep learning framework and other libraries for running the code of the book.</li>
</ol>
<p>This process applies to other instances (and other clouds), too, albeit with some minor modifications. Before going forward, you need to create an AWS account, see :numref:<code>sec_sagemaker</code> for more details.</p>
<h2 id="creating-and-running-an-ec2-instance"><a class="header" href="#creating-and-running-an-ec2-instance">Creating and Running an EC2 Instance</a></h2>
<p>After logging into your AWS account, click "EC2" (:numref:<code>fig_aws</code>) to go to the EC2 panel.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/aws.png" alt="Open the EC2 console." />
:width:<code>400px</code>
:label:<code>fig_aws</code></p>
<p>:numref:<code>fig_ec2</code> shows the EC2 panel.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/ec2.png" alt="The EC2 panel." />
:width:<code>700px</code>
:label:<code>fig_ec2</code></p>
<h3 id="presetting-location"><a class="header" href="#presetting-location">Presetting Location</a></h3>
<p>Select a nearby data center to reduce latency, e.g., "Oregon" (marked by the red box in the top-right of :numref:<code>fig_ec2</code>). If you are located in China,
you can select a nearby Asia Pacific region, such as Seoul or Tokyo. Please note
that some data centers may not have GPU instances.</p>
<h3 id="increasing-limits"><a class="header" href="#increasing-limits">Increasing Limits</a></h3>
<p>Before choosing an instance, check if there are quantity
restrictions by clicking the "Limits" label in the bar on the left as shown in
:numref:<code>fig_ec2</code>.
:numref:<code>fig_limits</code> shows an example of such a
limitation. The account currently cannot open "p2.xlarge" instances according to the region. If
you need to open one or more instances, click on the "Request limit increase" link to
apply for a higher instance quota.
Generally, it takes one business day to
process an application.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/limits.png" alt="Instance quantity restrictions." />
:width:<code>700px</code>
:label:<code>fig_limits</code></p>
<h3 id="launching-an-instance"><a class="header" href="#launching-an-instance">Launching an Instance</a></h3>
<p>Next, click the "Launch Instance" button marked by the red box in :numref:<code>fig_ec2</code> to launch your instance.</p>
<p>We begin by selecting a suitable Amazon Machine Image (AMI). Select an Ubuntu instance (:numref:<code>fig_ubuntu</code>).</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/ubuntu-new.png" alt="Choose an AMI." />
:width:<code>700px</code>
:label:<code>fig_ubuntu</code></p>
<p>EC2 provides many different instance configurations to choose from. This can sometimes feel overwhelming to a beginner. :numref:<code>tab_ec2</code> lists different suitable machines.</p>
<p>:Different EC2 instance types
:label:<code>tab_ec2</code></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>GPU</th><th>Notes</th></tr></thead><tbody>
<tr><td>g2</td><td>Grid K520</td><td>ancient</td></tr>
<tr><td>p2</td><td>Kepler K80</td><td>old but often cheap as spot</td></tr>
<tr><td>g3</td><td>Maxwell M60</td><td>good trade-off</td></tr>
<tr><td>p3</td><td>Volta V100</td><td>high performance for FP16</td></tr>
<tr><td>p4</td><td>Ampere A100</td><td>high performance for large-scale training</td></tr>
<tr><td>g4</td><td>Turing T4</td><td>inference optimized FP16/INT8</td></tr>
</tbody></table>
</div>
<p>All these servers come in multiple flavors indicating the number of GPUs used. For example, a p2.xlarge has 1 GPU and a p2.16xlarge has 16 GPUs and more memory. For more details, see the <a href="https://aws.amazon.com/ec2/instance-types/">AWS EC2 documentation</a> or a <a href="https://www.ec2instances.info">summary page</a>. For the purpose of illustration, a p2.xlarge will suffice (marked in the red box of :numref:<code>fig_p2x</code>).</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/p2x.png" alt="Choose an instance." />
:width:<code>700px</code>
:label:<code>fig_p2x</code></p>
<p>Note that you should use a GPU-enabled instance with suitable drivers and a GPU-enabled deep learning framework. Otherwise you will not see any benefit from using GPUs.</p>
<p>We go on to select the key pair used to access
the instance. If you do not have a key pair, click "Create new key pair" in :numref:<code>fig_keypair</code> to generate a key pair. Subsequently,
you can select the
previously generated key pair.
Make sure that you download the key pair and store it in a safe location if you
generated a new one. This is your only way to SSH into the server.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/keypair.png" alt="Select a key pair." />
:width:<code>500px</code>
:label:<code>fig_keypair</code></p>
<p>In this example, we will keep the default configurations for "Network settings" (click the "Edit" button to configure items such as the subnet and security groups). We just increase the default hard disk size to 64 GB (:numref:<code>fig_disk</code>). Note that CUDA by itself already takes up 4 GB.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/disk.png" alt="Modify the hard disk size." />
:width:<code>700px</code>
:label:<code>fig_disk</code></p>
<p>Click "Launch Instance" to launch the created
instance. Click the
instance ID shown in :numref:<code>fig_launching</code> to view the status of this instance.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/launching.png" alt="Click the instance ID." />
:width:<code>700px</code>
:label:<code>fig_launching</code></p>
<h3 id="connecting-to-the-instance"><a class="header" href="#connecting-to-the-instance">Connecting to the Instance</a></h3>
<p>As shown in :numref:<code>fig_connect</code>, after the instance state turns green, right-click the instance and select <code>Connect</code> to view the instance access method.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/connect.png" alt="View the instance access method." />
:width:<code>700px</code>
:label:<code>fig_connect</code></p>
<p>If this is a new key, it must not be publicly viewable for SSH to work. Go to the folder where you store <code>D2L_key.pem</code> and
execute the following command
to make the key not publicly viewable:</p>
<pre><code class="language-bash">chmod 400 D2L_key.pem
</code></pre>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/chmod.png" alt="View instance access and startup method." />
:width:<code>400px</code>
:label:<code>fig_chmod</code></p>
<p>Now, copy the SSH command in the lower red box of :numref:<code>fig_chmod</code> and paste onto the command line:</p>
<pre><code class="language-bash">ssh -i "D2L_key.pem" ubuntu@ec2-xx-xxx-xxx-xxx.y.compute.amazonaws.com
</code></pre>
<p>When the command line prompts "Are you sure you want to continue connecting (yes/no)", enter "yes" and press Enter to log into the instance.</p>
<p>Your server is ready now.</p>
<h2 id="installing-cuda"><a class="header" href="#installing-cuda">Installing CUDA</a></h2>
<p>Before installing CUDA, be sure to update the instance with the latest drivers.</p>
<pre><code class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential git libgfortran3
</code></pre>
<p>Here we download CUDA 12.1. Visit NVIDIA's <a href="https://developer.nvidia.com/cuda-toolkit-archive">official repository</a> to find the download link as shown in :numref:<code>fig_cuda</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/cuda121.png" alt="Find the CUDA 12.1 download address." />
:width:<code>500px</code>
:label:<code>fig_cuda</code></p>
<p>Copy the instructions and paste them onto the terminal to install CUDA 12.1.</p>
<pre><code class="language-bash"># The link and file name are subject to changes
wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin
sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600
wget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_installers/cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb
sudo dpkg -i cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb
sudo cp /var/cuda-repo-ubuntu2204-12-1-local/cuda-*-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get -y install cuda
</code></pre>
<p>After installing the program, run the following command to view the GPUs:</p>
<pre><code class="language-bash">nvidia-smi
</code></pre>
<p>Finally, add CUDA to the library path to help other libraries find it, such as appending the following lines to the end of <code>~/.bashrc</code>.</p>
<pre><code class="language-bash">export PATH="/usr/local/cuda-12.1/bin:$PATH"
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/usr/local/cuda-12.1/lib64
</code></pre>
<h2 id="installing-libraries-for-running-the-code"><a class="header" href="#installing-libraries-for-running-the-code">Installing Libraries for Running the Code</a></h2>
<p>To run the code of this book,
just follow steps in :ref:<code>chap_installation</code>
for Linux users on the EC2 instance
and use the following tips
for working on a remote Linux server:</p>
<ul>
<li>To download the bash script on the Miniconda installation page, right click the download link and select "Copy Link Address", then execute <code>wget [copied link address]</code>.</li>
<li>After running <code>~/miniconda3/bin/conda init</code>, you may execute <code>source ~/.bashrc</code> instead of closing and reopening your current shell.</li>
</ul>
<h2 id="running-the-jupyter-notebook-remotely"><a class="header" href="#running-the-jupyter-notebook-remotely">Running the Jupyter Notebook remotely</a></h2>
<p>To run the Jupyter Notebook remotely you need to use SSH port forwarding. After all, the server in the cloud does not have a monitor or keyboard. For this, log into your server from your desktop (or laptop) as follows:</p>
<pre><code># This command must be run in the local command line
ssh -i "/path/to/key.pem" ubuntu@ec2-xx-xxx-xxx-xxx.y.compute.amazonaws.com -L 8889:localhost:8888
</code></pre>
<p>Next, go to the location
of the downloaded code of this book
on the EC2 instance,
then run:</p>
<pre><code>conda activate d2l
jupyter notebook
</code></pre>
<p>:numref:<code>fig_jupyter</code> shows the possible output after you run the Jupyter Notebook. The last row is the URL for port 8888.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/jupyter.png" alt="Output after running the Jupyter Notebook. The last row is the URL for port 8888." />
:width:<code>700px</code>
:label:<code>fig_jupyter</code></p>
<p>Since you used port forwarding to port 8889,
copy the last row in the red box of :numref:<code>fig_jupyter</code>,
replace "8888" with "8889" in the URL,
and open it in your local browser.</p>
<h2 id="closing-unused-instances"><a class="header" href="#closing-unused-instances">Closing Unused Instances</a></h2>
<p>As cloud services are billed by the time of use, you should close instances that are not being used. Note that there are alternatives:</p>
<ul>
<li>"Stopping" an instance means that you will be able to start it again. This is akin to switching off the power for your regular server. However, stopped instances will still be billed a small amount for the hard disk space retained.</li>
<li>"Terminating" an instance will delete all data associated with it. This includes the disk, hence you cannot start it again. Only do this if you know that you will not need it in the future.</li>
</ul>
<p>If you want to use the instance as a template for many more instances,
right-click on the example in :numref:<code>fig_connect</code> and select "Image" $\rightarrow$
"Create" to create an image of the instance. Once this is complete, select
"Instance State" $\rightarrow$ "Terminate" to terminate the instance. The next
time you want to use this instance, you can follow the steps in this section
to create an instance based on
the saved image. The only difference is that, in "1. Choose AMI" shown in
:numref:<code>fig_ubuntu</code>, you must use the "My AMIs" option on the left to select your saved
image. The created instance will retain the information stored on the image hard
disk. For example, you will not have to reinstall CUDA and other runtime
environments.</p>
<h2 id="summary-139"><a class="header" href="#summary-139">Summary</a></h2>
<ul>
<li>We can launch and stop instances on demand without having to buy and build our own computer.</li>
<li>We need to install CUDA before using the GPU-enabled deep learning framework.</li>
<li>We can use port forwarding to run the Jupyter Notebook on a remote server.</li>
</ul>
<h2 id="exercises-157"><a class="header" href="#exercises-157">Exercises</a></h2>
<ol>
<li>The cloud offers convenience, but it does not come cheap. Find out how to launch <a href="https://aws.amazon.com/ec2/spot/">spot instances</a> to see how to reduce costs.</li>
<li>Experiment with different GPU servers. How fast are they?</li>
<li>Experiment with multi-GPU servers. How well can you scale things up?</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/423">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-google-colab"><a class="header" href="#using-google-colab">Using Google Colab</a></h1>
<p>:label:<code>sec_colab</code></p>
<p>We introduced how to run this book on AWS in :numref:<code>sec_sagemaker</code> and :numref:<code>sec_aws</code>. Another option is running this book on <a href="https://colab.research.google.com/">Google Colab</a>
if you have a Google account.</p>
<p>To run the code of a section on Colab, simply click the <code>Colab</code> button as shown in :numref:<code>fig_colab</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/colab.png" alt="Run the code of a section on Colab." />
:width:<code>300px</code>
:label:<code>fig_colab</code></p>
<p>If it is your first time to run a code cell,
you will receive a warning message as shown in :numref:<code>fig_colab2</code>.
Just click "RUN ANYWAY" to ignore it.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/colab-2.png" alt="Ignore the warning message by clicking &quot;RUN ANYWAY&quot;." />
:width:<code>300px</code>
:label:<code>fig_colab2</code></p>
<p>Next, Colab will connect you to an instance to run the code of this section.
Specifically, if a GPU is needed,
Colab will be automatically requested
for connecting to a GPU instance.</p>
<h2 id="summary-140"><a class="header" href="#summary-140">Summary</a></h2>
<ul>
<li>You can use Google Colab to run each section's code in this book.</li>
<li>Colab will be requested to connect to a GPU instance if a GPU is needed in any section of this book.</li>
</ul>
<h2 id="exercises-158"><a class="header" href="#exercises-158">Exercises</a></h2>
<ol>
<li>Open any section of this book using Google Colab.</li>
<li>Edit and run any section that requires a GPU using Google Colab.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/424">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting-servers-and-gpus"><a class="header" href="#selecting-servers-and-gpus">Selecting Servers and GPUs</a></h1>
<p>:label:<code>sec_buy_gpu</code></p>
<p>Deep learning training generally requires large amounts of computation. At present GPUs are the most cost-effective hardware accelerators for deep learning. In particular, compared with CPUs, GPUs are cheaper and offer higher performance, often by over an order of magnitude. Furthermore, a single server can support multiple GPUs, up to 8 for high end servers. More typical numbers are up to 4 GPUs for an engineering workstation, since heat, cooling, and power requirements escalate quickly beyond what an office building can support. For larger deployments, cloud computing (e.g., Amazon's <a href="https://aws.amazon.com/ec2/instance-types/p3/">P3</a> and <a href="https://aws.amazon.com/blogs/aws/in-the-works-ec2-instances-g4-with-nvidia-t4-gpus/">G4</a> instances) is a much more practical solution.</p>
<h2 id="selecting-servers"><a class="header" href="#selecting-servers">Selecting Servers</a></h2>
<p>There is typically no need to purchase high-end CPUs with many threads since much of the computation occurs on the GPUs. That said, due to the global interpreter lock (GIL) in Python single-thread performance of a CPU can matter in situations where we have 4--8 GPUs. All things equal this suggests that CPUs with a smaller number of cores but a higher clock frequency might be a more economical choice. For example, when choosing between a 6-core 4 GHz and an 8-core 3.5 GHz CPU, the former is much preferable, even though its aggregate speed is less.
An important consideration is that GPUs use lots of power and thus dissipate lots of heat. This requires very good cooling and a large enough chassis to use the GPUs. Follow the guidelines below if possible:</p>
<ol>
<li><strong>Power Supply</strong>. GPUs use significant amounts of power. Budget with up to 350W per device (check for the <em>peak demand</em> of the graphics card rather than typical demand, since efficient code can use lots of energy). If your power supply is not up to the demand you will find that your system becomes unstable.</li>
<li><strong>Chassis Size</strong>. GPUs are large and the auxiliary power connectors often need extra space. Also, large chassis are easier to cool.</li>
<li><strong>GPU Cooling</strong>. If you have a large number of GPUs you might want to invest in water cooling. Also, aim for <em>reference designs</em> even if they have fewer fans, since they are thin enough to allow for air intake between the devices. If you buy a multi-fan GPU it might be too thick to get enough air when installing multiple GPUs and you will run into thermal throttling.</li>
<li><strong>PCIe Slots</strong>. Moving data to and from the GPU (and exchanging it between GPUs) requires lots of bandwidth. We recommend PCIe 3.0 slots with 16 lanes. If you mount multiple GPUs, be sure to carefully read the motherboard description to ensure that 16$\times$ bandwidth is still available when multiple GPUs are used at the same time and that you are getting PCIe 3.0 as opposed to PCIe 2.0 for the additional slots. Some motherboards downgrade to 8$\times$ or even 4$\times$ bandwidth with multiple GPUs installed. This is partly due to the number of PCIe lanes that the CPU offers.</li>
</ol>
<p>In short, here are some recommendations for building a deep learning server:</p>
<ul>
<li><strong>Beginner</strong>. Buy a low end GPU with low power consumption (cheap gaming GPUs suitable for deep learning use 150--200W). If you are lucky your current computer supports it.</li>
<li><strong>1 GPU</strong>. A low-end CPU with 4 cores will be sufficient and most motherboards suffice. Aim for at least 32 GB DRAM and invest into an SSD for local data access. A power supply with 600W should be sufficient. Buy a GPU with lots of fans.</li>
<li><strong>2 GPUs</strong>. A low-end CPU with 4-6 cores will suffice. Aim for 64 GB DRAM and invest into an SSD. You will need in the order of 1000W for two high-end GPUs. In terms of mainboards, make sure that they have <em>two</em> PCIe 3.0 x16 slots. If you can, get a mainboard that has two free spaces (60mm spacing) between the PCIe 3.0 x16 slots for extra air. In this case, buy two GPUs with lots of fans.</li>
<li><strong>4 GPUs</strong>. Make sure that you buy a CPU with relatively fast single-thread speed (i.e., high clock frequency). You will probably need a CPU with a larger number of PCIe lanes, such as an AMD Threadripper. You will likely need relatively expensive mainboards to get 4 PCIe 3.0 x16 slots since they probably need a PLX to multiplex the PCIe lanes. Buy GPUs with reference design that are narrow and let air in between the GPUs. You need a 1600--2000W power supply and the outlet in your office might not support that. This server will probably run <em>loud and hot</em>. You do not want it under your desk. 128 GB of DRAM is recommended. Get an SSD (1--2 TB NVMe) for local storage and a bunch of hard disks in RAID configuration to store your data.</li>
<li><strong>8 GPUs</strong>. You need to buy a dedicated multi-GPU server chassis with multiple redundant power supplies (e.g., 2+1 for 1600W per power supply). This will require dual socket server CPUs, 256 GB ECC DRAM, a fast network card (10 GBE recommended), and you will need to check whether the servers support the <em>physical form factor</em> of the GPUs. Airflow and wiring placement differ significantly between consumer and server GPUs (e.g., RTX 2080 vs. Tesla V100). This means that you might not be able to install the consumer GPU in a server due to insufficient clearance for the power cable or lack of a suitable wiring harness (as one of the coauthors painfully discovered).</li>
</ul>
<h2 id="selecting-gpus"><a class="header" href="#selecting-gpus">Selecting GPUs</a></h2>
<p>At present, AMD and NVIDIA are the two main manufacturers of dedicated GPUs. NVIDIA was the first to enter the deep learning field and provides better support for deep learning frameworks via CUDA. Therefore, most buyers choose NVIDIA GPUs.</p>
<p>NVIDIA provides two types of GPUs, targeting individual users (e.g., via the GTX and RTX series) and enterprise users (via its Tesla series). The two types of GPUs provide comparable compute power. However, the enterprise user GPUs generally use (passive) forced cooling, more memory, and ECC (error correcting) memory. These GPUs are more suitable for data centers and usually cost ten times more than consumer GPUs.</p>
<p>If you are a large company with 100+ servers you should consider the NVIDIA Tesla series or alternatively use GPU servers in the cloud. For a lab or a small to medium company with 10+ servers the NVIDIA RTX series is likely most cost effective. You can buy preconfigured servers with Supermicro or Asus chassis that hold 4--8 GPUs efficiently.</p>
<p>GPU vendors typically release a new generation every one to two years, such as the GTX 1000 (Pascal) series released in 2017 and the RTX 2000 (Turing) series released in 2019. Each series offers several different models that provide different performance levels. GPU performance is primarily a combination of the following three parameters:</p>
<ol>
<li><strong>Compute Power</strong>. Generally we look for 32-bit floating-point compute power. 16-bit floating point training (FP16) is also entering the mainstream. If you are only interested in prediction, you can also use 8-bit integer. The latest generation of Turing GPUs offers 4-bit acceleration. Unfortunately at the time of writing the algorithms for training low-precision networks are not yet widespread.</li>
<li><strong>Memory Size</strong>. As your models become larger or the batches used during training grow bigger, you will need more GPU memory. Check for HBM2 (High Bandwidth Memory) vs. GDDR6 (Graphics DDR) memory. HBM2 is faster but much more expensive.</li>
<li><strong>Memory Bandwidth</strong>. You can only get the most out of your compute power when you have sufficient memory bandwidth. Look for wide memory buses if using GDDR6.</li>
</ol>
<p>For most users, it is enough to look at compute power. Note that many GPUs offer different types of acceleration. For example, NVIDIA's TensorCores accelerate a subset of operators by 5$\times$. Ensure that your libraries support this. The GPU memory should be no less than 4 GB (8 GB is much better). Try to avoid using the GPU also for displaying a GUI (use the built-in graphics instead). If you cannot avoid it, add an extra 2 GB of RAM for safety.</p>
<p>:numref:<code>fig_flopsvsprice</code> compares the 32-bit floating-point compute power and price of the various GTX 900, GTX 1000 and RTX 2000 series models. The prices suggested are those found on Wikipedia at the time of writing.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/flopsvsprice.svg" alt="Floating-point compute power and price comparison. " />
:label:<code>fig_flopsvsprice</code></p>
<p>We can see a number of things:</p>
<ol>
<li>Within each series, price and performance are roughly proportional. Titan models command a significant premium for the benefit of larger amounts of GPU memory. However, the newer models offer better cost effectiveness, as can be seen by comparing the 980 Ti and 1080 Ti. The price does not appear to improve much for the RTX 2000 series. However, this is due to the fact that they offer far superior low precision performance (FP16, INT8, and INT4).</li>
<li>The performance-to-cost ratio of the GTX 1000 series is about two times greater than the 900 series.</li>
<li>For the RTX 2000 series the performance (in GFLOPs) is an <em>affine</em> function of the price.</li>
</ol>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/wattvsprice.svg" alt="Floating-point compute power and energy consumption. " />
:label:<code>fig_wattvsprice</code></p>
<p>:numref:<code>fig_wattvsprice</code> shows how energy consumption scales mostly linearly with the amount of computation. Second, later generations are more efficient. This seems to be contradicted by the graph corresponding to the RTX 2000 series. However, this is a consequence of the TensorCores that draw disproportionately much energy.</p>
<h2 id="summary-141"><a class="header" href="#summary-141">Summary</a></h2>
<ul>
<li>Watch out for power, PCIe bus lanes, CPU single thread speed, and cooling when building a server.</li>
<li>You should purchase the latest GPU generation if possible.</li>
<li>Use the cloud for large deployments.</li>
<li>High density servers may not be compatible with all GPUs. Check the mechanical and cooling specifications before you buy.</li>
<li>Use FP16 or lower precision for high efficiency.</li>
</ul>
<p><a href="https://discuss.d2l.ai/t/425">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-this-book"><a class="header" href="#contributing-to-this-book">Contributing to This Book</a></h1>
<p>:label:<code>sec_how_to_contribute</code></p>
<p>Contributions by <a href="https://github.com/d2l-ai/d2l-en/graphs/contributors">readers</a> help us improve this book. If you find a typo, an outdated link, something where you think we missed a citation, where the code does not look elegant or where an explanation is unclear, please contribute back and help us help our readers. While in regular books the delay between print runs (and thus between typo corrections) can be measured in years, it typically takes hours to days to incorporate an improvement in this book. This is all possible due to version control and continuous integration (CI) testing. To do so you need to submit a <a href="https://github.com/d2l-ai/d2l-en/pulls">pull request</a> to the GitHub repository. When your pull request is merged into the code repository by the authors, you will become a contributor.</p>
<h2 id="submitting-minor-changes"><a class="header" href="#submitting-minor-changes">Submitting Minor Changes</a></h2>
<p>The most common contributions are editing one sentence or fixing typos. We recommend that you find the source file in the <a href="https://github.com/d2l-ai/d2l-en">GitHub repository</a> and edit the file directly. For example, you can search the file through the <a href="https://github.com/d2l-ai/d2l-en/find/master">Find file</a> button (:numref:<code>fig_edit_file</code>) to locate the source file (a markdown file). Then you click the "Edit this file" button on the upper-right corner to make your changes in the markdown file.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/edit-file.png" alt="Edit the file on Github." />
:width:<code>300px</code>
:label:<code>fig_edit_file</code></p>
<p>After you are done, fill in your change descriptions in the "Propose file change" panel on the page bottom and then click the "Propose file change" button. It will redirect you to a new page to review your changes (:numref:<code>fig_git_createpr</code>). If everything is good, you can submit a pull request by clicking the "Create pull request" button.</p>
<h2 id="proposing-major-changes"><a class="header" href="#proposing-major-changes">Proposing Major Changes</a></h2>
<p>If you plan to update a large portion of text or code, then you need to know a little bit more about the format this book is using. The source file is based on the <a href="https://daringfireball.net/projects/markdown/syntax">markdown format</a> with a set of extensions through the <a href="http://book.d2l.ai/user/markdown.html">D2L-Book</a> package such as referring to equations, images, chapters, and citations. You can use any markdown editors to open these files and make your changes.</p>
<p>If you would like to change the code, we recommend that you use the Jupyter Notebook to open these markdown files as described in :numref:<code>sec_jupyter</code>, so that you can run and test your changes. Please remember to clear all outputs before submitting your changes since our CI system will execute the sections you updated to generate outputs.</p>
<p>Some sections may support multiple framework implementations.
If you add a new code block, please use <code>%%tab</code> to mark this block on the beginning line. For example,
<code>%%tab pytorch</code> for a PyTorch code block, <code>%%tab tensorflow</code> for a TensorFlow code block, or <code>%%tab all</code> a shared code block for all implementations. You may refer to the <code>d2lbook</code> package for more information.</p>
<h2 id="submitting-major-changes"><a class="header" href="#submitting-major-changes">Submitting Major Changes</a></h2>
<p>We suggest you to use the standard Git process to submit a major change. In a nutshell the process works as described in :numref:<code>fig_contribute</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/contribute.svg" alt="Contributing to the book." />
:label:<code>fig_contribute</code></p>
<p>We will walk you through the steps in detail. If you are already familiar with Git you can skip this section. For concreteness we assume that the contributor's user name is "astonzhang".</p>
<h3 id="installing-git"><a class="header" href="#installing-git">Installing Git</a></h3>
<p>The Git open-source book describes <a href="https://git-scm.com/book/en/v2">how to install Git</a>. This typically works via <code>apt install git</code> on Ubuntu Linux, by installing the Xcode developer tools on macOS, or by using GitHub's <a href="https://desktop.github.com">desktop client</a>. If you do not have a GitHub account, you need to sign up for one.</p>
<h3 id="logging-in-to-github"><a class="header" href="#logging-in-to-github">Logging in to GitHub</a></h3>
<p>Enter the <a href="https://github.com/d2l-ai/d2l-en/">address</a> of the book's code repository in your browser. Click on the <code>Fork</code> button in the red box at the upper-right of :numref:<code>fig_git_fork</code>, to make a copy of the repository of this book. This is now <em>your copy</em> and you can change it any way you want.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/git-fork.png" alt="The code repository page." />
:width:<code>700px</code>
:label:<code>fig_git_fork</code></p>
<p>Now, the code repository of this book will be forked (i.e., copied) to your username, such as <code>astonzhang/d2l-en</code> shown at the upper-left of :numref:<code>fig_git_forked</code>.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/git-forked.png" alt="The forked code repository." />
:width:<code>700px</code>
:label:<code>fig_git_forked</code></p>
<h3 id="cloning-the-repository"><a class="header" href="#cloning-the-repository">Cloning the Repository</a></h3>
<p>To clone the repository (i.e., to make a local copy) we need to get its repository address. The green button in :numref:<code>fig_git_clone</code> displays this. Make sure that your local copy is up to date with the main repository if you decide to keep this fork around for longer. For now simply follow the instructions in :ref:<code>chap_installation</code> to get started. The main difference is that you are now downloading <em>your own fork</em> of the repository.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/git-clone.png" alt="Cloning the repository." />
:width:<code>700px</code>
:label:<code>fig_git_clone</code></p>
<pre><code># Replace your_github_username with your GitHub username
git clone https://github.com/your_github_username/d2l-en.git
</code></pre>
<h3 id="editing-and-pushing"><a class="header" href="#editing-and-pushing">Editing and Pushing</a></h3>
<p>Now it is time to edit the book. It is best to edit it in the Jupyter Notebook following instructions in :numref:<code>sec_jupyter</code>. Make the changes and check that they are OK. Assume that we have modified a typo in the file <code>~/d2l-en/chapter_appendix-tools-for-deep-learning/contributing.md</code>.
You can then check which files you have changed.</p>
<p>At this point Git will prompt that the <code>chapter_appendix-tools-for-deep-learning/contributing.md</code> file has been modified.</p>
<pre><code>mylaptop:d2l-en me$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   chapter_appendix-tools-for-deep-learning/contributing.md
</code></pre>
<p>After confirming that this is what you want, execute the following command:</p>
<pre><code>git add chapter_appendix-tools-for-deep-learning/contributing.md
git commit -m 'Fix a typo in git documentation'
git push
</code></pre>
<p>The changed code will then be in your personal fork of the repository. To request the addition of your change, you have to create a pull request for the official repository of the book.</p>
<h3 id="submitting-pull-requests"><a class="header" href="#submitting-pull-requests">Submitting Pull Requests</a></h3>
<p>As shown in :numref:<code>fig_git_newpr</code>, go to your fork of the repository on GitHub and select "New pull request". This will open up a screen that shows you the changes between your edits and what is current in the main repository of the book.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/git-newpr.png" alt="New pull request." />
:width:<code>700px</code>
:label:<code>fig_git_newpr</code></p>
<p>Finally, submit a pull request by clicking the button as shown in :numref:<code>fig_git_createpr</code>. Make sure to describe the changes you have made in the pull request.
This will make it easier for the authors to review it and to merge it with the book. Depending on the changes, this might get accepted right away, rejected, or more likely, you will get some feedback on the changes. Once you have incorporated them, you are good to go.</p>
<p><img src="chapter_appendix-tools-for-deep-learning/../img/git-createpr.png" alt="Create pull request." />
:width:<code>700px</code>
:label:<code>fig_git_createpr</code></p>
<h2 id="summary-142"><a class="header" href="#summary-142">Summary</a></h2>
<ul>
<li>You can use GitHub to contribute to this book.</li>
<li>You can edit the file on GitHub directly for minor changes.</li>
<li>For a major change, please fork the repository, edit things locally, and only contribute back once you are ready.</li>
<li>Pull requests are how contributions are being bundled up. Try not to submit huge pull requests since this makes them hard to understand and incorporate. Better send several smaller ones.</li>
</ul>
<h2 id="exercises-159"><a class="header" href="#exercises-159">Exercises</a></h2>
<ol>
<li>Star and fork the <code>d2l-ai/d2l-en</code> repository.</li>
<li>If you spot anything that needs improvement (e.g., missing a reference), submit a pull request.</li>
<li>It is usually a better practice to create a pull request using a new branch. Learn how to do it with <a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">Git branching</a>.</li>
</ol>
<p><a href="https://discuss.d2l.ai/t/426">Discussions</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-{.python .input}">%load_ext d2lbook.tab
tab.interact_select(['mxnet', 'pytorch', 'tensorflow', 'jax'])
</code></pre>
<h1 id="utility-functions-and-classes"><a class="header" href="#utility-functions-and-classes">Utility Functions and Classes</a></h1>
<p>:label:<code>sec_utils</code></p>
<p>This section contains the implementations of utility functions and classes used in this book.</p>
<pre><code class="language-{.python .input}">%%tab mxnet
import inspect
import collections
from d2l import mxnet as d2l
from IPython import display
from mxnet import autograd, gluon, np, npx
from mxnet.gluon import nn
import random
npx.set_np()
</code></pre>
<pre><code class="language-{.python .input  n=1}">%%tab pytorch
import inspect
import collections
from d2l import torch as d2l
from IPython import display
from torch import nn
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
import inspect
from IPython import display
import collections
from d2l import tensorflow as d2l
import tensorflow as tf
</code></pre>
<pre><code class="language-{.python .input}">%%tab jax
import inspect
from IPython import display
import collections
from d2l import jax as d2l
import jax
</code></pre>
<p>Hyperparameters.</p>
<pre><code class="language-{.python .input}">%%tab all
@d2l.add_to_class(d2l.HyperParameters)  #@save
def save_hyperparameters(self, ignore=[]):
    """Save function arguments into class attributes."""
    frame = inspect.currentframe().f_back
    _, _, _, local_vars = inspect.getargvalues(frame)
    self.hparams = {k:v for k, v in local_vars.items()
                    if k not in set(ignore+['self']) and not k.startswith('_')}
    for k, v in self.hparams.items():
        setattr(self, k, v)
</code></pre>
<p>Progress bar.</p>
<pre><code class="language-{.python .input  n=22}">%%tab all
@d2l.add_to_class(d2l.ProgressBoard)  #@save
def draw(self, x, y, label, every_n=1):
    Point = collections.namedtuple('Point', ['x', 'y'])
    if not hasattr(self, 'raw_points'):
        self.raw_points = collections.OrderedDict()
        self.data = collections.OrderedDict()
    if label not in self.raw_points:
        self.raw_points[label] = []
        self.data[label] = []    
    points = self.raw_points[label]
    line = self.data[label]
    points.append(Point(x, y))
    if len(points) != every_n:
        return    
    mean = lambda x: sum(x) / len(x)
    line.append(Point(mean([p.x for p in points]), 
                      mean([p.y for p in points])))
    points.clear()
    if not self.display: 
        return
    d2l.use_svg_display()
    if self.fig is None:
        self.fig = d2l.plt.figure(figsize=self.figsize)
    plt_lines, labels = [], []
    for (k, v), ls, color in zip(self.data.items(), self.ls, self.colors):        
        plt_lines.append(d2l.plt.plot([p.x for p in v], [p.y for p in v], 
                                      linestyle=ls, color=color)[0])
        labels.append(k)        
    axes = self.axes if self.axes else d2l.plt.gca()
    if self.xlim: axes.set_xlim(self.xlim)
    if self.ylim: axes.set_ylim(self.ylim)
    if not self.xlabel: self.xlabel = self.x    
    axes.set_xlabel(self.xlabel)
    axes.set_ylabel(self.ylabel)
    axes.set_xscale(self.xscale)
    axes.set_yscale(self.yscale)
    axes.legend(plt_lines, labels)    
    display.display(self.fig)
    display.clear_output(wait=True)
</code></pre>
<p>Add FrozenLake enviroment</p>
<pre><code class="language-{.python .input}">%%tab pytorch

def frozen_lake(seed): #@save
    # See https://www.gymlibrary.dev/environments/toy_text/frozen_lake/ to learn more about this env
    # How to process env.P.items is adpated from https://sites.google.com/view/deep-rl-bootcamp/labs
    import gym

    env = gym.make('FrozenLake-v1', is_slippery=False)
    env.seed(seed)
    env.action_space.np_random.seed(seed)
    env.action_space.seed(seed)
    env_info = {}
    env_info['desc'] = env.desc  # 2D array specifying what each grid item means
    env_info['num_states'] = env.nS  # Number of observations/states or obs/state dim
    env_info['num_actions'] = env.nA  # Number of actions or action dim
    # Define indices for (transition probability, nextstate, reward, done) tuple
    env_info['trans_prob_idx'] = 0  # Index of transition probability entry
    env_info['nextstate_idx'] = 1  # Index of next state entry
    env_info['reward_idx'] = 2  # Index of reward entry
    env_info['done_idx'] = 3  # Index of done entry
    env_info['mdp'] = {}
    env_info['env'] = env

    for (s, others) in env.P.items():
        # others(s) = {a0: [ (p(s'|s,a0), s', reward, done),...], a1:[...], ...}

        for (a, pxrds) in others.items():
            # pxrds is [(p1,next1,r1,d1),(p2,next2,r2,d2),..].
            # e.g. [(0.3, 0, 0, False), (0.3, 0, 0, False), (0.3, 4, 1, False)]
            env_info['mdp'][(s,a)] = pxrds

    return env_info

</code></pre>
<p>Create enviroment</p>
<pre><code class="language-{.python .input}">%%tab pytorch

def make_env(name ='', seed=0): #@save
    # Input parameters:
    # name: specifies a gym environment.
    # For Value iteration, only FrozenLake-v1 is supported.
    if name == 'FrozenLake-v1':
        return frozen_lake(seed)

    else:
        raise ValueError("%s env is not supported in this Notebook")

</code></pre>
<p>Show value function</p>
<pre><code class="language-{.python .input}">%%tab pytorch

def show_value_function_progress(env_desc, V, pi): #@save
    # This function visualizes how value and policy changes over time.
    # V: [num_iters, num_states]
    # pi: [num_iters, num_states]
    # How to visualize value function is adapted (but changed) from: https://sites.google.com/view/deep-rl-bootcamp/labs

    num_iters = V.shape[0]
    fig, ax  = plt.subplots(figsize=(15, 15))

    for k in range(V.shape[0]):
        plt.subplot(4, 4, k + 1)
        plt.imshow(V[k].reshape(4,4), cmap="bone")
        ax = plt.gca()
        ax.set_xticks(np.arange(0, 5)-.5, minor=True)
        ax.set_yticks(np.arange(0, 5)-.5, minor=True)
        ax.grid(which="minor", color="w", linestyle='-', linewidth=3)
        ax.tick_params(which="minor", bottom=False, left=False)
        ax.set_xticks([])
        ax.set_yticks([])

        # LEFT action: 0, DOWN action: 1
        # RIGHT action: 2, UP action: 3
        action2dxdy = {0:(-.25, 0),1: (0, .25),
                       2:(0.25, 0),3: (-.25, 0)}

        for y in range(4):
            for x in range(4):
                action = pi[k].reshape(4,4)[y, x]
                dx, dy = action2dxdy[action]

                if env_desc[y,x].decode() == 'H':
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="y",
                         size=20, fontweight='bold')

                elif env_desc[y,x].decode() == 'G':
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="w",
                         size=20, fontweight='bold')

                else:
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="g",
                         size=15, fontweight='bold')

                # No arrow for cells with G and H labels
                if env_desc[y,x].decode() != 'G' and env_desc[y,x].decode() != 'H':
                    ax.arrow(x, y, dx, dy, color='r', head_width=0.2, head_length=0.15)

        ax.set_title("Step = "  + str(k + 1), fontsize=20)

    fig.tight_layout()
    plt.show()

</code></pre>
<p>Show Q function</p>
<pre><code class="language-{.python .input}">%%tab pytorch

def show_Q_function_progress(env_desc, V_all, pi_all): #@save
    # This function visualizes how value and policy changes over time.
    # V: [num_iters, num_states]
    # pi: [num_iters, num_states]

    # We want to only shows few values
    num_iters_all = V_all.shape[0]
    num_iters = num_iters_all // 10

    vis_indx = np.arange(0, num_iters_all, num_iters).tolist()
    vis_indx.append(num_iters_all - 1)
    V = np.zeros((len(vis_indx), V_all.shape[1]))
    pi = np.zeros((len(vis_indx), V_all.shape[1]))

    for c, i in enumerate(vis_indx):
        V[c]  = V_all[i]
        pi[c] = pi_all[i]

    num_iters = V.shape[0]
    fig, ax = plt.subplots(figsize=(15, 15))

    for k in range(V.shape[0]):
        plt.subplot(4, 4, k + 1)
        plt.imshow(V[k].reshape(4,4), cmap="bone")
        ax = plt.gca()
        ax.set_xticks(np.arange(0, 5)-.5, minor=True)
        ax.set_yticks(np.arange(0, 5)-.5, minor=True)
        ax.grid(which="minor", color="w", linestyle='-', linewidth=3)
        ax.tick_params(which="minor", bottom=False, left=False)
        ax.set_xticks([])
        ax.set_yticks([])

        # LEFT action: 0, DOWN action: 1
        # RIGHT action: 2, UP action: 3
        action2dxdy = {0:(-.25, 0),1:(0, .25),
                       2:(0.25, 0),3:(-.25, 0)}

        for y in range(4):
            for x in range(4):
                action = pi[k].reshape(4,4)[y, x]
                dx, dy = action2dxdy[action]

                if env_desc[y,x].decode() == 'H':
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="y",
                         size=20, fontweight='bold')

                elif env_desc[y,x].decode() == 'G':
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="w",
                         size=20, fontweight='bold')

                else:
                    ax.text(x, y, str(env_desc[y,x].decode()),
                       ha="center", va="center", color="g",
                         size=15, fontweight='bold')

                # No arrow for cells with G and H labels
                if env_desc[y,x].decode() != 'G' and env_desc[y,x].decode() != 'H':
                    ax.arrow(x, y, dx, dy, color='r', head_width=0.2, head_length=0.15)

        ax.set_title("Step = "  + str(vis_indx[k] + 1), fontsize=20)

    fig.tight_layout()
    plt.show()

</code></pre>
<p>Trainer</p>
<p>A bunch of functions that will be deprecated:</p>
<pre><code class="language-{.python .input}">%%tab mxnet
def load_array(data_arrays, batch_size, is_train=True):  #@save
    """Construct a Gluon data iterator."""
    dataset = gluon.data.ArrayDataset(*data_arrays)
    return gluon.data.DataLoader(dataset, batch_size, shuffle=is_train)

def synthetic_data(w, b, num_examples):  #@save
    """Generate y = Xw + b + noise."""
    X = d2l.normal(0, 1, (num_examples, len(w)))
    y = d2l.matmul(X, w) + b
    y += d2l.normal(0, 0.01, y.shape)
    return X, d2l.reshape(y, (-1, 1))

def sgd(params, lr, batch_size):  #@save
    """Minibatch stochastic gradient descent."""
    for param in params:
        param[:] = param - lr * param.grad / batch_size

def get_dataloader_workers():  #@save
    """Use 4 processes to read the data except for Windows."""
    return 0 if sys.platform.startswith('win') else 4

def load_data_fashion_mnist(batch_size, resize=None):  #@save
    """Download the Fashion-MNIST dataset and then load it into memory."""
    dataset = gluon.data.vision
    trans = [dataset.transforms.ToTensor()]
    if resize:
        trans.insert(0, dataset.transforms.Resize(resize))
    trans = dataset.transforms.Compose(trans)
    mnist_train = dataset.FashionMNIST(train=True).transform_first(trans)
    mnist_test = dataset.FashionMNIST(train=False).transform_first(trans)
    return (gluon.data.DataLoader(mnist_train, batch_size, shuffle=True,
                                  num_workers=get_dataloader_workers()),
            gluon.data.DataLoader(mnist_test, batch_size, shuffle=False,
                                  num_workers=get_dataloader_workers()))

def evaluate_accuracy_gpu(net, data_iter, device=None):  #@save
    """Compute the accuracy for a model on a dataset using a GPU."""
    if not device:  # Query the first device where the first parameter is on
        device = list(net.collect_params().values())[0].list_ctx()[0]
    # No. of correct predictions, no. of predictions
    metric = d2l.Accumulator(2)
    for X, y in data_iter:
        X, y = X.as_in_ctx(device), y.as_in_ctx(device)
        metric.add(d2l.accuracy(net(X), y), d2l.size(y))
    return metric[0] / metric[1]

#@save
def train_ch6(net, train_iter, test_iter, num_epochs, lr, device):
    """Train a model with a GPU (defined in Chapter 6)."""
    net.initialize(force_reinit=True, ctx=device, init=init.Xavier())
    loss = gluon.loss.SoftmaxCrossEntropyLoss()
    trainer = gluon.Trainer(net.collect_params(),
                            'sgd', {'learning_rate': lr})
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=['train loss', 'train acc', 'test acc'])
    timer, num_batches = d2l.Timer(), len(train_iter)
    for epoch in range(num_epochs):
        # Sum of training loss, sum of training accuracy, no. of examples
        metric = d2l.Accumulator(3)
        for i, (X, y) in enumerate(train_iter):
            timer.start()
            # Here is the major difference from `d2l.train_epoch_ch3`
            X, y = X.as_in_ctx(device), y.as_in_ctx(device)
            with autograd.record():
                y_hat = net(X)
                l = loss(y_hat, y)
            l.backward()
            trainer.step(X.shape[0])
            metric.add(l.sum(), d2l.accuracy(y_hat, y), X.shape[0])
            timer.stop()
            train_l = metric[0] / metric[2]
            train_acc = metric[1] / metric[2]
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (train_l, train_acc, None))
        test_acc = evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'loss {train_l:.3f}, train acc {train_acc:.3f}, '
          f'test acc {test_acc:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec '
          f'on {str(device)}')
    
def grad_clipping(net, theta):  #@save
    """Clip the gradient."""
    if isinstance(net, gluon.Block):
        params = [p.data() for p in net.collect_params().values()]
    else:
        params = net.params
    norm = math.sqrt(sum((p.grad ** 2).sum() for p in params))
    if norm &gt; theta:
        for param in params:
            param.grad[:] *= theta / norm
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch

def load_array(data_arrays, batch_size, is_train=True):  #@save
    """Construct a PyTorch data iterator."""
    dataset = torch.utils.data.TensorDataset(*data_arrays)
    return torch.utils.data.DataLoader(dataset, batch_size, shuffle=is_train)

def synthetic_data(w, b, num_examples):  #@save
    """Generate y = Xw + b + noise."""
    X = d2l.normal(0, 1, (num_examples, len(w)))
    y = d2l.matmul(X, w) + b
    y += d2l.normal(0, 0.01, y.shape)
    return X, d2l.reshape(y, (-1, 1))

def sgd(params, lr, batch_size): #@save
    """Minibatch stochastic gradient descent."""
    with torch.no_grad():
        for param in params:
            param -= lr * param.grad / batch_size
            param.grad.zero_()

def get_dataloader_workers():  #@save
    """Use 4 processes to read the data."""
    return 4

def load_data_fashion_mnist(batch_size, resize=None):  #@save
    """Download the Fashion-MNIST dataset and then load it into memory."""
    trans = [transforms.ToTensor()]
    if resize:
        trans.insert(0, transforms.Resize(resize))
    trans = transforms.Compose(trans)
    mnist_train = torchvision.datasets.FashionMNIST(
        root="../data", train=True, transform=trans, download=True)
    mnist_test = torchvision.datasets.FashionMNIST(
        root="../data", train=False, transform=trans, download=True)
    return (torch.utils.data.DataLoader(mnist_train, batch_size, shuffle=True,
                                        num_workers=get_dataloader_workers()),
            torch.utils.data.DataLoader(mnist_test, batch_size, shuffle=False,
                                        num_workers=get_dataloader_workers()))

def evaluate_accuracy_gpu(net, data_iter, device=None): #@save
    """Compute the accuracy for a model on a dataset using a GPU."""
    if isinstance(net, nn.Module):
        net.eval()  # Set the model to evaluation mode
        if not device:
            device = next(iter(net.parameters())).device
    # No. of correct predictions, no. of predictions
    metric = d2l.Accumulator(2)

    with torch.no_grad():
        for X, y in data_iter:
            if isinstance(X, list):
                # Required for BERT Fine-tuning (to be covered later)
                X = [x.to(device) for x in X]
            else:
                X = X.to(device)
            y = y.to(device)
            metric.add(d2l.accuracy(net(X), y), d2l.size(y))
    return metric[0] / metric[1]


#@save
def train_ch6(net, train_iter, test_iter, num_epochs, lr, device):
    """Train a model with a GPU (defined in Chapter 6)."""
    def init_weights(m):
        if type(m) == nn.Linear or type(m) == nn.Conv2d:
            nn.init.xavier_uniform_(m.weight)
    net.apply(init_weights)
    print('training on', device)
    net.to(device)
    optimizer = torch.optim.SGD(net.parameters(), lr=lr)
    loss = nn.CrossEntropyLoss()
    animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                            legend=['train loss', 'train acc', 'test acc'])
    timer, num_batches = d2l.Timer(), len(train_iter)
    for epoch in range(num_epochs):
        # Sum of training loss, sum of training accuracy, no. of examples
        metric = d2l.Accumulator(3)
        net.train()
        for i, (X, y) in enumerate(train_iter):
            timer.start()
            optimizer.zero_grad()
            X, y = X.to(device), y.to(device)
            y_hat = net(X)
            l = loss(y_hat, y)
            l.backward()
            optimizer.step()
            with torch.no_grad():
                metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0])
            timer.stop()
            train_l = metric[0] / metric[2]
            train_acc = metric[1] / metric[2]
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (train_l, train_acc, None))
        test_acc = evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'loss {train_l:.3f}, train acc {train_acc:.3f}, '
          f'test acc {test_acc:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec '
          f'on {str(device)}')
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow

def load_array(data_arrays, batch_size, is_train=True):  #@save
    """Construct a TensorFlow data iterator."""
    dataset = tf.data.Dataset.from_tensor_slices(data_arrays)
    if is_train:
        dataset = dataset.shuffle(buffer_size=1000)
    dataset = dataset.batch(batch_size)
    return dataset

def synthetic_data(w, b, num_examples):  #@save
    """Generate y = Xw + b + noise."""
    X = tf.zeros((num_examples, w.shape[0]))
    X += tf.random.normal(shape=X.shape)
    y = tf.matmul(X, tf.reshape(w, (-1, 1))) + b
    y += tf.random.normal(shape=y.shape, stddev=0.01)
    y = tf.reshape(y, (-1, 1))
    return X, y


def sgd(params, grads, lr, batch_size):  #@save
    """Minibatch stochastic gradient descent."""
    for param, grad in zip(params, grads):
        param.assign_sub(lr * grad / batch_size)

def load_data_fashion_mnist(batch_size, resize=None):   #@save
    """Download the Fashion-MNIST dataset and then load it into memory."""
    mnist_train, mnist_test = tf.keras.datasets.fashion_mnist.load_data()
    # Divide all numbers by 255 so that all pixel values are between
    # 0 and 1, add a batch dimension at the last. And cast label to int32
    process = lambda X, y: (tf.expand_dims(X, axis=3) / 255,
                            tf.cast(y, dtype='int32'))
    resize_fn = lambda X, y: (
        tf.image.resize_with_pad(X, resize, resize) if resize else X, y)
    return (
        tf.data.Dataset.from_tensor_slices(process(*mnist_train)).batch(
            batch_size).shuffle(len(mnist_train[0])).map(resize_fn),
        tf.data.Dataset.from_tensor_slices(process(*mnist_test)).batch(
            batch_size).map(resize_fn))

class TrainCallback(tf.keras.callbacks.Callback):  #@save
    """A callback to visiualize the training progress."""
    def __init__(self, net, train_iter, test_iter, num_epochs, device_name):
        self.timer = d2l.Timer()
        self.animator = d2l.Animator(
            xlabel='epoch', xlim=[1, num_epochs], legend=[
                'train loss', 'train acc', 'test acc'])
        self.net = net
        self.train_iter = train_iter
        self.test_iter = test_iter
        self.num_epochs = num_epochs
        self.device_name = device_name
    def on_epoch_begin(self, epoch, logs=None):
        self.timer.start()
    def on_epoch_end(self, epoch, logs):
        self.timer.stop()
        test_acc = self.net.evaluate(
            self.test_iter, verbose=0, return_dict=True)['accuracy']
        metrics = (logs['loss'], logs['accuracy'], test_acc)
        self.animator.add(epoch + 1, metrics)
        if epoch == self.num_epochs - 1:
            batch_size = next(iter(self.train_iter))[0].shape[0]
            num_examples = batch_size * tf.data.experimental.cardinality(
                self.train_iter).numpy()
            print(f'loss {metrics[0]:.3f}, train acc {metrics[1]:.3f}, '
                  f'test acc {metrics[2]:.3f}')
            print(f'{num_examples / self.timer.avg():.1f} examples/sec on '
                  f'{str(self.device_name)}')

#@save
def train_ch6(net_fn, train_iter, test_iter, num_epochs, lr, device):
    """Train a model with a GPU (defined in Chapter 6)."""
    device_name = device._device_name
    strategy = tf.distribute.OneDeviceStrategy(device_name)
    with strategy.scope():
        optimizer = tf.keras.optimizers.SGD(learning_rate=lr)
        loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)
        net = net_fn()
        net.compile(optimizer=optimizer, loss=loss, metrics=['accuracy'])
    callback = TrainCallback(net, train_iter, test_iter, num_epochs,
                             device_name)
    net.fit(train_iter, epochs=num_epochs, verbose=0, callbacks=[callback])
    return net
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
def evaluate_accuracy(net, data_iter):  #@save
    """Compute the accuracy for a model on a dataset."""
    metric = Accumulator(2)  # No. of correct predictions, no. of predictions
    for X, y in data_iter:
        metric.add(accuracy(net(X), y), d2l.size(y))
    return metric[0] / metric[1]
</code></pre>
<pre><code class="language-{.python .input}">%%tab all
def show_images(imgs, num_rows, num_cols, titles=None, scale=1.5):  #@save
    """Plot a list of images."""
    figsize = (num_cols * scale, num_rows * scale)
    _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize)
    axes = axes.flatten()
    for i, (ax, img) in enumerate(zip(axes, imgs)):
        try:
            img = d2l.numpy(img)
        except:
            pass
        ax.imshow(img)
        ax.axes.get_xaxis().set_visible(False)
        ax.axes.get_yaxis().set_visible(False)
        if titles:
            ax.set_title(titles[i])
    return axes
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow

def linreg(X, w, b):  #@save
    """The linear regression model."""
    return d2l.matmul(X, w) + b

def squared_loss(y_hat, y):  #@save
    """Squared loss."""
    return (y_hat - d2l.reshape(y, y_hat.shape)) ** 2 / 2

def get_fashion_mnist_labels(labels):  #@save
    """Return text labels for the Fashion-MNIST dataset."""
    text_labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat',
                   'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot']
    return [text_labels[int(i)] for i in labels]

#@tab pytorch, mxnet, tensorflow
class Animator:  #@save
    """For plotting data in animation."""
    def __init__(self, xlabel=None, ylabel=None, legend=None, xlim=None,
                 ylim=None, xscale='linear', yscale='linear',
                 fmts=('-', 'm--', 'g-.', 'r:'), nrows=1, ncols=1,
                 figsize=(3.5, 2.5)):
        # Incrementally plot multiple lines
        if legend is None:
            legend = []
        d2l.use_svg_display()
        self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)
        if nrows * ncols == 1:
            self.axes = [self.axes, ]
        # Use a lambda function to capture arguments
        self.config_axes = lambda: d2l.set_axes(
            self.axes[0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)
        self.X, self.Y, self.fmts = None, None, fmts

    def add(self, x, y):
        # Add multiple data points into the figure
        if not hasattr(y, "__len__"):
            y = [y]
        n = len(y)
        if not hasattr(x, "__len__"):
            x = [x] * n
        if not self.X:
            self.X = [[] for _ in range(n)]
        if not self.Y:
            self.Y = [[] for _ in range(n)]
        for i, (a, b) in enumerate(zip(x, y)):
            if a is not None and b is not None:
                self.X[i].append(a)
                self.Y[i].append(b)
        self.axes[0].cla()
        for x, y, fmt in zip(self.X, self.Y, self.fmts):
            self.axes[0].plot(x, y, fmt)
        self.config_axes()
        display.display(self.fig)
        display.clear_output(wait=True)

#@tab pytorch, mxnet, tensorflow
class Accumulator:  #@save
    """For accumulating sums over `n` variables."""
    def __init__(self, n):
        self.data = [0.0] * n

    def add(self, *args):
        self.data = [a + float(b) for a, b in zip(self.data, args)]

    def reset(self):
        self.data = [0.0] * len(self.data)

    def __getitem__(self, idx):
        return self.data[idx]


#@tab pytorch, mxnet, tensorflow
def accuracy(y_hat, y):  #@save
    """Compute the number of correct predictions."""
    if len(y_hat.shape) &gt; 1 and y_hat.shape[1] &gt; 1:
        y_hat = d2l.argmax(y_hat, axis=1)
    cmp = d2l.astype(y_hat, y.dtype) == y
    return float(d2l.reduce_sum(d2l.astype(cmp, y.dtype)))
</code></pre>
<pre><code class="language-{.python .input}">%%tab all

import os
import requests
import zipfile
import tarfile
import hashlib

def download(url, folder='../data', sha1_hash=None):  #@save
    """Download a file to folder and return the local filepath."""
    if not url.startswith('http'):
        # For back compatability
        url, sha1_hash = DATA_HUB[url]
    os.makedirs(folder, exist_ok=True)
    fname = os.path.join(folder, url.split('/')[-1])
    # Check if hit cache
    if os.path.exists(fname) and sha1_hash:
        sha1 = hashlib.sha1()
        with open(fname, 'rb') as f:
            while True:
                data = f.read(1048576)
                if not data:
                    break
                sha1.update(data)
        if sha1.hexdigest() == sha1_hash:
            return fname
    # Download
    print(f'Downloading {fname} from {url}...')
    r = requests.get(url, stream=True, verify=True)
    with open(fname, 'wb') as f:
        f.write(r.content)
    return fname

def extract(filename, folder=None):  #@save
    """Extract a zip/tar file into folder."""
    base_dir = os.path.dirname(filename)
    _, ext = os.path.splitext(filename)
    assert ext in ('.zip', '.tar', '.gz'), 'Only support zip/tar files.'
    if ext == '.zip':
        fp = zipfile.ZipFile(filename, 'r')
    else:
        fp = tarfile.open(filename, 'r')
    if folder is None:
        folder = base_dir
    fp.extractall(folder)
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow

def download_extract(name, folder=None):  #@save
    """Download and extract a zip/tar file."""
    fname = download(name)
    base_dir = os.path.dirname(fname)
    data_dir, ext = os.path.splitext(fname)
    if ext == '.zip':
        fp = zipfile.ZipFile(fname, 'r')
    elif ext in ('.tar', '.gz'):
        fp = tarfile.open(fname, 'r')
    else:
        assert False, 'Only zip/tar files can be extracted.'
    fp.extractall(base_dir)
    return os.path.join(base_dir, folder) if folder else data_dir


def tokenize(lines, token='word'):  #@save
    """Split text lines into word or character tokens."""
    assert token in ('word', 'char'), 'Unknown token type: ' + token
    return [line.split() if token == 'word' else list(line) for line in lines]

</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch

def evaluate_loss(net, data_iter, loss):  #@save
    """Evaluate the loss of a model on the given dataset."""
    metric = d2l.Accumulator(2)  # Sum of losses, no. of examples
    for X, y in data_iter:
        out = net(X)
        y = d2l.reshape(y, out.shape)
        l = loss(out, y)
        metric.add(d2l.reduce_sum(l), d2l.size(l))
    return metric[0] / metric[1]
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet, tensorflow
def evaluate_loss(net, data_iter, loss):  #@save
    """Evaluate the loss of a model on the given dataset."""
    metric = d2l.Accumulator(2)  # Sum of losses, no. of examples
    for X, y in data_iter:
        l = loss(net(X), y)
        metric.add(d2l.reduce_sum(l), d2l.size(l))
    return metric[0] / metric[1]
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
def grad_clipping(net, theta):  #@save
    """Clip the gradient."""
    if isinstance(net, nn.Module):
        params = [p for p in net.parameters() if p.requires_grad]
    else:
        params = net.params
    norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params))
    if norm &gt; theta:
        for param in params:
            param.grad[:] *= theta / norm
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
def grad_clipping(grads, theta):  #@save
    """Clip the gradient."""
    theta = tf.constant(theta, dtype=tf.float32)
    new_grad = []
    for grad in grads:
        if isinstance(grad, tf.IndexedSlices):
            new_grad.append(tf.convert_to_tensor(grad))
        else:
            new_grad.append(grad)
    norm = tf.math.sqrt(sum((tf.reduce_sum(grad ** 2)).numpy()
                        for grad in new_grad))
    norm = tf.cast(norm, tf.float32)
    if tf.greater(norm, theta):
        for i, grad in enumerate(new_grad):
            new_grad[i] = grad * theta / norm
    else:
        new_grad = new_grad
    return new_grad
</code></pre>
<p>More for the attention chapter.</p>
<pre><code class="language-{.python .input}">%%tab pytorch, mxnet, tensorflow
#@save
d2l.DATA_HUB['fra-eng'] = (d2l.DATA_URL + 'fra-eng.zip',
                           '94646ad1522d915e7b0f9296181140edcf86a4f5')

#@save
def read_data_nmt():
    """Load the English-French dataset."""
    data_dir = d2l.download_extract('fra-eng')
    with open(os.path.join(data_dir, 'fra.txt'), 'r', encoding='utf-8') as f:
        return f.read()

#@save
def preprocess_nmt(text):
    """Preprocess the English-French dataset."""
    def no_space(char, prev_char):
        return char in set(',.!?') and prev_char != ' '

    # Replace non-breaking space with space, and convert uppercase letters to
    # lowercase ones
    text = text.replace('\u202f', ' ').replace('\xa0', ' ').lower()
    # Insert space between words and punctuation marks
    out = [' ' + char if i &gt; 0 and no_space(char, text[i - 1]) else char
           for i, char in enumerate(text)]
    return ''.join(out)

#@save
def tokenize_nmt(text, num_examples=None):
    """Tokenize the English-French dataset."""
    source, target = [], []
    for i, line in enumerate(text.split('\n')):
        if num_examples and i &gt; num_examples:
            break
        parts = line.split('\t')
        if len(parts) == 2:
            source.append(parts[0].split(' '))
            target.append(parts[1].split(' '))
    return source, target

    
#@save
def truncate_pad(line, num_steps, padding_token):
    """Truncate or pad sequences."""
    if len(line) &gt; num_steps:
        return line[:num_steps]  # Truncate
    return line + [padding_token] * (num_steps - len(line))  # Pad


#@save
def build_array_nmt(lines, vocab, num_steps):
    """Transform text sequences of machine translation into minibatches."""
    lines = [vocab[l] for l in lines]
    lines = [l + [vocab['&lt;eos&gt;']] for l in lines]
    array = d2l.tensor([truncate_pad(
        l, num_steps, vocab['&lt;pad&gt;']) for l in lines])
    valid_len = d2l.reduce_sum(
        d2l.astype(array != vocab['&lt;pad&gt;'], d2l.int32), 1)
    return array, valid_len


#@save
def load_data_nmt(batch_size, num_steps, num_examples=600):
    """Return the iterator and the vocabularies of the translation dataset."""
    text = preprocess_nmt(read_data_nmt())
    source, target = tokenize_nmt(text, num_examples)
    src_vocab = d2l.Vocab(source, min_freq=2,
                          reserved_tokens=['&lt;pad&gt;', '&lt;bos&gt;', '&lt;eos&gt;'])
    tgt_vocab = d2l.Vocab(target, min_freq=2,
                          reserved_tokens=['&lt;pad&gt;', '&lt;bos&gt;', '&lt;eos&gt;'])
    src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps)
    tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps)
    data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len)
    data_iter = d2l.load_array(data_arrays, batch_size)
    return data_iter, src_vocab, tgt_vocab
</code></pre>
<pre><code class="language-{.python .input}">%%tab mxnet
    
#@save
class MaskedSoftmaxCELoss(gluon.loss.SoftmaxCELoss):
    """The softmax cross-entropy loss with masks."""
    # `pred` shape: (`batch_size`, `num_steps`, `vocab_size`)
    # `label` shape: (`batch_size`, `num_steps`)
    # `valid_len` shape: (`batch_size`,)
    def forward(self, pred, label, valid_len):
        # `weights` shape: (`batch_size`, `num_steps`, 1)
        weights = np.expand_dims(np.ones_like(label), axis=-1)
        weights = npx.sequence_mask(weights, valid_len, True, axis=1)
        return super(MaskedSoftmaxCELoss, self).forward(pred, label, weights)

#@save
def train_seq2seq(net, data_iter, lr, num_epochs, tgt_vocab, device):
    """Train a model for sequence to sequence."""
    net.initialize(init.Xavier(), force_reinit=True, ctx=device)
    trainer = gluon.Trainer(net.collect_params(), 'adam',
                            {'learning_rate': lr})
    loss = MaskedSoftmaxCELoss()
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[10, num_epochs])
    for epoch in range(num_epochs):
        timer = d2l.Timer()
        metric = d2l.Accumulator(2)  # Sum of training loss, no. of tokens
        for batch in data_iter:
            X, X_valid_len, Y, Y_valid_len = [
                x.as_in_ctx(device) for x in batch]
            bos = np.array(
                [tgt_vocab['&lt;bos&gt;']] * Y.shape[0], ctx=device).reshape(-1, 1)
            dec_input = d2l.concat([bos, Y[:, :-1]], 1)  # Teacher forcing
            with autograd.record():
                Y_hat, _ = net(X, dec_input, X_valid_len)
                l = loss(Y_hat, Y, Y_valid_len)
            l.backward()
            d2l.grad_clipping(net, 1)
            num_tokens = Y_valid_len.sum()
            trainer.step(num_tokens)
            metric.add(l.sum(), num_tokens)
        if (epoch + 1) % 10 == 0:
            animator.add(epoch + 1, (metric[0] / metric[1],))
    print(f'loss {metric[0] / metric[1]:.3f}, {metric[1] / timer.stop():.1f} '
          f'tokens/sec on {str(device)}')

#@save
def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps,
                    device, save_attention_weights=False):
    """Predict for sequence to sequence."""
    src_tokens = src_vocab[src_sentence.lower().split(' ')] + [
        src_vocab['&lt;eos&gt;']]
    enc_valid_len = np.array([len(src_tokens)], ctx=device)
    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab['&lt;pad&gt;'])
    # Add the batch axis
    enc_X = np.expand_dims(np.array(src_tokens, ctx=device), axis=0)
    enc_outputs = net.encoder(enc_X, enc_valid_len)
    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)
    # Add the batch axis
    dec_X = np.expand_dims(np.array([tgt_vocab['&lt;bos&gt;']], ctx=device), axis=0)
    output_seq, attention_weight_seq = [], []
    for _ in range(num_steps):
        Y, dec_state = net.decoder(dec_X, dec_state)
        # We use the token with the highest prediction likelihood as input
        # of the decoder at the next time step
        dec_X = Y.argmax(axis=2)
        pred = dec_X.squeeze(axis=0).astype('int32').item()
        # Save attention weights (to be covered later)
        if save_attention_weights:
            attention_weight_seq.append(net.decoder.attention_weights)
        # Once the end-of-sequence token is predicted, the generation of the
        # output sequence is complete
        if pred == tgt_vocab['&lt;eos&gt;']:
            break
        output_seq.append(pred)
    return ' '.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq
</code></pre>
<pre><code class="language-{.python .input}">%%tab pytorch
#@save
def sequence_mask(X, valid_len, value=0):
    """Mask irrelevant entries in sequences."""
    maxlen = X.size(1)
    mask = torch.arange((maxlen), dtype=torch.float32,
                        device=X.device)[None, :] &lt; valid_len[:, None]
    X[~mask] = value
    return X

    
#@save
class MaskedSoftmaxCELoss(nn.CrossEntropyLoss):
    """The softmax cross-entropy loss with masks."""
    # `pred` shape: (`batch_size`, `num_steps`, `vocab_size`)
    # `label` shape: (`batch_size`, `num_steps`)
    # `valid_len` shape: (`batch_size`,)
    def forward(self, pred, label, valid_len):
        weights = torch.ones_like(label)
        weights = sequence_mask(weights, valid_len)
        self.reduction='none'
        unweighted_loss = super(MaskedSoftmaxCELoss, self).forward(
            pred.permute(0, 2, 1), label)
        weighted_loss = (unweighted_loss * weights).mean(dim=1)
        return weighted_loss
    
#@save
def train_seq2seq(net, data_iter, lr, num_epochs, tgt_vocab, device):
    """Train a model for sequence to sequence."""
    def xavier_init_weights(m):
        if type(m) == nn.Linear:
            nn.init.xavier_uniform_(m.weight)
        if type(m) == nn.GRU:
            for param in m._flat_weights_names:
                if "weight" in param:
                    nn.init.xavier_uniform_(m._parameters[param])
    net.apply(xavier_init_weights)
    net.to(device)
    optimizer = torch.optim.Adam(net.parameters(), lr=lr)
    loss = MaskedSoftmaxCELoss()
    net.train()
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[10, num_epochs])
    for epoch in range(num_epochs):
        timer = d2l.Timer()
        metric = d2l.Accumulator(2)  # Sum of training loss, no. of tokens
        for batch in data_iter:
            optimizer.zero_grad()
            X, X_valid_len, Y, Y_valid_len = [x.to(device) for x in batch]
            bos = torch.tensor([tgt_vocab['&lt;bos&gt;']] * Y.shape[0],
                               device=device).reshape(-1, 1)
            dec_input = d2l.concat([bos, Y[:, :-1]], 1)  # Teacher forcing
            Y_hat, _ = net(X, dec_input, X_valid_len)
            l = loss(Y_hat, Y, Y_valid_len)
            l.sum().backward()  # Make the loss scalar for `backward`
            d2l.grad_clipping(net, 1)
            num_tokens = Y_valid_len.sum()
            optimizer.step()
            with torch.no_grad():
                metric.add(l.sum(), num_tokens)
        if (epoch + 1) % 10 == 0:
            animator.add(epoch + 1, (metric[0] / metric[1],))
    print(f'loss {metric[0] / metric[1]:.3f}, {metric[1] / timer.stop():.1f} '
          f'tokens/sec on {str(device)}')
    

#@save
def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps,
                    device, save_attention_weights=False):
    """Predict for sequence to sequence."""
    # Set `net` to eval mode for inference
    net.eval()
    src_tokens = src_vocab[src_sentence.lower().split(' ')] + [
        src_vocab['&lt;eos&gt;']]
    enc_valid_len = torch.tensor([len(src_tokens)], device=device)
    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab['&lt;pad&gt;'])
    # Add the batch axis
    enc_X = torch.unsqueeze(
        torch.tensor(src_tokens, dtype=torch.long, device=device), dim=0)
    enc_outputs = net.encoder(enc_X, enc_valid_len)
    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)
    # Add the batch axis
    dec_X = torch.unsqueeze(torch.tensor(
        [tgt_vocab['&lt;bos&gt;']], dtype=torch.long, device=device), dim=0)
    output_seq, attention_weight_seq = [], []
    for _ in range(num_steps):
        Y, dec_state = net.decoder(dec_X, dec_state)
        # We use the token with the highest prediction likelihood as input
        # of the decoder at the next time step
        dec_X = Y.argmax(dim=2)
        pred = dec_X.squeeze(dim=0).type(torch.int32).item()
        # Save attention weights (to be covered later)
        if save_attention_weights:
            attention_weight_seq.append(net.decoder.attention_weights)
        # Once the end-of-sequence token is predicted, the generation of the
        # output sequence is complete
        if pred == tgt_vocab['&lt;eos&gt;']:
            break
        output_seq.append(pred)
    return ' '.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq
</code></pre>
<pre><code class="language-{.python .input}">%%tab tensorflow
#@save
def sequence_mask(X, valid_len, value=0):
    """Mask irrelevant entries in sequences."""
    maxlen = X.shape[1]
    mask = tf.range(start=0, limit=maxlen, dtype=tf.float32)[
        None, :] &lt; tf.cast(valid_len[:, None], dtype=tf.float32)
    
    if len(X.shape) == 3:
        return tf.where(tf.expand_dims(mask, axis=-1), X, value)
    else:
        return tf.where(mask, X, value)

    
#@save
class MaskedSoftmaxCELoss(tf.keras.losses.Loss):
    """The softmax cross-entropy loss with masks."""
    def __init__(self, valid_len):
        super().__init__(reduction='none')
        self.valid_len = valid_len
    
    # `pred` shape: (`batch_size`, `num_steps`, `vocab_size`)
    # `label` shape: (`batch_size`, `num_steps`)
    # `valid_len` shape: (`batch_size`,)
    def call(self, label, pred):
        weights = tf.ones_like(label, dtype=tf.float32)
        weights = sequence_mask(weights, self.valid_len)
        label_one_hot = tf.one_hot(label, depth=pred.shape[-1])
        unweighted_loss = tf.keras.losses.CategoricalCrossentropy(
            from_logits=True, reduction='none')(label_one_hot, pred)
        weighted_loss = tf.reduce_mean((unweighted_loss*weights), axis=1)
        return weighted_loss
    
#@save
def train_seq2seq(net, data_iter, lr, num_epochs, tgt_vocab, device):
    """Train a model for sequence to sequence."""
    optimizer = tf.keras.optimizers.Adam(learning_rate=lr)
    animator = d2l.Animator(xlabel="epoch", ylabel="loss",
                            xlim=[10, num_epochs])
    for epoch in range(num_epochs):
        timer = d2l.Timer()
        metric = d2l.Accumulator(2)  # Sum of training loss, no. of tokens
        for batch in data_iter:
            X, X_valid_len, Y, Y_valid_len = [x for x in batch]
            bos = tf.reshape(tf.constant([tgt_vocab['&lt;bos&gt;']] * Y.shape[0]),
                             shape=(-1, 1))
            dec_input = tf.concat([bos, Y[:, :-1]], 1)  # Teacher forcing
            with tf.GradientTape() as tape:
                Y_hat, _ = net(X, dec_input, X_valid_len, training=True)
                l = MaskedSoftmaxCELoss(Y_valid_len)(Y, Y_hat)
            gradients = tape.gradient(l, net.trainable_variables)
            gradients = d2l.grad_clipping(gradients, 1)
            optimizer.apply_gradients(zip(gradients, net.trainable_variables))
            num_tokens = tf.reduce_sum(Y_valid_len).numpy()
            metric.add(tf.reduce_sum(l), num_tokens)
        if (epoch + 1) % 10 == 0:
            animator.add(epoch + 1, (metric[0] / metric[1],))
    print(f'loss {metric[0] / metric[1]:.3f}, {metric[1] / timer.stop():.1f} '
          f'tokens/sec on {str(device._device_name)}')
    
#@save
def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps,
                    save_attention_weights=False):
    """Predict for sequence to sequence."""
    src_tokens = src_vocab[src_sentence.lower().split(' ')] + [
        src_vocab['&lt;eos&gt;']]
    enc_valid_len = tf.constant([len(src_tokens)])
    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab['&lt;pad&gt;'])
    # Add the batch axis
    enc_X = tf.expand_dims(src_tokens, axis=0)
    enc_outputs = net.encoder(enc_X, enc_valid_len, training=False)
    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)
    # Add the batch axis
    dec_X = tf.expand_dims(tf.constant([tgt_vocab['&lt;bos&gt;']]), axis=0)
    output_seq, attention_weight_seq = [], []
    for _ in range(num_steps):
        Y, dec_state = net.decoder(dec_X, dec_state, training=False)
        # We use the token with the highest prediction likelihood as input
        # of the decoder at the next time step
        dec_X = tf.argmax(Y, axis=2)
        pred = tf.squeeze(dec_X, axis=0)
        # Save attention weights
        if save_attention_weights:
            attention_weight_seq.append(net.decoder.attention_weights)
        # Once the end-of-sequence token is predicted, the generation of the
        # output sequence is complete
        if pred == tgt_vocab['&lt;eos&gt;']:
            break
        output_seq.append(pred.numpy())
    return ' '.join(tgt_vocab.to_tokens(tf.reshape(output_seq, shape = -1).numpy().tolist())), attention_weight_seq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-d2l-api-document"><a class="header" href="#the-d2l-api-document">The <code>d2l</code> API Document</a></h1>
<p>:label:<code>sec_d2l</code></p>
<p>This section displays classes and functions (sorted alphabetically) in the <code>d2l</code> package, showing where they are defined in the book so you can find more detailed implementations and explanations.
See also the source code on the <a href="https://github.com/d2l-ai/d2l-en/tree/master/d2l">GitHub repository</a>.</p>
<p>:begin_tab:<code>pytorch</code></p>
<pre><code class="language-eval_rst">
.. currentmodule:: d2l.torch

</code></pre>
<p>:begin_tab:<code>mxnet</code></p>
<pre><code class="language-eval_rst">
.. currentmodule:: d2l.mxnet

</code></pre>
<p>:end_tab:</p>
<p>:begin_tab:<code>tensorflow</code></p>
<pre><code class="language-eval_rst">
.. currentmodule:: d2l.torch

</code></pre>
<p>:end_tab:</p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<pre><code class="language-eval_rst">
.. autoclass:: AdditiveAttention
   :members:
   
.. autoclass:: AddNorm
   :members:

.. autoclass:: AttentionDecoder
   :members: 

.. autoclass:: Classifier
   :members: 
   
.. autoclass:: DataModule
   :members: 
   
.. autoclass:: Decoder
   :members: 
   
.. autoclass:: DotProductAttention
   :members:
   
.. autoclass:: Encoder
   :members:
   
.. autoclass:: EncoderDecoder
   :members:
   
.. autoclass:: FashionMNIST
   :members: 
   
.. autoclass:: GRU
   :members: 
   
.. autoclass:: HyperParameters
   :members: 
   
.. autoclass:: LeNet
   :members: 
   
.. autoclass:: LinearRegression
   :members: 
   
.. autoclass:: LinearRegressionScratch
   :members: 
   
.. autoclass:: Module
   :members: 
   
.. autoclass:: MTFraEng
   :members: 
   
.. autoclass:: MultiHeadAttention
   :members:
   
.. autoclass:: PositionalEncoding
   :members:
   
.. autoclass:: PositionWiseFFN
   :members:
   
.. autoclass:: ProgressBoard
   :members: 
   
.. autoclass:: Residual
   :members: 
   
.. autoclass:: ResNeXtBlock
   :members:
   
.. autoclass:: RNN
   :members: 
   
.. autoclass:: RNNLM
   :members:
   
.. autoclass:: RNNLMScratch
   :members:
   
.. autoclass:: RNNScratch
   :members: 
   
.. autoclass:: Seq2Seq
   :members:  
   
.. autoclass:: Seq2SeqEncoder
   :members:
   
.. autoclass:: SGD
   :members: 
   
.. autoclass:: SoftmaxRegression
   :members: 

.. autoclass:: SyntheticRegressionData
   :members: 

.. autoclass:: TimeMachine
   :members: 

.. autoclass:: Trainer
   :members: 

.. autoclass:: TransformerEncoder 
   :members:

.. autoclass:: TransformerEncoderBlock
   :members:

.. autoclass:: Vocab
   :members: 
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><code class="language-eval_rst">
.. autofunction:: add_to_class

.. autofunction:: bleu

.. autofunction:: check_len

.. autofunction:: check_shape

.. autofunction:: corr2d

.. autofunction:: cpu

.. autofunction:: gpu

.. autofunction:: init_cnn

.. autofunction:: init_seq2seq

.. autofunction:: masked_softmax

.. autofunction:: num_gpus

.. autofunction:: plot

.. autofunction:: set_axes

.. autofunction:: set_figsize

.. autofunction:: show_heatmaps

.. autofunction:: show_list_len_pair_hist

.. autofunction:: try_all_gpus

.. autofunction:: try_gpu

.. autofunction:: use_svg_display

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-eval_rst">
.. only:: html

   References
   ==========

</code></pre>
<p>:bibliography:<code>../d2l.bib</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
